<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e79dc9260fe7737b92ae37a13293d18776f2b50" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613898" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Dá suporte a todas as classes na hierarquia de classe do .NET Framework e fornece serviços de nível baixo para classes derivadas. Esta é a classe base definitiva de todas as classes do .NET Framework. É a raiz da hierarquia de tipo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas normalmente não exigem uma classe para declarar a herança de <xref:System.Object> porque a herança está implícita.  
  
 Como todas as classes no .NET Framework são derivadas <xref:System.Object>, todos os métodos definidos na <xref:System.Object> classe está disponível em todos os objetos no sistema. Derivado classes can e substituir alguns desses métodos, incluindo:  
  
-   <xref:System.Object.Equals%2A> – Dá suporte a comparações entre objetos.  
  
-   <xref:System.Object.Finalize%2A> -Executa operações de limpeza antes que um objeto seja recuperado automaticamente.  
  
-   <xref:System.Object.GetHashCode%2A> -Gera um número que corresponde ao valor do objeto para dar suporte o uso de uma tabela de hash.  
  
-   <xref:System.Object.ToString%2A> -Fabrica uma cadeia de caracteres de texto legível que descreve uma instância da classe.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Se você estiver criando uma classe, como uma coleção, que deve lidar com qualquer tipo de objeto, você pode criar membros de classe que aceitam instâncias da <xref:System.Object> classe. No entanto, o processo de conversão boxing e unboxing um tipo transporta um custo de desempenho. Se você souber a que sua nova classe frequentemente manipulará determinados tipos de valor, você pode usar uma das duas táticas para minimizar o custo de conversão boxing.  
  
-   Criar um método geral que aceita um <xref:System.Object> tipo e um conjunto de sobrecargas de método de tipo específico que aceitam cada tipo de valor que você espera que sua classe para manipular com frequência. Se existir um método de tipo específico que aceita o tipo de parâmetro de chamada, nenhuma conversão boxing ocorrerá, e o método de tipo específico é invocado. Se não houver nenhum argumento de método que corresponde ao tipo de parâmetro de chamada, o parâmetro é convertido e o método geral é invocado.  
  
-   Projetar seu tipo e seus membros para usar genéricos. O common language runtime cria um tipo genérico fechado quando você cria uma instância de sua classe e especifica um argumento de tipo genérico. O método genérico é específico de tipo e pode ser invocado sem o parâmetro de chamada a conversão boxing.  
  
 Embora, às vezes, é necessário desenvolver classes de finalidade geral que aceitam e retornam <xref:System.Object> tipos, você pode melhorar o desempenho, fornecendo também uma classe de tipo específico para lidar com um tipo usado com frequência. Por exemplo, fornecer uma classe que é específica para definir e obter valores booleanos elimina o custo de conversão boxing e unboxing valores boolianos.  
  
   
  
## Examples  
 O exemplo a seguir define um tipo de ponto derivado de <xref:System.Object> de classe e substitui a muitos dos métodos virtuais do <xref:System.Object> classe. Além disso, o exemplo mostra como chamar muitos dos estático e métodos de instância a <xref:System.Object> classe.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Membros de instância não são garantidos para ser thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado por construtores em classes derivadas, mas ele também pode ser usado para criar diretamente uma instância da <xref:System.Object> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se duas instâncias de objeto são iguais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado com o objeto atual.</param>
        <summary>Determina se o objeto especificado é igual ao objeto atual.</summary>
        <returns>
          <see langword="true" /> se o objeto especificado for igual ao objeto atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de comparação entre a instância atual e o `obj` parâmetro depende se a instância atual é um tipo de referência ou um tipo de valor.  
  
-   Se a instância atual é um tipo de referência, o <xref:System.Object.Equals%28System.Object%29> método testa a igualdade de referência e uma chamada para o <xref:System.Object.Equals%28System.Object%29> método é equivalente a uma chamada para o <xref:System.Object.ReferenceEquals%2A> método. Igualdade de referência significa que as variáveis de objeto são comparadas se referem ao mesmo objeto. O exemplo a seguir ilustra o resultado da comparação. Ele define uma `Person` classe, que é um tipo de referência, e chama o `Person` construtor de classe para instanciar dois novos `Person` objetos, `person1a` e `person2`, que têm o mesmo valor. Ele também atribui `person1a` a outra variável de objeto, `person1b`. Como a saída do exemplo mostra `person1a` e `person1b` são iguais porque eles referenciam o mesmo objeto. No entanto, `person1a` e `person2` não forem iguais, embora tenham o mesmo valor.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Se a instância atual é um tipo de valor, o <xref:System.Object.Equals%28System.Object%29> método testa a igualdade de valor. Igualdade de valor significa o seguinte:  
  
    -   Os dois objetos são do mesmo tipo. Como mostra o exemplo a seguir, uma <xref:System.Byte> objeto que tem um valor 12 não é igual a um <xref:System.Int32> objeto que tem um valor de 12, porque os dois objetos têm diferentes tipos de tempo de execução.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Os valores dos campos públicos e privados de dois objetos são iguais. O exemplo a seguir testa a igualdade de valor. Ele define uma `Person` estrutura, que é um tipo de valor, e chama o `Person` construtor de classe para instanciar dois novos `Person` objetos, `person1` e `person2`, que têm o mesmo valor. Como mostra a saída do exemplo, embora as variáveis de dois objetos se referirem a objetos diferentes, `person1` e `person2` forem iguais, porque eles têm o mesmo valor para a privada `personName` campo.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Porque o <xref:System.Object> classe é a classe base para todos os tipos no .NET Framework, o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método fornece a comparação de igualdade padrão para todos os outros tipos. No entanto, muitas vezes substituem tipos de <xref:System.Object.Equals%2A> método implementar a igualdade de valor. Para obter mais informações, consulte as notas de chamadores e observações para seções de herdeiros.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando você chama o <xref:System.Object.Equals%28System.Object%29> sobrecarga de método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.Equals%28System.Object%29>. Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). As classes a [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e atualmente não implementam um <xref:System.Object.Equals%28System.Object%29> método. No entanto, eles parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.Equals%28System.Object%29> sobrecarga de método.  
  
## <a name="notes-for-callers"></a>Observações para chamadores  
 As classes derivadas frequentemente substituir o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método implementar a igualdade de valor. Além disso, tipos frequentemente fornecem uma sobrecarga adicional com rigidez de tipos para o `Equals` método, normalmente Implementando o <xref:System.IEquatable%601> interface. Quando você chama o `Equals` método para testar a igualdade, você deve saber se a instância atual substitui <xref:System.Object.Equals%2A?displayProperty=nameWithType> e entender como uma chamada específica para um `Equals` método for resolvido. Caso contrário, você pode executar um teste de igualdade que seja diferente do que o que você pretendia, e o método pode retornar um valor inesperado.  
  
 O exemplo a seguir fornece uma ilustração. Ele cria três <xref:System.Text.StringBuilder> objetos com cadeias de caracteres idênticas e, em seguida, faz quatro chamadas para `Equals` métodos. O primeira chamada do método retorna `true`e o retorno de três restantes `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 No primeiro caso, fortemente tipado <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> sobrecarga de método, que testa a igualdade de valor, é chamada. Como as cadeias de caracteres atribuída para as duas <xref:System.Text.StringBuilder> objetos forem iguais, o método retorna `true`. No entanto, <xref:System.Text.StringBuilder> não substitui <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Por isso, quando o <xref:System.Text.StringBuilder> objeto é convertido em um <xref:System.Object>, quando um <xref:System.Text.StringBuilder> instância é atribuída a uma variável do tipo <xref:System.Object>e quando o <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> método recebe dois <xref:System.Text.StringBuilder> objetos, o padrão <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>método é chamado. Porque <xref:System.Text.StringBuilder> é um tipo de referência, isso é equivalente a passando os dois <xref:System.Text.StringBuilder> objetos para o <xref:System.Object.ReferenceEquals%2A> método. Embora todas as três <xref:System.Text.StringBuilder> objetos contêm cadeias de caracteres idênticas, eles se referem aos três objetos distintos. Como resultado, esses três método chama retorno `false`.  
  
 Você pode comparar o objeto atual com outro objeto de igualdade de referência chamando o <xref:System.Object.ReferenceEquals%2A> método. No Visual Basic, você também pode usar o `is` palavra-chave (por exemplo, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Observações para herdeiros  
 Ao definir seu próprio tipo, esse tipo herda a funcionalidade definida pelo `Equals` método do seu tipo base. A tabela a seguir lista a implementação padrão da `Equals` método para as principais categorias de tipos no .NET Framework.  
  
|Categoria do tipo|Igualdade definido pelo|Comentários|  
|-------------------|-------------------------|--------------|  
|Classe que deriva diretamente <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdade de referência; equivalente a chamar <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Estrutura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Igualdade de valor; comparação direta de byte por byte, ou usando a reflexão de comparação de campo por campo.|  
|Enumeração|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Os valores devem ter o mesmo tipo de enumeração e o mesmo valor subjacente.|  
|delegado|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegados devem ter o mesmo tipo com listas de invocação idênticos.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Igualdade de referência.|  
  
 Para um tipo de valor, você sempre deve substituir <xref:System.Object.Equals%2A>, porque testa a igualdade que dependem de reflexão oferece um desempenho ruim. Você também pode substituir a implementação padrão de <xref:System.Object.Equals%2A> para tipos de referência para testar a igualdade de valor em vez de igualdade de referência e definir o significado preciso de igualdade de valor. Essas implementações de <xref:System.Object.Equals%2A> retornar `true` se os dois objetos têm o mesmo valor, mesmo se eles não são a mesma instância. O implementador do tipo decide o que constitui o valor de um objeto, mas é geralmente alguns ou todos os dados armazenados nas variáveis de instância do objeto. Por exemplo, o valor de uma <xref:System.String> objeto baseia-se nos caracteres da cadeia de caracteres; a <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> substituições de método a <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método retorne `true` para qualquer dois de cadeia de caracteres instâncias que contêm os mesmos caracteres na mesma ordem.  
  
 O exemplo a seguir mostra como substituir o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para testar a igualdade de valor. Ele substitui o <xref:System.Object.Equals%2A> método para o `Person` classe. Se `Person` aceitos sua implementação de classe base de igualdade, dois `Person` objetos seriam iguais somente se eles referenciados de um único objeto. No entanto, nesse caso, duas `Person` os objetos são iguais se tiverem o mesmo valor para o `Person.Id` propriedade.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Além de substituir <xref:System.Object.Equals%2A>, você pode implementar o <xref:System.IEquatable%601> interface para fornecer um teste com rigidez de tipos para igualdade.  
  
 As instruções a seguir devem ser verdadeiras para todas as implementações do <xref:System.Object.Equals%28System.Object%29> método. Na lista, `x`, `y`, e `z` representam as referências de objeto que não são **nulo**.  
  
-   `x.Equals(x)` Retorna `true`, exceto nos casos que envolvem tipos de ponto flutuante. Consulte 60559:2011 ISO/IEC/IEEE, tecnologia da informação – sistemas do microprocessador – aritmética de ponto flutuante.  
  
-   `x.Equals(y)` retorna o mesmo valor que `y.Equals(x)`.  
  
-   `x.Equals(y)` Retorna `true` se os dois `x` e `y` são `NaN`.  
  
-   Se `(x.Equals(y) && y.Equals(z))` retorna `true`, em seguida, `x.Equals(z)` retorna `true`.  
  
-   Chamadas sucessivas à `x.Equals(y)` retornam o mesmo valor contanto que os objetos referenciados por `x` e `y` não são modificados.  
  
-   `x.Equals(null)` retorna `false`.  
  
 Implementações de <xref:System.Object.Equals%2A> não deve lançar exceções; eles sempre devem retornar um valor. Por exemplo, se `obj` está `null`, o <xref:System.Object.Equals%2A> método deverá retornar `false` em vez de gerar um <xref:System.ArgumentNullException>.  
  
 Siga estas diretrizes ao substituir <xref:System.Object.Equals%28System.Object%29>:  
  
-   Tipos que implementam <xref:System.IComparable> deve substituir <xref:System.Object.Equals%28System.Object%29>.  
  
-   Os tipos que substituem <xref:System.Object.Equals%28System.Object%29> também deve substituir <xref:System.Object.GetHashCode%2A>; caso contrário, as tabelas de hash podem não funcionar corretamente.  
  
-   Você deve considerar implementar o <xref:System.IEquatable%601> interface para oferecer suporte a fortemente tipada testa a igualdade. Sua <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementação deve retornar os resultados que são consistentes com <xref:System.Object.Equals%2A>.  
  
-   Se sua linguagem de programação dá suporte à sobrecarga de operador e sobrecarregar o operador de igualdade para um determinado tipo, você também deve substituir o <xref:System.Object.Equals%28System.Object%29> método para retornar o mesmo resultado que o operador de igualdade. Isso ajuda a garantir que código de biblioteca de classe que usa <xref:System.Object.Equals%2A> (como <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>) se comporta de maneira consistente com a maneira como o operador de igualdade é usado pelo código do aplicativo.  
  
### <a name="guidelines-for-reference-types"></a>Diretrizes para tipos de referência  
 As diretrizes a seguir se aplicam a substituição <xref:System.Object.Equals%28System.Object%29> para um tipo de referência:  
  
-   Considere a substituição <xref:System.Object.Equals%2A> se a semântica do tipo é baseada no fato de que o tipo representa algum valor (es).  
  
-   A maioria dos tipos de referência não deve sobrecarregar o operador de igualdade, mesmo que elas substituem <xref:System.Object.Equals%2A>. No entanto, se você estiver implementando um tipo de referência que deve ter a semântica de valor, como um tipo de número complexo, você deve substituir o operador de igualdade.  
  
-   Você não deve substituir <xref:System.Object.Equals%2A> em um tipo de referência mutável. Isso ocorre porque, substituindo <xref:System.Object.Equals%2A> requer que você também substituir o <xref:System.Object.GetHashCode%2A> método, conforme discutido na seção anterior. Isso significa que o código hash de uma instância de um tipo de referência mutável pode alterar durante seu tempo de vida, o que pode fazer com que o objeto a ser perdidos em uma tabela de hash.  
  
### <a name="guidelines-for-value-types"></a>Diretrizes para tipos de valor  
 As diretrizes a seguir se aplicam a substituição <xref:System.Object.Equals%28System.Object%29> para um tipo de valor:  
  
-   Se você estiver definindo um tipo de valor que inclui um ou mais campos cujos valores são tipos de referência, você deve substituir <xref:System.Object.Equals%28System.Object%29>. O <xref:System.Object.Equals%28System.Object%29> implementação fornecida pelo <xref:System.ValueType> executa uma comparação byte por byte para tipos de valor cujos campos são todos os tipos de valor, mas usa a reflexão para realizar uma comparação de campo por campo de tipos de valor cujos campos incluem tipos de referência.  
  
-   Se você substituir <xref:System.Object.Equals%2A> e a linguagem de desenvolvimento oferece suporte à sobrecarga de operador, você deve sobrecarregar o operador de igualdade.  
  
-   Você deve implementar o <xref:System.IEquatable%601> interface. Chamar fortemente tipados <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método evita a conversão boxing de `obj` argumento.  
  
   
  
## Examples  
 A exemplo a seguir mostra uma `Point` classe que substitui o <xref:System.Object.Equals%2A> método para fornecer a igualdade de valor e um `Point3D` que é derivada da classe `Point`. Porque `Point` substituições <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para testar a igualdade de valor, o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método não é chamado. No entanto, `Point3D.Equals` chamadas `Point.Equals` porque `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> de maneira que fornece a igualdade de valor.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 O `Point.Equals` método verifica para ter certeza de que o `obj` argumento não é **nulo** e que ela faz referência a uma instância do mesmo tipo que este objeto. Se a verificação falhar, o método retorna `false`.  
  
 O `Point.Equals` chamadas de método a <xref:System.Object.GetType%2A> método para determinar se os tipos de tempo de execução dos dois objetos são idênticos. Se o método usado uma verificação do formulário `obj is Point` em c# ou `TryCast(obj, Point)` no Visual Basic, a verificação retornaria `true` em casos em que `obj` é uma instância de uma classe derivada de `Point`, embora `obj` e atual instância não são do mesmo tipo de tempo de execução. Após ter verificado que os dois objetos são do mesmo tipo, as conversões de método `obj` digitar `Point` e retorna o resultado de comparar os campos de instância dos dois objetos.  
  
 Na `Point3D.Equals`, o herdadas `Point.Equals` método, que substitui <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, é invocado antes de qualquer outra coisa é feita. Porque `Point3D` é uma classe selada (`NotInheritable` no Visual Basic), uma verificação no formulário `obj is Point` em c# ou `TryCast(obj, Point)` no Visual Basic é adequada para garantir que `obj` é um `Point3D` objeto. Se for um `Point3D` do objeto, ela será convertida em uma `Point` do objeto e passado para a implementação da classe base <xref:System.Object.Equals%2A>. Somente quando o herdadas `Point.Equals` método retorna `true` faz o método compare o `z` introduzidos na classe derivada de campos de instância.  
  
 O exemplo a seguir define uma `Rectangle` classe que implementa internamente um retângulo como dois `Point` objetos. O `Rectangle` substituições de classe também <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para fornecer a igualdade de valor.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Algumas linguagens como c# e Visual Basic dão suporte a sobrecarga de operador. Quando um tipo sobrecarregar o operador de igualdade, também deve substituir o <xref:System.Object.Equals%28System.Object%29> método para fornecer a mesma funcionalidade. Normalmente, isso é feito escrevendo o <xref:System.Object.Equals%28System.Object%29> método em termos de operador de igualdade sobrecarregados, como no exemplo a seguir.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Porque `Complex` é um tipo de valor, ele não pode ser derivado.  Portanto, a substituição para <xref:System.Object.Equals%28System.Object%29> método não precisa chamar <xref:System.Object.GetType%2A> para determinar o tempo de execução preciso de tipo de cada objeto, mas pode em vez disso, use o `is` operador em c# ou o `TypeOf` operador no Visual Basic para verificar o tipo dos `obj` parâmetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">O primeiro objeto a ser comparado.</param>
        <param name="objB">O segundo objeto a ser comparado.</param>
        <summary>Determina se as instâncias de objeto especificadas são consideradas iguais.</summary>
        <returns>
          <see langword="true" /> se os objetos forem considerados iguais; caso contrário, <see langword="false" />. Se <paramref name="objA" /> e <paramref name="objB" /> forem **null**, o método retornará <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método indica se dois objetos `objA` e `objB`, são iguais. Ele também permite que você teste objetos cujo valor é **nulo** quanto à igualdade. Ele compara `objA` e `objB` quanto à igualdade da seguinte maneira:  
  
-   Determina se os dois objetos representarem a mesma referência de objeto. Se isso acontecer, o método retorna `true`. Esse teste é equivalente a chamar o <xref:System.Object.ReferenceEquals%2A> método. Além disso, se os dois `objA` e `objB` são **nulo**, o método retorna `true`.  
  
-   Determina se o `objA` ou `objB` é **nulo**. Se Sim, ele retorna `false`.  
  
-   Se os dois objetos não representarem a mesma referência de objeto e nenhum deles **nulo**, ele chama `objA`.`Equals` (`objB`) e retorna o resultado. Isso significa que, se `objA` substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método e o compara com o <xref:System.Object.ReferenceEquals%2A> método.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que um objeto tente liberar recursos e executar outras operações de limpeza antes de ser recuperado pela coleta de lixo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Object.Finalize%2A> método é usado para executar operações de limpeza em recursos não gerenciados mantidos pelo objeto atual antes do objeto é destruído. O método é protegido e, portanto, é acessível somente por meio dessa classe ou por meio de uma classe derivada.  
  
 Nesta seção:  
  
-   [Como funciona a finalização](#How)  
  
-   [Observações para implementadores](#Notes)  
  
-   [A alternativa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Como funciona a finalização  
 O <xref:System.Object> classe não fornece uma implementação para o <xref:System.Object.Finalize%2A> método e o coletor de lixo não marcar tipos derivados de <xref:System.Object> para finalização, a menos que elas substituem a <xref:System.Object.Finalize%2A> método.  
  
 Se um tipo de substituir o <xref:System.Object.Finalize%2A> método, o coletor de lixo adiciona uma entrada para cada instância do tipo para uma estrutura interna chamada fila de finalização. Fila de finalização contém entradas para todos os objetos no heap gerenciado cujo código de finalização deve ser executado antes que o coletor de lixo possa recuperar sua memória. O coletor de lixo, em seguida, chama o <xref:System.Object.Finalize%2A> método automaticamente nas seguintes condições:  
  
-   Depois que o coletor de lixo tiver descoberto que um objeto está inacessível, a menos que o objeto tenha sido isentos das finalização por uma chamada para o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
-   **No .NET Framework só**, durante o desligamento de um domínio de aplicativo, a menos que o objeto é isento da finalização. Durante o desligamento, até mesmo objetos que ainda são acessíveis são finalizados.  
  
 <xref:System.Object.Finalize%2A> é chamado automaticamente apenas uma vez em uma determinada instância, a menos que o objeto for registrado novamente usando um mecanismo, como <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> e o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método não tiver sido chamado posteriormente.  
  
 <xref:System.Object.Finalize%2A> as operações têm as seguintes limitações:  
  
-   O tempo exato quando o finalizador for executado é indefinido. Para garantir a liberação determinística dos recursos para instâncias da sua classe, implementar uma `Close` método ou fornecer um <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação.  
  
-   Os finalizadores de dois objetos não são garantidos para ser executado em qualquer ordem específica, mesmo se um objeto se refere ao outro. Ou seja, se o objeto A tem uma referência ao objeto B, e ambos têm finalizadores, objeto B pode já ter sido finalizado quando o finalizador do objeto é iniciado.  
  
-   O thread no qual o finalizador é executado é especificado.  
  
 O <xref:System.Object.Finalize%2A> método talvez não sejam executados até a conclusão ou talvez não sejam executadas nas seguintes circunstâncias excepcionais:  
  
-   Se o finalizador de outra bloquear indefinidamente (entra em um loop infinito, tenta obter um bloqueio, ele nunca pode obter e assim por diante). Como o tempo de execução tenta executar os finalizadores até a conclusão, outros finalizadores não poderá ser chamados se um blocos finalizador indefinidamente.  
  
-   Se o processo é encerrado sem dar a oportunidade de limpar o tempo de execução. Nesse caso, a primeira notificação do tempo de execução do encerramento do processo é uma notificação de DLL_PROCESS_DETACH.  
  
 O tempo de execução continua finalize os objetos somente enquanto continua diminuindo o número de objetos finalizáveis durante o desligamento.  
  
 Se <xref:System.Object.Finalize%2A> ou uma substituição do <xref:System.Object.Finalize%2A> gera uma exceção e o tempo de execução não é hospedado por um aplicativo que substitui a política padrão, o tempo de execução encerra o processo e nenhum ativo `try` / `finally` blocos ou os finalizadores são executados. Esse comportamento garante a integridade do processo se o finalizador não é possível liberar ou destruir os recursos.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Substituindo o método Finalize 
 Você deve substituir <xref:System.Object.Finalize%2A> para uma classe que usa os recursos não gerenciados, como identificadores de arquivos ou conexões de banco de dados que devem ser liberadas quando o objeto gerenciado que usa-los é descartado durante a coleta de lixo. Você não deve implementar um <xref:System.Object.Finalize%2A> método para objetos gerenciados porque o coletor de lixo libera recursos gerenciados automaticamente.  
  
> [!IMPORTANT]
>  Se um <xref:System.Runtime.InteropServices.SafeHandle> objeto está disponível que encapsula o recurso não gerenciado, a alternativa recomendada é implementar o padrão de descarte com um identificador seguro e não substituir <xref:System.Object.Finalize%2A>. Para obter mais informações, consulte [alternativa SafeHandle o](#SafeHandle) seção.  
  
 O <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método não faz nada por padrão, mas você deve substituir <xref:System.Object.Finalize%2A> somente se necessário e somente para liberar recursos não gerenciados. Recuperando memória tende a levar muito mais tempo se uma operação de finalização é executado, porque ele requer pelo menos duas coletas de lixo. Além disso, você deve substituir o <xref:System.Object.Finalize%2A> somente tipos de método para referência. O common language runtime finaliza apenas tipos de referência. Ele ignora os finalizadores em tipos de valor.  

O escopo do <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método é `protected`. Quando você substitui o método em sua classe, você deve manter esse escopo limitado. Mantendo uma <xref:System.Object.Finalize%2A> método protegido, você impede que os usuários do aplicativo de um objeto de chamada <xref:System.Object.Finalize%2A> método diretamente.
  
 Todas as implementações do <xref:System.Object.Finalize%2A> em um tipo derivado deve chamar sua implementação do tipo base do <xref:System.Object.Finalize%2A>. Esse é o único caso em qual aplicativo o código tem permissão para chamar <xref:System.Object.Finalize%2A>. Um objeto <xref:System.Object.Finalize%2A> método não deve chamar um método em todos os objetos que não sejam de sua classe base. Isso ocorre porque os outros objetos que está sendo chamados podem ser coletados ao mesmo tempo como o objeto de chamada, como no caso de um desligamento de tempo de execução de linguagem comum. 
  
> [!NOTE]
>  O compilador c# não permite que você substitua o <xref:System.Object.Finalize%2A> método. Em vez disso, fornecer um finalizador com a implementação de um [destruidor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) para sua classe. Um destruidor c# chama automaticamente o destruidor de sua classe base.  
>   
>  Visual C++ também fornece sua própria sintaxe para implementar o <xref:System.Object.Finalize%2A> método. Para obter mais informações, consulte a seção "Destruidores e finalizadores" de [como: definir e consumir Classes e Structs (C + + / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Como a coleta de lixo é não determinística, você não souber exatamente quando o coletor de lixo realiza a finalização. Para liberar recursos imediatamente, você pode também optar por implementar a [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md) e o <xref:System.IDisposable> interface. O <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação pode ser chamada pelos consumidores da sua classe liberar recursos não gerenciados, e você pode usar o <xref:System.Object.Finalize%2A> método liberar recursos não gerenciados no caso em que o <xref:System.IDisposable.Dispose%2A> método não é chamado.  
  
 <xref:System.Object.Finalize%2A> pode levar a quase qualquer ação, inclusive a trazer de volta um objeto (isto é, fazer o objeto acessível novamente) depois que ele tem sido limpos durante a coleta de lixo. No entanto, o objeto pode apenas ser reativado uma vez. <xref:System.Object.Finalize%2A> não pode ser chamado em objetos reativados durante a coleta de lixo. Há uma ação que sua implementação de <xref:System.Object.Finalize%2A> nunca deve levar: ele nunca deve lançar uma exceção. Se todas as exceções geradas por métodos chamados da <xref:System.Object.Finalize%2A> método são não tratada pela <xref:System.Object.Finalize%2A> método, o tempo de execução supõe que o <xref:System.Object.Finalize%2A> retornado de método e continua a chamar o <xref:System.Object.Finalize%2A> métodos de outros objetos. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>A alternativa SafeHandle  
 Criar os finalizadores confiáveis costuma ser difícil, porque você não pode fazer suposições sobre o estado do seu aplicativo e sem tratamento de exceções do sistema, como <xref:System.OutOfMemoryException> e <xref:System.StackOverflowException> encerrar o finalizador. Em vez de implementar um finalizador para a sua classe para liberar recursos não gerenciados, você pode usar um objeto que deriva de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> de classe para encapsular os seus recursos não gerenciados e, em seguida, implementar o padrão dispose sem um finalizador. O .NET Framework fornece as seguintes classes de <xref:Microsoft.Win32?displayProperty=nameWithType> namespace que são derivados de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> é uma classe wrapper para um identificador de arquivo.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> é uma classe wrapper para identificadores de arquivos mapeados na memória.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> é uma classe wrapper para um ponteiro para um bloco de memória não gerenciada.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> são classes de wrapper para identificadores de criptografia.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> é uma classe wrapper para identificadores de pipe.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> é uma classe wrapper para um identificador para uma chave do registro.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> é uma classe wrapper para um identificador de espera.  
  
 O exemplo a seguir usa o [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md) com identificadores de segurança em vez de substituir o <xref:System.Object.Finalize%2A> método. Ele define uma `FileAssociation` classe que encapsula informações sobre o aplicativo que lida com arquivos com uma extensão de arquivo específico do registro. Os identificadores de duas registro retornados como `out` parâmetros pelo Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) chamadas de função são passadas para o <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> construtor. O tipo protegido `Dispose` , em seguida, chama um método a `SafeRegistryHandle.Dispose` método para liberar esses dois identificadores.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir verifica se o <xref:System.Object.Finalize%2A> método é chamado quando um objeto que substitui <xref:System.Object.Finalize%2A> é destruído. Observe que, em um aplicativo de produção, o <xref:System.Object.Finalize%2A> método deve ser substituído para liberar recursos não gerenciados mantidos pelo objeto. Observe também que o exemplo de c# fornecerá um destruidor em vez de substituir o <xref:System.Object.Finalize%2A> método.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Para obter um exemplo adicional que substitui o <xref:System.Object.Finalize%2A> método, consulte o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serve como a função de hash padrão.</summary>
        <returns>Um código hash do objeto atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um código hash é um valor numérico que é usado para inserir e identificar um objeto em uma coleção baseada em hash, como o <xref:System.Collections.Generic.Dictionary%602> classe, o <xref:System.Collections.Hashtable> classe ou um tipo derivado de <xref:System.Collections.DictionaryBase> classe. O <xref:System.Object.GetHashCode%2A> método fornece esse código hash para algoritmos que precisam de verificações rápidas de igualdade do objeto.  
  
> [!NOTE]
>  Para obter informações sobre como os códigos de hash são usados em tabelas de hash e alguns algoritmos de código de hash adicionais, consulte o [função de Hash](https://en.wikipedia.org/wiki/Hash_function) entrada na Wikipedia.  
  
 Dois objetos que são códigos de hash de retorno iguais são iguais. No entanto, o inverso não é verdadeiro: códigos hash igual não implicam igualdade de objetos, como os diferentes objetos (diferentes) têm códigos hash idênticos. Além disso, o .NET Framework não garante a implementação padrão da <xref:System.Object.GetHashCode%2A> método e o valor que este método retorna podem ser diferentes entre versões do .NET Framework e plataformas, como as plataformas de 32 bits e 64 bits. Por esses motivos, não use a implementação padrão desse método como um identificador exclusivo do objeto para fins de hash. Execute as duas consequências deste:  
  
-   Você não deve presumir que os códigos hash igual implicam igualdade de objetos.  
  
-   Você nunca deve persistir ou usar um código de hash fora do domínio de aplicativo no qual ele foi criado, pois o mesmo objeto pode hash entre plataformas, processos e domínios de aplicativo.  
  
> [!WARNING]
>  Um código hash destina-se de uma inserção e a pesquisa em coleções com base em uma tabela de hash. Um código de hash não é um valor permanente. Por esse motivo:  
>   
> -   Não serializar valores de hash de código ou armazená-los em bancos de dados.  
> -   Não use o código hash como chave para recuperar um objeto de uma coleção com chave.  
> -   Não envie códigos hash em domínios de aplicativo ou processos. Em alguns casos, os códigos de hash podem ser calculados em uma base de domínio por processo ou por aplicativo.  
> -   Não use o código de hash em vez de um valor retornado por uma função de hash criptográfica, se você precisar de um hash criptograficamente forte. Para hashes criptográficos, use uma classe derivada de <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
> -   Não teste a igualdade de códigos de hash para determinar se dois objetos são iguais. (Objetos desiguais podem ter códigos hash idênticos). Para testar a igualdade, chame o <xref:System.Object.ReferenceEquals%2A> ou <xref:System.Object.Equals%2A> método.  
  
 O <xref:System.Object.GetHashCode%2A> método pode ser substituído por um tipo derivado. Se <xref:System.Object.GetHashCode%2A> é não substituído, códigos hash para tipos de referência são computados chamando o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método da classe base, que calcula um código hash com base na referência do objeto; para obter mais informações, consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Em outras palavras, dois objetos para o qual o <xref:System.Object.ReferenceEquals%2A> método retorna `true` têm códigos de hash idênticos. Se os tipos de valor não substituem <xref:System.Object.GetHashCode%2A>, o <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> método da classe base usa reflexão para calcular o código hash com base nos valores de campos do tipo. Em outras palavras, os tipos de valor cujos campos tiverem valores iguais tem códigos hash igual. Para obter mais informações sobre como substituir <xref:System.Object.GetHashCode%2A>, consulte a seção "Observações para Herdeiros".  
  
> [!WARNING]
>  Se você substituir a <xref:System.Object.GetHashCode%2A> método, você também deverá substituir <xref:System.Object.Equals%2A>e vice-versa. Se seu substituída <xref:System.Object.Equals%2A> retorn `true` quando dois objetos são testados quanto à igualdade, seu substituída <xref:System.Object.GetHashCode%2A> método deve retornar o mesmo valor para os dois objetos.  
  
 Se um objeto que é usado como uma chave em uma tabela de hash não fornece uma implementação úteis da <xref:System.Object.GetHashCode%2A>, você pode especificar um provedor de código de hash, fornecendo uma <xref:System.Collections.IEqualityComparer> implementação para uma das sobrecargas do <xref:System.Collections.Hashtable> construtor de classe.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando você chama o <xref:System.Object.GetHashCode%2A> método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.GetHashCode%2A>. Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). As classes a [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e atualmente não implementam um <xref:System.Object.GetHashCode%2A>. No entanto, eles parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.GetHashCode%2A> método.  
  
   
  
## Examples  
 Uma das maneiras mais simples para calcular um código hash para um valor numérico que tem o mesmo ou um intervalo menor que o <xref:System.Int32> tipo é simplesmente retornar esse valor. O exemplo a seguir mostra a tal implementação para um `Number` estrutura.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Com frequência, um tipo tem vários campos de dados que podem participar na geração do código de hash. Uma maneira de gerar um código hash é combinar esses campos usando um `XOR (eXclusive OR)` operação, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 O exemplo anterior retorna o mesmo código hash para (n1, n2) e (n2, n1) e, portanto, pode gerar mais colisões que são desejáveis. Uma série de soluções está disponível para que os códigos de hash nesses casos não são idênticos. Uma é para retornar o código hash de um `Tuple` objeto que reflete a ordem de cada campo. O exemplo a seguir mostra uma possível implementação que usa o <xref:System.Tuple%602> classe. No entanto, observe que a sobrecarga de desempenho de instanciar um `Tuple` objeto pode afetar significativamente o desempenho geral de um aplicativo que armazena um grande número de objetos em tabelas de hash.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Uma segunda solução alternativa envolve ponderar os códigos hash individuais por deslocamento à esquerda os códigos de hash dos campos sucessivos por dois ou mais bits. De maneira ideal, em vez de ser descartado, bits deslocados além do bit 31 devem encapsular em vez de descartadas. Uma vez que os bits são descartados, os operadores de deslocamento à esquerda em c# e Visual Basic, isso requer criando um método de encapsulamento shift esquerdo semelhante ao seguinte:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 O exemplo a seguir, em seguida, usa esse método de shift e encapsulamento para calcular o código hash do `Point` estrutura usada nos exemplos anteriores.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Uma função de hash é usada para gerar rapidamente um número (código de hash) que corresponde ao valor de um objeto. Funções de hash são geralmente específicas para cada tipo e, de exclusividade, devem usar pelo menos um dos campos de instância como entrada. Códigos de hash não devem ser calculados usando os valores de campos estáticos.  
  
Para classes derivadas de <see cref="T:System.Object" />, o <see langword="GetHashCode" /> método pode delegar para a classe base <see cref="M:System.Object.GetHashCode" /> implementação somente se a classe derivada define igualdade para ser a igualdade de referência. A implementação padrão de <see cref="M:System.Object.GetHashCode" /> para referência de tipos retorna um código hash que é equivalente àquele retornado pelo <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> método. Você pode substituir <see cref="M:System.Object.GetHashCode" /> para tipos de referência imutável. Em geral, para tipos de referência mutável, você deve substituir <see cref="M:System.Object.GetHashCode" /> somente se: 
-Você pode calcular o código de hash de campos que não são mutáveis; ou 
-Você pode garantir que o código hash de um objeto mutável não será alterada enquanto o objeto está contido em uma coleção que se baseia em seu código de hash.  
  
Caso contrário, você pode pensar que o objeto mutável é perdido na tabela de hash. Se você optar por substituir <see cref="M:System.Object.GetHashCode" /> para um tipo de referência mutável, a documentação deve deixar claro que os usuários do seu tipo não devem modificar os valores de objeto enquanto o objeto é armazenado em uma tabela de hash.  
  
Para tipos de valor, <see cref="M:System.ValueType.GetHashCode" /> fornece uma implementação de código de hash padrão que usa a reflexão. Você deve considerar a ignorá-lo para melhorar o desempenho.  
  
 <block subset="none" type="note"><para>  
 Para obter mais informações e exemplos de códigos de hash em uma variedade de formas de computação, consulte a seção de exemplos.  
  
</para></block>  
  
 Uma função de hash deve ter as seguintes propriedades: 
-Se dois objetos comparam como iguais, o <see cref="M:System.Object.GetHashCode" /> método para cada objeto deve retornar o mesmo valor. No entanto, se dois objetos não são comparados como iguais, o <see cref="M:System.Object.GetHashCode" /> métodos para os dois objetos não precisa retornar valores diferentes.  
  
-A <see cref="M:System.Object.GetHashCode" /> método para um objeto consistentemente deve retornar o mesmo código hash, desde que não há nenhuma modificação para o estado do objeto que determina o valor retornado do objeto [Equals](xref:System.Object.Equals*) método. Observe que isso seja verdadeiro apenas para a execução atual de um aplicativo e que um código hash diferente pode ser retornado se o aplicativo for executado novamente.  
  
– Para o melhor desempenho, uma função de hash deve gerar uma distribuição uniforme para todas as entradas, incluindo entrada intensamente em cluster. Uma implicação é que as pequenas modificações para o estado do objeto devem resultar em grandes modificações no código de hash resultante para um melhor desempenho de tabela de hash.  
  
– Funções de hash devem ser baixo custo de computação.  
  
-O <see cref="M:System.Object.GetHashCode" /> método não deve lançar exceções.  
  
Por exemplo, a implementação do <see cref="M:System.String.GetHashCode" /> método fornecido pelo <see cref="T:System.String" /> classe retorna códigos de hash idênticos para os valores de cadeia de caracteres idêntica. Portanto, dois <see cref="T:System.String" /> objetos retornam o mesmo código hash se eles representarem o mesmo valor de cadeia de caracteres. Além disso, o método usa todos os caracteres na cadeia de caracteres para gerar a saída distribuída razoavelmente aleatoriamente, mesmo quando a entrada for clusterizada em determinados intervalos (por exemplo, muitos usuários podem ter cadeias de caracteres que contêm somente inferior 128 caracteres ASCII, embora um cadeia de caracteres pode conter nenhum dos caracteres Unicode 65.535).  
  
Fornecer uma boa função de hash em uma classe pode afetar significativamente o desempenho de adicionar esses objetos em uma tabela de hash. Em uma tabela de hash com as chaves que fornecem uma boa implementação de uma função de hash, procurando por um elemento leva um tempo constante (por exemplo, uma operação de (1)). Em uma tabela de hash com uma implementação inadequada de uma função de hash, o desempenho de uma pesquisa depende do número de itens na tabela de hash (por exemplo, um O (`n`) a operação, onde `n` é o número de itens na tabela de hash). Um usuário mal-intencionado pode inserir dados que aumenta o número de conflitos, o que pode afetar significativamente o desempenho de aplicativos que dependem de tabelas de hash, sob as seguintes condições: 
-Quando as funções de hash produzem colisões frequentes.  
  
-Quando uma grande proporção de objetos em uma tabela de hash produzir códigos de hash que são iguais ou aproximadamente iguais um ao outro.  
  
-Quando os usuários os dados do qual o código hash é calculado de entrada.  
  
As classes derivadas que substituem <see cref="M:System.Object.GetHashCode" /> também deve substituir <see cref="M:System.Object.Equals(System.Object)" /> para garantir que dois objetos considerados iguais têm o mesmo código hash; caso contrário, o <see cref="T:System.Collections.Hashtable" /> tipo pode não funcionar corretamente.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o <see cref="T:System.Type" /> da instância atual.</summary>
        <returns>O tipo de tempo de execução exato da instância atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque <xref:System.Object?displayProperty=nameWithType> é a classe base para todos os tipos no sistema de tipos do .NET Framework, o <xref:System.Object.GetType%2A> método pode ser usado para retornar <xref:System.Type> objetos que representam todos os tipos do .NET Framework. O .NET Framework reconhece os cinco categorias de tipos a seguir:  
  
-   Classes, que são derivadas da <xref:System.Object?displayProperty=nameWithType>,  
  
-   Tipos de valor, que são derivados da <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfaces, que são derivadas da <xref:System.Object?displayProperty=nameWithType> começando com o .NET Framework 2.0.  
  
-   Enumerações, que são derivadas da <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegados, que são derivados da <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Para dois objetos `x` e `y` que têm tipos de tempo de execução idênticos `Object.ReferenceEquals(x.GetType(),y.GetType())` retorna `true`. O exemplo a seguir usa o <xref:System.Object.GetType%2A> método com o <xref:System.Object.ReferenceEquals%2A> método para determinar se um valor numérico é o mesmo tipo que dois outros valores numéricos.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Para determinar se um objeto é um tipo específico, você pode usar a palavra-chave de comparação de tipo da sua linguagem ou construir. Por exemplo, você pode usar o `TypeOf…Is` construir no Visual Basic ou o `is` palavra-chave em c#.  
  
 O <xref:System.Object.GetType%2A> método é herdado por todos os tipos que derivam de <xref:System.Object>. Isso significa que, além de usar a palavra-chave de comparação da sua própria linguagem, você pode usar o <xref:System.Object.GetType%2A> método para determinar o tipo de um objeto específico, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 O <xref:System.Type> objeto expõe os metadados associados com a classe do atual <xref:System.Object>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra que <xref:System.Object.GetType%2A> retorna o tipo de tempo de execução da instância atual.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial do <see cref="T:System.Object" /> atual.</summary>
        <returns>Uma cópia superficial do atual <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Object.MemberwiseClone%2A> método cria uma cópia superficial criando um novo objeto e, em seguida, copiando os campos não estáticos do objeto atual para o novo objeto. Se um campo é um tipo de valor, uma cópia de bit por bit do campo será executada. Se um campo é um tipo de referência, a referência será copiada, mas o objeto referenciado é não; Portanto, o objeto original e seu clone se referem ao mesmo objeto.  
  
 Por exemplo, considere um objeto chamado X que faz referência a objetos A e B. o objeto B, por sua vez, o objeto de referências C. Uma cópia superficial de X cria um novo objeto X2 que também faz referência a objetos A e B. Por outro lado, uma cópia em profundidade de X cria um novo objeto X2 que referencia os novos objetos A2 e B2, que são cópias da e B. B2, por sua vez, referencia o novo objeto C2, que é uma cópia do C. O exemplo ilustra a diferença entre um shallow e uma operação de cópia em profundidade.  
  
 Há várias maneiras de implementar uma operação de cópia em profundidade, se a operação de cópia superficial é realizada pelo <xref:System.Object.MemberwiseClone%2A> método não atender às suas necessidades. Eles incluem o seguinte:  
  
-   Chame um construtor de classe do objeto a ser copiado para criar um segundo objeto com os valores de propriedade obtidos do primeiro objeto. Isso pressupõe que os valores de um objeto são totalmente definidos por seu construtor de classe.  
  
-   Chamar o <xref:System.Object.MemberwiseClone%2A> método para criar uma cópia superficial de um objeto e, em seguida, atribuir novos objetos cujos valores são os mesmos que o objeto original para quaisquer propriedades ou campos cujos valores são tipos de referência. O `DeepCopy` método no exemplo ilustra essa abordagem.  
  
-   Serializar o objeto para ser profunda copiada e, em seguida, restaurar os dados serializados para uma variável de objeto diferente.  
  
-   Use a reflexão com a recursão para executar a operação de cópia em profundidade.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o <xref:System.Object.MemberwiseClone%2A> método. Ele define uma `ShallowCopy` método que chama o <xref:System.Object.MemberwiseClone%2A> método para executar uma operação de cópia superficial em um `Person` objeto. Ele também define uma `DeepCopy` método que executa uma operação de cópia em profundidade em uma `Person` objeto.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 Neste exemplo, o `Person.IdInfo` propriedade retorna um `IdInfo` objeto. Como a saída do exemplo mostra, quando um `Person` objeto será clonado, chamando o <xref:System.Object.MemberwiseClone%2A> método, clonado `Person` objeto é uma cópia independente do objeto original, exceto que eles compartilham o mesmo `Person.IdInfo` referência de objeto. Como resultado, modificando o clone `Person.IdInfo` alterações de propriedade do objeto original `Person.IdInfo` propriedade. Por outro lado, quando uma operação de cópia em profundidade é executada, clonado `Person` do objeto, incluindo seu `Person.IdInfo` propriedade, pode ser modificado sem afetar o objeto original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">O primeiro objeto a ser comparado.</param>
        <param name="objB">O segundo objeto a ser comparado.</param>
        <summary>Determina se as instâncias de <see cref="T:System.Object" /> especificadas são a mesma instância.</summary>
        <returns>
          <see langword="true" /> se <paramref name="objA" /> for a mesma instância que <paramref name="objB" /> ou se ambos forem **null**; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao contrário do <xref:System.Object.Equals%2A> método e o operador de igualdade, o <xref:System.Object.ReferenceEquals%2A> método não pode ser substituído. Por isso, se você quiser testar duas referências de igualdade do objeto e você não tiver certeza sobre a implementação do `Equals` método, você pode chamar o <xref:System.Object.ReferenceEquals%2A> método.  
  
 No entanto, o valor de retorno de <xref:System.Object.ReferenceEquals%2A> método pode aparecer como anormais nesses dois cenários:  
  
-   Ao comparar tipos de valor. Se `objA` e `objB` são tipos de valor, eles são boxed antes de serem passados para o <xref:System.Object.ReferenceEquals%2A> método. Isso significa que, se os dois `objA` e `objB` representam a mesma instância de um tipo de valor, o <xref:System.Object.ReferenceEquals%2A> mesmo assim, o método retorna `false`, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Para obter informações sobre tipos de valor de conversão boxing, consulte [conversão Boxing e Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Ao comparar cadeias de caracteres. Se `objA` e `objB` são cadeias de caracteres, o <xref:System.Object.ReferenceEquals%2A> retorno do método `true` se a cadeia de caracteres é internalizada. Ele não executa um teste de igualdade de valor.  No exemplo a seguir `s1` e `s2` são iguais, porque eles são duas instâncias de uma única cadeia de caracteres interno. No entanto, `s3` e `s4` não forem iguais, porque embora são tiverem valores de cadeia de caracteres idêntica, essa cadeia de caracteres não é interno.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Para obter mais informações sobre a centralização da cadeia de caracteres, consulte <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Object.ReferenceEquals%2A> para determinar se dois objetos são a mesma instância.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o objeto atual.</summary>
        <returns>Uma cadeia de caracteres que representa o objeto atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> é o principal método no .NET Framework de formatação. Ele converte um objeto em sua representação de cadeia de caracteres para que ele é adequado para exibição. (Para obter informações sobre a formatação de suporte no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).) Implementações padrão da <xref:System.Object.ToString%2A?displayProperty=nameWithType> o nome totalmente qualificado do tipo do objeto de retorno do método.  
  
> [!IMPORTANT]
>  Talvez você tenha atingido nesta página clicando no link da lista de membros de outro tipo. Isso ocorre porque esse tipo não substituir <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Em vez disso, ele herda a funcionalidade do <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
 Tipos frequentemente substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para fornecer uma representação de cadeia de caracteres mais adequada de um tipo específico. Tipos frequentemente sobrecarregar o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para fornecer suporte para cadeias de caracteres de formato ou formatação sensível à cultura.  
  
 Nesta seção:  
  
 [O método ToString () padrão](#Default)   
 [Substituindo o método ToString)](#Overriding)   
 [Sobrecarregando o método ToString](#Overloading)   
 [Estendendo o método ToString](#Extending)   
 [Notas para o tempo de execução do Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>O método ToString () padrão  
 A implementação padrão do <xref:System.Object.ToString%2A> método retorna o nome totalmente qualificado do tipo do <xref:System.Object>, como mostra o exemplo a seguir.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Porque <xref:System.Object> é a classe base de todos os tipos de referência no .NET Framework, esse comportamento é herdado por tipos de referência que não substituem o <xref:System.Object.ToString%2A> método. O exemplo a seguir ilustra essa situação. Ele define uma classe chamada `Object1` que aceita a implementação padrão de todos os <xref:System.Object> membros. Seu <xref:System.Object.ToString%2A> método retorna o nome de tipo totalmente qualificado do objeto.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Substituindo o método ToString)  
 Tipos comumente substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para retornar uma cadeia de caracteres que representa a instância do objeto. Por exemplo, os tipos de base, como <xref:System.Char>, <xref:System.Int32>, e <xref:System.String> fornecer <xref:System.Object.ToString%2A> implementações que retornam o formulário de cadeia de caracteres do valor que representa o objeto. O exemplo a seguir define uma classe, `Object2`, que substitui o <xref:System.Object.ToString%2A> método para retornar o nome do tipo juntamente com seus valores.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 A tabela a seguir lista as categorias de tipo no .NET Framework e indica se elas substituem a <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.  
  
|Categoria do tipo|Substituições de ToString)|Comportamento|  
|-------------------|-----------------------------------|--------------|  
|Classe|N/D|N/D|  
|Estrutura|Sim (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Mesmo que ToString)|  
|Enumeração|Sim (<xref:System.Enum.ToString?displayProperty=nameWithType>)|O nome do membro|  
|Interface|Não|N/D|  
|delegado|Não|N/D|  
  
 Consulte as seção Observações para herdeiros para obter mais informações sobre substituição de <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Sobrecarregando o método ToString  
 Além de substituir o Next sem parâmetros <xref:System.Object.ToString?displayProperty=nameWithType> sobrecarregam do método, muitos tipos de `ToString` método para fornecer versões do método que aceitam parâmetros. Normalmente, isso é feito para oferecer suporte à formatação de variável e formatação sensível à cultura.  
  
 A exemplo a seguir sobrecarrega o `ToString` método para retornar uma cadeia de caracteres de resultado que inclui o valor de vários campos de um `Automobile` classe. Ele define quatro cadeias de caracteres de formato: G, que retorna o nome do modelo e o ano; 1!d, que retorna o nome do modelo, o ano e o número de portas; C, que retorna o nome do modelo, o ano e o número de cilindros; e A, que retorna uma cadeia de caracteres com todos os valores de campo de quatro.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 O exemplo a seguir chama o sobrecarregado <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para exibir a formatação de cultura de um valor de moeda.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Para obter mais informações sobre cadeias de caracteres de formato e a formatação sensível à cultura, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md). Para as cadeias de caracteres de formato compatíveis com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato com suporte pelos valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Estendendo o método ToString  
 Como um tipo herda o padrão <xref:System.Object.ToString%2A?displayProperty=nameWithType> método, você pode encontrar seu comportamento indesejável e quiser alterá-lo. Isso é particularmente verdadeiro de matrizes e classes de coleção. Enquanto você pode esperar o `ToString` método de uma classe de coleção ou matriz para exibir os valores de seus membros, ele exibirá o nome de tipo totalmente qualificado do tipo, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Você tem várias opções para produzir a cadeia de caracteres de resultado que você gostaria.  
  
-   Se o tipo é uma matriz, um objeto de coleção ou um objeto que implementa o <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interfaces, você pode enumerar seus elementos usando o `foreach` instrução em c# ou o `For Each...Next` construir no Visual Basic.  
  
-   Se a classe não for `sealed` (em c#) ou `NotInheritable` (no Visual Basic), você pode desenvolver uma classe wrapper que herda da classe base cujo <xref:System.Object.ToString%2A?displayProperty=nameWithType> método você deseja personalizar. No mínimo, isso requer que você faça o seguinte:  
  
    1.  Implemente construtores necessários. Classes derivadas não herdam seus construtores de classe base.  
  
    2.  Substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para retornar a cadeia de caracteres de resultado que você gostaria.  
  
     O exemplo a seguir define uma classe wrapper para o <xref:System.Collections.Generic.List%601> classe. Ele substitui o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para exibir o valor de cada método de coleção, em vez do nome de tipo totalmente qualificado.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Desenvolver uma [método de extensão](~/docs/standard/design-guidelines/extension-methods.md) que retorna a cadeia de caracteres de resultado que você deseja. Observe que você não pode substituir o padrão <xref:System.Object.ToString%2A?displayProperty=nameWithType> método dessa forma (ou seja, sua classe de extensão (em c#) ou o módulo (no Visual Basic) não pode ter um método sem parâmetros chamado `ToString` que é chamado no lugar do tipo original `ToString` método . Você precisará fornecer algum outro nome para seu sem parâmetros `ToString` substituição.  
  
     O exemplo a seguir define dois métodos que estendem o <xref:System.Collections.Generic.List%601> classe: um sem parâmetros `ToString2` método e uma `ToString` método com um <xref:System.String> parâmetro que representa uma cadeia de caracteres de formato.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando você chama o <xref:System.Object.ToString%2A> método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.ToString%2A>. Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). As classes de [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e não implemente sempre um <xref:System.Object.ToString%2A>. No entanto, eles sempre parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece um comportamento padrão para esses métodos.  
  
 Começando com o [!INCLUDE[net_v451](~/includes/net-v451-md.md)], o common language runtime usará [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) em uma [!INCLUDE[wrt](~/includes/wrt-md.md)] objeto antes de fazer fallback para a implementação padrão de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.ToString%2A> método.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>O [!INCLUDE[wrt](~/includes/wrt-md.md)] e a interface de IStringable  
 Começando com [!INCLUDE[win81](~/includes/win81-md.md)], o [!INCLUDE[wrt](~/includes/wrt-md.md)] inclui um [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cujo único método, da interface [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fornece suporte para formatação básica comparável ao que fornecido pelo <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Para evitar ambiguidade, você não deve implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em tipos gerenciados.  
  
 Quando os objetos gerenciados são chamados pelo código nativo ou código escritos em linguagens como JavaScript ou C + + c++ /CX, eles aparecem para implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). O common language runtime será encaminhado automaticamente as chamadas de [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) à <xref:System.Object.ToString%2A?displayProperty=nameWithType> no evento [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) não está implementado no objeto gerenciado.  
  
> [!WARNING]
>  Porque o common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) para todos os tipos de gerenciados [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos, é recomendável que você não fornecer seus próprios [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementação. Implementando [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) pode resultar em comportamento não intencional, ao chamar `ToString` da [!INCLUDE[wrt](~/includes/wrt-md.md)], C + c++ /CX ou JavaScript.  
  
 Se você optar por implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em um tipo gerenciado público exportado em um [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, as seguintes restrições se aplicam:  
  
-   Você pode definir as [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface somente em uma relação de "implementos de classe", como  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     em C#, ou  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     no Visual Basic.  
  
-   Você não pode implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em uma interface.  
  
-   Você não pode declarar um parâmetro seja do tipo [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) não pode ser o tipo de retorno de método, propriedade ou campo.  
  
-   Você não pode ocultar sua [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementação de classes base usando uma definição de método como o seguinte:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Em vez disso, o [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementação sempre deve substituir a implementação da classe base. Você pode ocultar uma implementação de `ToString` invocando-a apenas em uma instância da classe fortemente tipada.  
  
 Observe que, em uma variedade de condições, chamadas de código nativo para um tipo gerenciado que implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ou oculta sua [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementação pode produzir um comportamento inesperado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando você implementa seus próprios tipos, você deve substituir o <see cref="M:System.Object.ToString" /> método para retornar valores que são significativas para esses tipos. As classes derivadas que precisam de mais controle sobre a formatação que <see cref="M:System.Object.ToString" /> fornece pode implementar o <see cref="T:System.IFormattable" /> interface. Sua <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> método permite que você defina cadeias de caracteres de formato que controlam a formatação e usar um <see cref="T:System.IFormatProvider" /> objeto que pode fornecer para formatação de cultura específica.  
  
Substituições do <see cref="M:System.Object.ToString" /> método deve seguir estas diretrizes: 
-A cadeia de caracteres retornada deve ser legível por humanos e amigável.  
  
-A cadeia de caracteres retornada deve identificar exclusivamente o valor da instância do objeto.  
  
-A cadeia de caracteres retornada deve ser tão curta quanto possível, para que ele é adequado para exibição por um depurador.  
  
-Seu <see cref="M:System.Object.ToString" /> substituição não deve retornar <see cref="F:System.String.Empty" /> ou uma cadeia de caracteres nula.  
  
-Seu <see cref="M:System.Object.ToString" /> substituição não deve lançar uma exceção.  
  
-Se a representação de cadeia de caracteres de uma instância é sensível à cultura, ou pode ser formatada de várias maneiras, implemente o <see cref="T:System.IFormattable" /> interface.  
  
-Se a cadeia de caracteres retornada inclui informações confidenciais, você deve primeiro exige uma permissão apropriada. Se a solicitação for bem-sucedida, você pode retornar as informações confidenciais; Caso contrário, você deve retornar uma cadeia de caracteres que exclui as informações confidenciais.  
  
-Seu <see cref="M:System.Object.ToString" /> substituição não deve ter nenhum efeito colateral observável para evitar complicações na depuração. Por exemplo, uma chamada para o <see cref="M:System.Object.ToString" /> método não deve alterar o valor dos campos de instância.  
  
-Se o tipo implementa um método de análise (ou <see langword="Parse" /> ou <see langword="TryParse" /> algum outro método estático que cria uma instância do tipo de uma cadeia de caracteres, um construtor ou método), você deve garantir que a cadeia de caracteres retornada pelo <see cref="M:System.Object.ToString" /> método pode ser convertido em uma instância do objeto.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>