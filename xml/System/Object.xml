<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e79dc9260fe7737b92ae37a13293d18776f2b50" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613898" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a622d-101">Dá suporte a todas as classes na hierarquia de classe do .NET Framework e fornece serviços de nível baixo para classes derivadas.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a622d-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="a622d-102">Esta é a classe base definitiva de todas as classes do .NET Framework. É a raiz da hierarquia de tipo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a622d-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-103">Idiomas normalmente não exigem uma classe para declarar a herança de <xref:System.Object> porque a herança está implícita.</span><span class="sxs-lookup"><span data-stu-id="a622d-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="a622d-104">Como todas as classes no .NET Framework são derivadas <xref:System.Object>, todos os métodos definidos na <xref:System.Object> classe está disponível em todos os objetos no sistema.</span><span class="sxs-lookup"><span data-stu-id="a622d-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="a622d-105">Derivado classes can e substituir alguns desses métodos, incluindo:</span><span class="sxs-lookup"><span data-stu-id="a622d-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="a622d-106"><xref:System.Object.Equals%2A> – Dá suporte a comparações entre objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="a622d-107"><xref:System.Object.Finalize%2A> -Executa operações de limpeza antes que um objeto seja recuperado automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a622d-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="a622d-108"><xref:System.Object.GetHashCode%2A> -Gera um número que corresponde ao valor do objeto para dar suporte o uso de uma tabela de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="a622d-109"><xref:System.Object.ToString%2A> -Fabrica uma cadeia de caracteres de texto legível que descreve uma instância da classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="a622d-110">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="a622d-110">Performance Considerations</span></span>  
 <span data-ttu-id="a622d-111">Se você estiver criando uma classe, como uma coleção, que deve lidar com qualquer tipo de objeto, você pode criar membros de classe que aceitam instâncias da <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="a622d-112">No entanto, o processo de conversão boxing e unboxing um tipo transporta um custo de desempenho.</span><span class="sxs-lookup"><span data-stu-id="a622d-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="a622d-113">Se você souber a que sua nova classe frequentemente manipulará determinados tipos de valor, você pode usar uma das duas táticas para minimizar o custo de conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="a622d-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="a622d-114">Criar um método geral que aceita um <xref:System.Object> tipo e um conjunto de sobrecargas de método de tipo específico que aceitam cada tipo de valor que você espera que sua classe para manipular com frequência.</span><span class="sxs-lookup"><span data-stu-id="a622d-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="a622d-115">Se existir um método de tipo específico que aceita o tipo de parâmetro de chamada, nenhuma conversão boxing ocorrerá, e o método de tipo específico é invocado.</span><span class="sxs-lookup"><span data-stu-id="a622d-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="a622d-116">Se não houver nenhum argumento de método que corresponde ao tipo de parâmetro de chamada, o parâmetro é convertido e o método geral é invocado.</span><span class="sxs-lookup"><span data-stu-id="a622d-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="a622d-117">Projetar seu tipo e seus membros para usar genéricos.</span><span class="sxs-lookup"><span data-stu-id="a622d-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="a622d-118">O common language runtime cria um tipo genérico fechado quando você cria uma instância de sua classe e especifica um argumento de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="a622d-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="a622d-119">O método genérico é específico de tipo e pode ser invocado sem o parâmetro de chamada a conversão boxing.</span><span class="sxs-lookup"><span data-stu-id="a622d-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="a622d-120">Embora, às vezes, é necessário desenvolver classes de finalidade geral que aceitam e retornam <xref:System.Object> tipos, você pode melhorar o desempenho, fornecendo também uma classe de tipo específico para lidar com um tipo usado com frequência.</span><span class="sxs-lookup"><span data-stu-id="a622d-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="a622d-121">Por exemplo, fornecer uma classe que é específica para definir e obter valores booleanos elimina o custo de conversão boxing e unboxing valores boolianos.</span><span class="sxs-lookup"><span data-stu-id="a622d-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-122">O exemplo a seguir define um tipo de ponto derivado de <xref:System.Object> de classe e substitui a muitos dos métodos virtuais do <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="a622d-123">Além disso, o exemplo mostra como chamar muitos dos estático e métodos de instância a <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a622d-124">Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a622d-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="a622d-125">Membros de instância não são garantidos para ser thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a622d-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-126">Inicializa uma nova instância da classe <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-127">Este construtor é chamado por construtores em classes derivadas, mas ele também pode ser usado para criar diretamente uma instância da <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a622d-128">Determina se duas instâncias de objeto são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="a622d-129">O objeto a ser comparado com o objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a622d-130">Determina se o objeto especificado é igual ao objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-131">
            <see langword="true" /> se o objeto especificado for igual ao objeto atual; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-132">O tipo de comparação entre a instância atual e o `obj` parâmetro depende se a instância atual é um tipo de referência ou um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="a622d-133">Se a instância atual é um tipo de referência, o <xref:System.Object.Equals%28System.Object%29> método testa a igualdade de referência e uma chamada para o <xref:System.Object.Equals%28System.Object%29> método é equivalente a uma chamada para o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a622d-134">Igualdade de referência significa que as variáveis de objeto são comparadas se referem ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="a622d-135">O exemplo a seguir ilustra o resultado da comparação.</span><span class="sxs-lookup"><span data-stu-id="a622d-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="a622d-136">Ele define uma `Person` classe, que é um tipo de referência, e chama o `Person` construtor de classe para instanciar dois novos `Person` objetos, `person1a` e `person2`, que têm o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="a622d-137">Ele também atribui `person1a` a outra variável de objeto, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="a622d-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="a622d-138">Como a saída do exemplo mostra `person1a` e `person1b` são iguais porque eles referenciam o mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="a622d-139">No entanto, `person1a` e `person2` não forem iguais, embora tenham o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="a622d-140">Se a instância atual é um tipo de valor, o <xref:System.Object.Equals%28System.Object%29> método testa a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="a622d-141">Igualdade de valor significa o seguinte:</span><span class="sxs-lookup"><span data-stu-id="a622d-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="a622d-142">Os dois objetos são do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="a622d-142">The two objects are of the same type.</span></span> <span data-ttu-id="a622d-143">Como mostra o exemplo a seguir, uma <xref:System.Byte> objeto que tem um valor 12 não é igual a um <xref:System.Int32> objeto que tem um valor de 12, porque os dois objetos têm diferentes tipos de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="a622d-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="a622d-144">Os valores dos campos públicos e privados de dois objetos são iguais.</span><span class="sxs-lookup"><span data-stu-id="a622d-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="a622d-145">O exemplo a seguir testa a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-145">The following example tests for value equality.</span></span> <span data-ttu-id="a622d-146">Ele define uma `Person` estrutura, que é um tipo de valor, e chama o `Person` construtor de classe para instanciar dois novos `Person` objetos, `person1` e `person2`, que têm o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="a622d-147">Como mostra a saída do exemplo, embora as variáveis de dois objetos se referirem a objetos diferentes, `person1` e `person2` forem iguais, porque eles têm o mesmo valor para a privada `personName` campo.</span><span class="sxs-lookup"><span data-stu-id="a622d-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="a622d-148">Porque o <xref:System.Object> classe é a classe base para todos os tipos no .NET Framework, o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método fornece a comparação de igualdade padrão para todos os outros tipos.</span><span class="sxs-lookup"><span data-stu-id="a622d-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="a622d-149">No entanto, muitas vezes substituem tipos de <xref:System.Object.Equals%2A> método implementar a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="a622d-150">Para obter mais informações, consulte as notas de chamadores e observações para seções de herdeiros.</span><span class="sxs-lookup"><span data-stu-id="a622d-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="a622d-151">Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="a622d-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="a622d-152">Quando você chama o <xref:System.Object.Equals%28System.Object%29> sobrecarga de método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="a622d-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="a622d-153">Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="a622d-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="a622d-154">As classes a [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e atualmente não implementam um <xref:System.Object.Equals%28System.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="a622d-155">No entanto, eles parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.</span><span class="sxs-lookup"><span data-stu-id="a622d-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="a622d-156">as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.Equals%28System.Object%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="a622d-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="a622d-157">Observações para chamadores</span><span class="sxs-lookup"><span data-stu-id="a622d-157">Notes for Callers</span></span>  
 <span data-ttu-id="a622d-158">As classes derivadas frequentemente substituir o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método implementar a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="a622d-159">Além disso, tipos frequentemente fornecem uma sobrecarga adicional com rigidez de tipos para o `Equals` método, normalmente Implementando o <xref:System.IEquatable%601> interface.</span><span class="sxs-lookup"><span data-stu-id="a622d-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="a622d-160">Quando você chama o `Equals` método para testar a igualdade, você deve saber se a instância atual substitui <xref:System.Object.Equals%2A?displayProperty=nameWithType> e entender como uma chamada específica para um `Equals` método for resolvido.</span><span class="sxs-lookup"><span data-stu-id="a622d-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="a622d-161">Caso contrário, você pode executar um teste de igualdade que seja diferente do que o que você pretendia, e o método pode retornar um valor inesperado.</span><span class="sxs-lookup"><span data-stu-id="a622d-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="a622d-162">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="a622d-162">The following example provides an illustration.</span></span> <span data-ttu-id="a622d-163">Ele cria três <xref:System.Text.StringBuilder> objetos com cadeias de caracteres idênticas e, em seguida, faz quatro chamadas para `Equals` métodos.</span><span class="sxs-lookup"><span data-stu-id="a622d-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="a622d-164">O primeira chamada do método retorna `true`e o retorno de três restantes `false`.</span><span class="sxs-lookup"><span data-stu-id="a622d-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="a622d-165">No primeiro caso, fortemente tipado <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> sobrecarga de método, que testa a igualdade de valor, é chamada.</span><span class="sxs-lookup"><span data-stu-id="a622d-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="a622d-166">Como as cadeias de caracteres atribuída para as duas <xref:System.Text.StringBuilder> objetos forem iguais, o método retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="a622d-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="a622d-167">No entanto, <xref:System.Text.StringBuilder> não substitui <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a622d-168">Por isso, quando o <xref:System.Text.StringBuilder> objeto é convertido em um <xref:System.Object>, quando um <xref:System.Text.StringBuilder> instância é atribuída a uma variável do tipo <xref:System.Object>e quando o <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> método recebe dois <xref:System.Text.StringBuilder> objetos, o padrão <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>método é chamado.</span><span class="sxs-lookup"><span data-stu-id="a622d-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="a622d-169">Porque <xref:System.Text.StringBuilder> é um tipo de referência, isso é equivalente a passando os dois <xref:System.Text.StringBuilder> objetos para o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a622d-170">Embora todas as três <xref:System.Text.StringBuilder> objetos contêm cadeias de caracteres idênticas, eles se referem aos três objetos distintos.</span><span class="sxs-lookup"><span data-stu-id="a622d-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="a622d-171">Como resultado, esses três método chama retorno `false`.</span><span class="sxs-lookup"><span data-stu-id="a622d-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="a622d-172">Você pode comparar o objeto atual com outro objeto de igualdade de referência chamando o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a622d-173">No Visual Basic, você também pode usar o `is` palavra-chave (por exemplo, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="a622d-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="a622d-174">Observações para herdeiros</span><span class="sxs-lookup"><span data-stu-id="a622d-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="a622d-175">Ao definir seu próprio tipo, esse tipo herda a funcionalidade definida pelo `Equals` método do seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="a622d-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="a622d-176">A tabela a seguir lista a implementação padrão da `Equals` método para as principais categorias de tipos no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a622d-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="a622d-177">Categoria do tipo</span><span class="sxs-lookup"><span data-stu-id="a622d-177">Type category</span></span>|<span data-ttu-id="a622d-178">Igualdade definido pelo</span><span class="sxs-lookup"><span data-stu-id="a622d-178">Equality defined by</span></span>|<span data-ttu-id="a622d-179">Comentários</span><span class="sxs-lookup"><span data-stu-id="a622d-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="a622d-180">Classe que deriva diretamente <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a622d-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="a622d-181">Igualdade de referência; equivalente a chamar <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="a622d-182">Estrutura</span><span class="sxs-lookup"><span data-stu-id="a622d-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="a622d-183">Igualdade de valor; comparação direta de byte por byte, ou usando a reflexão de comparação de campo por campo.</span><span class="sxs-lookup"><span data-stu-id="a622d-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="a622d-184">Enumeração</span><span class="sxs-lookup"><span data-stu-id="a622d-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="a622d-185">Os valores devem ter o mesmo tipo de enumeração e o mesmo valor subjacente.</span><span class="sxs-lookup"><span data-stu-id="a622d-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="a622d-186">delegado</span><span class="sxs-lookup"><span data-stu-id="a622d-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="a622d-187">Delegados devem ter o mesmo tipo com listas de invocação idênticos.</span><span class="sxs-lookup"><span data-stu-id="a622d-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="a622d-188">Interface</span><span class="sxs-lookup"><span data-stu-id="a622d-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="a622d-189">Igualdade de referência.</span><span class="sxs-lookup"><span data-stu-id="a622d-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="a622d-190">Para um tipo de valor, você sempre deve substituir <xref:System.Object.Equals%2A>, porque testa a igualdade que dependem de reflexão oferece um desempenho ruim.</span><span class="sxs-lookup"><span data-stu-id="a622d-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="a622d-191">Você também pode substituir a implementação padrão de <xref:System.Object.Equals%2A> para tipos de referência para testar a igualdade de valor em vez de igualdade de referência e definir o significado preciso de igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="a622d-192">Essas implementações de <xref:System.Object.Equals%2A> retornar `true` se os dois objetos têm o mesmo valor, mesmo se eles não são a mesma instância.</span><span class="sxs-lookup"><span data-stu-id="a622d-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="a622d-193">O implementador do tipo decide o que constitui o valor de um objeto, mas é geralmente alguns ou todos os dados armazenados nas variáveis de instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="a622d-194">Por exemplo, o valor de uma <xref:System.String> objeto baseia-se nos caracteres da cadeia de caracteres; a <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> substituições de método a <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método retorne `true` para qualquer dois de cadeia de caracteres instâncias que contêm os mesmos caracteres na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="a622d-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="a622d-195">O exemplo a seguir mostra como substituir o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método para testar a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="a622d-196">Ele substitui o <xref:System.Object.Equals%2A> método para o `Person` classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="a622d-197">Se `Person` aceitos sua implementação de classe base de igualdade, dois `Person` objetos seriam iguais somente se eles referenciados de um único objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="a622d-198">No entanto, nesse caso, duas `Person` os objetos são iguais se tiverem o mesmo valor para o `Person.Id` propriedade.</span><span class="sxs-lookup"><span data-stu-id="a622d-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="a622d-199">Além de substituir <xref:System.Object.Equals%2A>, você pode implementar o <xref:System.IEquatable%601> interface para fornecer um teste com rigidez de tipos para igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="a622d-200">As instruções a seguir devem ser verdadeiras para todas as implementações do <xref:System.Object.Equals%28System.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="a622d-201">Na lista, `x`, `y`, e `z` representam as referências de objeto que não são **nulo**.</span><span class="sxs-lookup"><span data-stu-id="a622d-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="a622d-202">`x.Equals(x)` Retorna `true`, exceto nos casos que envolvem tipos de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="a622d-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="a622d-203">Consulte 60559:2011 ISO/IEC/IEEE, tecnologia da informação – sistemas do microprocessador – aritmética de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="a622d-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="a622d-204">`x.Equals(y)` retorna o mesmo valor que `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="a622d-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="a622d-205">`x.Equals(y)` Retorna `true` se os dois `x` e `y` são `NaN`.</span><span class="sxs-lookup"><span data-stu-id="a622d-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="a622d-206">Se `(x.Equals(y) && y.Equals(z))` retorna `true`, em seguida, `x.Equals(z)` retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="a622d-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="a622d-207">Chamadas sucessivas à `x.Equals(y)` retornam o mesmo valor contanto que os objetos referenciados por `x` e `y` não são modificados.</span><span class="sxs-lookup"><span data-stu-id="a622d-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="a622d-208">`x.Equals(null)` retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="a622d-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="a622d-209">Implementações de <xref:System.Object.Equals%2A> não deve lançar exceções; eles sempre devem retornar um valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="a622d-210">Por exemplo, se `obj` está `null`, o <xref:System.Object.Equals%2A> método deverá retornar `false` em vez de gerar um <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="a622d-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="a622d-211">Siga estas diretrizes ao substituir <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="a622d-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="a622d-212">Tipos que implementam <xref:System.IComparable> deve substituir <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="a622d-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="a622d-213">Os tipos que substituem <xref:System.Object.Equals%28System.Object%29> também deve substituir <xref:System.Object.GetHashCode%2A>; caso contrário, as tabelas de hash podem não funcionar corretamente.</span><span class="sxs-lookup"><span data-stu-id="a622d-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="a622d-214">Você deve considerar implementar o <xref:System.IEquatable%601> interface para oferecer suporte a fortemente tipada testa a igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="a622d-215">Sua <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementação deve retornar os resultados que são consistentes com <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="a622d-216">Se sua linguagem de programação dá suporte à sobrecarga de operador e sobrecarregar o operador de igualdade para um determinado tipo, você também deve substituir o <xref:System.Object.Equals%28System.Object%29> método para retornar o mesmo resultado que o operador de igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="a622d-217">Isso ajuda a garantir que código de biblioteca de classe que usa <xref:System.Object.Equals%2A> (como <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>) se comporta de maneira consistente com a maneira como o operador de igualdade é usado pelo código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a622d-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="a622d-218">Diretrizes para tipos de referência</span><span class="sxs-lookup"><span data-stu-id="a622d-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="a622d-219">As diretrizes a seguir se aplicam a substituição <xref:System.Object.Equals%28System.Object%29> para um tipo de referência:</span><span class="sxs-lookup"><span data-stu-id="a622d-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="a622d-220">Considere a substituição <xref:System.Object.Equals%2A> se a semântica do tipo é baseada no fato de que o tipo representa algum valor (es).</span><span class="sxs-lookup"><span data-stu-id="a622d-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="a622d-221">A maioria dos tipos de referência não deve sobrecarregar o operador de igualdade, mesmo que elas substituem <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="a622d-222">No entanto, se você estiver implementando um tipo de referência que deve ter a semântica de valor, como um tipo de número complexo, você deve substituir o operador de igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="a622d-223">Você não deve substituir <xref:System.Object.Equals%2A> em um tipo de referência mutável.</span><span class="sxs-lookup"><span data-stu-id="a622d-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="a622d-224">Isso ocorre porque, substituindo <xref:System.Object.Equals%2A> requer que você também substituir o <xref:System.Object.GetHashCode%2A> método, conforme discutido na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="a622d-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="a622d-225">Isso significa que o código hash de uma instância de um tipo de referência mutável pode alterar durante seu tempo de vida, o que pode fazer com que o objeto a ser perdidos em uma tabela de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="a622d-226">Diretrizes para tipos de valor</span><span class="sxs-lookup"><span data-stu-id="a622d-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="a622d-227">As diretrizes a seguir se aplicam a substituição <xref:System.Object.Equals%28System.Object%29> para um tipo de valor:</span><span class="sxs-lookup"><span data-stu-id="a622d-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="a622d-228">Se você estiver definindo um tipo de valor que inclui um ou mais campos cujos valores são tipos de referência, você deve substituir <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="a622d-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="a622d-229">O <xref:System.Object.Equals%28System.Object%29> implementação fornecida pelo <xref:System.ValueType> executa uma comparação byte por byte para tipos de valor cujos campos são todos os tipos de valor, mas usa a reflexão para realizar uma comparação de campo por campo de tipos de valor cujos campos incluem tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="a622d-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="a622d-230">Se você substituir <xref:System.Object.Equals%2A> e a linguagem de desenvolvimento oferece suporte à sobrecarga de operador, você deve sobrecarregar o operador de igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="a622d-231">Você deve implementar o <xref:System.IEquatable%601> interface.</span><span class="sxs-lookup"><span data-stu-id="a622d-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="a622d-232">Chamar fortemente tipados <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método evita a conversão boxing de `obj` argumento.</span><span class="sxs-lookup"><span data-stu-id="a622d-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-233">A exemplo a seguir mostra uma `Point` classe que substitui o <xref:System.Object.Equals%2A> método para fornecer a igualdade de valor e um `Point3D` que é derivada da classe `Point`.</span><span class="sxs-lookup"><span data-stu-id="a622d-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="a622d-234">Porque `Point` substituições <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para testar a igualdade de valor, o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método não é chamado.</span><span class="sxs-lookup"><span data-stu-id="a622d-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="a622d-235">No entanto, `Point3D.Equals` chamadas `Point.Equals` porque `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> de maneira que fornece a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="a622d-236">O `Point.Equals` método verifica para ter certeza de que o `obj` argumento não é **nulo** e que ela faz referência a uma instância do mesmo tipo que este objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="a622d-237">Se a verificação falhar, o método retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="a622d-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="a622d-238">O `Point.Equals` chamadas de método a <xref:System.Object.GetType%2A> método para determinar se os tipos de tempo de execução dos dois objetos são idênticos.</span><span class="sxs-lookup"><span data-stu-id="a622d-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="a622d-239">Se o método usado uma verificação do formulário `obj is Point` em c# ou `TryCast(obj, Point)` no Visual Basic, a verificação retornaria `true` em casos em que `obj` é uma instância de uma classe derivada de `Point`, embora `obj` e atual instância não são do mesmo tipo de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="a622d-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="a622d-240">Após ter verificado que os dois objetos são do mesmo tipo, as conversões de método `obj` digitar `Point` e retorna o resultado de comparar os campos de instância dos dois objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="a622d-241">Na `Point3D.Equals`, o herdadas `Point.Equals` método, que substitui <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, é invocado antes de qualquer outra coisa é feita.</span><span class="sxs-lookup"><span data-stu-id="a622d-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="a622d-242">Porque `Point3D` é uma classe selada (`NotInheritable` no Visual Basic), uma verificação no formulário `obj is Point` em c# ou `TryCast(obj, Point)` no Visual Basic é adequada para garantir que `obj` é um `Point3D` objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="a622d-243">Se for um `Point3D` do objeto, ela será convertida em uma `Point` do objeto e passado para a implementação da classe base <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="a622d-244">Somente quando o herdadas `Point.Equals` método retorna `true` faz o método compare o `z` introduzidos na classe derivada de campos de instância.</span><span class="sxs-lookup"><span data-stu-id="a622d-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="a622d-245">O exemplo a seguir define uma `Rectangle` classe que implementa internamente um retângulo como dois `Point` objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="a622d-246">O `Rectangle` substituições de classe também <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para fornecer a igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="a622d-247">Algumas linguagens como c# e Visual Basic dão suporte a sobrecarga de operador.</span><span class="sxs-lookup"><span data-stu-id="a622d-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="a622d-248">Quando um tipo sobrecarregar o operador de igualdade, também deve substituir o <xref:System.Object.Equals%28System.Object%29> método para fornecer a mesma funcionalidade.</span><span class="sxs-lookup"><span data-stu-id="a622d-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="a622d-249">Normalmente, isso é feito escrevendo o <xref:System.Object.Equals%28System.Object%29> método em termos de operador de igualdade sobrecarregados, como no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="a622d-250">Porque `Complex` é um tipo de valor, ele não pode ser derivado.</span><span class="sxs-lookup"><span data-stu-id="a622d-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="a622d-251">Portanto, a substituição para <xref:System.Object.Equals%28System.Object%29> método não precisa chamar <xref:System.Object.GetType%2A> para determinar o tempo de execução preciso de tipo de cada objeto, mas pode em vez disso, use o `is` operador em c# ou o `TypeOf` operador no Visual Basic para verificar o tipo dos `obj` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="a622d-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="a622d-252">O primeiro objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="a622d-253">O segundo objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a622d-254">Determina se as instâncias de objeto especificadas são consideradas iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-255">
            <see langword="true" /> se os objetos forem considerados iguais; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="a622d-256">Se <paramref name="objA" /> e <paramref name="objB" /> forem **null**, o método retornará <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-257">Estático <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método indica se dois objetos `objA` e `objB`, são iguais.</span><span class="sxs-lookup"><span data-stu-id="a622d-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="a622d-258">Ele também permite que você teste objetos cujo valor é **nulo** quanto à igualdade.</span><span class="sxs-lookup"><span data-stu-id="a622d-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="a622d-259">Ele compara `objA` e `objB` quanto à igualdade da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="a622d-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="a622d-260">Determina se os dois objetos representarem a mesma referência de objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="a622d-261">Se isso acontecer, o método retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="a622d-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="a622d-262">Esse teste é equivalente a chamar o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a622d-263">Além disso, se os dois `objA` e `objB` são **nulo**, o método retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="a622d-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="a622d-264">Determina se o `objA` ou `objB` é **nulo**.</span><span class="sxs-lookup"><span data-stu-id="a622d-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="a622d-265">Se Sim, ele retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="a622d-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="a622d-266">Se os dois objetos não representarem a mesma referência de objeto e nenhum deles **nulo**, ele chama `objA`.`Equals` (`objB`) e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="a622d-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="a622d-267">Isso significa que, se `objA` substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="a622d-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-268">O exemplo a seguir ilustra a <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> método e o compara com o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-269">Permite que um objeto tente liberar recursos e executar outras operações de limpeza antes de ser recuperado pela coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-270">O <xref:System.Object.Finalize%2A> método é usado para executar operações de limpeza em recursos não gerenciados mantidos pelo objeto atual antes do objeto é destruído.</span><span class="sxs-lookup"><span data-stu-id="a622d-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="a622d-271">O método é protegido e, portanto, é acessível somente por meio dessa classe ou por meio de uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="a622d-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="a622d-272">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="a622d-272">In this section:</span></span>  
  
-   [<span data-ttu-id="a622d-273">Como funciona a finalização</span><span class="sxs-lookup"><span data-stu-id="a622d-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="a622d-274">Observações para implementadores</span><span class="sxs-lookup"><span data-stu-id="a622d-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="a622d-275">A alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="a622d-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="a622d-276">Como funciona a finalização</span><span class="sxs-lookup"><span data-stu-id="a622d-276">How finalization works</span></span>  
 <span data-ttu-id="a622d-277">O <xref:System.Object> classe não fornece uma implementação para o <xref:System.Object.Finalize%2A> método e o coletor de lixo não marcar tipos derivados de <xref:System.Object> para finalização, a menos que elas substituem a <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="a622d-278">Se um tipo de substituir o <xref:System.Object.Finalize%2A> método, o coletor de lixo adiciona uma entrada para cada instância do tipo para uma estrutura interna chamada fila de finalização.</span><span class="sxs-lookup"><span data-stu-id="a622d-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="a622d-279">Fila de finalização contém entradas para todos os objetos no heap gerenciado cujo código de finalização deve ser executado antes que o coletor de lixo possa recuperar sua memória.</span><span class="sxs-lookup"><span data-stu-id="a622d-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="a622d-280">O coletor de lixo, em seguida, chama o <xref:System.Object.Finalize%2A> método automaticamente nas seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="a622d-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="a622d-281">Depois que o coletor de lixo tiver descoberto que um objeto está inacessível, a menos que o objeto tenha sido isentos das finalização por uma chamada para o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="a622d-282">**No .NET Framework só**, durante o desligamento de um domínio de aplicativo, a menos que o objeto é isento da finalização.</span><span class="sxs-lookup"><span data-stu-id="a622d-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="a622d-283">Durante o desligamento, até mesmo objetos que ainda são acessíveis são finalizados.</span><span class="sxs-lookup"><span data-stu-id="a622d-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="a622d-284"><xref:System.Object.Finalize%2A> é chamado automaticamente apenas uma vez em uma determinada instância, a menos que o objeto for registrado novamente usando um mecanismo, como <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> e o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método não tiver sido chamado posteriormente.</span><span class="sxs-lookup"><span data-stu-id="a622d-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="a622d-285"><xref:System.Object.Finalize%2A> as operações têm as seguintes limitações:</span><span class="sxs-lookup"><span data-stu-id="a622d-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="a622d-286">O tempo exato quando o finalizador for executado é indefinido.</span><span class="sxs-lookup"><span data-stu-id="a622d-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="a622d-287">Para garantir a liberação determinística dos recursos para instâncias da sua classe, implementar uma `Close` método ou fornecer um <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação.</span><span class="sxs-lookup"><span data-stu-id="a622d-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="a622d-288">Os finalizadores de dois objetos não são garantidos para ser executado em qualquer ordem específica, mesmo se um objeto se refere ao outro.</span><span class="sxs-lookup"><span data-stu-id="a622d-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="a622d-289">Ou seja, se o objeto A tem uma referência ao objeto B, e ambos têm finalizadores, objeto B pode já ter sido finalizado quando o finalizador do objeto é iniciado.</span><span class="sxs-lookup"><span data-stu-id="a622d-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="a622d-290">O thread no qual o finalizador é executado é especificado.</span><span class="sxs-lookup"><span data-stu-id="a622d-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="a622d-291">O <xref:System.Object.Finalize%2A> método talvez não sejam executados até a conclusão ou talvez não sejam executadas nas seguintes circunstâncias excepcionais:</span><span class="sxs-lookup"><span data-stu-id="a622d-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="a622d-292">Se o finalizador de outra bloquear indefinidamente (entra em um loop infinito, tenta obter um bloqueio, ele nunca pode obter e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="a622d-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="a622d-293">Como o tempo de execução tenta executar os finalizadores até a conclusão, outros finalizadores não poderá ser chamados se um blocos finalizador indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="a622d-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="a622d-294">Se o processo é encerrado sem dar a oportunidade de limpar o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="a622d-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="a622d-295">Nesse caso, a primeira notificação do tempo de execução do encerramento do processo é uma notificação de DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="a622d-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="a622d-296">O tempo de execução continua finalize os objetos somente enquanto continua diminuindo o número de objetos finalizáveis durante o desligamento.</span><span class="sxs-lookup"><span data-stu-id="a622d-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="a622d-297">Se <xref:System.Object.Finalize%2A> ou uma substituição do <xref:System.Object.Finalize%2A> gera uma exceção e o tempo de execução não é hospedado por um aplicativo que substitui a política padrão, o tempo de execução encerra o processo e nenhum ativo `try` / `finally` blocos ou os finalizadores são executados.</span><span class="sxs-lookup"><span data-stu-id="a622d-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="a622d-298">Esse comportamento garante a integridade do processo se o finalizador não é possível liberar ou destruir os recursos.</span><span class="sxs-lookup"><span data-stu-id="a622d-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="a622d-299">Substituindo o método Finalize</span><span class="sxs-lookup"><span data-stu-id="a622d-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="a622d-300">Você deve substituir <xref:System.Object.Finalize%2A> para uma classe que usa os recursos não gerenciados, como identificadores de arquivos ou conexões de banco de dados que devem ser liberadas quando o objeto gerenciado que usa-los é descartado durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="a622d-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="a622d-301">Você não deve implementar um <xref:System.Object.Finalize%2A> método para objetos gerenciados porque o coletor de lixo libera recursos gerenciados automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a622d-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a622d-302">Se um <xref:System.Runtime.InteropServices.SafeHandle> objeto está disponível que encapsula o recurso não gerenciado, a alternativa recomendada é implementar o padrão de descarte com um identificador seguro e não substituir <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="a622d-303">Para obter mais informações, consulte [alternativa SafeHandle o](#SafeHandle) seção.</span><span class="sxs-lookup"><span data-stu-id="a622d-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="a622d-304">O <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método não faz nada por padrão, mas você deve substituir <xref:System.Object.Finalize%2A> somente se necessário e somente para liberar recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="a622d-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="a622d-305">Recuperando memória tende a levar muito mais tempo se uma operação de finalização é executado, porque ele requer pelo menos duas coletas de lixo.</span><span class="sxs-lookup"><span data-stu-id="a622d-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="a622d-306">Além disso, você deve substituir o <xref:System.Object.Finalize%2A> somente tipos de método para referência.</span><span class="sxs-lookup"><span data-stu-id="a622d-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="a622d-307">O common language runtime finaliza apenas tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="a622d-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="a622d-308">Ele ignora os finalizadores em tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="a622d-309">O escopo do <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método é `protected`.</span><span class="sxs-lookup"><span data-stu-id="a622d-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="a622d-310">Quando você substitui o método em sua classe, você deve manter esse escopo limitado.</span><span class="sxs-lookup"><span data-stu-id="a622d-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="a622d-311">Mantendo uma <xref:System.Object.Finalize%2A> método protegido, você impede que os usuários do aplicativo de um objeto de chamada <xref:System.Object.Finalize%2A> método diretamente.</span><span class="sxs-lookup"><span data-stu-id="a622d-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="a622d-312">Todas as implementações do <xref:System.Object.Finalize%2A> em um tipo derivado deve chamar sua implementação do tipo base do <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="a622d-313">Esse é o único caso em qual aplicativo o código tem permissão para chamar <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="a622d-314">Um objeto <xref:System.Object.Finalize%2A> método não deve chamar um método em todos os objetos que não sejam de sua classe base.</span><span class="sxs-lookup"><span data-stu-id="a622d-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="a622d-315">Isso ocorre porque os outros objetos que está sendo chamados podem ser coletados ao mesmo tempo como o objeto de chamada, como no caso de um desligamento de tempo de execução de linguagem comum.</span><span class="sxs-lookup"><span data-stu-id="a622d-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="a622d-316">O compilador c# não permite que você substitua o <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="a622d-317">Em vez disso, fornecer um finalizador com a implementação de um [destruidor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) para sua classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="a622d-318">Um destruidor c# chama automaticamente o destruidor de sua classe base.</span><span class="sxs-lookup"><span data-stu-id="a622d-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="a622d-319">Visual C++ também fornece sua própria sintaxe para implementar o <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="a622d-320">Para obter mais informações, consulte a seção "Destruidores e finalizadores" de [como: definir e consumir Classes e Structs (C + + / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="a622d-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="a622d-321">Como a coleta de lixo é não determinística, você não souber exatamente quando o coletor de lixo realiza a finalização.</span><span class="sxs-lookup"><span data-stu-id="a622d-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="a622d-322">Para liberar recursos imediatamente, você pode também optar por implementar a [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md) e o <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="a622d-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a622d-323">O <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação pode ser chamada pelos consumidores da sua classe liberar recursos não gerenciados, e você pode usar o <xref:System.Object.Finalize%2A> método liberar recursos não gerenciados no caso em que o <xref:System.IDisposable.Dispose%2A> método não é chamado.</span><span class="sxs-lookup"><span data-stu-id="a622d-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="a622d-324"><xref:System.Object.Finalize%2A> pode levar a quase qualquer ação, inclusive a trazer de volta um objeto (isto é, fazer o objeto acessível novamente) depois que ele tem sido limpos durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="a622d-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="a622d-325">No entanto, o objeto pode apenas ser reativado uma vez. <xref:System.Object.Finalize%2A> não pode ser chamado em objetos reativados durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="a622d-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="a622d-326">Há uma ação que sua implementação de <xref:System.Object.Finalize%2A> nunca deve levar: ele nunca deve lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="a622d-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="a622d-327">Se todas as exceções geradas por métodos chamados da <xref:System.Object.Finalize%2A> método são não tratada pela <xref:System.Object.Finalize%2A> método, o tempo de execução supõe que o <xref:System.Object.Finalize%2A> retornado de método e continua a chamar o <xref:System.Object.Finalize%2A> métodos de outros objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="a622d-328">A alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="a622d-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="a622d-329">Criar os finalizadores confiáveis costuma ser difícil, porque você não pode fazer suposições sobre o estado do seu aplicativo e sem tratamento de exceções do sistema, como <xref:System.OutOfMemoryException> e <xref:System.StackOverflowException> encerrar o finalizador.</span><span class="sxs-lookup"><span data-stu-id="a622d-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="a622d-330">Em vez de implementar um finalizador para a sua classe para liberar recursos não gerenciados, você pode usar um objeto que deriva de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> de classe para encapsular os seus recursos não gerenciados e, em seguida, implementar o padrão dispose sem um finalizador.</span><span class="sxs-lookup"><span data-stu-id="a622d-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="a622d-331">O .NET Framework fornece as seguintes classes de <xref:Microsoft.Win32?displayProperty=nameWithType> namespace que são derivados de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="a622d-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="a622d-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> é uma classe wrapper para um identificador de arquivo.</span><span class="sxs-lookup"><span data-stu-id="a622d-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="a622d-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> é uma classe wrapper para identificadores de arquivos mapeados na memória.</span><span class="sxs-lookup"><span data-stu-id="a622d-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="a622d-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> é uma classe wrapper para um ponteiro para um bloco de memória não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="a622d-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="a622d-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> são classes de wrapper para identificadores de criptografia.</span><span class="sxs-lookup"><span data-stu-id="a622d-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="a622d-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> é uma classe wrapper para identificadores de pipe.</span><span class="sxs-lookup"><span data-stu-id="a622d-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="a622d-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> é uma classe wrapper para um identificador para uma chave do registro.</span><span class="sxs-lookup"><span data-stu-id="a622d-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="a622d-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> é uma classe wrapper para um identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="a622d-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="a622d-339">O exemplo a seguir usa o [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md) com identificadores de segurança em vez de substituir o <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="a622d-340">Ele define uma `FileAssociation` classe que encapsula informações sobre o aplicativo que lida com arquivos com uma extensão de arquivo específico do registro.</span><span class="sxs-lookup"><span data-stu-id="a622d-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="a622d-341">Os identificadores de duas registro retornados como `out` parâmetros pelo Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) chamadas de função são passadas para o <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> construtor.</span><span class="sxs-lookup"><span data-stu-id="a622d-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="a622d-342">O tipo protegido `Dispose` , em seguida, chama um método a `SafeRegistryHandle.Dispose` método para liberar esses dois identificadores.</span><span class="sxs-lookup"><span data-stu-id="a622d-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="a622d-343">O exemplo a seguir verifica se o <xref:System.Object.Finalize%2A> método é chamado quando um objeto que substitui <xref:System.Object.Finalize%2A> é destruído.</span><span class="sxs-lookup"><span data-stu-id="a622d-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="a622d-344">Observe que, em um aplicativo de produção, o <xref:System.Object.Finalize%2A> método deve ser substituído para liberar recursos não gerenciados mantidos pelo objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="a622d-345">Observe também que o exemplo de c# fornecerá um destruidor em vez de substituir o <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="a622d-346">Para obter um exemplo adicional que substitui o <xref:System.Object.Finalize%2A> método, consulte o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-347">Serve como a função de hash padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-348">Um código hash do objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-349">Um código hash é um valor numérico que é usado para inserir e identificar um objeto em uma coleção baseada em hash, como o <xref:System.Collections.Generic.Dictionary%602> classe, o <xref:System.Collections.Hashtable> classe ou um tipo derivado de <xref:System.Collections.DictionaryBase> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="a622d-350">O <xref:System.Object.GetHashCode%2A> método fornece esse código hash para algoritmos que precisam de verificações rápidas de igualdade do objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a622d-351">Para obter informações sobre como os códigos de hash são usados em tabelas de hash e alguns algoritmos de código de hash adicionais, consulte o [função de Hash](https://en.wikipedia.org/wiki/Hash_function) entrada na Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="a622d-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="a622d-352">Dois objetos que são códigos de hash de retorno iguais são iguais.</span><span class="sxs-lookup"><span data-stu-id="a622d-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="a622d-353">No entanto, o inverso não é verdadeiro: códigos hash igual não implicam igualdade de objetos, como os diferentes objetos (diferentes) têm códigos hash idênticos.</span><span class="sxs-lookup"><span data-stu-id="a622d-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="a622d-354">Além disso, o .NET Framework não garante a implementação padrão da <xref:System.Object.GetHashCode%2A> método e o valor que este método retorna podem ser diferentes entre versões do .NET Framework e plataformas, como as plataformas de 32 bits e 64 bits.</span><span class="sxs-lookup"><span data-stu-id="a622d-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="a622d-355">Por esses motivos, não use a implementação padrão desse método como um identificador exclusivo do objeto para fins de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="a622d-356">Execute as duas consequências deste:</span><span class="sxs-lookup"><span data-stu-id="a622d-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="a622d-357">Você não deve presumir que os códigos hash igual implicam igualdade de objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="a622d-358">Você nunca deve persistir ou usar um código de hash fora do domínio de aplicativo no qual ele foi criado, pois o mesmo objeto pode hash entre plataformas, processos e domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a622d-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a622d-359">Um código hash destina-se de uma inserção e a pesquisa em coleções com base em uma tabela de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="a622d-360">Um código de hash não é um valor permanente.</span><span class="sxs-lookup"><span data-stu-id="a622d-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="a622d-361">Por esse motivo:</span><span class="sxs-lookup"><span data-stu-id="a622d-361">For this reason:</span></span>  
>   
> -   <span data-ttu-id="a622d-362">Não serializar valores de hash de código ou armazená-los em bancos de dados.</span><span class="sxs-lookup"><span data-stu-id="a622d-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="a622d-363">Não use o código hash como chave para recuperar um objeto de uma coleção com chave.</span><span class="sxs-lookup"><span data-stu-id="a622d-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="a622d-364">Não envie códigos hash em domínios de aplicativo ou processos.</span><span class="sxs-lookup"><span data-stu-id="a622d-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="a622d-365">Em alguns casos, os códigos de hash podem ser calculados em uma base de domínio por processo ou por aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a622d-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="a622d-366">Não use o código de hash em vez de um valor retornado por uma função de hash criptográfica, se você precisar de um hash criptograficamente forte.</span><span class="sxs-lookup"><span data-stu-id="a622d-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="a622d-367">Para hashes criptográficos, use uma classe derivada de <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="a622d-368">Não teste a igualdade de códigos de hash para determinar se dois objetos são iguais.</span><span class="sxs-lookup"><span data-stu-id="a622d-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="a622d-369">(Objetos desiguais podem ter códigos hash idênticos). Para testar a igualdade, chame o <xref:System.Object.ReferenceEquals%2A> ou <xref:System.Object.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="a622d-370">O <xref:System.Object.GetHashCode%2A> método pode ser substituído por um tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="a622d-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="a622d-371">Se <xref:System.Object.GetHashCode%2A> é não substituído, códigos hash para tipos de referência são computados chamando o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método da classe base, que calcula um código hash com base na referência do objeto; para obter mais informações, consulte <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a622d-372">Em outras palavras, dois objetos para o qual o <xref:System.Object.ReferenceEquals%2A> método retorna `true` têm códigos de hash idênticos.</span><span class="sxs-lookup"><span data-stu-id="a622d-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="a622d-373">Se os tipos de valor não substituem <xref:System.Object.GetHashCode%2A>, o <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> método da classe base usa reflexão para calcular o código hash com base nos valores de campos do tipo.</span><span class="sxs-lookup"><span data-stu-id="a622d-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="a622d-374">Em outras palavras, os tipos de valor cujos campos tiverem valores iguais tem códigos hash igual.</span><span class="sxs-lookup"><span data-stu-id="a622d-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="a622d-375">Para obter mais informações sobre como substituir <xref:System.Object.GetHashCode%2A>, consulte a seção "Observações para Herdeiros".</span><span class="sxs-lookup"><span data-stu-id="a622d-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a622d-376">Se você substituir a <xref:System.Object.GetHashCode%2A> método, você também deverá substituir <xref:System.Object.Equals%2A>e vice-versa.</span><span class="sxs-lookup"><span data-stu-id="a622d-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="a622d-377">Se seu substituída <xref:System.Object.Equals%2A> retorn `true` quando dois objetos são testados quanto à igualdade, seu substituída <xref:System.Object.GetHashCode%2A> método deve retornar o mesmo valor para os dois objetos.</span><span class="sxs-lookup"><span data-stu-id="a622d-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="a622d-378">Se um objeto que é usado como uma chave em uma tabela de hash não fornece uma implementação úteis da <xref:System.Object.GetHashCode%2A>, você pode especificar um provedor de código de hash, fornecendo uma <xref:System.Collections.IEqualityComparer> implementação para uma das sobrecargas do <xref:System.Collections.Hashtable> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="a622d-379">Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="a622d-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="a622d-380">Quando você chama o <xref:System.Object.GetHashCode%2A> método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="a622d-381">Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="a622d-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="a622d-382">As classes a [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e atualmente não implementam um <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="a622d-383">No entanto, eles parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.</span><span class="sxs-lookup"><span data-stu-id="a622d-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="a622d-384">as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.GetHashCode%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-384">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-385">Uma das maneiras mais simples para calcular um código hash para um valor numérico que tem o mesmo ou um intervalo menor que o <xref:System.Int32> tipo é simplesmente retornar esse valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="a622d-386">O exemplo a seguir mostra a tal implementação para um `Number` estrutura.</span><span class="sxs-lookup"><span data-stu-id="a622d-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="a622d-387">Com frequência, um tipo tem vários campos de dados que podem participar na geração do código de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="a622d-388">Uma maneira de gerar um código hash é combinar esses campos usando um `XOR (eXclusive OR)` operação, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="a622d-389">O exemplo anterior retorna o mesmo código hash para (n1, n2) e (n2, n1) e, portanto, pode gerar mais colisões que são desejáveis.</span><span class="sxs-lookup"><span data-stu-id="a622d-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="a622d-390">Uma série de soluções está disponível para que os códigos de hash nesses casos não são idênticos.</span><span class="sxs-lookup"><span data-stu-id="a622d-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="a622d-391">Uma é para retornar o código hash de um `Tuple` objeto que reflete a ordem de cada campo.</span><span class="sxs-lookup"><span data-stu-id="a622d-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="a622d-392">O exemplo a seguir mostra uma possível implementação que usa o <xref:System.Tuple%602> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="a622d-393">No entanto, observe que a sobrecarga de desempenho de instanciar um `Tuple` objeto pode afetar significativamente o desempenho geral de um aplicativo que armazena um grande número de objetos em tabelas de hash.</span><span class="sxs-lookup"><span data-stu-id="a622d-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="a622d-394">Uma segunda solução alternativa envolve ponderar os códigos hash individuais por deslocamento à esquerda os códigos de hash dos campos sucessivos por dois ou mais bits.</span><span class="sxs-lookup"><span data-stu-id="a622d-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="a622d-395">De maneira ideal, em vez de ser descartado, bits deslocados além do bit 31 devem encapsular em vez de descartadas.</span><span class="sxs-lookup"><span data-stu-id="a622d-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="a622d-396">Uma vez que os bits são descartados, os operadores de deslocamento à esquerda em c# e Visual Basic, isso requer criando um método de encapsulamento shift esquerdo semelhante ao seguinte:</span><span class="sxs-lookup"><span data-stu-id="a622d-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="a622d-397">O exemplo a seguir, em seguida, usa esse método de shift e encapsulamento para calcular o código hash do `Point` estrutura usada nos exemplos anteriores.</span><span class="sxs-lookup"><span data-stu-id="a622d-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a622d-398">Uma função de hash é usada para gerar rapidamente um número (código de hash) que corresponde ao valor de um objeto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-398">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span>
            </span>
            <span data-ttu-id="a622d-399">Funções de hash são geralmente específicas para cada tipo e, de exclusividade, devem usar pelo menos um dos campos de instância como entrada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-399">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span>
            </span>
            <span data-ttu-id="a622d-400">Códigos de hash não devem ser calculados usando os valores de campos estáticos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-400">Hash codes should not be computed by using the values of static fields.</span>
            </span>
            <span data-ttu-id="a622d-401">Para classes derivadas de <see cref="T:System.Object" />, o <see langword="GetHashCode" /> método pode delegar para a classe base <see cref="M:System.Object.GetHashCode" /> implementação somente se a classe derivada define igualdade para ser a igualdade de referência.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-401">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span>
            </span>
            <span data-ttu-id="a622d-402">A implementação padrão de <see cref="M:System.Object.GetHashCode" /> para referência de tipos retorna um código hash que é equivalente àquele retornado pelo <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-402">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span>
            </span>
            <span data-ttu-id="a622d-403">Você pode substituir <see cref="M:System.Object.GetHashCode" /> para tipos de referência imutável.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-403">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span>
            </span>
            <span data-ttu-id="a622d-404">Em geral, para tipos de referência mutável, você deve substituir <see cref="M:System.Object.GetHashCode" /> somente se:</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-404">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span>
            </span>
            <span data-ttu-id="a622d-405">-Você pode calcular o código de hash de campos que não são mutáveis; ou</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-405">-   You can compute the hash code from fields that are not mutable; or</span>
            </span>
            <span data-ttu-id="a622d-406">-Você pode garantir que o código hash de um objeto mutável não será alterada enquanto o objeto está contido em uma coleção que se baseia em seu código de hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-406">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span>
            </span>
            <span data-ttu-id="a622d-407">Caso contrário, você pode pensar que o objeto mutável é perdido na tabela de hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-407">Otherwise, you might think that the mutable object is lost in the hash table.</span>
            </span>
            <span data-ttu-id="a622d-408">Se você optar por substituir <see cref="M:System.Object.GetHashCode" /> para um tipo de referência mutável, a documentação deve deixar claro que os usuários do seu tipo não devem modificar os valores de objeto enquanto o objeto é armazenado em uma tabela de hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-408">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span>
            </span>
            <span data-ttu-id="a622d-409">Para tipos de valor, <see cref="M:System.ValueType.GetHashCode" /> fornece uma implementação de código de hash padrão que usa a reflexão.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-409">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span>
            </span>
            <span data-ttu-id="a622d-410">Você deve considerar a ignorá-lo para melhorar o desempenho.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-410">You should consider overriding it for better performance.</span>
            </span>
            <block subset="none" type="note">
              <para>
                <span data-ttu-id="a622d-411">Para obter mais informações e exemplos de códigos de hash em uma variedade de formas de computação, consulte a seção de exemplos.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="a622d-411">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span>
                </span>
              </para>
            </block>
            <span data-ttu-id="a622d-412">Uma função de hash deve ter as seguintes propriedades:</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-412">A hash function must have the following properties:</span>
            </span>
            <span data-ttu-id="a622d-413">-Se dois objetos comparam como iguais, o <see cref="M:System.Object.GetHashCode" /> método para cada objeto deve retornar o mesmo valor.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-413">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span>
            </span>
            <span data-ttu-id="a622d-414">No entanto, se dois objetos não são comparados como iguais, o <see cref="M:System.Object.GetHashCode" /> métodos para os dois objetos não precisa retornar valores diferentes.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-414">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span>
            </span>
            <span data-ttu-id="a622d-415">-A <see cref="M:System.Object.GetHashCode" /> método para um objeto consistentemente deve retornar o mesmo código hash, desde que não há nenhuma modificação para o estado do objeto que determina o valor retornado do objeto [Equals](xref:System.Object.Equals*) método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-415">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span>
            </span>
            <span data-ttu-id="a622d-416">Observe que isso seja verdadeiro apenas para a execução atual de um aplicativo e que um código hash diferente pode ser retornado se o aplicativo for executado novamente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-416">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span>
            </span>
            <span data-ttu-id="a622d-417">– Para o melhor desempenho, uma função de hash deve gerar uma distribuição uniforme para todas as entradas, incluindo entrada intensamente em cluster.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-417">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span>
            </span>
            <span data-ttu-id="a622d-418">Uma implicação é que as pequenas modificações para o estado do objeto devem resultar em grandes modificações no código de hash resultante para um melhor desempenho de tabela de hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-418">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span>
            </span>
            <span data-ttu-id="a622d-419">– Funções de hash devem ser baixo custo de computação.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-419">-   Hash functions should be inexpensive to compute.</span>
            </span>
            <span data-ttu-id="a622d-420">-O <see cref="M:System.Object.GetHashCode" /> método não deve lançar exceções.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-420">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span>
            </span>
            <span data-ttu-id="a622d-421">Por exemplo, a implementação do <see cref="M:System.String.GetHashCode" /> método fornecido pelo <see cref="T:System.String" /> classe retorna códigos de hash idênticos para os valores de cadeia de caracteres idêntica.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-421">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span>
            </span>
            <span data-ttu-id="a622d-422">Portanto, dois <see cref="T:System.String" /> objetos retornam o mesmo código hash se eles representarem o mesmo valor de cadeia de caracteres.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-422">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span>
            </span>
            <span data-ttu-id="a622d-423">Além disso, o método usa todos os caracteres na cadeia de caracteres para gerar a saída distribuída razoavelmente aleatoriamente, mesmo quando a entrada for clusterizada em determinados intervalos (por exemplo, muitos usuários podem ter cadeias de caracteres que contêm somente inferior 128 caracteres ASCII, embora um cadeia de caracteres pode conter nenhum dos caracteres Unicode 65.535).</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-423">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span>
            </span>
            <span data-ttu-id="a622d-424">Fornecer uma boa função de hash em uma classe pode afetar significativamente o desempenho de adicionar esses objetos em uma tabela de hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-424">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span>
            </span>
            <span data-ttu-id="a622d-425">Em uma tabela de hash com as chaves que fornecem uma boa implementação de uma função de hash, procurando por um elemento leva um tempo constante (por exemplo, uma operação de (1)).</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-425">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span>
            </span>
            <span data-ttu-id="a622d-426">Em uma tabela de hash com uma implementação inadequada de uma função de hash, o desempenho de uma pesquisa depende do número de itens na tabela de hash (por exemplo, um O (`n`) a operação, onde `n` é o número de itens na tabela de hash).</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-426">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span>
            </span>
            <span data-ttu-id="a622d-427">Um usuário mal-intencionado pode inserir dados que aumenta o número de conflitos, o que pode afetar significativamente o desempenho de aplicativos que dependem de tabelas de hash, sob as seguintes condições:</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-427">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span>
            </span>
            <span data-ttu-id="a622d-428">-Quando as funções de hash produzem colisões frequentes.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-428">-   When hash functions produce frequent collisions.</span>
            </span>
            <span data-ttu-id="a622d-429">-Quando uma grande proporção de objetos em uma tabela de hash produzir códigos de hash que são iguais ou aproximadamente iguais um ao outro.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-429">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span>
            </span>
            <span data-ttu-id="a622d-430">-Quando os usuários os dados do qual o código hash é calculado de entrada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-430">-   When users input the data from which the hash code is computed.</span>
            </span>
            <span data-ttu-id="a622d-431">As classes derivadas que substituem <see cref="M:System.Object.GetHashCode" /> também deve substituir <see cref="M:System.Object.Equals(System.Object)" /> para garantir que dois objetos considerados iguais têm o mesmo código hash; caso contrário, o <see cref="T:System.Collections.Hashtable" /> tipo pode não funcionar corretamente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-431">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-432">Obtém o <see cref="T:System.Type" /> da instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-432">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-433">O tipo de tempo de execução exato da instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-433">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-434">Porque <xref:System.Object?displayProperty=nameWithType> é a classe base para todos os tipos no sistema de tipos do .NET Framework, o <xref:System.Object.GetType%2A> método pode ser usado para retornar <xref:System.Type> objetos que representam todos os tipos do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a622d-434">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="a622d-435">O .NET Framework reconhece os cinco categorias de tipos a seguir:</span><span class="sxs-lookup"><span data-stu-id="a622d-435">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="a622d-436">Classes, que são derivadas da <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="a622d-436">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="a622d-437">Tipos de valor, que são derivados da <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-437">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a622d-438">Interfaces, que são derivadas da <xref:System.Object?displayProperty=nameWithType> começando com o .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="a622d-438">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="a622d-439">Enumerações, que são derivadas da <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-439">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a622d-440">Delegados, que são derivados da <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-440">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a622d-441">Para dois objetos `x` e `y` que têm tipos de tempo de execução idênticos `Object.ReferenceEquals(x.GetType(),y.GetType())` retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="a622d-441">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="a622d-442">O exemplo a seguir usa o <xref:System.Object.GetType%2A> método com o <xref:System.Object.ReferenceEquals%2A> método para determinar se um valor numérico é o mesmo tipo que dois outros valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="a622d-442">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="a622d-443">Para determinar se um objeto é um tipo específico, você pode usar a palavra-chave de comparação de tipo da sua linguagem ou construir.</span><span class="sxs-lookup"><span data-stu-id="a622d-443">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="a622d-444">Por exemplo, você pode usar o `TypeOf…Is` construir no Visual Basic ou o `is` palavra-chave em c#.</span><span class="sxs-lookup"><span data-stu-id="a622d-444">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="a622d-445">O <xref:System.Object.GetType%2A> método é herdado por todos os tipos que derivam de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a622d-445">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="a622d-446">Isso significa que, além de usar a palavra-chave de comparação da sua própria linguagem, você pode usar o <xref:System.Object.GetType%2A> método para determinar o tipo de um objeto específico, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-446">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="a622d-447">O <xref:System.Type> objeto expõe os metadados associados com a classe do atual <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a622d-447">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-448">O exemplo de código a seguir demonstra que <xref:System.Object.GetType%2A> retorna o tipo de tempo de execução da instância atual.</span><span class="sxs-lookup"><span data-stu-id="a622d-448">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-449">Cria uma cópia superficial do <see cref="T:System.Object" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-449">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-450">Uma cópia superficial do atual <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-450">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-451">O <xref:System.Object.MemberwiseClone%2A> método cria uma cópia superficial criando um novo objeto e, em seguida, copiando os campos não estáticos do objeto atual para o novo objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-451">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="a622d-452">Se um campo é um tipo de valor, uma cópia de bit por bit do campo será executada.</span><span class="sxs-lookup"><span data-stu-id="a622d-452">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="a622d-453">Se um campo é um tipo de referência, a referência será copiada, mas o objeto referenciado é não; Portanto, o objeto original e seu clone se referem ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-453">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="a622d-454">Por exemplo, considere um objeto chamado X que faz referência a objetos A e B. o objeto B, por sua vez, o objeto de referências C. Uma cópia superficial de X cria um novo objeto X2 que também faz referência a objetos A e B. Por outro lado, uma cópia em profundidade de X cria um novo objeto X2 que referencia os novos objetos A2 e B2, que são cópias da e B. B2, por sua vez, referencia o novo objeto C2, que é uma cópia do C. O exemplo ilustra a diferença entre um shallow e uma operação de cópia em profundidade.</span><span class="sxs-lookup"><span data-stu-id="a622d-454">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="a622d-455">Há várias maneiras de implementar uma operação de cópia em profundidade, se a operação de cópia superficial é realizada pelo <xref:System.Object.MemberwiseClone%2A> método não atender às suas necessidades.</span><span class="sxs-lookup"><span data-stu-id="a622d-455">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="a622d-456">Eles incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="a622d-456">These include the following:</span></span>  
  
-   <span data-ttu-id="a622d-457">Chame um construtor de classe do objeto a ser copiado para criar um segundo objeto com os valores de propriedade obtidos do primeiro objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-457">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="a622d-458">Isso pressupõe que os valores de um objeto são totalmente definidos por seu construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-458">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="a622d-459">Chamar o <xref:System.Object.MemberwiseClone%2A> método para criar uma cópia superficial de um objeto e, em seguida, atribuir novos objetos cujos valores são os mesmos que o objeto original para quaisquer propriedades ou campos cujos valores são tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="a622d-459">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="a622d-460">O `DeepCopy` método no exemplo ilustra essa abordagem.</span><span class="sxs-lookup"><span data-stu-id="a622d-460">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="a622d-461">Serializar o objeto para ser profunda copiada e, em seguida, restaurar os dados serializados para uma variável de objeto diferente.</span><span class="sxs-lookup"><span data-stu-id="a622d-461">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="a622d-462">Use a reflexão com a recursão para executar a operação de cópia em profundidade.</span><span class="sxs-lookup"><span data-stu-id="a622d-462">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-463">O exemplo a seguir ilustra o <xref:System.Object.MemberwiseClone%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-463">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="a622d-464">Ele define uma `ShallowCopy` método que chama o <xref:System.Object.MemberwiseClone%2A> método para executar uma operação de cópia superficial em um `Person` objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-464">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="a622d-465">Ele também define uma `DeepCopy` método que executa uma operação de cópia em profundidade em uma `Person` objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-465">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="a622d-466">Neste exemplo, o `Person.IdInfo` propriedade retorna um `IdInfo` objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-466">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="a622d-467">Como a saída do exemplo mostra, quando um `Person` objeto será clonado, chamando o <xref:System.Object.MemberwiseClone%2A> método, clonado `Person` objeto é uma cópia independente do objeto original, exceto que eles compartilham o mesmo `Person.IdInfo` referência de objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-467">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="a622d-468">Como resultado, modificando o clone `Person.IdInfo` alterações de propriedade do objeto original `Person.IdInfo` propriedade.</span><span class="sxs-lookup"><span data-stu-id="a622d-468">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="a622d-469">Por outro lado, quando uma operação de cópia em profundidade é executada, clonado `Person` do objeto, incluindo seu `Person.IdInfo` propriedade, pode ser modificado sem afetar o objeto original.</span><span class="sxs-lookup"><span data-stu-id="a622d-469">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="a622d-470">O primeiro objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-470">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="a622d-471">O segundo objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-471">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a622d-472">Determina se as instâncias de <see cref="T:System.Object" /> especificadas são a mesma instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-472">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-473">
            <see langword="true" /> se <paramref name="objA" /> for a mesma instância que <paramref name="objB" /> ou se ambos forem **null**; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-473">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-474">Ao contrário do <xref:System.Object.Equals%2A> método e o operador de igualdade, o <xref:System.Object.ReferenceEquals%2A> método não pode ser substituído.</span><span class="sxs-lookup"><span data-stu-id="a622d-474">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="a622d-475">Por isso, se você quiser testar duas referências de igualdade do objeto e você não tiver certeza sobre a implementação do `Equals` método, você pode chamar o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-475">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="a622d-476">No entanto, o valor de retorno de <xref:System.Object.ReferenceEquals%2A> método pode aparecer como anormais nesses dois cenários:</span><span class="sxs-lookup"><span data-stu-id="a622d-476">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="a622d-477">Ao comparar tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-477">When comparing value types.</span></span> <span data-ttu-id="a622d-478">Se `objA` e `objB` são tipos de valor, eles são boxed antes de serem passados para o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-478">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a622d-479">Isso significa que, se os dois `objA` e `objB` representam a mesma instância de um tipo de valor, o <xref:System.Object.ReferenceEquals%2A> mesmo assim, o método retorna `false`, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-479">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="a622d-480">Para obter informações sobre tipos de valor de conversão boxing, consulte [conversão Boxing e Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="a622d-480">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="a622d-481">Ao comparar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="a622d-481">When comparing strings.</span></span> <span data-ttu-id="a622d-482">Se `objA` e `objB` são cadeias de caracteres, o <xref:System.Object.ReferenceEquals%2A> retorno do método `true` se a cadeia de caracteres é internalizada.</span><span class="sxs-lookup"><span data-stu-id="a622d-482">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="a622d-483">Ele não executa um teste de igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="a622d-483">It does not perform a test for value equality.</span></span>  <span data-ttu-id="a622d-484">No exemplo a seguir `s1` e `s2` são iguais, porque eles são duas instâncias de uma única cadeia de caracteres interno.</span><span class="sxs-lookup"><span data-stu-id="a622d-484">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="a622d-485">No entanto, `s3` e `s4` não forem iguais, porque embora são tiverem valores de cadeia de caracteres idêntica, essa cadeia de caracteres não é interno.</span><span class="sxs-lookup"><span data-stu-id="a622d-485">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="a622d-486">Para obter mais informações sobre a centralização da cadeia de caracteres, consulte <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-486">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a622d-487">O exemplo a seguir usa <xref:System.Object.ReferenceEquals%2A> para determinar se dois objetos são a mesma instância.</span><span class="sxs-lookup"><span data-stu-id="a622d-487">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a622d-488">Retorna uma cadeia de caracteres que representa o objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-488">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a622d-489">Uma cadeia de caracteres que representa o objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-489">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a622d-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> é o principal método no .NET Framework de formatação.</span><span class="sxs-lookup"><span data-stu-id="a622d-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="a622d-491">Ele converte um objeto em sua representação de cadeia de caracteres para que ele é adequado para exibição.</span><span class="sxs-lookup"><span data-stu-id="a622d-491">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="a622d-492">(Para obter informações sobre a formatação de suporte no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).) Implementações padrão da <xref:System.Object.ToString%2A?displayProperty=nameWithType> o nome totalmente qualificado do tipo do objeto de retorno do método.</span><span class="sxs-lookup"><span data-stu-id="a622d-492">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a622d-493">Talvez você tenha atingido nesta página clicando no link da lista de membros de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="a622d-493">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="a622d-494">Isso ocorre porque esse tipo não substituir <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-494">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a622d-495">Em vez disso, ele herda a funcionalidade do <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-495">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a622d-496">Tipos frequentemente substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para fornecer uma representação de cadeia de caracteres mais adequada de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="a622d-496">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="a622d-497">Tipos frequentemente sobrecarregar o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para fornecer suporte para cadeias de caracteres de formato ou formatação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="a622d-497">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="a622d-498">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="a622d-498">In this section:</span></span>  
  
 <span data-ttu-id="a622d-499">[O método ToString () padrão](#Default) </span><span class="sxs-lookup"><span data-stu-id="a622d-499">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="a622d-500">[Substituindo o método ToString)](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="a622d-500">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="a622d-501">[Sobrecarregando o método ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="a622d-501">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="a622d-502">[Estendendo o método ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="a622d-502">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="a622d-503">Notas para o tempo de execução do Windows</span><span class="sxs-lookup"><span data-stu-id="a622d-503">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="a622d-504">O método ToString () padrão</span><span class="sxs-lookup"><span data-stu-id="a622d-504">The default Object.ToString() method</span></span>  
 <span data-ttu-id="a622d-505">A implementação padrão do <xref:System.Object.ToString%2A> método retorna o nome totalmente qualificado do tipo do <xref:System.Object>, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-505">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="a622d-506">Porque <xref:System.Object> é a classe base de todos os tipos de referência no .NET Framework, esse comportamento é herdado por tipos de referência que não substituem o <xref:System.Object.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-506">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="a622d-507">O exemplo a seguir ilustra essa situação.</span><span class="sxs-lookup"><span data-stu-id="a622d-507">The following example illustrates this.</span></span> <span data-ttu-id="a622d-508">Ele define uma classe chamada `Object1` que aceita a implementação padrão de todos os <xref:System.Object> membros.</span><span class="sxs-lookup"><span data-stu-id="a622d-508">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="a622d-509">Seu <xref:System.Object.ToString%2A> método retorna o nome de tipo totalmente qualificado do objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-509">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="a622d-510">Substituindo o método ToString)</span><span class="sxs-lookup"><span data-stu-id="a622d-510">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="a622d-511">Tipos comumente substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para retornar uma cadeia de caracteres que representa a instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-511">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="a622d-512">Por exemplo, os tipos de base, como <xref:System.Char>, <xref:System.Int32>, e <xref:System.String> fornecer <xref:System.Object.ToString%2A> implementações que retornam o formulário de cadeia de caracteres do valor que representa o objeto.</span><span class="sxs-lookup"><span data-stu-id="a622d-512">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="a622d-513">O exemplo a seguir define uma classe, `Object2`, que substitui o <xref:System.Object.ToString%2A> método para retornar o nome do tipo juntamente com seus valores.</span><span class="sxs-lookup"><span data-stu-id="a622d-513">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="a622d-514">A tabela a seguir lista as categorias de tipo no .NET Framework e indica se elas substituem a <xref:System.Object.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-514">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="a622d-515">Categoria do tipo</span><span class="sxs-lookup"><span data-stu-id="a622d-515">Type category</span></span>|<span data-ttu-id="a622d-516">Substituições de ToString)</span><span class="sxs-lookup"><span data-stu-id="a622d-516">Overrides Object.ToString()</span></span>|<span data-ttu-id="a622d-517">Comportamento</span><span class="sxs-lookup"><span data-stu-id="a622d-517">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="a622d-518">Classe</span><span class="sxs-lookup"><span data-stu-id="a622d-518">Class</span></span>|<span data-ttu-id="a622d-519">N/D</span><span class="sxs-lookup"><span data-stu-id="a622d-519">n/a</span></span>|<span data-ttu-id="a622d-520">N/D</span><span class="sxs-lookup"><span data-stu-id="a622d-520">n/a</span></span>|  
|<span data-ttu-id="a622d-521">Estrutura</span><span class="sxs-lookup"><span data-stu-id="a622d-521">Structure</span></span>|<span data-ttu-id="a622d-522">Sim (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="a622d-522">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="a622d-523">Mesmo que ToString)</span><span class="sxs-lookup"><span data-stu-id="a622d-523">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="a622d-524">Enumeração</span><span class="sxs-lookup"><span data-stu-id="a622d-524">Enumeration</span></span>|<span data-ttu-id="a622d-525">Sim (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="a622d-525">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="a622d-526">O nome do membro</span><span class="sxs-lookup"><span data-stu-id="a622d-526">The member name</span></span>|  
|<span data-ttu-id="a622d-527">Interface</span><span class="sxs-lookup"><span data-stu-id="a622d-527">Interface</span></span>|<span data-ttu-id="a622d-528">Não</span><span class="sxs-lookup"><span data-stu-id="a622d-528">No</span></span>|<span data-ttu-id="a622d-529">N/D</span><span class="sxs-lookup"><span data-stu-id="a622d-529">n/a</span></span>|  
|<span data-ttu-id="a622d-530">delegado</span><span class="sxs-lookup"><span data-stu-id="a622d-530">Delegate</span></span>|<span data-ttu-id="a622d-531">Não</span><span class="sxs-lookup"><span data-stu-id="a622d-531">No</span></span>|<span data-ttu-id="a622d-532">N/D</span><span class="sxs-lookup"><span data-stu-id="a622d-532">n/a</span></span>|  
  
 <span data-ttu-id="a622d-533">Consulte as seção Observações para herdeiros para obter mais informações sobre substituição de <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-533">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="a622d-534">Sobrecarregando o método ToString</span><span class="sxs-lookup"><span data-stu-id="a622d-534">Overloading the ToString method</span></span>  
 <span data-ttu-id="a622d-535">Além de substituir o Next sem parâmetros <xref:System.Object.ToString?displayProperty=nameWithType> sobrecarregam do método, muitos tipos de `ToString` método para fornecer versões do método que aceitam parâmetros.</span><span class="sxs-lookup"><span data-stu-id="a622d-535">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="a622d-536">Normalmente, isso é feito para oferecer suporte à formatação de variável e formatação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="a622d-536">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="a622d-537">A exemplo a seguir sobrecarrega o `ToString` método para retornar uma cadeia de caracteres de resultado que inclui o valor de vários campos de um `Automobile` classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-537">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="a622d-538">Ele define quatro cadeias de caracteres de formato: G, que retorna o nome do modelo e o ano; 1!d, que retorna o nome do modelo, o ano e o número de portas; C, que retorna o nome do modelo, o ano e o número de cilindros; e A, que retorna uma cadeia de caracteres com todos os valores de campo de quatro.</span><span class="sxs-lookup"><span data-stu-id="a622d-538">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="a622d-539">O exemplo a seguir chama o sobrecarregado <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para exibir a formatação de cultura de um valor de moeda.</span><span class="sxs-lookup"><span data-stu-id="a622d-539">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="a622d-540">Para obter mais informações sobre cadeias de caracteres de formato e a formatação sensível à cultura, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="a622d-540">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="a622d-541">Para as cadeias de caracteres de formato compatíveis com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="a622d-541">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="a622d-542">Para as cadeias de caracteres de formato com suporte pelos valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="a622d-542">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="a622d-543">Estendendo o método ToString</span><span class="sxs-lookup"><span data-stu-id="a622d-543">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="a622d-544">Como um tipo herda o padrão <xref:System.Object.ToString%2A?displayProperty=nameWithType> método, você pode encontrar seu comportamento indesejável e quiser alterá-lo.</span><span class="sxs-lookup"><span data-stu-id="a622d-544">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="a622d-545">Isso é particularmente verdadeiro de matrizes e classes de coleção.</span><span class="sxs-lookup"><span data-stu-id="a622d-545">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="a622d-546">Enquanto você pode esperar o `ToString` método de uma classe de coleção ou matriz para exibir os valores de seus membros, ele exibirá o nome de tipo totalmente qualificado do tipo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="a622d-546">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="a622d-547">Você tem várias opções para produzir a cadeia de caracteres de resultado que você gostaria.</span><span class="sxs-lookup"><span data-stu-id="a622d-547">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="a622d-548">Se o tipo é uma matriz, um objeto de coleção ou um objeto que implementa o <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interfaces, você pode enumerar seus elementos usando o `foreach` instrução em c# ou o `For Each...Next` construir no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a622d-548">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="a622d-549">Se a classe não for `sealed` (em c#) ou `NotInheritable` (no Visual Basic), você pode desenvolver uma classe wrapper que herda da classe base cujo <xref:System.Object.ToString%2A?displayProperty=nameWithType> método você deseja personalizar.</span><span class="sxs-lookup"><span data-stu-id="a622d-549">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="a622d-550">No mínimo, isso requer que você faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="a622d-550">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="a622d-551">Implemente construtores necessários.</span><span class="sxs-lookup"><span data-stu-id="a622d-551">Implement any necessary constructors.</span></span> <span data-ttu-id="a622d-552">Classes derivadas não herdam seus construtores de classe base.</span><span class="sxs-lookup"><span data-stu-id="a622d-552">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="a622d-553">Substituir o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para retornar a cadeia de caracteres de resultado que você gostaria.</span><span class="sxs-lookup"><span data-stu-id="a622d-553">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="a622d-554">O exemplo a seguir define uma classe wrapper para o <xref:System.Collections.Generic.List%601> classe.</span><span class="sxs-lookup"><span data-stu-id="a622d-554">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="a622d-555">Ele substitui o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para exibir o valor de cada método de coleção, em vez do nome de tipo totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="a622d-555">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="a622d-556">Desenvolver uma [método de extensão](~/docs/standard/design-guidelines/extension-methods.md) que retorna a cadeia de caracteres de resultado que você deseja.</span><span class="sxs-lookup"><span data-stu-id="a622d-556">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="a622d-557">Observe que você não pode substituir o padrão <xref:System.Object.ToString%2A?displayProperty=nameWithType> método dessa forma (ou seja, sua classe de extensão (em c#) ou o módulo (no Visual Basic) não pode ter um método sem parâmetros chamado `ToString` que é chamado no lugar do tipo original `ToString` método .</span><span class="sxs-lookup"><span data-stu-id="a622d-557">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="a622d-558">Você precisará fornecer algum outro nome para seu sem parâmetros `ToString` substituição.</span><span class="sxs-lookup"><span data-stu-id="a622d-558">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="a622d-559">O exemplo a seguir define dois métodos que estendem o <xref:System.Collections.Generic.List%601> classe: um sem parâmetros `ToString2` método e uma `ToString` método com um <xref:System.String> parâmetro que representa uma cadeia de caracteres de formato.</span><span class="sxs-lookup"><span data-stu-id="a622d-559">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="a622d-560">Observações para o [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="a622d-560">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="a622d-561">Quando você chama o <xref:System.Object.ToString%2A> método em uma classe de [!INCLUDE[wrt](~/includes/wrt-md.md)], ele fornece o comportamento padrão para classes que não substituem <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-561">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="a622d-562">Isso faz parte do suporte fornecido pelo .NET Framework para o [!INCLUDE[wrt](~/includes/wrt-md.md)] (consulte [tempo de execução do Windows e de aplicativos .NET Framework dão suporte para Windows Store](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="a622d-562">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="a622d-563">As classes de [!INCLUDE[wrt](~/includes/wrt-md.md)] não herdam <xref:System.Object>e não implemente sempre um <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a622d-563">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="a622d-564">No entanto, eles sempre parecem ter <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece um comportamento padrão para esses métodos.</span><span class="sxs-lookup"><span data-stu-id="a622d-564">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="a622d-565">Começando com o [!INCLUDE[net_v451](~/includes/net-v451-md.md)], o common language runtime usará [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) em uma [!INCLUDE[wrt](~/includes/wrt-md.md)] objeto antes de fazer fallback para a implementação padrão de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-565">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="a622d-566">as classes que são escritas em c# ou Visual Basic podem substituir o <xref:System.Object.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a622d-566">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="a622d-567">O [!INCLUDE[wrt](~/includes/wrt-md.md)] e a interface de IStringable</span><span class="sxs-lookup"><span data-stu-id="a622d-567">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="a622d-568">Começando com [!INCLUDE[win81](~/includes/win81-md.md)], o [!INCLUDE[wrt](~/includes/wrt-md.md)] inclui um [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cujo único método, da interface [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fornece suporte para formatação básica comparável ao que fornecido pelo <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a622d-568">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a622d-569">Para evitar ambiguidade, você não deve implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em tipos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="a622d-569">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="a622d-570">Quando os objetos gerenciados são chamados pelo código nativo ou código escritos em linguagens como JavaScript ou C + + c++ /CX, eles aparecem para implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="a622d-570">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="a622d-571">O common language runtime será encaminhado automaticamente as chamadas de [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) à <xref:System.Object.ToString%2A?displayProperty=nameWithType> no evento [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) não está implementado no objeto gerenciado.</span><span class="sxs-lookup"><span data-stu-id="a622d-571">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a622d-572">Porque o common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) para todos os tipos de gerenciados [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos, é recomendável que você não fornecer seus próprios [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementação.</span><span class="sxs-lookup"><span data-stu-id="a622d-572">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="a622d-573">Implementando [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) pode resultar em comportamento não intencional, ao chamar `ToString` da [!INCLUDE[wrt](~/includes/wrt-md.md)], C + c++ /CX ou JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a622d-573">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="a622d-574">Se você optar por implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em um tipo gerenciado público exportado em um [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, as seguintes restrições se aplicam:</span><span class="sxs-lookup"><span data-stu-id="a622d-574">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="a622d-575">Você pode definir as [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface somente em uma relação de "implementos de classe", como</span><span class="sxs-lookup"><span data-stu-id="a622d-575">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="a622d-576">em C#, ou</span><span class="sxs-lookup"><span data-stu-id="a622d-576">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="a622d-577">no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a622d-577">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="a622d-578">Você não pode implementar [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) em uma interface.</span><span class="sxs-lookup"><span data-stu-id="a622d-578">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="a622d-579">Você não pode declarar um parâmetro seja do tipo [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="a622d-579">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="a622d-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) não pode ser o tipo de retorno de método, propriedade ou campo.</span><span class="sxs-lookup"><span data-stu-id="a622d-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="a622d-581">Você não pode ocultar sua [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementação de classes base usando uma definição de método como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="a622d-581">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="a622d-582">Em vez disso, o [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementação sempre deve substituir a implementação da classe base.</span><span class="sxs-lookup"><span data-stu-id="a622d-582">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="a622d-583">Você pode ocultar uma implementação de `ToString` invocando-a apenas em uma instância da classe fortemente tipada.</span><span class="sxs-lookup"><span data-stu-id="a622d-583">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="a622d-584">Observe que, em uma variedade de condições, chamadas de código nativo para um tipo gerenciado que implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ou oculta sua [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementação pode produzir um comportamento inesperado.</span><span class="sxs-lookup"><span data-stu-id="a622d-584">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a622d-585">Quando você implementa seus próprios tipos, você deve substituir o <see cref="M:System.Object.ToString" /> método para retornar valores que são significativas para esses tipos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-585">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span>
            </span>
            <span data-ttu-id="a622d-586">As classes derivadas que precisam de mais controle sobre a formatação que <see cref="M:System.Object.ToString" /> fornece pode implementar o <see cref="T:System.IFormattable" /> interface.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-586">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span>
            </span>
            <span data-ttu-id="a622d-587">Sua <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> método permite que você defina cadeias de caracteres de formato que controlam a formatação e usar um <see cref="T:System.IFormatProvider" /> objeto que pode fornecer para formatação de cultura específica.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-587">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span>
            </span>
            <span data-ttu-id="a622d-588">Substituições do <see cref="M:System.Object.ToString" /> método deve seguir estas diretrizes:</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-588">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span>
            </span>
            <span data-ttu-id="a622d-589">-A cadeia de caracteres retornada deve ser legível por humanos e amigável.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-589">-   The returned string should be friendly and readable by humans.</span>
            </span>
            <span data-ttu-id="a622d-590">-A cadeia de caracteres retornada deve identificar exclusivamente o valor da instância do objeto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-590">-   The returned string should uniquely identify the value of the object instance.</span>
            </span>
            <span data-ttu-id="a622d-591">-A cadeia de caracteres retornada deve ser tão curta quanto possível, para que ele é adequado para exibição por um depurador.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-591">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span>
            </span>
            <span data-ttu-id="a622d-592">-Seu <see cref="M:System.Object.ToString" /> substituição não deve retornar <see cref="F:System.String.Empty" /> ou uma cadeia de caracteres nula.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-592">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span>
            </span>
            <span data-ttu-id="a622d-593">-Seu <see cref="M:System.Object.ToString" /> substituição não deve lançar uma exceção.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-593">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span>
            </span>
            <span data-ttu-id="a622d-594">-Se a representação de cadeia de caracteres de uma instância é sensível à cultura, ou pode ser formatada de várias maneiras, implemente o <see cref="T:System.IFormattable" /> interface.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-594">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span>
            </span>
            <span data-ttu-id="a622d-595">-Se a cadeia de caracteres retornada inclui informações confidenciais, você deve primeiro exige uma permissão apropriada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-595">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span>
            </span>
            <span data-ttu-id="a622d-596">Se a solicitação for bem-sucedida, você pode retornar as informações confidenciais; Caso contrário, você deve retornar uma cadeia de caracteres que exclui as informações confidenciais.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-596">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span>
            </span>
            <span data-ttu-id="a622d-597">-Seu <see cref="M:System.Object.ToString" /> substituição não deve ter nenhum efeito colateral observável para evitar complicações na depuração.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-597">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span>
            </span>
            <span data-ttu-id="a622d-598">Por exemplo, uma chamada para o <see cref="M:System.Object.ToString" /> método não deve alterar o valor dos campos de instância.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-598">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span>
            </span>
            <span data-ttu-id="a622d-599">-Se o tipo implementa um método de análise (ou <see langword="Parse" /> ou <see langword="TryParse" /> algum outro método estático que cria uma instância do tipo de uma cadeia de caracteres, um construtor ou método), você deve garantir que a cadeia de caracteres retornada pelo <see cref="M:System.Object.ToString" /> método pode ser convertido em uma instância do objeto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a622d-599">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">
          <span data-ttu-id="a622d-600">Tipos de formatação no .NET</span>
          <span class="sxs-lookup">
            <span data-stu-id="a622d-600">Formatting Types in .NET</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>