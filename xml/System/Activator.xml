<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="649e2d3e07f02c1ccba5e28b759c2ea88f4fe624" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48674297" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contém métodos para criar tipos de objetos localmente ou remotamente, ou obter referências a objetos remotos existentes. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Activator.CreateInstance%2A> método cria uma instância de um tipo definido em um assembly, invocando o construtor que melhor corresponde os argumentos especificados. Se nenhum argumento for especificado, o construtor sem parâmetros, ou seja, o construtor padrão, é invocado.  
  
 Você deve ter permissão suficiente para pesquisar e chamar um construtor; Caso contrário, uma exceção é lançada. Por padrão, somente os construtores públicos são considerados durante a pesquisa para um construtor. Se nenhum construtor ou um construtor padrão pode ser encontrado, uma exceção é lançada.  
  
 Um parâmetro de associador Especifica um objeto que procura um assembly para um construtor adequado. Você pode especificar seus próprios critérios associadores e de pesquisa. Se Nenhum associador for especificado, um associador padrão será usado. Para obter mais informações, consulte as classes <xref:System.Reflection.Binder?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um parâmetro de evidência afeta a política de segurança e permissões para o construtor. Para obter mais informações, consulte a classe <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>.  
  
 Uma instância de um tipo pode ser criada em um site local ou remoto. Se o tipo é criado remotamente, um parâmetro de atributo de ativação Especifica o URI do site remoto. A chamada para criar a instância possam passar através de sites intermediários antes de atingir o site remoto. Outros atributos de ativação podem modificar o ambiente ou o contexto, no qual a chamada opera nos sites remotos e intermediários.  
  
 Se a instância é criada localmente, uma referência a esse objeto é retornada. Se a instância for criada remotamente, uma referência a um proxy é retornada. O objeto remoto é manipulado por meio do proxy como se fosse um objeto local.  
  
 O <xref:System.Activator.GetObject%2A> método cria um proxy para um objeto remoto em execução no momento, objeto conhecido ativado pelo servidor ou serviço Web XML. Você pode especificar a mídia de conexão, ou seja, o canal. Para obter mais informações, consulte a classe <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>.  
  
 Os assemblies contêm definições de tipo. O <xref:System.Activator.CreateInstance%2A> método cria uma instância de um tipo de um assembly em execução no momento. O <xref:System.Activator.CreateInstanceFrom%2A> método cria uma instância de um arquivo que contém um assembly. O <xref:System.Activator.CreateComInstanceFrom%2A> método cria uma instância de um objeto COM de um arquivo que contém um assembly.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Activator> classe construa dinamicamente objetos em tempo de execução.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma instância do objeto COM cujo nome é especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <summary>Cria uma instância do objeto COM cujo nome é especificado, usando o arquivo do assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo COM as <xref:System.Activator.CreateComInstanceFrom%2A> método pode criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é lançada.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Não é possível criar uma instância por meio do COM.  
  
- ou - 
 <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata.  
  
- ou - 
Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> é a cadeia de caracteres vazia ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="hashValue">O valor do código hash calculado.</param>
        <param name="hashAlgorithm">O algoritmo de hash usado para o hash de arquivos e para gerar o nome forte.</param>
        <summary>Cria uma instância do objeto COM cujo nome é especificado, usando o arquivo do assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo COM as <xref:System.Activator.CreateComInstanceFrom%2A> método pode criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é lançada.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> é a cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.
        
- ou - 
        <paramref name="assemblyName" /> é maior que o comprimento máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> foi encontrado, mas não pode ser carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see langword="WebPermission" /> necessário.</exception>
        <exception cref="T:System.TypeLoadException">Não é possível criar uma instância por meio do COM.  
  
- ou - 
 <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.MemberAccessException">Não foi possível criar uma instância de uma classe abstrata.  
  
- ou - 
Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma instância do tipo especificado usando o construtor que corresponde melhor aos parâmetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Um objeto do contexto de ativação que especifica o objeto a ser criado.</param>
        <summary>Cria uma instância do tipo designado pelo objeto <see cref="T:System.ActivationContext" /> especificado.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar o objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 O contexto de ativação é usado durante a ativação baseada em manifesto para configurar a política de domínio e fornecer um modelo de segurança baseado em aplicativo. O <xref:System.ActivationContext> classe contém um <xref:System.ApplicationIdentity> objeto que fornece acesso ao manifesto do aplicativo. Para obter mais informações, consulte a classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor padrão do tipo.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor a ser invocado deve ser acessível.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como chamar o <xref:System.Activator.CreateInstance%28System.Type%29> método. São criadas instâncias de vários tipos diferentes e seus valores padrão são exibidos.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente de seus conjuntos de concessão. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Um objeto do contexto de ativação que especifica o objeto a ser criado.</param>
        <param name="activationCustomData">Uma matriz de cadeias de caracteres Unicode que contêm dados de ativação personalizados.</param>
        <summary>Cria uma instância do tipo que é designada pelo objeto <see cref="T:System.ActivationContext" /> especificado e ativada com os dados de ativação personalizados especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar o objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 O contexto de ativação é usado durante a ativação baseada em manifesto para configurar a política de domínio e fornecer um modelo de segurança baseado em aplicativo. O <xref:System.ActivationContext> classe contém um <xref:System.ApplicationIdentity> objeto que fornece acesso ao manifesto do aplicativo. Para obter mais informações, consulte a classe <xref:System.Security.Policy.ApplicationSecurityManager>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 `assemblyName` pode ser um destes procedimentos:  
  
-   O nome simples de um assembly, sem a extensão do arquivo ou caminho. Por exemplo, você especificaria `TypeExtensions` para um assembly cujo caminho e nome é.\bin\TypeExtensions.dll.  
  
-   O nome completo de um assembly assinado, que consiste em seu nome simples, versão, cultura e token de chave pública; Por exemplo, "TypeExtensions, versão Version=1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Para obter mais informações sobre como o common language runtime identifica e carrega os assemblies, consulte [como o tempo de execução Localiza Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Para obter informações sobre como usar o arquivo de configuração de aplicativo para definir locais de assembly, consulte [especificando o local do Assembly](~/docs/framework/configure-apps/specify-assembly-location.md). Se `assemblyName` for encontrado, ele é carregado no contexto padrão.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe chamada `Person` em um assembly chamado `PersonInfo`. Observe que o `Person` classe possui dois construtores, um dos quais não tem parâmetro.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 A exemplo a seguir chama o <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> método para instanciar o `Person` classe. Ele requer uma referência ao PersonInfo.dll a ser adicionado ao projeto. Porque o <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> chamadas de método de `Person` construtor padrão da classe, o exemplo atribui um valor ao seu `Name` propriedade.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 No entanto, <xref:System.Activator.CreateInstance%2A> frequentemente é chamado para instanciar um tipo que cruza os limites de máquina ou que não é conhecido em tempo de design. Nesse caso, você não pode incluir uma referência ao assembly no projeto e não pode fazer chamadas early bound para membros do tipo. Para contornar essa limitação, o exemplo a seguir usa o <xref:System.Activator.CreateInstance%2A> método juntamente com a reflexão para atribuir um valor para o `Person` do objeto `Name` propriedade e para exibir seu valor.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <param name="nonPublic">
          <see langword="true" /> se um construtor padrão público ou não público puder corresponder; <see langword="false" /> se apenas um construtor padrão público puder corresponder.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor padrão do tipo.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros e tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os membros e tipos não públicos é restrito para o chamador conceda definido ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor a ser invocado deve ser acessível e deve fornecer a correspondência mais específica com a lista de argumentos especificada.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método para criar um <xref:System.String> objeto. Ele chama o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> construtor para instanciar uma cadeia de caracteres que contém dez elementos de uma matriz de caracteres começando na posição no décimo quarto.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 O exemplo a seguir cria uma matriz denteada cujos elementos são os argumentos a serem passados para um <xref:System.String> construtor. O exemplo, em seguida, passa cada matriz para o <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> método para invocar o construtor de cadeia de caracteres apropriada.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio remoto em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <summary>Cria uma instância do tipo, cujo nome é especificado no domínio remoto especificado, usando o assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir que o chamador imediato tenha confiança total.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ou <paramref name="domain" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de um tipo abstrato.  
  
- ou - 
Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões dos tipos não públicos está restrito ao conjunto de concessões do chamador ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
 <paramref name="activationAttributes" /> não é um <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
matriz.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ocorreu um erro durante a tentativa de ativação remota em um destino especificado em <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor a ser invocado deve ser acessível e deve fornecer a correspondência mais específica com a lista de argumentos especificada.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os tipos não públicos é restrito a concessão do chamador Defina ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>type</c>. Se <c>bindingAttr</c> for zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos será realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>type</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados do construtor <c>type</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor a ser invocado deve fornecer a correspondência mais específica com a lista de argumentos especificada sob as restrições do associador especificado e atributos de associação.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros e tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os membros e tipos não públicos é restrito para o chamador conceda definido ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">O tipo de objeto a ser criado.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>type</c>. Se <c>bindingAttr</c> for zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos será realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>type</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados do construtor <c>type</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo especificado usando o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor a ser invocado deve fornecer a correspondência mais específica com a lista de argumentos especificada sob as restrições do associador especificado e atributos de associação.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros e tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões dos tipos não públicos e membros é restrito para o chamador concedem o conjunto ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="type" /> é um tipo genérico aberto (ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> não pode ser um <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
- ou - 
A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O assembly que contém <paramref name="type" /> é um assembly dinâmico que foi criado com <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor que está sendo chamado lança uma exceção.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> é um objeto COM, mas o identificador de classe usado para obter o tipo é inválido, ou a classe identificada não é registrada.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> não é um tipo válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer a evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o assembly nomeado e o construtor que melhor corresponde aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar membros e tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os membros e tipos não públicos é restrito para o chamador conceda definido ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado no domínio remoto especificado usando o assembly nomeado e o construtor que corresponda melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir que o chamador imediato tenha confiança total.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityInfo">Informações usadas para tomar decisões sobre política de segurança e conceder permissões.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o assembly nomeado e o construtor que melhor corresponde aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para criar membros e tipos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador e se o conjunto de concessões do assembly que contém os membros e tipos não públicos é restrito para o chamador conceda definido ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyName">O nome do assembly em que o tipo chamado <c>typeName</c> é procurado. Caso <c>assemblyName</c> seja <see langword="null" />, o assembly em execução é pesquisado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Ela costuma ser uma matriz contendo um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. O <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> especifica a URL necessária para ativar um objeto remoto.</param>
        <param name="securityAttributes">Informações usadas para tomar decisões sobre política de segurança e conceder permissões.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado no domínio remoto especificado usando o assembly nomeado e o construtor que corresponda melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstance%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir que o chamador imediato tenha confiança total.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">O tipo COM não foi obtido por meio de <see cref="Overload:System.Type.GetTypeFromProgID" /> ou <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">A criação de tipos <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> e <see cref="T:System.RuntimeArgumentHandle" /> ou arrays desses tipos não é suportada.  
  
- ou - 
 <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
O construtor que melhor corresponde a <paramref name="args" /> tem argumentos <see langword="varargs" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.  
  
- ou - 
O nome do assembly ou a base de código é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo a ser criado.</typeparam>
        <summary>Cria uma instância do tipo designado pelo parâmetro de tipo genérico especificado, usando o construtor sem parâmetros.</summary>
        <returns>Uma referência ao objeto recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Activator.CreateInstance%60%601> método genérico é usado por compiladores para implementar a instanciação de tipos especificados pelos parâmetros de tipo. Por exemplo, no seguinte método genérico, a implementação de `new T()` (`gcnew T()` em C++) utiliza o <xref:System.Activator.CreateInstance%60%601> método genérico.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Em geral, não há nenhum uso para o <xref:System.Activator.CreateInstance%60%601> código de método genérico no aplicativo, porque o tipo deve ser conhecido no tempo de compilação. Se o tipo é conhecido no tempo de compilação, a sintaxe de instanciação normal pode ser usada (`new` operador em c#, `New` no Visual Basic, `gcnew` em C++). Se o tipo não for conhecido no tempo de compilação, você pode chamar uma sobrecarga não genérico de <xref:System.Activator.CreateInstance%2A>.  
  
 Não há nenhuma das sobrecargas a <xref:System.Activator.CreateInstance%60%601> método genérico que usam listas de argumento, porque não genérica de sobrecargas de <xref:System.Activator.CreateInstance%2A> já fornecem resolução de construtor de associação tardia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MissingMemberException" />.  
  
</para>
          </block>  
  
O tipo que é especificado para <paramref name="T" /> não tem um construtor sem parâmetros.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o arquivo de assembly nomeado e o construtor que corresponde melhor aos parâmetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o arquivo do assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como chamar o <xref:System.Activator.CreateInstanceFrom%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Activator> classe.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio remoto em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <summary>Cria uma instância do tipo, cujo nome é especificado no domínio remoto especificado, usando o arquivo do assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir que o chamador imediato tenha confiança total.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o arquivo do assembly nomeado e o construtor padrão.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o arquivo de assembly nomeado e o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio remoto em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado no domínio remoto especificado usando o arquivo do assembly nomeado e o construtor que corresponda melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Para obter informações sobre outras exceções que podem ser lançadas por métodos invocados, consulte as seções de exceções do <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
 <paramref name="assemblyName" /> foi compilado para uma versão do Common Language Runtime posterior à versão que carregada no momento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer a evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityInfo">Informações usadas para tomar decisões sobre política de segurança e conceder permissões.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado, usando o arquivo de assembly nomeado e o construtor que corresponde melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">O domínio remoto em que o tipo chamado <c>typeName</c> é criado.</param>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly em que o tipo chamado <c>typeName</c> é procurado.</param>
        <param name="typeName">O nome do tipo preferido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para especificar que a pesquisa de <c>typeName</c> não diferencia maiúsculas de minúsculas, <see langword="false" /> para especificar que a pesquisa diferencia maiúsculas de minúsculas.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <c>typeName</c>. Caso <c>bindingAttr</c> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</param>
        <param name="binder">Um objeto que usa <c>bindingAttr</c> e <c>args</c> para buscar e identificar o construtor <c>typeName</c>. Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</param>
        <param name="args">Uma matriz de argumentos correspondentes em número, ordem e digite e os parâmetros do construtor a serem invocados. Se <c>args</c> for uma matriz vazia ou <see langword="null" />, o construtor que não usa parâmetros (o construtor padrão) será invocado.</param>
        <param name="culture">Informações específicas de cultura que controlam a coerção de <c>args</c> para os tipos formais declarados para o construtor <c>typeName</c>. Se <c>culture</c> for <see langword="null" />, a <see cref="T:System.Globalization.CultureInfo" /> do thread atual será usada.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, essa é uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityAttributes">Informações usadas para tomar decisões sobre política de segurança e conceder permissões.</param>
        <summary>Cria uma instância do tipo cujo nome é especificado no domínio remoto especificado usando o arquivo do assembly nomeado e o construtor que corresponda melhor aos parâmetros especificados.</summary>
        <returns>Um identificador que deve ser desencapsulado para acessar a instância recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Activator.CreateInstanceFrom%2A> quando um host precise executar código em um domínio de aplicativo que tem permissões de segurança restritas.  
  
 Use o método <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> para desencapsular o valor de retorno.  
  
> [!NOTE]
>  Este método usa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> para exigir que o chamador imediato tenha confiança total.  
  
 Para obter informações sobre outras exceções que possam ser lançadas por métodos invocados, consulte a seção Exceções dos métodos <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> e <xref:System.Activator.CreateInstance%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MemberAccessException">Não é possível criar uma instância de uma classe abstrata, ou este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O construtor, que foi invocado por meio da reflexão, lançou uma exceção.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador tem o <see cref="T:System.Security.Permissions.FileIOPermission" /> necessário.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> não é uma matriz vazia, e o tipo que está sendo criado não deriva de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
- ou - 
A versão 2.0 do Common Language Runtime (CLR) ou posterior é carregado no momento, e <paramref name="assemblyName" /> foi compilado para uma versão do CLR posterior à versão carregada atualmente. Todas as versões do .NET Framework 2.0, 3.0 e 3.5 usam o CLR versão 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer a evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a capacidade de pesquisar caminhos de diretório e ler seu conteúdo. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar tipos e membros não públicos, independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um proxy para um serviço Web XML ou objeto bem conhecido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do objeto conhecido ao qual você deseja se conectar.</param>
        <param name="url">A URL do objeto conhecido.</param>
        <summary>Cria um proxy para o objeto conhecido indicado pelo tipo especificado e pela URL.</summary>
        <returns>Um proxy que aponta para um ponto de extremidade servido pelo objeto conhecido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame o proxy para enviar mensagens para o objeto remoto. Não há mensagens são enviadas pela rede até que um método é chamado no proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> não é empacotado por referência e não é uma interface.</exception>
        <exception cref="T:System.MemberAccessException">Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do objeto conhecido ao qual você deseja se conectar.</param>
        <param name="url">A URL do objeto conhecido.</param>
        <param name="state">Dados específicos de canal ou <see langword="null" />.</param>
        <summary>Cria um proxy para o objeto conhecido indicado pelo tipo especificado, URL e dados de canal.</summary>
        <returns>Um proxy que aponta para um ponto de extremidade servido pelo objeto conhecido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame o proxy para enviar mensagens para o objeto remoto. Não há mensagens são enviadas pela rede até que um método é chamado no proxy.  
  
 O `state` parâmetro comunica informações para o canal e é passado para o <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="url" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> não é empacotado por referência e não é uma interface.</exception>
        <exception cref="T:System.MemberAccessException">Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">A matriz passada dos nomes a serem mapeados.</param>
        <param name="cNames">A contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">A matriz alocada pelo chamador que recebe as IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é usado para acessar classes gerenciadas a partir de código não gerenciado e não deve ser chamado a partir de código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Um objeto que recebe um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é usado para acessar classes gerenciadas a partir de código não gerenciado e não deve ser chamado a partir de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Quando este método retorna, contém um ponteiro para um local que recebe o número de interfaces de informações de tipo fornecidas pelo objeto. Este parâmetro é passado não inicializado.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é usado para acessar classes gerenciadas a partir de código não gerenciado e não deve ser chamado a partir de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Um identificador de distribuição que identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Um ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Um ponteiro para o local em que o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Um ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é usado para acessar classes gerenciadas a partir de código não gerenciado e não deve ser chamado a partir de código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
  </Members>
</Type>