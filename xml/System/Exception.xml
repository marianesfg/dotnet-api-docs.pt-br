<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="32456a5d5f1f43059c002bacf13fda738938008f" /><Meta Name="ms.sourcegitcommit" Value="9802d4c6745a8ae514b26f144fb3969265b224ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/22/2018" /><Meta Name="ms.locfileid" Value="53750537" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa erros que ocorrem durante a execução do aplicativo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe é a classe base para todas as exceções. Quando ocorre um erro, o sistema ou o aplicativo em execução no momento relata lançando uma exceção que contém informações sobre o erro. Depois que uma exceção é lançada, ela é tratada pelo aplicativo ou pelo manipulador de exceção padrão.  
  
 Nesta seção:  
  
 [Erros e exceções](#Errors)   
 [Blocos try/catch](#TryCatch)   
 [Recursos de tipo de exceção](#Features)   
 [Propriedades de classe de exceção](#Properties)   
 [Considerações sobre desempenho](#Performance)   
 [Gerando uma exceção novamente](#Rethrow)   
 [Escolhendo exceções padrão](#Standard)   
 [Implementando exceções personalizadas](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Erros e exceções  
 Erros de tempo de execução podem ocorrer por vários motivos. No entanto, nem todos os erros devem ser tratados como exceções em seu código. Aqui estão algumas categorias de erros que podem ocorrer em tempo de execução e as maneiras apropriadas para responder a eles.  
  
-   **Erros de uso.** Um erro de uso representa um erro na lógica do programa que pode resultar em uma exceção. No entanto, o erro deve ser resolvido, não por meio de manipulação de exceção, mas, modificando o código defeituoso. Por exemplo, a substituição do <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método no exemplo a seguir pressupõe que o `obj` argumento sempre deve ser não nulo.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     O <xref:System.NullReferenceException> exceção que resulta quando `obj` é `null` podem ser eliminados, modificando o código-fonte para testar null antes de chamar explicitamente o <xref:System.Object.Equals%2A?displayProperty=nameWithType> substituição e, em seguida, compilar novamente. O exemplo a seguir contém o código-fonte corrigido que manipula um `null` argumento.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Em vez de usar o tratamento de exceção para erros de uso, você pode usar o <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> método para identificar erros de uso em compilações de depuração e o <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> compilações de método para identificar erros de uso na depuração e versão. Para obter mais informações, consulte [asserções em código gerenciado](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Erros de programa.** Um erro de programa é um erro de tempo de execução que não pode ser evitado necessariamente escrevendo código livre de bugs.  
  
     Em alguns casos, um erro de programa pode refletir uma condição de erro esperado ou rotina. Nesse caso, você talvez queira evitar o uso de manipulação de exceção para lidar com o erro de programa e em vez disso, repita a operação. Por exemplo, se o usuário deve inserir uma data em um formato específico, você pode analisar a cadeia de caracteres de data por meio da chamada a <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> método, que retorna um <xref:System.Boolean> valor que indica se a operação de análise foi bem-sucedida, em vez de usar o <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>método, que lança uma <xref:System.FormatException> exceção se a cadeia de caracteres de data não pode ser convertida em um <xref:System.DateTime> valor. Da mesma forma, se um usuário tenta abrir um arquivo que não existe, você pode primeiro chamar o <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> método para verificar se o arquivo existe e, se não estiver, solicita que o usuário se deseja criá-lo.  
  
     Em outros casos, um erro de programa reflete uma condição de erro inesperado que pode ser manipulada em seu código. Por exemplo, mesmo se você tiver verificado para garantir a existência de um arquivo, ele pode ser excluído antes de você pode abri-lo ou ele pode estar corrompido. Nesse caso, tentar abrir o arquivo pela instanciação de um <xref:System.IO.StreamReader> objeto ou uma chamada a <xref:System.IO.File.Open%2A> método pode lançar um <xref:System.IO.FileNotFoundException> exceção. Nesses casos, você deve usar tratamento de exceções para recuperar do erro.  
  
-   **Falhas do sistema.** Uma falha do sistema é um erro de tempo de execução que não pode ser manipulado por meio de programação de forma significativa. Por exemplo, qualquer método pode lançar um <xref:System.OutOfMemoryException> exceção se o common language runtime não consegue alocar memória adicional. Em geral, falhas de sistema não são tratadas por meio de manipulação de exceção. Em vez disso, você poderá usar um evento, tal como <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> e chamar o <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> método para registrar informações de exceção e notificar o usuário sobre a falha antes do aplicativo será encerrado.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Blocos try/catch  
 O common language runtime fornece um modelo de tratamento de exceção que se baseia a representação de exceções como objetos e a separação de código do programa e o código na manipulação de exceção `try` blocos e `catch` blocos. Pode haver um ou mais `catch` bloqueia, cada um projetado para lidar com um tipo específico de exceção ou um bloco projetado para capturar uma exceção mais específica que outro bloco.  
  
 Se um aplicativo manipula as exceções que ocorrem durante a execução de um bloco de código do aplicativo, o código deve ser colocado em uma `try` instrução e é chamado um `try` bloco. Código do aplicativo que lida com as exceções geradas por um `try` bloco é colocado dentro de uma `catch` instrução e é chamado um `catch` bloco. Zero ou mais `catch` blocos são associados com um `try` bloco e cada `catch` bloco inclui um filtro de tipo que determina os tipos de exceções que ele manipula.  
  
 Quando uma exceção ocorre em um `try` bloco, o sistema procura associado `catch` bloqueia na ordem em que aparecem no código do aplicativo, até que ele localiza um `catch` bloco que manipula a exceção. Um `catch` bloco manipula uma exceção do tipo `T` se o filtro de tipo do bloco catch especifica `T` ou qualquer tipo que `T` deriva. O sistema interromperá a pesquisa depois que ele localiza o primeiro `catch` bloco que manipula a exceção. Por esse motivo, no código do aplicativo, uma `catch` bloco que manipula um tipo deve ser especificado antes um `catch` bloco que lida com seus tipos base, conforme demonstrado no exemplo a seguir nesta seção. Um bloco catch que manipula `System.Exception` é especificado pela última vez.  
  
 Se nenhum da `catch` associados ao atual de blocos `try` bloco lidar com a exceção e atual `try` bloco está aninhado dentro de outras `try` bloqueia na chamada atual, o `catch` blocos associados com o próximo delimitador `try` bloco são pesquisados. Se nenhum `catch` bloco para a exceção for encontrado, o sistema procura os níveis de aninhamento anteriores na chamada atual. Se nenhum `catch` bloqueie a exceção é encontrada na chamada atual, a exceção é passada na pilha de chamada e o quadro de pilha anterior é procurado por um `catch` bloco que manipula a exceção. A pesquisa da pilha de chamadas continua até que a exceção é tratada ou não há mais quadros existem na pilha de chamadas. Se a parte superior da pilha de chamadas for atingido sem encontrar uma `catch` cuida de bloco que manipula a exceção, o manipulador de exceção padrão e o aplicativo será encerrado.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Recursos do tipo de exceção  
 Tipos de exceção suportam os seguintes recursos:  
  
-   Texto legível por humanos que descreve o erro. Quando ocorre uma exceção, o tempo de execução faz uma mensagem de texto disponível para informar ao usuário sobre a natureza do erro e sugerir a ação para resolver o problema. Essa mensagem de texto é mantida no <xref:System.Exception.Message%2A> propriedade do objeto de exceção. Durante a criação do objeto de exceção, você pode passar uma cadeia de caracteres de texto para o construtor para descrever os detalhes da exceção em particular. Se nenhum argumento de mensagem de erro é fornecido para o construtor, a mensagem de erro padrão será usada. Para obter mais informações, consulte a propriedade <xref:System.Exception.Message%2A>.  
  
-   O estado da pilha de chamadas quando a exceção foi lançada. O <xref:System.Exception.StackTrace%2A> propriedade executa um rastreamento de pilha que pode ser usado para determinar onde o erro ocorreu no código. O rastreamento de pilha lista os métodos chamados e os números de linha no arquivo de origem em que as chamadas são feitas.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Propriedades da classe de exceção  
 O <xref:System.Exception> classe inclui um número de propriedades que ajudam a identificar o local do código, o tipo, o arquivo de Ajuda e o motivo da exceção: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, e <xref:System.Exception.Data%2A>.  
  
 Quando um relacionamento causal com existe entre duas ou mais exceções, o <xref:System.Exception.InnerException%2A> propriedade mantém essas informações. A exceção externa é gerada em resposta a essa exceção interna. O código que manipula a exceção externa pode usar as informações da exceção interna anteriormente para tratar o erro de forma mais adequada. Informações complementares sobre a exceção podem ser armazenadas como uma coleção de pares chave/valor no <xref:System.Exception.Data%2A> propriedade.  
  
 A cadeia de caracteres de mensagem de erro que é passada para o construtor durante a criação do objeto de exceção deve ser localizada e pode ser fornecida por meio de um arquivo de recurso a <xref:System.Resources.ResourceManager> classe. Para obter mais informações sobre recursos localizados, consulte o [Criando Assemblies satélite](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) e [Empacotando e implantando recursos](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) tópicos.  
  
 Para fornecer ao usuário com informações abrangentes sobre o motivo da exceção, o <xref:System.Exception.HelpLink%2A> propriedade pode conter uma URL (ou URN) para um arquivo de Ajuda.  
  
 O <xref:System.Exception> classe usa o HRESULT COR_E_EXCEPTION, que tem o valor 0x80131500.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância das <xref:System.Exception> classe, consulte o <xref:System.Exception.%23ctor%2A> construtores.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Lançando ou tratando uma exceção consome uma quantidade significativa de recursos do sistema e o tempo de execução. Gera exceções somente para lidar com condições extraordinários realmente, não para manipular eventos previsíveis ou controle de fluxo. Por exemplo, em alguns casos, como quando você estiver desenvolvendo uma biblioteca de classes, é razoável lançar uma exceção se um argumento de método é inválido porque você espera que seu método ser chamado com parâmetros válidos. Um argumento de método inválido, se não for o resultado de um erro de uso, significa que alguma coisa extraordinária ocorreu. Por outro lado, lançará uma exceção se a entrada do usuário é inválida, porque você pode esperar que os usuários insiram ocasionalmente dados inválidos. Em vez disso, fornecem um mecanismo de repetição para que os usuários podem inserir uma entrada válida. Nem você deve usar exceções para lidar com erros de uso. Em vez disso, use [asserções](/visualstudio/debugger/assertions-in-managed-code) para identificar e corrigir erros de uso.  
  
 Além disso, não lance uma exceção quando um código de retorno é suficiente; Não converta um código de retorno em uma exceção; e fazer catch não rotineiramente uma exceção, ignorá-lo e, em seguida, continuar o processamento.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Gerando uma exceção novamente  
 Em muitos casos, um manipulador de exceção simplesmente quer passar a exceção para o chamador. Isso geralmente ocorre em:  
  
-   Uma biblioteca de classes que por sua vez, encapsula chamadas para métodos na biblioteca de classes .NET Framework ou outras bibliotecas de classes.  
  
-   Um aplicativo ou uma biblioteca que encontra uma exceção fatal. O manipulador de exceção pode registrar a exceção e, em seguida, relançar a exceção.  
  
 A maneira recomendada para gerar novamente uma exceção é simplesmente usar o [lançar](~/docs/csharp/language-reference/keywords/throw.md) instrução em c# e o [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) instrução no Visual Basic sem incluir uma expressão. Isso garante que todas as informações de pilha de chamada são preservadas quando a exceção é propagada para o chamador. O exemplo a seguir ilustra essa situação. Um método de extensão de cadeia de caracteres `FindOccurrences`, encapsula uma ou mais chamadas para <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> sem validar seus argumentos com antecedência.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Em seguida, chama um chamador `FindOccurrences` duas vezes. Na segunda chamada para `FindOccurrences`, o chamador passa uma `null` como a cadeia de caracteres de pesquisa, quais casos a <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método para lançar um <xref:System.ArgumentNullException> exceção. Essa exceção é tratada pelo `FindOccurrences` método e retransmitiu ao chamador. Como a instrução throw é usada com nenhuma expressão, a saída do exemplo mostra que a pilha de chamadas é preservada.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Por outro lado, se a exceção é lançada novamente usando o  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 instrução, a pilha de chamadas completa não é preservada e o exemplo geraria a seguinte saída:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Uma alternativa um pouco mais complicada é gerar uma nova exceção e para preservar informações de pilha de chamada da exceção original em uma exceção interna. O chamador pode, em seguida, usar a nova exceção <xref:System.Exception.InnerException%2A> propriedade para recuperar o quadro de pilha e outras informações sobre a exceção original. Nesse caso, a instrução throw é:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 O código de usuário que manipula a exceção deve saber que o <xref:System.Exception.InnerException%2A> propriedade contém informações sobre a exceção original, como ilustra o seguinte manipulador de exceção.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Escolhendo exceções padrão  
 Quando você tem que gerar uma exceção, você geralmente pode usar um tipo de exceção existente no .NET Framework em vez de implementar uma exceção personalizada. Você deve usar um tipo de exceção padrão nestas duas condições:  
  
-   Você está lançando uma exceção causada por um erro de uso (isto é, por um erro na lógica do programa feita pelo desenvolvedor que está chamando seu método). Normalmente, você gerará uma exceção, como <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, ou <xref:System.NotSupportedException>. A cadeia de caracteres que você fornece ao construtor do objeto de exceção ao instanciar o objeto de exceção deve descrever o erro para que o desenvolvedor possa corrigi-lo. Para obter mais informações, consulte a propriedade <xref:System.Exception.Message%2A>.  
  
-   Tratamento de erro que poderá ser comunicado ao chamador com uma exceção do .NET Framework existente. Você deve lançar a exceção mais derivada possíveis. Por exemplo, se um método exige um argumento para ser um membro válido de um tipo de enumeração, você deve lançar uma <xref:System.ComponentModel.InvalidEnumArgumentException> (classe derivada de mais) em vez de um <xref:System.ArgumentException>.  
  
 A tabela a seguir lista os tipos de exceções comuns e as condições sob as quais gerá-los.  
  
|Exceção|Condição|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Um argumento não nulo que é passado para um método é inválido.|  
|<xref:System.ArgumentNullException>|Um argumento que é passado para um método é `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Um argumento está fora do intervalo de valores válidos.|  
|<xref:System.IO.DirectoryNotFoundException>|Parte de um caminho de diretório não é válido.|  
|<xref:System.DivideByZeroException>|O denominador em um número inteiro ou <xref:System.Decimal> operação de divisão é zero.|  
|<xref:System.IO.DriveNotFoundException>|Uma unidade não está disponível ou não existe.|  
|<xref:System.IO.FileNotFoundException>|Um arquivo não existe.|  
|<xref:System.FormatException>|Um valor não está em um formato apropriado para ser convertido de uma cadeia de caracteres por um método de conversão, como `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Um índice está fora dos limites de uma matriz ou coleção.|  
|<xref:System.InvalidOperationException>|Uma chamada de método é inválida no estado atual de um objeto.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|A chave especificada para acessar um membro em uma coleção não foi encontrada.|  
|<xref:System.NotImplementedException>|Um método ou operação não está implementada.|  
|<xref:System.NotSupportedException>|Não há suporte para um método ou operação.|  
|<xref:System.ObjectDisposedException>|Uma operação é executada em um objeto que foi descartado.|  
|<xref:System.OverflowException>|Uma operação aritmética, projeção ou conversão resulta em um estouro.|  
|<xref:System.IO.PathTooLongException>|Um nome de caminho ou arquivo excede o comprimento máximo definido pelo sistema.|  
|<xref:System.PlatformNotSupportedException>|Não há suporte para a operação na plataforma atual.|  
|<xref:System.RankException>|Uma matriz com o número errado de dimensões é passada para um método.|  
|<xref:System.TimeoutException>|O intervalo de tempo alocado para uma operação expirou.|  
|<xref:System.UriFormatException>|Um Uniform Resource identificador (URI inválido) é usado.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implementando exceções personalizadas  
 Nos seguintes casos, não é adequada usar uma exceção do .NET Framework existente para lidar com uma condição de erro:  
  
-   Quando a exceção reflete um erro de programa exclusivo que não pode ser mapeado para uma exceção do .NET Framework existente.  
  
-   Quando a exceção requer manipulação que é diferente do que o tratamento apropriado para uma exceção do .NET Framework existente ou a exceção deve ser a ambiguidade removida de uma exceção semelhante. Por exemplo, se você acionar um <xref:System.ArgumentOutOfRangeException> exceção ao analisar a representação numérica de uma cadeia de caracteres que está fora do intervalo do tipo integral de destino, você não desejaria usar a mesma exceção para um erro que resulta do chamador não fornecendo o restritos valores apropriados ao chamar o método.  
  
 O <xref:System.Exception> é a classe base de todas as exceções no .NET Framework. Muitas classes derivadas confiam no comportamento herdado dos membros a <xref:System.Exception> classe; eles não substituam os membros da <xref:System.Exception>, nem definirem qualquer membros exclusivos.  
  
 Para definir sua própria classe de exceção:  
  
1.  Definir uma classe que herda de <xref:System.Exception>. Se necessário, defina quaisquer membros exclusivos necessários por sua classe para fornecer informações adicionais sobre a exceção. Por exemplo, o <xref:System.ArgumentException> classe inclui um <xref:System.ArgumentException.ParamName%2A> propriedade que especifica o nome do parâmetro cujo argumento causou a exceção, e o <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> propriedade inclui um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> propriedade que indica o intervalo de tempo limite.  
  
2.  Se necessário, substitua qualquer membro herdado cuja funcionalidade que você deseja alterar ou modificar. Observe que a maioria dos existente classes derivadas de <xref:System.Exception> não substituem o comportamento de membros herdados.  
  
3.  Determine se seu objeto de exceção personalizada é serializável. Serialização permite que você salve informações sobre a exceção e permite que as informações de exceção para serem compartilhados por um servidor e um proxy de cliente em um contexto de comunicação remota. Para fazer com que o objeto de exceção serializável, marque-o com o <xref:System.SerializableAttribute> atributo.  
  
4.  Defina os construtores de sua classe de exceção. Normalmente, as classes de exceção têm um ou mais dos seguintes construtores:  
  
    -   <xref:System.Exception.%23ctor>, que usa valores padrão para inicializar as propriedades de um novo objeto de exceção.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, que inicializa um novo objeto de exceção com uma mensagem de erro especificada.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, que inicializa um novo objeto de exceção com uma exceção interna e a mensagem de erro especificada.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, que é um `protected` construtor que inicializa um novo objeto de exceção dos dados serializados. Se você optou por fazer o seu objeto de exceção serializável, você deve implementar esse construtor.  
  
 O exemplo a seguir ilustra o uso de uma classe de exceção personalizada. Ele define uma `NotPrimeException` exceção que é lançada quando um cliente tenta recuperar uma sequência de números primos, especificando um número inicial que não for primo. A exceção define uma nova propriedade, `NonPrime`, que retorna o não-número primo que causou a exceção. Além de implementar um construtor sem parâmetros protegido e um construtor com <xref:System.Runtime.Serialization.SerializationInfo> e <xref:System.Runtime.Serialization.StreamingContext> parâmetros para a serialização, o `NotPrimeException` classe define três construtores adicionais para dar suporte a `NonPrime` propriedade.  Cada construtor chama um construtor de classe base, além de preservar o valor de não-número primo. O `NotPrimeException` classe também é marcado com o <xref:System.SerializableAttribute> atributo.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 O `PrimeNumberGenerator` classe mostrada no exemplo a seguir usa Sieve de Eratosthenes para calcular a sequência de números primos, de 2 a um limite especificado pelo cliente na chamada ao construtor de classe. O `GetPrimesFrom` método retorna todos os números primos que são maiores que ou igual ao limite inferior especificado, mas gera um `NotPrimeException` se que o limite inferior não for um número primo.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 O exemplo a seguir faz duas chamadas para o `GetPrimesFrom` método com números não primos, um dos quais cruza os limites de domínio de aplicativo. Em ambos os casos, a exceção é lançada e tratada com êxito no código do cliente.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Tempo de execução do Windows e [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Na [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] para [!INCLUDE[win8](~/includes/win8-md.md)], algumas informações de exceção são geralmente perdidas quando uma exceção é propagada por meio de quadros de pilha não tenham o .NET Framework. Começando com o [!INCLUDE[net_v451](~/includes/net-v451-md.md)] e [!INCLUDE[win81](~/includes/win81-md.md)], o common language runtime continua a usar o original <xref:System.Exception> objeto que foi lançado, a menos que essa exceção foi modificada em um quadro de pilha não tenham o .NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma `catch` bloco que é definido para tratar <xref:System.ArithmeticException> erros. Isso `catch` bloquear também captura <xref:System.DivideByZeroException> erros, porque <xref:System.DivideByZeroException> deriva <xref:System.ArithmeticException> e não há nenhum `catch` bloco definido explicitamente para <xref:System.DivideByZeroException> erros.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Manipulando e lançando exceções</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos em aplicativos de área de trabalho</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Asserções em código gerenciado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Exception" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Exception" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa o <xref:System.Exception.Message%2A> propriedade da nova instância para uma mensagem fornecida pelo sistema que descreve o erro e leva em conta a cultura atual do sistema.  
  
 Todas as classes derivadas devem fornecer esse construtor padrão. A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.Exception>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Uma referência nula (`Nothing` no Visual Basic).|  
|<xref:System.Exception.Message%2A>|Uma descrição localizada fornecida pelo sistema.|  
  
   
  
## Examples  
 O exemplo de código a seguir é derivado um `Exception` que usa uma mensagem predefinida. O código demonstra o uso do construtor sem parâmetros para a classe derivada e a base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem que descreve o erro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Exception" /> com uma mensagem de erro especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa o <xref:System.Exception.Message%2A> propriedade da nova instância usando o `message` parâmetro. Se o `message` parâmetro é `null`, isso é o mesmo que chamar o <xref:System.Exception.%23ctor%2A> construtor.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.Exception>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Uma referência nula (`Nothing` no Visual Basic).|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro.|  
  
   
  
## Examples  
 O exemplo de código a seguir é derivado um `Exception` uma condição específica. O código demonstra o uso do construtor que aceita uma mensagem especificada pelo chamador como um parâmetro, para a classe derivada e a base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
        <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Exception" /> com dados serializados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado durante a desserialização para reconstituir o objeto de exceção transmitido por um fluxo. Para obter mais informações, consulte [serialização XML e SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 O exemplo de código a seguir define uma derivada serializável `Exception` classe. O código força um erro de divisão por 0 e, em seguida, cria uma instância de exceção derivada usando o (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) construtor. O código serializa a instância de um arquivo, desserializa o arquivo em uma nova exceção, ele gerará, e, em seguida, captura e exibe os dados da exceção.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">O nome de classe <see langword="null" /> ou <see cref="P:System.Exception.HResult" /> é zero (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serialização XML e SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem de erro que explica a razão da exceção.</param>
        <param name="innerException">A exceção que é a causa da exceção atual ou uma referência nula (<see langword="Nothing" /> no Visual Basic) se nenhuma exceção interna é especificada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Exception" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma exceção que é lançada como um resultado direto de uma exceção anterior deve incluir uma referência para a exceção anterior na propriedade <xref:System.Exception.InnerException%2A>. A propriedade <xref:System.Exception.InnerException%2A> retorna o mesmo valor que é passado para o construtor ou uma referência nula (`Nothing` no Visual Basic) caso a propriedade <xref:System.Exception.InnerException%2A> não forneça o valor de exceção interna para o construtor.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.Exception>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|A referência de exceção interna.|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro.|  
  
   
  
## Examples  
 O exemplo de código a seguir é derivado um `Exception` uma condição específica. O código demonstra o uso do construtor que aceita uma mensagem e exceção interna, como parâmetros para a classe derivada e a base de `Exception` classe.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de pares de chave/valor que fornecem informações adicionais definidas pelo usuário sobre a exceção.</summary>
        <value>Um objeto que implementa a interface <see cref="T:System.Collections.IDictionary" /> e que contém uma coleção de pares chave-valor definidos pelo usuário. O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Collections.IDictionary?displayProperty=nameWithType> objeto retornado pelo <xref:System.Exception.Data%2A> propriedade para armazenar e recuperar informações suplementares relevantes para a exceção. As informações estão na forma de um número arbitrário de pares chave/valor definidos pelo usuário. O componente principal do cada par chave/valor normalmente é uma cadeia de caracteres de identifica, enquanto o componente de valor do par pode ser qualquer tipo de objeto.  
  
## <a name="keyvalue-pair-security"></a>Segurança do par de chave/valor  
 Os pares chave/valor armazenados na coleção retornada pelo <xref:System.Exception.Data%2A> propriedade não são seguras. Se seu aplicativo chama uma série aninhada de rotinas, e cada rotina contém manipuladores de exceção, a pilha de chamadas resultante contém uma hierarquia desses manipuladores de exceção. Se uma rotina de nível inferior lançará uma exceção, qualquer manipulador de exceção de nível superior na hierarquia de pilha de chamada pode ler e/ou modificar os pares chave/valor armazenados na coleção por qualquer outro manipulador de exceção. Isso significa que você deve garantir que as informações nos pares chave/valor não são confidenciais e que seu aplicativo funcionará corretamente se as informações nos pares chave/valor estão corrompidas.  
  
## <a name="key-conflicts"></a>Conflitos de chave  
 Um conflito de chave ocorre quando os manipuladores de exceção diferentes especificam a mesma chave para acessar um par chave/valor. Tenha cuidado ao desenvolver seu aplicativo porque a consequência de um conflito de chave é que manipuladores de exceção de nível inferior inadvertidamente podem se comunicar com os manipuladores de exceção de nível mais altos, e essa comunicação pode causar erros de programa sutis. No entanto, se você for cuidadoso, você pode usar conflitos de chave para aprimorar seu aplicativo.  
  
## <a name="avoiding-key-conflicts"></a>Evitando conflitos de chave  
 Evite conflitos de chave ao adotar uma convenção de nomenclatura para gerar chaves exclusivas para pares chave/valor. Por exemplo, uma convenção de nomenclatura pode produzir uma chave que consiste no nome delimitados do seu aplicativo, o método que fornece informações complementares para o par e um identificador exclusivo.  
  
 Suponha que dois aplicativos, chamado produtos e fornecedores, cada um tem um método chamado Sales. O método de vendas no aplicativo produtos fornece o número de identificação (o unidade ou SKU de manutenção de estoque) de um produto. O método de vendas no aplicativo fornecedores fornece o número de identificação ou SID de um fornecedor. Consequentemente, a convenção de nomenclatura para este exemplo gera as chaves, "Products.Sales.SKU" e "Suppliers.Sales.SID".  
  
## <a name="exploiting-key-conflicts"></a>Explorando conflitos de chave  
 Explorar os conflitos de chave usando a presença de uma ou mais chaves especiais, pré-organizados para controlar o processamento. Suponha que, em um cenário, o manipulador de exceção de nível mais alto na hierarquia de pilha de chamada captura todas as exceções geradas por manipuladores de exceção de nível inferior. Se existir um par chave/valor com uma chave especial, o manipulador de exceção de alto nível formata os pares chave/valor restantes no <xref:System.Collections.IDictionary> objeto de alguma maneira não padrão; caso contrário, os pares de chave/valor restantes são formatados de alguma maneira normal.  
  
 Agora suponha que, em outro cenário, o manipulador de exceção em cada nível da hierarquia de pilha de chamada captura a exceção lançada pelo manipulador de exceção de nível inferior próximo. Além disso, cada manipulador de exceção sabe que a coleção retornada pela <xref:System.Exception.Data%2A> propriedade contém um conjunto de pares chave/valor que pode ser acessado com um conjunto pré-organizados de chaves.  
  
 Cada manipulador de exceção usa o pré-organizados conjunto de chaves para atualizar o componente de valor do par chave/valor correspondente com informações exclusivas para o manipulador de exceção. Depois que o processo de atualização for concluído, o manipulador de exceção lança a exceção para o próximo manipulador de exceção de nível mais alto. Por fim, o manipulador de exceção de nível mais alto acessa os pares chave/valor e exibe as informações de atualização consolidado de todos os manipuladores de exceção de nível inferior.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar e recuperar informações usando o <xref:System.Exception.Data%2A> propriedade.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna a <see cref="T:System.Exception" /> que é a causa raiz de uma ou mais exceções subsequentes.</summary>
        <returns>A primeira exceção gerada em uma cadeia de exceções. Se a propriedade <see cref="P:System.Exception.InnerException" /> da exceção atual for uma referência nula (<see langword="Nothing" /> no Visual Basic), essa propriedade retornará a exceção atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cadeia de exceções consiste em um conjunto de exceções, de modo que cada exceção na cadeia foi lançada como um resultado direto da exceção referenciada em seu `InnerException` propriedade. Para uma determinada cadeia, pode haver exatamente uma exceção que é a causa raiz de todas as outras exceções na cadeia. Essa exceção é chamada a exceção de base e sua `InnerException` propriedade sempre contém uma referência nula.  
  
 Para todas as exceções em uma cadeia de exceções, o `GetBaseException` método deve retornar o mesmo objeto (a exceção de base).  
  
 Use o `GetBaseException` método quando você deseja encontrar a causa raiz de uma exceção, mas não é necessário para obter informações sobre exceções que possam ter ocorrido entre a exceção atual e a primeira exceção.  
  
   
  
## Examples  
 O exemplo de código a seguir define dois derivados `Exception` classes. Ele força uma exceção e, em seguida, gera novamente com cada uma das classes derivadas. O código mostra o uso do `GetBaseException` método para recuperar a exceção original.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>O <see langword="GetBaseException" /> for substituído em classes que exigem controle sobre o formato ou o conteúdo da exceção.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que mantém os dados de objeto serializados sobre a exceção que está sendo lançada.</param>
        <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
        <summary>Quando substituído em uma classe derivada, define o <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com informações sobre a exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` define um <xref:System.Runtime.Serialization.SerializationInfo> com todos os dados de objeto de exceção destinados para a serialização. Durante a desserialização, a exceção é reconstituída a partir de `SerializationInfo` transmitido no fluxo.  
  
   
  
## Examples  
 O exemplo de código a seguir define uma derivada serializável `Exception` classe que implementa `GetObjectData`, que faz alterações secundárias a duas propriedades e, em seguida, chama a classe base para executar a serialização. O exemplo força um erro de divisão por 0 e, em seguida, cria uma instância da exceção derivada. O código serializa a instância de um arquivo, desserializa o arquivo em uma nova exceção, ele gerará, e, em seguida, captura e exibe os dados da exceção.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <see langword="Nothing" /> é uma referência nula (<paramref name="info" /> no Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o tipo de tempo de execução da instância atual.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo de tempo de execução exato da instância atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Exception.GetType%2A> método existe para oferecer suporte à infraestrutura .NET Framework e internamente chama o método fundamental, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um link para o arquivo de ajuda associado a essa exceção.</summary>
        <value>O URN (Uniform Resource Name) ou a URL (Uniform Resource Locator).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno, que representa um arquivo de Ajuda, é um URN ou URL. Por exemplo, o `HelpLink` valor poderia ser:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 O seguinte código de exemplo lança um `Exception` que define o `HelpLink` propriedade em seu construtor e, em seguida, captura a exceção e exibe `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define HRESULT, um valor numérico codificado que é atribuído a uma exceção específica.</summary>
        <value>O valor HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT é um valor de 32 bits, dividido em três campos diferentes: um código de gravidade, um código de facilidade e um código de erro. O código de severidade indica se o valor de retorno representa informações, aviso ou erro. O código de facilidade identifica a área do sistema responsável pelo erro. O código de erro é um número exclusivo atribuído para representar a exceção. Cada exceção é mapeada para um HRESULT distinto. Quando o código gerenciado gera uma exceção, o tempo de execução passa o HRESULT para o cliente COM. Quando o código não gerenciado retorna um erro, o HRESULT é convertido em uma exceção, que é então emitida pelo tempo de execução. Para obter informações sobre valores HRESULT e suas exceções correspondentes do .NET Framework, consulte [como: Mapear HRESULTs e exceções](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Ver [valores HRESULT comuns](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) na documentação do Windows para obter uma lista dos valores que você provavelmente encontrará.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Exception.HResult%2A> setter da propriedade é protegido, enquanto que o getter é público.  Nas versões anteriores do .NET Framework, getter e setter são protegidos.  
  
   
  
## Examples  
 O exemplo de código a seguir define um derivado `Exception` classe que define o `HResult` propriedade para um valor personalizado em seu construtor.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Como mapear HRESULTs e exceções</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Valores HRESULT comuns</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a instância <see cref="T:System.Exception" /> que causou a exceção atual.</summary>
        <value>Um objeto que descreve o erro que causou a exceção atual. A propriedade <see cref="P:System.Exception.InnerException" /> retornará o mesmo valor passado para o construtor <see cref="M:System.Exception.#ctor(System.String,System.Exception)" />, ou <see langword="null" />, se o valor de exceção interno não foi fornecido para o construtor. Esta propriedade é somente para leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma exceção `X` é lançada como um resultado direto de uma exceção anterior `Y`, o <xref:System.Exception.InnerException%2A> propriedade do `X` deve conter uma referência a `Y`.  
  
 Use o <xref:System.Exception.InnerException%2A> propriedade para obter o conjunto de exceções que conduziram à exceção atual.  
  
 Você pode criar uma nova exceção que captura uma exceção anterior. O código que manipula que a segunda exceção pode fazer uso das informações adicionais da exceção anterior para tratar o erro de forma mais adequada.  
  
 Suponha que há uma função que lê um arquivo e formata os dados desse arquivo. Neste exemplo, como o código tenta ler o arquivo, um <xref:System.IO.IOException> é gerada. A função captura a <xref:System.IO.IOException> e gera um <xref:System.IO.FileNotFoundException>. O <xref:System.IO.IOException> puderam ser salvos na <xref:System.Exception.InnerException%2A> propriedade da <xref:System.IO.FileNotFoundException>, permitindo que o código que captura o <xref:System.IO.FileNotFoundException> para examinar a causa do erro inicial.  
  
 O <xref:System.Exception.InnerException%2A> propriedade, que contém uma referência à exceção interna, é definida após a inicialização do objeto de exceção.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a lançar e capturar uma exceção que faz referência a uma exceção interna.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma mensagem que descreve a exceção atual.</summary>
        <value>A mensagem de erro que explica a razão da exceção ou uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O desenvolvedor que está tratando a exceção de destino de mensagens de erro. O texto do <xref:System.Exception.Message%2A> propriedade completamente deve descrever o erro e, quando possível, também deve explicar como corrigir o erro. Manipuladores de exceção de nível superior podem exibir a mensagem para os usuários finais, portanto, você deve garantir que ele é gramaticalmente correto e que cada sentença da mensagem termina com um período. Não use pontos de interrogação ou pontos de exclamação. Se seu aplicativo usa mensagens de exceção localizada, você deve garantir que eles são transferidos com precisão.  
  
> [!IMPORTANT]
>  Não divulgue informações confidenciais em mensagens de exceção sem verificar as permissões apropriadas.  
  
 O valor de <xref:System.Exception.Message%2A> propriedade é incluída nas informações retornadas por <xref:System.Exception.ToString%2A>. O <xref:System.Exception.Message%2A> propriedade é definida somente durante a criação de um <xref:System.Exception>. Se nenhuma mensagem foi fornecida para o construtor para a instância atual, o sistema fornecerá uma mensagem padrão que é formatada usando a cultura atual do sistema.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Tempo de execução do Windows e [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Começando com o [!INCLUDE[net_v451](~/includes/net-v451-md.md)] e [!INCLUDE[win81](~/includes/win81-md.md)], a fidelidade de mensagens de erro de exceções são propagadas de tipos de tempo de execução do Windows e membros que não fazem parte do .NET Framework é aprimorada. Em particular, mensagens de exceção de extensões de componentes do Visual C++ (C + + c++ /CX) agora são propagadas novamente no .NET Framework <xref:System.Exception> objetos.  
  
   
  
## Examples  
 O exemplo de código a seguir gera e, em seguida, captura uma <xref:System.Exception> exceção e exibe o texto da exceção de mensagem usando o <xref:System.Exception.Message%2A> propriedade.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você lançar uma exceção de uma propriedade, e você precisa consultar no texto do <see cref="P:System.Exception.Message" /> para o argumento de propriedade que definem ou obtêm, use "valor" como o nome do argumento da propriedade.</para></block>
        <block subset="none" type="overrides"><para>O <see cref="P:System.Exception.Message" /> propriedade seja substituída em classes que exigem controle sobre o formato ou o conteúdo da mensagem. Normalmente, o código do aplicativo acessa essa propriedade quando ele precisa exibir informações sobre uma exceção foi detectada.  
  
A mensagem de erro deve ser localizada.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma exceção é serializada para criar um objeto de estado de exceção que contém dados serializados sobre a exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto de estado de exceção implementa o <xref:System.Runtime.Serialization.ISafeSerializationData> interface.  
  
 Quando o <xref:System.Exception.SerializeObjectState> evento é assinado, a exceção é desserializada e criada como uma exceção vazia. O construtor da exceção não é executado, e o estado de exceção também é desserializado. O <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> método de retorno de chamada do objeto de estado de exceção, em seguida, é notificado para que ele pode desserializados enviar dados por push a exceção vazia.  
  
 O <xref:System.Exception.SerializeObjectState> evento permite que os tipos de exceção transparente serializar e desserializar dados de exceção. O código transparente pode executar comandos dentro dos limites do conjunto de permissões que ele está operando em, mas não é possível executar, chamar, derivar de ou conter código crítico.  
  
 Se o <xref:System.Exception.SerializeObjectState> evento não está inscrito, desserialização ocorre como de costume usando o <xref:System.Exception.%23ctor%2A> construtor.  
  
 Normalmente, um manipulador para o <xref:System.Exception.SerializeObjectState> evento for adicionado no construtor da exceção para fornecer sua serialização. Mas, como o construtor não é executado quando o <xref:System.Exception.SerializeObjectState> manipulador de eventos é executado, serializar uma exceção desserializada pode lançar um <xref:System.Runtime.Serialization.SerializationException> exceção ao tentar desserializar a exceção. Para evitar isso, você também deve adicionar o manipulador para o <xref:System.Exception.SerializeObjectState> evento no <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> método. Consulte a seção de exemplos para obter uma ilustração.  
  
   
  
## Examples  
 O exemplo a seguir define uma `BadDivisionException` que manipula o <xref:System.Exception.SerializeObjectState> eventos. Ele também contém um objeto de estado, que é aninhado estrutura denominada `BadDivisionExceptionState` que implementa o <xref:System.Runtime.Serialization.ISafeSerializationData> interface.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 O `BadDivisionException` exceção é lançada quando ocorre uma divisão de ponto flutuante por zero. Durante a primeira divisão por zero, o exemplo cria uma instância de um `BadDivisionException` objeto, serializa-lo e lança a exceção. Quando ocorrem divisões subsequentes por zero, o exemplo desserializa o objeto serializado anteriormente, reserializes-lo e lança a exceção. Para fornecer para serialização de objeto, a desserialização, a reserialization e a desserialização, o exemplo adiciona o <xref:System.Exception.SerializeObjectState> manipulador de eventos os dois o `BadDivisionException` construtor de classe e, no <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementação.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se esse evento é assinado e usado, todos os tipos derivados que seguem na hierarquia de herança devem implementar o mesmo mecanismo de serialização.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do aplicativo ou objeto que causa o erro.</summary>
        <value>O nome do aplicativo ou objeto que causa o erro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Exception.Source%2A> não está definida explicitamente, o tempo de execução define automaticamente como o nome do assembly no qual a exceção foi originada.  
  
   
  
## Examples  
 O exemplo a seguir gera uma `Exception` que define o `Source` propriedade em seu construtor e, em seguida, captura a exceção e exibe `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O objeto deve ser um <see cref="N:System.Reflection" /> de tempo de execução.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma representação de cadeia de caracteres de quadros imediatos na pilha de chamadas.</summary>
        <value>Uma cadeia de caracteres que descreve os quadros imediatos da pilha de chamadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pilha de execução mantém o registro de todos os métodos que estão em execução em um dado momento. Um rastreamento de chamadas de método é chamado de um rastreamento de pilha. A listagem de rastreamento de pilha fornece uma maneira a seguir a pilha de chamadas para o número de linha no método em que a exceção ocorre.  
  
 O <xref:System.Exception.StackTrace%2A> propriedade retorna os quadros da pilha de chamadas que se originam no local em que a exceção foi lançada. Você pode obter informações sobre os quadros na pilha de chamadas adicionais ao criar uma nova instância dos <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> classe e usando seus <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> método.  
  
 O common language runtime (CLR) atualiza o rastreamento de pilha sempre que uma exceção é lançada no código do aplicativo (usando o `throw` palavra-chave). Se a exceção foi gerada novamente em um método que é diferente do que o método no qual ela foi originalmente lançada, o rastreamento de pilha contém o local no método em que a exceção foi originalmente lançada e o local no método em que a exceção foi emitida novamente. Se a exceção é lançada e gerada novamente mais tarde, no mesmo método, o rastreamento de pilha contém apenas o local onde a exceção foi relançada e não inclui o local em que a exceção foi originalmente lançada.  
  
 O <xref:System.Exception.StackTrace%2A> propriedade pode não relatar tantas chamadas de método conforme o esperado devido a transformações de código, como inlining, que ocorrem durante a otimização.  
  
   
  
## Examples  
 O seguinte código de exemplo lança um `Exception` e, em seguida, captura a ele e exibe um rastreamento de pilha usando o `StackTrace` propriedade.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>O <see langword="StackTrace" /> propriedade seja substituída em classes que exigem controle sobre o formato ou o conteúdo de rastreamento de pilha.  
  
Por padrão, o rastreamento de pilha é capturado imediatamente antes de um objeto de exceção é lançado. Use <see cref="P:System.Environment.StackTrace" /> para obter informações de rastreamento de pilha quando nenhuma exceção está sendo gerada.</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o método que gerou a exceção atual.</summary>
        <value>O <see cref="T:System.Reflection.MethodBase" /> que gerou a exceção atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o método que gerou essa exceção não estiver disponível e o rastreamento de pilha não é uma referência nula (`Nothing` no Visual Basic), <xref:System.Exception.TargetSite%2A> obtém o método do rastreamento de pilha. Se o rastreamento de pilha for uma referência nula, o <xref:System.Exception.TargetSite%2A> também retornará uma referência nula.  
  
> [!NOTE]
>  O <xref:System.Exception.TargetSite%2A> propriedade pode não relatar com precisão o nome do método em que ocorreu uma exceção se o manipulador de exceção manipula uma exceção entre limites de domínio de aplicativo.  
  
   
  
## Examples  
 O seguinte código de exemplo lança um `Exception` e, em seguida, captura-lo e exibe o método de origem usando o `TargetSite` propriedade.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria e retorna uma representação de cadeia de caracteres da exceção atual.</summary>
        <returns>Uma representação de cadeia de caracteres de exceção atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Retorna uma representação da exceção atual que deve ser compreendido por humanos. Onde a exceção contém dados sensíveis à cultura, a representação de cadeia de caracteres retornada por `ToString` é necessário levar em conta a cultura atual do sistema. Embora não haja nenhum requisito exato para o formato de cadeia de caracteres retornada, ele deve tentar refletem o valor do objeto como percebido pelo usuário.  
  
 A implementação padrão de <xref:System.Exception.ToString%2A> obtém o nome da classe que gerou a exceção atual, a mensagem, o resultado da chamada <xref:System.Exception.ToString%2A> sobre a exceção interna e o resultado da chamada <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Se qualquer um desses membros for `null`, seu valor não está incluído na cadeia de caracteres retornada.  
  
 Se não houver nenhuma mensagem de erro ou se for uma cadeia de caracteres vazia (""), nenhuma mensagem de erro será retornado. O nome da exceção interna e o rastreamento de pilha serão retornadas apenas se eles não são `null`.  
  
 Este método substitui <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir faz com que uma exceção e exibe o resultado da chamada <xref:System.Exception.ToString%2A> sobre essa exceção. Observe que o <xref:System.Exception.ToString%2A?displayProperty=nameWithType> método é chamado implicitamente quando a instância da classe de exceção é exibida na lista de argumentos do <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> método.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>