<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="304b1bd9af5de3e3f68ea339684c80c84ccb7715" /><Meta Name="ms.sourcegitcommit" Value="a47b87b664d20090dc34412ab430dec69af9c3f8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="01/04/2019" /><Meta Name="ms.locfileid" Value="54030836" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="37550-101">Representa as declarações de tipo: tipos de classe, tipos de interface, tipos de matriz, tipos de valor, tipos de enumeração, parâmetros de tipo, definições de tipo genérico e tipos genéricos construídos abertos ou fechados.</span><span class="sxs-lookup"><span data-stu-id="37550-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-102">`Type` é a raiz do <xref:System.Reflection> funcionalidade e é a principal maneira de acessar os metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="37550-103">Usar os membros de <xref:System.Type> para obter informações sobre uma declaração de tipo, sobre os membros de um tipo (como os construtores, métodos, campos, propriedades e eventos de uma classe), bem como o módulo e o assembly no qual a classe seja implantada.</span><span class="sxs-lookup"><span data-stu-id="37550-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="37550-104">Nenhuma permissão é necessária para o código usar a reflexão para obter informações sobre tipos e seus membros, independentemente de seus níveis de acesso.</span><span class="sxs-lookup"><span data-stu-id="37550-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="37550-105">Nenhuma permissão é necessária para o código usar a reflexão para acessar os membros públicos ou outros membros cujos níveis de acesso devem torná-las visíveis durante a compilação normal.</span><span class="sxs-lookup"><span data-stu-id="37550-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="37550-106">No entanto, para que seu código para usar a reflexão para acessar os membros que normalmente seriam inacessíveis, tais como métodos privados ou internos ou protegidos por campos de um tipo não herda sua classe, seu código deve ter <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="37550-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="37550-107">Ver [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="37550-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="37550-108">`Type` é uma classe base abstrata que permite várias implementações.</span><span class="sxs-lookup"><span data-stu-id="37550-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="37550-109">O sistema sempre fornecerá a classe derivada `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="37550-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="37550-110">Reflexão, começando com a palavra tempo de execução de todas as classes são criadas apenas uma vez por objeto nas operações de comparação de sistema e suporte.</span><span class="sxs-lookup"><span data-stu-id="37550-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-111">Em cenários de multithreading não bloqueiam <xref:System.Type> objetos para sincronizar o acesso ao `static` dados.</span><span class="sxs-lookup"><span data-stu-id="37550-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="37550-112">Outro código, em que você não tem controle, também pode bloquear seu tipo de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="37550-113">Isso pode resultar em um deadlock.</span><span class="sxs-lookup"><span data-stu-id="37550-113">This might result in a deadlock.</span></span> <span data-ttu-id="37550-114">Em vez disso, sincronizar o acesso a dados estáticos, bloqueando uma privada `static` objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-115">Uma classe derivada pode acessar membros protegidos de classes de base do código de chamada.</span><span class="sxs-lookup"><span data-stu-id="37550-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="37550-116">Além disso, o acesso é permitido para membros do assembly do assembly do código de chamada.</span><span class="sxs-lookup"><span data-stu-id="37550-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="37550-117">Como regra, se a permissão de acesso no código de associação inicial, em seguida, você também podem acessar no código de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="37550-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-118">Interfaces que estendem as outras interfaces não herdam os métodos definidos nas interfaces estendidas.</span><span class="sxs-lookup"><span data-stu-id="37550-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="37550-119">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="37550-119">In this section:</span></span>  
  
 <span data-ttu-id="37550-120">[Quais tipos representa um objeto do tipo?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="37550-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="37550-121">[Recuperando um objeto de tipo](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="37550-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="37550-122">Comparando objetos de tipo de igualdade</span><span class="sxs-lookup"><span data-stu-id="37550-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="37550-123">Quais tipos representa um objeto do tipo?</span><span class="sxs-lookup"><span data-stu-id="37550-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="37550-124">Essa classe é thread-safe; vários threads simultaneamente podem ler de uma instância desse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="37550-125">Uma instância da <xref:System.Type> classe pode representar qualquer um dos seguintes tipos:</span><span class="sxs-lookup"><span data-stu-id="37550-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="37550-126">Classes</span><span class="sxs-lookup"><span data-stu-id="37550-126">Classes</span></span>  
  
-   <span data-ttu-id="37550-127">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="37550-127">Value types</span></span>  
  
-   <span data-ttu-id="37550-128">Matrizes</span><span class="sxs-lookup"><span data-stu-id="37550-128">Arrays</span></span>  
  
-   <span data-ttu-id="37550-129">Interfaces</span><span class="sxs-lookup"><span data-stu-id="37550-129">Interfaces</span></span>  
  
-   <span data-ttu-id="37550-130">Enumerações</span><span class="sxs-lookup"><span data-stu-id="37550-130">Enumerations</span></span>  
  
-   <span data-ttu-id="37550-131">Delegados</span><span class="sxs-lookup"><span data-stu-id="37550-131">Delegates</span></span>  
  
-   <span data-ttu-id="37550-132">Tipos genéricos construídos e definições de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="37550-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="37550-133">Argumentos de tipo e parâmetros de tipo de tipos genéricos construídos, definições de tipo genérico e definições de método genérico</span><span class="sxs-lookup"><span data-stu-id="37550-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="37550-134">Recuperando um objeto de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="37550-135">O <xref:System.Type> associado com um tipo específico de objeto pode ser obtido das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="37550-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="37550-136">A instância <xref:System.Object.GetType%2A?displayProperty=nameWithType> método retorna um <xref:System.Type> objeto que representa o tipo de uma instância.</span><span class="sxs-lookup"><span data-stu-id="37550-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="37550-137">Como todos os tipos gerenciados derivam <xref:System.Object>, o <xref:System.Object.GetType%2A> método pode ser chamado em uma instância de qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="37550-138">A exemplo a seguir chama o <xref:System.Object.GetType%2A?displayProperty=nameWithType> método para determinar o tipo de tempo de execução de cada objeto em uma matriz de objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="37550-139">Estático <xref:System.Type.GetType%2A?displayProperty=nameWithType> métodos retornam um <xref:System.Type> objeto que representa um tipo especificado pelo seu nome totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="37550-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="37550-140">O <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> métodos retornam `Type` objetos que representam os tipos definidos em um módulo.</span><span class="sxs-lookup"><span data-stu-id="37550-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="37550-141">O primeiro método pode ser usado para obter uma matriz de <xref:System.Type> objetos para todos os tipos de públicos e privados definidos em um módulo.</span><span class="sxs-lookup"><span data-stu-id="37550-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="37550-142">(Você pode obter uma instância do `Module` por meio de <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> método, ou por meio o <xref:System.Type.Module%2A?displayProperty=nameWithType> propriedade.)</span><span class="sxs-lookup"><span data-stu-id="37550-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="37550-143">O <xref:System.Reflection.Assembly?displayProperty=nameWithType> objeto contém uma série de métodos para recuperar as classes definidas em um assembly, incluindo <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="37550-144">O <xref:System.Type.FindInterfaces%2A> método retorna uma lista filtrada de tipos de interface com suporte por um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="37550-145">O <xref:System.Type.GetElementType%2A> método retorna um `Type` objeto que representa o elemento.</span><span class="sxs-lookup"><span data-stu-id="37550-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="37550-146">O <xref:System.Type.GetInterfaces%2A> e <xref:System.Type.GetInterface%2A> métodos retornam <xref:System.Type> objetos que representam os tipos de interface com suporte por um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="37550-147">O <xref:System.Type.GetTypeArray%2A> método retorna uma matriz de <xref:System.Type> objetos que representam os tipos especificados por um conjunto arbitrário de objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="37550-148">Os objetos são especificados com uma matriz do tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="37550-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="37550-149">O <xref:System.Type.GetTypeFromProgID%2A> e <xref:System.Type.GetTypeFromCLSID%2A> métodos são fornecidos para a interoperabilidade COM.</span><span class="sxs-lookup"><span data-stu-id="37550-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="37550-150">Elas retornam um <xref:System.Type> objeto que representa o tipo especificado por um `ProgID` ou `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="37550-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="37550-151">O <xref:System.Type.GetTypeFromHandle%2A> método é fornecido para fins de interoperabilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="37550-152">Ele retorna um `Type` objeto que representa o tipo especificado por um identificador de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="37550-153">O c# `typeof` operador, o C++ `typeid` operador e o Visual Basic `GetType` operador obter a `Type` objeto para um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="37550-154">O <xref:System.Type.MakeGenericType%2A> método retorna um <xref:System.Type> objeto que representa um tipo genérico construído, o que é um tipo construído aberto se seus <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, e um tipo construído caso contrário.</span><span class="sxs-lookup"><span data-stu-id="37550-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="37550-155">Um tipo genérico pode ser instanciado somente se ele estiver fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="37550-156">O <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, e <xref:System.Type.MakeByRefType%2A> métodos retornam <xref:System.Type> objetos que representam, respectivamente, uma matriz de um tipo especificado, um ponteiro para um tipo especificado e o tipo de um parâmetro de referência (`ref` no c#, `ByRef`no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="37550-157">Comparando objetos de tipo de igualdade</span><span class="sxs-lookup"><span data-stu-id="37550-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="37550-158">Um <xref:System.Type> objeto que representa um tipo é exclusivo; ou seja, duas <xref:System.Type> referências de objeto se referem ao mesmo objeto se e somente se eles representarem o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="37550-159">Isso permite a comparação de <xref:System.Type> objetos usando a igualdade de referência.</span><span class="sxs-lookup"><span data-stu-id="37550-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="37550-160">O exemplo a seguir compara o <xref:System.Type> objetos que representam um número de valores inteiros para determinar se eles são do mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="37550-161">O exemplo a seguir mostra alguns recursos representativos de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="37550-162">O c# `typeof` operador (`GetType` operador no Visual Basic `typeid` operador no Visual C++) é usado para obter uma <xref:System.Type> objeto representando <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="37550-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="37550-163">Neste <xref:System.Type> objeto, o <xref:System.Type.GetMethod%2A> método é usado para obter uma <xref:System.Reflection.MethodInfo> que representa o <xref:System.String.Substring%2A> sobrecarga que utiliza um local inicial e um comprimento.</span><span class="sxs-lookup"><span data-stu-id="37550-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="37550-164">Para identificar a assinatura de sobrecarga, o exemplo de código cria uma matriz temporária que contém duas <xref:System.Type> objetos que representam `int` (`Integer` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-165">Para ser preciso, a matriz contém duas referências à instância do <xref:System.Type> que representa `int` no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="37550-166">Para qualquer tipo, há apenas uma instância de <xref:System.Type> por domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="37550-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="37550-167">O exemplo de código usa o <xref:System.Reflection.MethodInfo> para invocar o <xref:System.String.Substring%2A> método na cadeia de caracteres "Olá, mundo!" e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="37550-168">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="37550-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="37550-169">Ao herdar da <see langword="Type" />, você deve substituir os seguintes membros:</span><span class="sxs-lookup"><span data-stu-id="37550-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="37550-170">Exibindo informações de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-171">Inicializa uma nova instância da classe <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-172">Este construtor é chamado por classes derivadas durante a construção de objetos do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-173">Obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo é declarado.</span><span class="sxs-lookup"><span data-stu-id="37550-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="37550-174">Para tipos genéricos, obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo genérico é definido.</span><span class="sxs-lookup"><span data-stu-id="37550-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="37550-175">Uma instância de <see cref="T:System.Reflection.Assembly" /> que descreve o assembly que contém o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="37550-176">Para tipos genéricos, a instância descreve o assembly que contém a definição de tipo genérico, não o assembly que cria e usa um tipo construído específico.</span><span class="sxs-lookup"><span data-stu-id="37550-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-177">Se o atual <xref:System.Type> objeto representa um tipo genérico construído, essa propriedade retorna o assembly que contém a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="37550-178">Por exemplo, suponha que você cria um assembly denominado MyGenerics.dll que contém a definição de tipo genérico `MyGenericStack<T>` (`MyGenericStack(Of T)` no Visual Basic, `generic<T> ref class MyGenericStack` em C++).</span><span class="sxs-lookup"><span data-stu-id="37550-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="37550-179">Se você criar uma instância do `MyGenericStack<int>` (`MyGenericStack(Of Integer)` no Visual Basic) em outro assembly, o <xref:System.Type.Assembly%2A> propriedade para o tipo construído retorna um <xref:System.Reflection.Assembly> objeto que representa o MyGenerics.dll.</span><span class="sxs-lookup"><span data-stu-id="37550-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="37550-180">Da mesma forma, se o atual <xref:System.Type> objeto representa um parâmetro genérico não atribuído `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="37550-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="37550-181">Se o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade não está disponível em uma implementação específica do .NET, como .NET Core ou a plataforma Universal do Windows, use o <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriedade em vez disso.</span><span class="sxs-lookup"><span data-stu-id="37550-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="37550-182">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-183">O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-184">Obtém o nome do tipo qualificado pelo assembly, que inclui o nome do assembly do qual este objeto <see cref="T:System.Type" /> foi carregado.</span><span class="sxs-lookup"><span data-stu-id="37550-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="37550-185">O nome qualificado pelo assembly do <see cref="T:System.Type" />, que inclui o nome do assembly do qual o <see cref="T:System.Type" /> foi carregado, ou <see langword="null" /> se a instância atual representa um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-186">O nome qualificado pelo assembly de um tipo consiste do nome do tipo, incluindo o namespace, seguido por uma vírgula, seguida pelo nome de exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="37550-187">O nome de exibição de um assembly é obtido usando o <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-188">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="37550-189">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="37550-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="37550-190">No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="37550-191">Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37550-192">O nome simples de uma classe aninhada da emissão de todos os compiladores que dão suporte a common language runtime e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="37550-193">Delimitador</span><span class="sxs-lookup"><span data-stu-id="37550-193">Delimiter</span></span>|<span data-ttu-id="37550-194">Significado</span><span class="sxs-lookup"><span data-stu-id="37550-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="37550-195">Barra invertida (\\)</span><span class="sxs-lookup"><span data-stu-id="37550-195">Backslash (\\)</span></span>|<span data-ttu-id="37550-196">Caractere de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-196">Escape character.</span></span>|  
|<span data-ttu-id="37550-197">Vírgula (,)</span><span class="sxs-lookup"><span data-stu-id="37550-197">Comma (,)</span></span>|<span data-ttu-id="37550-198">Precede o nome Assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="37550-199">Sinal de adição (+)</span><span class="sxs-lookup"><span data-stu-id="37550-199">Plus sign (+)</span></span>|<span data-ttu-id="37550-200">Precede uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="37550-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="37550-201">Ponto final (.)</span><span class="sxs-lookup"><span data-stu-id="37550-201">Period (.)</span></span>|<span data-ttu-id="37550-202">Denota identificadores de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="37550-203">Colchetes ([])</span><span class="sxs-lookup"><span data-stu-id="37550-203">Brackets ([])</span></span>|<span data-ttu-id="37550-204">Depois de um nome de tipo, indica uma matriz desse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="37550-205">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-205">-or-</span></span><br /><br /> <span data-ttu-id="37550-206">Para um tipo genérico, inclui a lista de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="37550-207">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-207">-or-</span></span><br /><br /> <span data-ttu-id="37550-208">Dentro de uma lista de argumentos de tipo, inclui um tipo qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="37550-209">Por exemplo, o nome qualificado do assembly para uma classe pode ser assim:</span><span class="sxs-lookup"><span data-stu-id="37550-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="37550-210">Se o namespace contivesse um sinal de adição, por exemplo, TopNamespace.Sub+Namespace, então, no sinal de adição (+) deve ser precedido por um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="37550-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="37550-211">Seria a emissão de reflexão essa cadeia de caracteres da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="37550-212">Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".</span><span class="sxs-lookup"><span data-stu-id="37550-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="37550-213">Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="37550-214">Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="37550-215"><xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System.</span><span class="sxs-lookup"><span data-stu-id="37550-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="37550-216"><xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="37550-217">Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="37550-218">Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="37550-219">Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="37550-220">No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="37550-221">Argumentos genéricos de tipos genéricos são as próprias qualificado pelo nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="37550-222">Por exemplo, no nome de tipo qualificado pelo assembly `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic), `int` é expandido para o nome de tipo qualificado pelo assembly <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="37550-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="37550-223">Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-224">O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="37550-225">O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-226">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-227">Obtém os atributos associados ao <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-228">Um objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa o conjunto de atributos do <see cref="T:System.Type" />, a menos que <see cref="T:System.Type" /> represente um parâmetro de tipo genérico; nesse caso, o valor não é especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-229">Alguns membros o <xref:System.Reflection.TypeAttributes> enumeração são máscaras que representam um grupo de valores.</span><span class="sxs-lookup"><span data-stu-id="37550-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="37550-230">Cada grupo inclui um membro cujo valor subjacente for zero.</span><span class="sxs-lookup"><span data-stu-id="37550-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="37550-231">Por exemplo, o valor subjacente do <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membro na <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupo for zero, como é o <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membro no <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupo.</span><span class="sxs-lookup"><span data-stu-id="37550-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="37550-232">Por isso, você deve usar a máscara antes de testar para obter esses valores.</span><span class="sxs-lookup"><span data-stu-id="37550-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="37550-233">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="37550-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="37550-234">Para a maioria das finalidades, as propriedades como <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, e <xref:System.Type.IsSpecialName%2A> são mais fáceis de usar do que os atributos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="37550-235">Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna os atributos da definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="37550-236">Por exemplo, os atributos retornados para `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic) são os atributos do `MyGenericClass<T>` (`MyGenericClass(Of T)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-237">Se o atual <xref:System.Type> representa um parâmetro de tipo genérico - ou seja, se o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` : a <xref:System.Reflection.TypeAttributes> valor retornado por essa propriedade não for especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-238">A seguir usa de exemplo os <xref:System.Type.Attributes%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-238">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-239">Obtém o tipo do qual o <see cref="T:System.Type" /> atual é herdado diretamente.</span><span class="sxs-lookup"><span data-stu-id="37550-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="37550-240">O <see cref="T:System.Type" /> do qual o <see cref="T:System.Type" /> atual é herdado diretamente ou <see langword="null" /> se o <see langword="Type" /> atual representar a classe <see cref="T:System.Object" /> ou uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-241">O tipo base é o tipo do qual o tipo atual herda diretamente.</span><span class="sxs-lookup"><span data-stu-id="37550-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="37550-242"><xref:System.Object> é o único tipo que não tem um tipo base, portanto `null` é retornado como o tipo base do <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="37550-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="37550-243">Interfaces de herdam de interfaces de base zero ou mais; Portanto, essa propriedade retornará `null` se o `Type` objeto representa uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="37550-244">As interfaces base podem ser determinadas com <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="37550-245">Se o atual <xref:System.Type> representa um tipo genérico construído, o tipo base reflete os argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="37550-246">Por exemplo, considere as declarações a seguir:</span><span class="sxs-lookup"><span data-stu-id="37550-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="37550-247">Para o tipo construído `C<int>` (`C(Of Integer)` no Visual Basic), o <xref:System.Type.BaseType%2A> propriedade retorna `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="37550-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="37550-248">Se o atual <xref:System.Type> representa um parâmetro de tipo de uma definição de tipo genérico, <xref:System.Type.BaseType%2A> retorna a restrição de classe, ou seja, a classe que o parâmetro de tipo deve herdar.</span><span class="sxs-lookup"><span data-stu-id="37550-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="37550-249">Se não houver nenhuma restrição de classe <xref:System.Type.BaseType%2A> retorna <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37550-250">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-251">O exemplo a seguir demonstra como usar o <xref:System.Type.BaseType%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="37550-252">O exemplo a seguir usa a recursão para listar a hierarquia completa de herança de cada classe encontrado em um assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="37550-253">O exemplo define uma classe chamada `C` que deriva de uma classe chamada `B`, que, por sua vez, deriva uma classe chamada `A`.</span><span class="sxs-lookup"><span data-stu-id="37550-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-254">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-255">Obtém um valor que indica se o objeto <see cref="T:System.Type" /> atual tem parâmetros de tipo que não foram substituídos por tipos específicos.</span><span class="sxs-lookup"><span data-stu-id="37550-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="37550-256"><see langword="true" /> se o <see cref="T:System.Type" /> objeto é um parâmetro de tipo genérico ou tem parâmetros de tipo para os quais tipos específicos não foram fornecidos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-257">Para criar uma instância de um tipo, não deve haver definições de tipo genérico ou tipos construídos abertos nos argumentos de tipo do tipo em si, em quaisquer tipos genéricos ou em todos os elementos do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="37550-258">Outra maneira de dizer isso é que, quando examinada recursivamente, o tipo não deve conter nenhum parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="37550-259">Como tipos podem ser arbitrariamente complexos, é difícil tomar essa decisão.</span><span class="sxs-lookup"><span data-stu-id="37550-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="37550-260">Para conveniência e para reduzir a chance de erro, o <xref:System.Type.ContainsGenericParameters%2A> propriedade fornece uma maneira padrão para distinguir entre tipos construídos fechados, que podem ser instanciados e aberta construído tipos, que não é possível.</span><span class="sxs-lookup"><span data-stu-id="37550-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="37550-261">Se o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, o tipo não pode ser instanciado.</span><span class="sxs-lookup"><span data-stu-id="37550-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="37550-262">O <xref:System.Type.ContainsGenericParameters%2A> propriedade pesquisa recursivamente para parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="37550-263">Por exemplo, ele retorna `true` para uma matriz cujos elementos são o tipo `A<T>` (`A(Of T)` no Visual Basic), mesmo que a matriz não é em si genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="37550-264">Compare isso com o comportamento do <xref:System.Type.IsGenericType%2A> propriedade, que retorna `false` para matrizes.</span><span class="sxs-lookup"><span data-stu-id="37550-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="37550-265">Para um conjunto de classes de exemplo e uma tabela que mostra os valores de <xref:System.Type.ContainsGenericParameters%2A> propriedade, consulte <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-266">O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e, em seguida, define uma segunda classe genérica que deriva de primeira classe.</span><span class="sxs-lookup"><span data-stu-id="37550-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="37550-267">Classe base a classe derivada da tem dois argumentos de tipo: o primeiro é <xref:System.Int32> e o segundo é um parâmetro de tipo do tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="37550-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="37550-268">O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-269">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-270">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-271">Obtém um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo, se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="37550-272">Se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico, um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-273">O método declarativo é uma definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="37550-274">Ou seja, se <xref:System.Type.DeclaringMethod%2A> não retorna `null`, em seguida, `DeclaringMethod.IsGenericMethodDefinition` retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="37550-275">O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico no qual o parâmetro de tipo genérico foi originalmente definido:</span><span class="sxs-lookup"><span data-stu-id="37550-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="37550-276">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="37550-277">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.</span><span class="sxs-lookup"><span data-stu-id="37550-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="37550-278">Introdução a <xref:System.Type.DeclaringMethod%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="37550-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="37550-279">O <xref:System.Reflection.MethodBase> que é retornado pela <xref:System.Type.DeclaringMethod%2A> propriedade é um <xref:System.Reflection.MethodInfo> no caso de um método genérico, ou um <xref:System.Reflection.ConstructorInfo> no caso de um construtor genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-280">No .NET Framework versão 2.0, não há suporte para construtores genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="37550-281">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-282">O exemplo de código a seguir define uma classe que tem um método genérico, atribui um argumento de tipo para o método e invoca o método genérico construído resultante.</span><span class="sxs-lookup"><span data-stu-id="37550-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="37550-283">Ele também exibe informações sobre a definição de método genérico e o método construído.</span><span class="sxs-lookup"><span data-stu-id="37550-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="37550-284">Ao exibir informações sobre os parâmetros de tipo da definição de método genérico, na `DisplayGenericMethodInfo` método, o código de exemplo mostra o valor da <xref:System.Type.DeclaringMethod%2A> propriedade para o parâmetro de tipo genérico do método.</span><span class="sxs-lookup"><span data-stu-id="37550-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-285">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-286">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-287">Obtém o tipo que declara o tipo aninhado atual ou o parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="37550-288">Um objeto <see cref="T:System.Type" /> que representará o tipo de delimitador se o tipo atual for um tipo aninhado, a definição de tipo genérico se o tipo atual for um parâmetro de tipo de um tipo genérico ou o tipo que declara o método genérico se o tipo atual for um parâmetro de tipo de um método genérico. Caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-289">Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico, essa propriedade retorna a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="37550-290">Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um método genérico, essa propriedade retorna o tipo que contém a definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="37550-291">Se o tipo for genérico, definição de tipo genérico é retornada.</span><span class="sxs-lookup"><span data-stu-id="37550-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="37550-292">Ou seja, o código a seguir retorna a definição de tipo genérico de <xref:System.Collections.Generic.List%601> classe genérica, que contém o <xref:System.Collections.Generic.List%601.ConvertAll%2A> método genérico:</span><span class="sxs-lookup"><span data-stu-id="37550-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="37550-293">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, o <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico em que o parâmetro de tipo genérico foi originalmente definido:</span><span class="sxs-lookup"><span data-stu-id="37550-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="37550-294">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="37550-295">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.</span><span class="sxs-lookup"><span data-stu-id="37550-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="37550-296">Introdução a <xref:System.Type.DeclaringType%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="37550-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-297">Este exemplo exibe o tipo de declaração de um método em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-298">Obtém uma referência ao associador padrão, que implementa regras internas para selecionar os membros adequados a serem chamados por <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="37550-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="37550-299">Uma referência ao associador padrão usado pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="37550-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-300">O associador padrão fornecido com o common language runtime é aplicável em todas, exceto as circunstâncias mais especializadas.</span><span class="sxs-lookup"><span data-stu-id="37550-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="37550-301">Se você precisar de um associador que segue as regras que diferem do associador padrão fornecido, definem um tipo derivado do <xref:System.Reflection.Binder> de classe e passar uma instância desse tipo usando o `binder` parâmetro de um do <xref:System.Type.InvokeMember%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="37550-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="37550-302">Reflexão modela as regras de acessibilidade do common type system.</span><span class="sxs-lookup"><span data-stu-id="37550-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="37550-303">Por exemplo, se o chamador estiver no mesmo assembly, o chamador não precisar permissões especiais para membros internos.</span><span class="sxs-lookup"><span data-stu-id="37550-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="37550-304">Caso contrário, o chamador precisa <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="37550-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="37550-305">Isso é consistente com a pesquisa de membros que são protegidas, privadas e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="37550-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="37550-306">O princípio geral é que <xref:System.Reflection.Binder.ChangeType%2A> deve executar somente conversões, que nunca perdem dados de ampliação.</span><span class="sxs-lookup"><span data-stu-id="37550-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="37550-307">Um exemplo de uma conversão de ampliação está convertendo um valor que é um inteiro com sinal de 32 bits para um valor que é um inteiro com sinal de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="37550-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="37550-308">Isso é diferenciado de uma conversão de estreitamento, que poderá perder dados.</span><span class="sxs-lookup"><span data-stu-id="37550-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="37550-309">Um exemplo de uma conversão redutora é converter um inteiro com sinal de 64 bits em um inteiro com sinal de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="37550-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="37550-310">A tabela a seguir lista as conversões com suporte pelo associador de padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="37550-311">Tipo de fonte</span><span class="sxs-lookup"><span data-stu-id="37550-311">Source Type</span></span>|<span data-ttu-id="37550-312">Tipo de destino</span><span class="sxs-lookup"><span data-stu-id="37550-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="37550-313">Qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="37550-313">Any type</span></span>|<span data-ttu-id="37550-314">Seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="37550-314">Its base type.</span></span>|  
|<span data-ttu-id="37550-315">Qualquer tipo</span><span class="sxs-lookup"><span data-stu-id="37550-315">Any type</span></span>|<span data-ttu-id="37550-316">A interface que ele implementa.</span><span class="sxs-lookup"><span data-stu-id="37550-316">The interface it implements.</span></span>|  
|<span data-ttu-id="37550-317">Char</span><span class="sxs-lookup"><span data-stu-id="37550-317">Char</span></span>|<span data-ttu-id="37550-318">Unt16, UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-319">Byte</span><span class="sxs-lookup"><span data-stu-id="37550-319">Byte</span></span>|<span data-ttu-id="37550-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-321">SByte</span><span class="sxs-lookup"><span data-stu-id="37550-321">SByte</span></span>|<span data-ttu-id="37550-322">Int16, Int32, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="37550-323">UInt16</span></span>|<span data-ttu-id="37550-324">UInt32, Int32, UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-325">Int16</span><span class="sxs-lookup"><span data-stu-id="37550-325">Int16</span></span>|<span data-ttu-id="37550-326">Int32, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="37550-327">UInt32</span></span>|<span data-ttu-id="37550-328">UInt64, Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-329">Int32</span><span class="sxs-lookup"><span data-stu-id="37550-329">Int32</span></span>|<span data-ttu-id="37550-330">Int64, Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="37550-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="37550-331">UInt64</span></span>|<span data-ttu-id="37550-332">Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-332">Single, Double</span></span>|  
|<span data-ttu-id="37550-333">Int64</span><span class="sxs-lookup"><span data-stu-id="37550-333">Int64</span></span>|<span data-ttu-id="37550-334">Single e Double</span><span class="sxs-lookup"><span data-stu-id="37550-334">Single, Double</span></span>|  
|<span data-ttu-id="37550-335">Simples</span><span class="sxs-lookup"><span data-stu-id="37550-335">Single</span></span>|<span data-ttu-id="37550-336">Duplo</span><span class="sxs-lookup"><span data-stu-id="37550-336">Double</span></span>|  
|<span data-ttu-id="37550-337">Não referência</span><span class="sxs-lookup"><span data-stu-id="37550-337">Non-reference</span></span>|<span data-ttu-id="37550-338">Por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="37550-339">O exemplo a seguir obtém o associador padrão a `DefaultBinder` propriedade e invoca um membro de MyClass, passando a `DefaultBinder` valor como um parâmetro para <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-340">Separa nomes no namespace de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="37550-341">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-342">Representa uma matriz vazia do tipo <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="37550-343">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37550-344">O seguinte exemplo de código mostra a `EmptyTypes` campo usado em uma da `GetConstructor` métodos para obter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-345">Determina se o tipo de sistema subjacente do <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Object" /> ou <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="37550-346">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="37550-347">Para que a comparação seja bem-sucedida, <paramref name="o" /> deve ser capaz de ser convertido em um objeto do tipo <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="37550-348">Determina se o tipo de sistema subjacente do objeto <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Object" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="37550-349"><see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="37550-350">Esse método sempre retorna <see langword="false" /> se: .</span><span class="sxs-lookup"><span data-stu-id="37550-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="37550-351">
-   <paramref name="o" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="37550-352">
-   <paramref name="o" /> não pode ser convertido em um objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-353">Este método substitui <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37550-354">Ele projeta `o` a um objeto do tipo <xref:System.Type> e chama o <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="37550-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-355">O exemplo a seguir usa <xref:System.Type.Equals%28System.Object%29> para comparar vários <xref:System.Type> objeto instâncias com vários <xref:System.Object> instâncias.</span><span class="sxs-lookup"><span data-stu-id="37550-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="37550-356">Duas coisas são particularmente vale a pena observar sobre o exemplo:</span><span class="sxs-lookup"><span data-stu-id="37550-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="37550-357">A comparação de um <xref:System.Type> objeto que representa um inteiro com um <xref:System.Reflection.TypeInfo> objeto que representa um inteiro de retorno `true` porque <xref:System.Reflection.TypeInfo> é derivado de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="37550-358">A comparação de um <xref:System.Type> objeto que representa uma <xref:System.Collections.Generic.IList%601> objeto (um tipo genérico aberto) com um `List(Of String)` retorna o objeto (um tipo genérico fechado) `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="37550-359">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="37550-360">Determina se o tipo de sistema subjacente do <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-361"><see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37550-362">O exemplo a seguir usa `Equals` para comparar dois tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-363">Representa o filtro de membro usado em atributos.</span><span class="sxs-lookup"><span data-stu-id="37550-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="37550-364">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-365">Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="37550-366">O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="37550-367">O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="37550-368">O `Object` pode ser atribuído o valor de qualquer um dos campos nas classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="37550-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="37550-369">Por exemplo, o `Object` pode ser atribuído o valor de um campo de `FieldAttributes` como público.</span><span class="sxs-lookup"><span data-stu-id="37550-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="37550-370">Nesse caso, quando o `FilterAttribute` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto é decorado com o atributo de campo público nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-371">O exemplo a seguir obtém a `FilterAttribute` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os membros especificados e seus atributos.</span><span class="sxs-lookup"><span data-stu-id="37550-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-372">Representa o filtro de membro, que diferencia maiúsculas de minúsculas, usado nos nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="37550-373">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-374">Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="37550-375">O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="37550-376">O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="37550-377">O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "\*" caractere curinga.</span><span class="sxs-lookup"><span data-stu-id="37550-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="37550-378">Correspondência de cadeia de caracteres de final de curinga só tem suporte.</span><span class="sxs-lookup"><span data-stu-id="37550-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="37550-379">Por exemplo, o `Object` pode ser atribuído o valor de "Byte \*".</span><span class="sxs-lookup"><span data-stu-id="37550-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="37550-380">Nesse caso, quando o `FilterName` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "Byte".</span><span class="sxs-lookup"><span data-stu-id="37550-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-381">O exemplo de código a seguir obtém os métodos associados definido pelo usuário `Application` tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-382">Representa o filtro de membro, que não diferencia maiúsculas de minúsculas, usado nos nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="37550-383">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-384">Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="37550-385">O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="37550-386">O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`.</span><span class="sxs-lookup"><span data-stu-id="37550-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="37550-387">O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "\*" caractere curinga.</span><span class="sxs-lookup"><span data-stu-id="37550-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="37550-388">Correspondência de cadeia de caracteres de final de curinga só tem suporte.</span><span class="sxs-lookup"><span data-stu-id="37550-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="37550-389">Por exemplo, o `Object` pode ser atribuído o valor de "ByTe \*".</span><span class="sxs-lookup"><span data-stu-id="37550-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="37550-390">Nesse caso, quando o `FilterName` delegado é invocado, ele retornará true somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "byte", ignorando maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-391">O exemplo a seguir obtém a `MemberFilter` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os métodos e seus atributos do `String` classe que começam com a letra "c", desconsiderando o caso.</span><span class="sxs-lookup"><span data-stu-id="37550-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="37550-392">O delegado que compara as interfaces com <paramref name="filterCriteria" />.</span><span class="sxs-lookup"><span data-stu-id="37550-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="37550-393">Os critérios de pesquisa que determinam se uma interface deve ser incluída na matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="37550-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="37550-394">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representa uma lista filtrada das interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-395">Uma matriz de objetos <see cref="T:System.Type" /> que representam uma lista filtrada das interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual ou uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhuma interface correspondente ao filtro estiver implementada ou for herdada pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-396">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-397">O <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> e <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegados fornecidos pelo <xref:System.Reflection.Module?displayProperty=nameWithType> classe também pode ser usada, substitui o <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegar.</span><span class="sxs-lookup"><span data-stu-id="37550-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="37550-398">Todas as interfaces implementadas por esta classe são consideradas durante a pesquisa se declaradas por essa classe em si ou uma classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="37550-399">Esse método pesquisará a hierarquia de classe base, retornando cada uma das interfaces correspondentes que cada classe implemente, bem como todas as correspondentes interfaces de cada uma implementa essas interfaces (ou seja, o fechamento transitivo de interfaces de correspondência é retornado).</span><span class="sxs-lookup"><span data-stu-id="37550-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="37550-400">Interfaces não duplicado será retornado.</span><span class="sxs-lookup"><span data-stu-id="37550-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="37550-401">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, <xref:System.Type.FindInterfaces%2A> pesquisas de todas as interfaces declaradas dentro das restrições no parâmetro de tipo, e todas as interfaces herdadas por meio de interfaces declarado dentro das restrições.</span><span class="sxs-lookup"><span data-stu-id="37550-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="37550-402">Se o atual <xref:System.Type> representa um argumento de tipo de um tipo genérico, <xref:System.Type.FindInterfaces%2A> pesquisará todas as interfaces implementadas pelo tipo, se eles corresponderem às restrições.</span><span class="sxs-lookup"><span data-stu-id="37550-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-403"><xref:System.Type.FindInterfaces%2A> pode retornar as interfaces genéricas, mesmo em tipos não genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="37550-404">Por exemplo, um tipo não genérico pode implementar `IEnumerable<int>` (`IEnumerable(Of Integer)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-405">O exemplo a seguir localiza a interface especificada implementada ou herdada pelo tipo especificado e, em seguida, exibe os nomes de interface.</span><span class="sxs-lookup"><span data-stu-id="37550-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-406"><paramref name="filter" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-407">Um inicializador estático é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="37550-408">Um objeto que indica o tipo de membro a ser pesquisado.</span><span class="sxs-lookup"><span data-stu-id="37550-408">An object that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-409">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-409">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-410">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-410">-or-</span></span> 
<span data-ttu-id="37550-411">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-411">Zero, to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="37550-412">O delegado que faz as comparações, retornando <see langword="true" /> se o membro inspecionado no momento corresponder ao <paramref name="filterCriteria" />. Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span> <span data-ttu-id="37550-413">Use os delegados <see langword="FilterAttribute" />, <see langword="FilterName" /> e <see langword="FilterNameIgnoreCase" /> fornecidos por essa classe.</span><span class="sxs-lookup"><span data-stu-id="37550-413">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span></span> <span data-ttu-id="37550-414">O primeiro usa os campos <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> como critérios de pesquisa e os outros dois delegados usam objetos <see langword="String" /> como critérios de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-414">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="37550-415">Os critérios de pesquisa que determinam se um membro é retornado na matriz de objetos <see langword="MemberInfo" />.</span><span class="sxs-lookup"><span data-stu-id="37550-415">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="37550-416">Os campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> podem ser usados em conjunto com o delegado <see langword="FilterAttribute" /> fornecido por essa classe.</span><span class="sxs-lookup"><span data-stu-id="37550-416">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="37550-417">Retorna uma matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> do tipo do membro especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-417">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="37550-418">Uma matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> do tipo de membro especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-418">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="37550-419">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-419">-or-</span></span> 
<span data-ttu-id="37550-420">Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros do tipo <paramref name="memberType" /> que correspondem aos critérios de filtro.</span><span class="sxs-lookup"><span data-stu-id="37550-420">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-421">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-421">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-422">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-422">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-423">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-423">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-424">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-424">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-425">Especifique `BindingFlags.Instance` para incluir membros de instância na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-425">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="37550-426">Especifique `BindingFlags.Static` para incluir membros estáticos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-426">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="37550-427">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-427">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-428">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-428">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="37550-429">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-429">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-430">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-430">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-431">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-431">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-432">Os valores válidos para <xref:System.Type.MemberType%2A> são definidos em <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="37550-432">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="37550-433">Se nenhum desses membros forem encontrados, uma matriz vazia será retornada.</span><span class="sxs-lookup"><span data-stu-id="37550-433">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="37550-434">Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-434">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-435">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-435">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-436">Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico ou método genérico, <xref:System.Type.FindMembers%2A> processa todos os membros declarados pela restrição de classe e as restrições de interface do parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-436">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-437">O exemplo a seguir localiza todos os membros em uma classe que correspondem aos critérios de pesquisa especificados e, em seguida, exibe os membros correspondentes.</span><span class="sxs-lookup"><span data-stu-id="37550-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-438"><paramref name="filter" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-439">Obtém o nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="37550-440">O nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly; ou <see langword="null" />, se a instância atual representar um parâmetro de tipo genérico, um tipo de matriz, um tipo de ponteiro ou um tipo <see langword="byref" /> baseado em um parâmetro de tipo, ou um tipo genérico que não é uma definição de tipo genérica, mas que contém parâmetros de tipo não resolvidos.</span><span class="sxs-lookup"><span data-stu-id="37550-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-441">Por exemplo, o nome totalmente qualificado do <xref:System.String> é do tipo `System.String`.</span><span class="sxs-lookup"><span data-stu-id="37550-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="37550-442">Compare isso com o nome qualificado pelo assembly retornado pelo <xref:System.Type.AssemblyQualifiedName%2A> propriedade, que consiste o nome completo e o nome completo do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="37550-443">Se o tipo atual representa um tipo genérico fechado, os argumentos de tipo na cadeia de caracteres retornada pelo <xref:System.Type.FullName%2A> propriedade são qualificados por seu nome completo do assembly, mesmo que a representação de cadeia de caracteres do tipo genérico em si não está qualificada pelo seu completo nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="37550-444">O exemplo a seguir ilustra a diferença na propriedade FullName para um tipo que representa a definição de tipo genérico e um que representa um tipo genérico fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="37550-445">Essa propriedade retorna `null` se:</span><span class="sxs-lookup"><span data-stu-id="37550-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="37550-446">Atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="37550-447">O exemplo a seguir recupera o parâmetro de tipo de <xref:System.Nullable%601> tipo e tenta exibir seu <xref:System.Type.FullName%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="37550-448">O atual <xref:System.Type> objeto representa um tipo de matriz, um tipo de ponteiro ou um `byref` tipo com base em um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="37550-449">O exemplo a seguir define um tipo genérico, `Generictype1<T>`, com três métodos: `Display(T[])`, que é passado a uma matriz do tipo T; `HandleT(T)`, que é passado um objeto T; e `ChangeValue(ref T)`, que é passado um objeto T por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="37550-450">Como c# e Visual Basic não permitem definir T como um ponteiro na `HandleT` método, precisamos chamar o <xref:System.Type.MakePointerType%2A> método no <xref:System.Type> objeto que representa o tipo de parâmetro do método para criar um ponteiro para um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="37550-451">A saída do exemplo mostra que em todos os três casos, o <xref:System.Type.FullName%2A> é de propriedade `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="37550-452">O tipo atual contém parâmetros de tipo genérico que não foram substituídos por tipos específicos (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`), mas o tipo não é uma definição de tipo genérico (ou seja, o <xref:System.Type.IsGenericTypeDefinition%2A> retorna de propriedade `false`</span><span class="sxs-lookup"><span data-stu-id="37550-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="37550-453">No exemplo a seguir `Derived<T>` herda de `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="37550-454">O <xref:System.Type.BaseType%2A> propriedade obtém o <xref:System.Type> objeto que representa o tipo base `Derived<T>`e sua <xref:System.Type.FullName%2A> propriedade retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="37550-455">Para obter um <xref:System.Type.FullName%2A> que não é `null`, você pode usar o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter a definição de tipo genérico, como mostra o exemplo.</span><span class="sxs-lookup"><span data-stu-id="37550-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="37550-456">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-457">O exemplo a seguir exibe o nome completo do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="37550-458">O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-459">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-460">Obtém uma combinação de <see cref="T:System.Reflection.GenericParameterAttributes" /> sinalizadores que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="37550-461">Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-462">O valor dessa propriedade contém sinalizadores que descrevem se o parâmetro de tipo genérico atual é covariante e sinalizadores que descrevem a quaisquer restrições especiais.</span><span class="sxs-lookup"><span data-stu-id="37550-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="37550-463">Use o <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valor para selecionar os sinalizadores de covariância e, em seguida, use o <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valor para selecionar os sinalizadores de restrição.</span><span class="sxs-lookup"><span data-stu-id="37550-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="37550-464">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-465">O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo que têm diferentes restrições.</span><span class="sxs-lookup"><span data-stu-id="37550-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="37550-466">Quando o programa é executado, as restrições são examinadas por meio de <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-467">O objeto <see cref="T:System.Type" /> atual não é um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="37550-468">Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-469">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-470">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-471">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-472">Obtém a posição do parâmetro de tipo, na lista de parâmetros de tipo, do tipo genérico ou do método que declarou o parâmetro, quando o objeto <see cref="T:System.Type" /> representa um parâmetro de tipo de um tipo genérico ou método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="37550-473">A posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico ou método que define o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="37550-474">Números de posição começam em 0.</span><span class="sxs-lookup"><span data-stu-id="37550-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-475">O <xref:System.Type.GenericParameterPosition%2A> propriedade retorna a posição de um parâmetro de tipo na lista de parâmetros da definição de tipo genérico ou definição de método genérico, em que o parâmetro de tipo foi originalmente definido.</span><span class="sxs-lookup"><span data-stu-id="37550-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="37550-476">O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo ou método genérica:</span><span class="sxs-lookup"><span data-stu-id="37550-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="37550-477">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="37550-478">Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.</span><span class="sxs-lookup"><span data-stu-id="37550-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="37550-479">Para fornecer o contexto correto para o valor da <xref:System.Type.GenericParameterPosition%2A> propriedade, é necessário identificar o tipo ou método genérico pertence um parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="37550-480">Por exemplo, considere o valor de retorno do método genérico `GetSomething` no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="37550-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="37550-481">O tipo retornado por `GetSomething` depende dos argumentos de tipo fornecidos a classe `A` e, ao `GetSomething` em si.</span><span class="sxs-lookup"><span data-stu-id="37550-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="37550-482">Você pode obter um <xref:System.Reflection.MethodInfo> para `GetSomething`, e que você pode obter o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="37550-483">Quando você examina os parâmetros de tipo do tipo de retorno, <xref:System.Type.GenericParameterPosition%2A> retorna 0 para ambos.</span><span class="sxs-lookup"><span data-stu-id="37550-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="37550-484">A posição do `V` é 0 porque `V` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para a classe `A`.</span><span class="sxs-lookup"><span data-stu-id="37550-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="37550-485">A posição do `X` é 0 porque `X` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="37550-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-486">Chamar o <xref:System.Type.GenericParameterPosition%2A> propriedade faz com que uma exceção se o atual <xref:System.Type> não representa um parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="37550-487">Quando você examinar os argumentos de tipo de um tipo construído aberto, use o <xref:System.Type.IsGenericParameter%2A> propriedade dizer que são parâmetros de tipo e que são tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="37550-488">O <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para um parâmetro de tipo; em seguida, você pode usar o <xref:System.Type.GenericParameterPosition%2A> método obter sua posição e usar os <xref:System.Type.DeclaringMethod%2A> e <xref:System.Type.DeclaringType%2A> propriedades para determinar o método genérico ou definição que o define de tipo .</span><span class="sxs-lookup"><span data-stu-id="37550-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-489">O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e define uma segunda classe genérica que deriva de primeira classe.</span><span class="sxs-lookup"><span data-stu-id="37550-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="37550-490">Classe base a classe derivada da tem dois argumentos de tipo: o primeiro é <xref:System.Int32>, e o segundo é um parâmetro de tipo do tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="37550-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="37550-491">O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-492">O tipo atual não representa um parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="37550-493">Ou seja, <see cref="P:System.Type.IsGenericParameter" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-494">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-495">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-496">Obtém uma matriz dos argumentos de tipo genérico para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="37550-497">Uma matriz dos argumentos de tipo genérico para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-498">Essa propriedade obtém apenas os argumentos de tipo genérico; ou seja, os tipos que foram especificados para os parâmetros de tipo genérico do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="37550-499">Se o tipo atual é uma definição de tipo genérico, essa propriedade retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-500">Se um tipo genérico for usado em um método genérico ou em outro tipo genérico, alguns dos seus argumentos de tipo genérico podem ser parâmetros de tipo genérico do método ou tipo delimitador.</span><span class="sxs-lookup"><span data-stu-id="37550-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="37550-501">Para obter os parâmetros de tipo genérico de um tipo que representa uma definição de tipo genérico, use o <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="37550-502">Para obter um <xref:System.Reflection.TypeInfo> objeto atual <xref:System.Type> do objeto, use o <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> método de extensão.</span><span class="sxs-lookup"><span data-stu-id="37550-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-503">Obtém o número de dimensões em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="37550-504">Um inteiro que contém o número de dimensões no tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37550-505">O exemplo a seguir exibe o número de dimensões em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-506">Não há suporte para a funcionalidade desse método na classe base. Em vez disso, ela deve ser implementada em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-507">O tipo atual não é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-508">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.Attributes" /> e obtém um bitmask que indica os atributos associados com o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-509">Um objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa o conjunto de atributos do <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-510">Obtém um construtor específico do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="37550-511">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor desejado.</span><span class="sxs-lookup"><span data-stu-id="37550-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="37550-512">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-512">-or-</span></span> 
<span data-ttu-id="37550-513">Uma matriz vazia de objetos <see cref="T:System.Type" />, para obter um construtor que não aceita parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="37550-514">Tal matriz vazia é fornecida pelo campo <see langword="static" /> de <see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="37550-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="37550-515">Pesquisa um construtor de instância pública cujos parâmetros correspondem aos tipos na matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="37550-516">Um objeto que representa o construtor de instância pública cujos parâmetros correspondem aos tipos na matriz de tipos de parâmetro, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-517">Essa sobrecarga de método procura por construtores de instância pública e não pode ser usada para obter um inicializador de classe (. cctor).</span><span class="sxs-lookup"><span data-stu-id="37550-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="37550-518">Para obter um inicializador de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-519">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-520">Se o construtor solicitado é não público, esse método retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-521">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-522">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-523">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-524">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-525">O exemplo a seguir obtém o tipo de `MyClass`, obtém o <xref:System.Reflection.ConstructorInfo> de objeto e exibe a assinatura do construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-526"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-527">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-527">-or-</span></span> 
<span data-ttu-id="37550-528">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-529"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-530">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-531">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-531">-or-</span></span> 
<span data-ttu-id="37550-532">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-532">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-533">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-534">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-534">-or-</span></span> 
<span data-ttu-id="37550-535">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="37550-536">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.</span><span class="sxs-lookup"><span data-stu-id="37550-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="37550-537">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-537">-or-</span></span> 
<span data-ttu-id="37550-538">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="37550-539">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-539">-or-</span></span> 
 <span data-ttu-id="37550-540"><see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="37550-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-541">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz de tipo de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="37550-542">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-543">Pesquisa o construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-544">Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor que corresponde aos requisitos especificados, se encontrados, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-545">Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="37550-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="37550-546">Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.</span><span class="sxs-lookup"><span data-stu-id="37550-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="37550-547">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-548">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-549">Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="37550-550">Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="37550-551">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-552">Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-552">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-553">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-554">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-555">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-556">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-557">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-558">O programa a seguir obtém o tipo de `MyClass1` classe, obtém o <xref:System.Reflection.ConstructorInfo> os sinalizadores de associação especificadas de correspondência de objeto e exibe a assinatura do construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-559"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-560">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-560">-or-</span></span> 
<span data-ttu-id="37550-561">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-562"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-563">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-563">-or-</span></span> 
 <span data-ttu-id="37550-564"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-565">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-565">-or-</span></span> 
 <span data-ttu-id="37550-566"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-567">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-567">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-568">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-568">-or-</span></span> 
<span data-ttu-id="37550-569">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-569">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-570">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-571">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-571">-or-</span></span> 
<span data-ttu-id="37550-572">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="37550-573">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a maneira como o valor retornado é passado, a quais registros são usados para argumentos e à forma que a pilha é limpa.</span><span class="sxs-lookup"><span data-stu-id="37550-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="37550-574">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.</span><span class="sxs-lookup"><span data-stu-id="37550-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="37550-575">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-575">-or-</span></span> 
<span data-ttu-id="37550-576">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-577">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-578">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-579">Pesquisa por um construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="37550-580">Um objeto que representa o construtor que corresponde aos requisitos especificados, se encontrado, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-581">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-582">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-583">Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="37550-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="37550-584">Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.</span><span class="sxs-lookup"><span data-stu-id="37550-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="37550-585">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-586">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-587">Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="37550-588">Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="37550-589">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-590">Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-590">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-591">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-592">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-593">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-593">Member Type</span></span>|<span data-ttu-id="37550-594">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-594">Static</span></span>|<span data-ttu-id="37550-595">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-596">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-596">Constructor</span></span>|<span data-ttu-id="37550-597">Não</span><span class="sxs-lookup"><span data-stu-id="37550-597">No</span></span>|<span data-ttu-id="37550-598">Não</span><span class="sxs-lookup"><span data-stu-id="37550-598">No</span></span>|  
|<span data-ttu-id="37550-599">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-599">Field</span></span>|<span data-ttu-id="37550-600">Não</span><span class="sxs-lookup"><span data-stu-id="37550-600">No</span></span>|<span data-ttu-id="37550-601">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-601">Yes.</span></span> <span data-ttu-id="37550-602">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-603">evento</span><span class="sxs-lookup"><span data-stu-id="37550-603">Event</span></span>|<span data-ttu-id="37550-604">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-604">Not applicable</span></span>|<span data-ttu-id="37550-605">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-606">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-607">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-607">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-608">Método</span><span class="sxs-lookup"><span data-stu-id="37550-608">Method</span></span>|<span data-ttu-id="37550-609">Não</span><span class="sxs-lookup"><span data-stu-id="37550-609">No</span></span>|<span data-ttu-id="37550-610">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-610">Yes.</span></span> <span data-ttu-id="37550-611">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-612">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-612">Nested Type</span></span>|<span data-ttu-id="37550-613">Não</span><span class="sxs-lookup"><span data-stu-id="37550-613">No</span></span>|<span data-ttu-id="37550-614">Não</span><span class="sxs-lookup"><span data-stu-id="37550-614">No</span></span>|  
|<span data-ttu-id="37550-615">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-615">Property</span></span>|<span data-ttu-id="37550-616">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-616">Not applicable</span></span>|<span data-ttu-id="37550-617">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-618">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-619">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-620">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-621">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-622">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-623">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-624">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-625">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-626">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-627">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-628">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-629">O exemplo a seguir obtém o tipo de `MyClass1`, obtém o <xref:System.Reflection.ConstructorInfo> objeto que coincide com os sinalizadores de associação especificadas e exibe a assinatura do construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-630"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-631">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-631">-or-</span></span> 
<span data-ttu-id="37550-632">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-633"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-634">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-634">-or-</span></span> 
 <span data-ttu-id="37550-635"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-636">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-636">-or-</span></span> 
 <span data-ttu-id="37550-637"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-638">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-638">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-639">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-639">-or-</span></span> 
<span data-ttu-id="37550-640">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-640">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-641">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-642">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-642">-or-</span></span> 
<span data-ttu-id="37550-643">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="37550-644">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a maneira como o valor retornado é passado, a quais registros são usados para argumentos e à forma que a pilha é limpa.</span><span class="sxs-lookup"><span data-stu-id="37550-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="37550-645">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.</span><span class="sxs-lookup"><span data-stu-id="37550-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="37550-646">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-646">-or-</span></span> 
<span data-ttu-id="37550-647">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-648">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-649">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-650">Quando substituído em uma classe derivada, pesquisa por um construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="37550-651">Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor que corresponde aos requisitos especificados, se encontrados, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-652">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-653">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-654">Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="37550-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="37550-655">Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.</span><span class="sxs-lookup"><span data-stu-id="37550-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="37550-656">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-657">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-658">Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="37550-659">Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="37550-660">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-661">Esse método implementa <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-662"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-663">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-663">-or-</span></span> 
<span data-ttu-id="37550-664">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-665"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-666">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-666">-or-</span></span> 
 <span data-ttu-id="37550-667"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-668">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-668">-or-</span></span> 
 <span data-ttu-id="37550-669"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-670">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-671">Obtém os construtores do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-672">Retorna todos os construtores públicos definidos para o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-673">Uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa todos os construtores de instância pública definidos para o <see cref="T:System.Type" /> atual, mas não incluindo o inicializador de tipo (construtor estático).</span><span class="sxs-lookup"><span data-stu-id="37550-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="37550-674">Se nenhum construtor de instância pública for definido para o <see cref="T:System.Type" /> atual ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo ou método genérico, uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> será retornada.</span><span class="sxs-lookup"><span data-stu-id="37550-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-675">O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="37550-676">Seu código não deve depender a ordem em que os construtores são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-677">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-678">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-678">Member Type</span></span>|<span data-ttu-id="37550-679">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-679">Static</span></span>|<span data-ttu-id="37550-680">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-681">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-681">Constructor</span></span>|<span data-ttu-id="37550-682">Não</span><span class="sxs-lookup"><span data-stu-id="37550-682">No</span></span>|<span data-ttu-id="37550-683">Não</span><span class="sxs-lookup"><span data-stu-id="37550-683">No</span></span>|  
|<span data-ttu-id="37550-684">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-684">Field</span></span>|<span data-ttu-id="37550-685">Não</span><span class="sxs-lookup"><span data-stu-id="37550-685">No</span></span>|<span data-ttu-id="37550-686">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-686">Yes.</span></span> <span data-ttu-id="37550-687">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-688">evento</span><span class="sxs-lookup"><span data-stu-id="37550-688">Event</span></span>|<span data-ttu-id="37550-689">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-689">Not applicable</span></span>|<span data-ttu-id="37550-690">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-691">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-692">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-692">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-693">Método</span><span class="sxs-lookup"><span data-stu-id="37550-693">Method</span></span>|<span data-ttu-id="37550-694">Não</span><span class="sxs-lookup"><span data-stu-id="37550-694">No</span></span>|<span data-ttu-id="37550-695">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-695">Yes.</span></span> <span data-ttu-id="37550-696">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-697">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-697">Nested Type</span></span>|<span data-ttu-id="37550-698">Não</span><span class="sxs-lookup"><span data-stu-id="37550-698">No</span></span>|<span data-ttu-id="37550-699">Não</span><span class="sxs-lookup"><span data-stu-id="37550-699">No</span></span>|  
|<span data-ttu-id="37550-700">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-700">Property</span></span>|<span data-ttu-id="37550-701">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-701">Not applicable</span></span>|<span data-ttu-id="37550-702">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-703">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-704">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-705">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-706">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-707">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-708">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-709">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-710">Essa sobrecarga de método chama o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga de método, com <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-711">Ele não localizará os inicializadores de classe (. cctor).</span><span class="sxs-lookup"><span data-stu-id="37550-711">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="37550-712">Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-713">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-714">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-715">Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-716">Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-717">Este exemplo mostra a saída do <xref:System.Type.GetConstructors%2A> de sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.</span><span class="sxs-lookup"><span data-stu-id="37550-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="37550-718">A saída desse código é:</span><span class="sxs-lookup"><span data-stu-id="37550-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="37550-719">2</span><span class="sxs-lookup"><span data-stu-id="37550-719">2</span></span>  
  
 <span data-ttu-id="37550-720">False</span><span class="sxs-lookup"><span data-stu-id="37550-720">False</span></span>  
  
 <span data-ttu-id="37550-721">False</span><span class="sxs-lookup"><span data-stu-id="37550-721">False</span></span>  
  
 <span data-ttu-id="37550-722">Porque o <xref:System.Type.GetConstructors> sobrecarga usa apenas <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, o construtor estático não é contado pela `for` expressão nem avaliadas pelo `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="37550-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="37550-723">Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarregar e passar a combinação (lógicas `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:</span><span class="sxs-lookup"><span data-stu-id="37550-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="37550-724">Agora, a saída é:</span><span class="sxs-lookup"><span data-stu-id="37550-724">Now the output is:</span></span>  
  
 <span data-ttu-id="37550-725">3</span><span class="sxs-lookup"><span data-stu-id="37550-725">3</span></span>  
  
 <span data-ttu-id="37550-726">False</span><span class="sxs-lookup"><span data-stu-id="37550-726">False</span></span>  
  
 <span data-ttu-id="37550-727">verdadeiro</span><span class="sxs-lookup"><span data-stu-id="37550-727">True</span></span>  
  
 <span data-ttu-id="37550-728">False</span><span class="sxs-lookup"><span data-stu-id="37550-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-729">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-729">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-730">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-730">-or-</span></span> 
<span data-ttu-id="37550-731">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-731">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-732">Quando substituído em uma classe derivada, pesquisa os construtores definidos para o <see cref="T:System.Type" /> atual usando os <see langword="BindingFlags" /> especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="37550-733">Uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> representando todos os construtores definidos para o <see cref="T:System.Type" /> atual que corresponde às restrições de associação especificadas, incluindo o inicializador de tipo, se ele estiver definido.</span><span class="sxs-lookup"><span data-stu-id="37550-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="37550-734">Retorna uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> se nenhum construtor estiver definido para o <see cref="T:System.Type" /> atual, se nenhum dos construtores definidos corresponderem às restrições de associação ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo genérico ou método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-735">O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-735">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="37550-736">Seu código não deve depender a ordem em que os construtores são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-736">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-737">`bindingAttr` pode ser usado para especificar se deseja retornar apenas os construtores públicos ou construtores público e não públicos.</span><span class="sxs-lookup"><span data-stu-id="37550-737">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="37550-738">Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="37550-738">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="37550-739">Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.</span><span class="sxs-lookup"><span data-stu-id="37550-739">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="37550-740">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-740">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-741">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-741">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-742">Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-742">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="37550-743">Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-743">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="37550-744">Construtores de classes base não são retornados.</span><span class="sxs-lookup"><span data-stu-id="37550-744">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="37550-745">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-745">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-746">Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-746">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-747">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-747">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-748">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-748">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-749">Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-749">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-750">Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-750">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-751">Este exemplo mostra a saída do <xref:System.Type.GetConstructors> de sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.</span><span class="sxs-lookup"><span data-stu-id="37550-751">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="37550-752">A saída desse código é:</span><span class="sxs-lookup"><span data-stu-id="37550-752">The output of this code is:</span></span>  
  
 <span data-ttu-id="37550-753">2</span><span class="sxs-lookup"><span data-stu-id="37550-753">2</span></span>  
  
 <span data-ttu-id="37550-754">False</span><span class="sxs-lookup"><span data-stu-id="37550-754">False</span></span>  
  
 <span data-ttu-id="37550-755">False</span><span class="sxs-lookup"><span data-stu-id="37550-755">False</span></span>  
  
 <span data-ttu-id="37550-756">Porque o <xref:System.Type.GetConstructors%2A> sobrecarga usa apenas <xref:System.Reflection.BindingFlags.Public> e <xref:System.Reflection.BindingFlags.Instance>, o construtor estático não é contado pela `for` expressão nem avaliadas pelo `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="37550-756">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="37550-757">Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%2A> sobrecarregar e passá-lo a combinação (OR lógico) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:</span><span class="sxs-lookup"><span data-stu-id="37550-757">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="37550-758">Agora, a saída é:</span><span class="sxs-lookup"><span data-stu-id="37550-758">Now the output is:</span></span>  
  
 <span data-ttu-id="37550-759">3</span><span class="sxs-lookup"><span data-stu-id="37550-759">3</span></span>  
  
 <span data-ttu-id="37550-760">False</span><span class="sxs-lookup"><span data-stu-id="37550-760">False</span></span>  
  
 <span data-ttu-id="37550-761">verdadeiro</span><span class="sxs-lookup"><span data-stu-id="37550-761">True</span></span>  
  
 <span data-ttu-id="37550-762">False</span><span class="sxs-lookup"><span data-stu-id="37550-762">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-763">Procura os membros definidos para o <see cref="T:System.Type" /> atual, cujo <see cref="T:System.Reflection.DefaultMemberAttribute" /> está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-763">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="37550-764">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos os membros padrão do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-764">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-765">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-765">-or-</span></span> 
<span data-ttu-id="37550-766">Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-766">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-767">O <xref:System.Type.GetDefaultMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-767">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-768">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-768">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-769">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-769">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-770">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-770">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-771">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-771">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-772">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-772">Member Type</span></span>|<span data-ttu-id="37550-773">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-773">Static</span></span>|<span data-ttu-id="37550-774">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-774">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-775">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-775">Constructor</span></span>|<span data-ttu-id="37550-776">Não</span><span class="sxs-lookup"><span data-stu-id="37550-776">No</span></span>|<span data-ttu-id="37550-777">Não</span><span class="sxs-lookup"><span data-stu-id="37550-777">No</span></span>|  
|<span data-ttu-id="37550-778">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-778">Field</span></span>|<span data-ttu-id="37550-779">Não</span><span class="sxs-lookup"><span data-stu-id="37550-779">No</span></span>|<span data-ttu-id="37550-780">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-780">Yes.</span></span> <span data-ttu-id="37550-781">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-781">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-782">evento</span><span class="sxs-lookup"><span data-stu-id="37550-782">Event</span></span>|<span data-ttu-id="37550-783">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-783">Not applicable</span></span>|<span data-ttu-id="37550-784">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-784">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-785">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-785">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-786">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-786">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-787">Método</span><span class="sxs-lookup"><span data-stu-id="37550-787">Method</span></span>|<span data-ttu-id="37550-788">Não</span><span class="sxs-lookup"><span data-stu-id="37550-788">No</span></span>|<span data-ttu-id="37550-789">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-789">Yes.</span></span> <span data-ttu-id="37550-790">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-790">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-791">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-791">Nested Type</span></span>|<span data-ttu-id="37550-792">Não</span><span class="sxs-lookup"><span data-stu-id="37550-792">No</span></span>|<span data-ttu-id="37550-793">Não</span><span class="sxs-lookup"><span data-stu-id="37550-793">No</span></span>|  
|<span data-ttu-id="37550-794">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-794">Property</span></span>|<span data-ttu-id="37550-795">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-795">Not applicable</span></span>|<span data-ttu-id="37550-796">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-796">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-797">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-797">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-798">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-798">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-799">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-799">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-800">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-800">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-801">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-801">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-802">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-802">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-803">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-803">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-804">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-804">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="37550-805">Por exemplo, se classe `C<T>` tem uma propriedade `P` que retorna `T`, chamar <xref:System.Type.GetDefaultMembers%2A> na `C<int>` retorna `int P` em c# (`Property P As Integer` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-805">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-806">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-806">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-807">O exemplo a seguir obtém as informações do membro padrão de `MyClass` e exibe os membros padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-807">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-808">Quando substituído em uma classe derivada, retorna o <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de matriz, ponteiro ou tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="37550-808">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="37550-809">O <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de referência, ponteiro ou matriz atual ou <see langword="null" /> se <see cref="T:System.Type" /> atual não é uma matriz ou um ponteiro ou não é passado por referência ou representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-809">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-810">Esse método retornará `null` para o <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="37550-810">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-811">O exemplo a seguir demonstra como usar o `GetElementType` método.</span><span class="sxs-lookup"><span data-stu-id="37550-811">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="37550-812">O valor cujo nome deverá ser recuperado.</span><span class="sxs-lookup"><span data-stu-id="37550-812">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="37550-813">Retorna o nome da constante que tem o valor especificado para o tipo de enumeração atual.</span><span class="sxs-lookup"><span data-stu-id="37550-813">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="37550-814">O nome do membro do tipo de enumeração atual que tem o valor especificado ou <see langword="null" />, se tal constante não for encontrada.</span><span class="sxs-lookup"><span data-stu-id="37550-814">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-815">O tipo atual não é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-815">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="37550-816">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-816">-or-</span></span> 
 <span data-ttu-id="37550-817"><paramref name="value" /> não é do tipo atual, nem tem o mesmo tipo subjacente que o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-817"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-818"><paramref name="value" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-818"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-819">Retorna os nomes dos membros do tipo de enumeração atual.</span><span class="sxs-lookup"><span data-stu-id="37550-819">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="37550-820">Uma matriz que contém os nomes dos membros da enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-820">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-821">Os elementos da matriz de valores de retorno são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes enumeradas.</span><span class="sxs-lookup"><span data-stu-id="37550-821">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="37550-822">Se a matriz contém constantes enumeradas com o mesmo valor, a ordem de seus nomes correspondentes é especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-822">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-823">O tipo atual não é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-823">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-824">Retorna o tipo subjacente do tipo de enumeração atual.</span><span class="sxs-lookup"><span data-stu-id="37550-824">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="37550-825">O tipo subjacente da enumeração atual.</span><span class="sxs-lookup"><span data-stu-id="37550-825">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-826">Por padrão, o tipo subjacente de uma enumeração no c# e Visual Basic é <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="37550-826">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="37550-827">Outros tipos de inteiro podem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-827">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-828">O tipo atual não é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-828">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="37550-829">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-829">-or-</span></span> 
<span data-ttu-id="37550-830">O tipo de enumeração não é válido, pois contém mais de um campo de instância.</span><span class="sxs-lookup"><span data-stu-id="37550-830">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-831">Retorna uma matriz de valores das constantes no tipo de enumeração especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-831">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="37550-832">Uma matriz que contém os valores.</span><span class="sxs-lookup"><span data-stu-id="37550-832">An array that contains the values.</span></span> <span data-ttu-id="37550-833">Os elementos da matriz são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes de enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-833">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-834">O tipo atual não é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-834">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-835">Obtém um evento específico declarado ou herdado pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-835">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-836">A cadeia de caracteres que contém o nome de um evento que é declarado ou herdado pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-836">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="37550-837">Retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento público especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-837">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="37550-838">O objeto que representa o evento público especificado, o qual é declarado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-838">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-839">Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-839">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="37550-840">Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-840">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-841">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-841">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-842">A pesquisa inclui eventos de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-842">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="37550-843">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-843">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-844">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-844">Member Type</span></span>|<span data-ttu-id="37550-845">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-845">Static</span></span>|<span data-ttu-id="37550-846">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-846">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-847">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-847">Constructor</span></span>|<span data-ttu-id="37550-848">Não</span><span class="sxs-lookup"><span data-stu-id="37550-848">No</span></span>|<span data-ttu-id="37550-849">Não</span><span class="sxs-lookup"><span data-stu-id="37550-849">No</span></span>|  
|<span data-ttu-id="37550-850">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-850">Field</span></span>|<span data-ttu-id="37550-851">Não</span><span class="sxs-lookup"><span data-stu-id="37550-851">No</span></span>|<span data-ttu-id="37550-852">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-852">Yes.</span></span> <span data-ttu-id="37550-853">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-853">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-854">evento</span><span class="sxs-lookup"><span data-stu-id="37550-854">Event</span></span>|<span data-ttu-id="37550-855">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-855">Not applicable</span></span>|<span data-ttu-id="37550-856">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-856">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-857">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-857">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-858">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-858">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-859">Método</span><span class="sxs-lookup"><span data-stu-id="37550-859">Method</span></span>|<span data-ttu-id="37550-860">Não</span><span class="sxs-lookup"><span data-stu-id="37550-860">No</span></span>|<span data-ttu-id="37550-861">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-861">Yes.</span></span> <span data-ttu-id="37550-862">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-862">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-863">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-863">Nested Type</span></span>|<span data-ttu-id="37550-864">Não</span><span class="sxs-lookup"><span data-stu-id="37550-864">No</span></span>|<span data-ttu-id="37550-865">Não</span><span class="sxs-lookup"><span data-stu-id="37550-865">No</span></span>|  
|<span data-ttu-id="37550-866">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-866">Property</span></span>|<span data-ttu-id="37550-867">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-867">Not applicable</span></span>|<span data-ttu-id="37550-868">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-868">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-869">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-869">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-870">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-870">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-871">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-871">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-872">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-872">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-873">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-873">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-874">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-874">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-875">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-875">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-876">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-876">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-877">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-877">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-878">O exemplo a seguir cria um <xref:System.Reflection.EventInfo> de objeto e obtém o evento para uma classe de botão para o evento especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-878">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-879"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-879"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-880">A cadeia de caracteres que contém o nome de um evento declarado ou herdado pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-880">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-881">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-881">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-882">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-882">-or-</span></span> 
<span data-ttu-id="37550-883">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-883">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-884">Quando substituído em uma classe derivada, retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento especificado, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-884">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-885">O objeto que representa o evento especificado, o qual é declarado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-885">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-886">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais eventos serão incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-886">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-887">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-887">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-888">Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-888">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="37550-889">Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-889">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="37550-890">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-890">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-891">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-891">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-892">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-892">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-893">`BindingFlags.DeclaredOnly` Pesquisar apenas os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-893">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-894">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-894">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-895">Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="37550-896">Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-897">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-897">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-898">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-898">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-899">O seguinte exemplo de código usa o <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> método para pesquisar um tipo para um público ou não público evento chamado "Click" que não seja `static` (`Shared` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-899">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-900"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-900"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-901">Obtém os eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-901">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-902">Retorna todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-902">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-903">Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-903">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-904">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-904">-or-</span></span> 
<span data-ttu-id="37550-905">Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o <see cref="T:System.Type" /> atual não tiver eventos públicos.</span><span class="sxs-lookup"><span data-stu-id="37550-905">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-906">Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-906">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="37550-907">Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-907">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-908">O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-908">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-909">Seu código não deve depender a ordem na qual os eventos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-909">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-910">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-910">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-911">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-911">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-912">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-912">Member Type</span></span>|<span data-ttu-id="37550-913">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-913">Static</span></span>|<span data-ttu-id="37550-914">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-914">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-915">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-915">Constructor</span></span>|<span data-ttu-id="37550-916">Não</span><span class="sxs-lookup"><span data-stu-id="37550-916">No</span></span>|<span data-ttu-id="37550-917">Não</span><span class="sxs-lookup"><span data-stu-id="37550-917">No</span></span>|  
|<span data-ttu-id="37550-918">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-918">Field</span></span>|<span data-ttu-id="37550-919">Não</span><span class="sxs-lookup"><span data-stu-id="37550-919">No</span></span>|<span data-ttu-id="37550-920">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-920">Yes.</span></span> <span data-ttu-id="37550-921">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-921">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-922">evento</span><span class="sxs-lookup"><span data-stu-id="37550-922">Event</span></span>|<span data-ttu-id="37550-923">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-923">Not applicable</span></span>|<span data-ttu-id="37550-924">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-924">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-925">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-925">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-926">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-926">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-927">Método</span><span class="sxs-lookup"><span data-stu-id="37550-927">Method</span></span>|<span data-ttu-id="37550-928">Não</span><span class="sxs-lookup"><span data-stu-id="37550-928">No</span></span>|<span data-ttu-id="37550-929">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-929">Yes.</span></span> <span data-ttu-id="37550-930">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-930">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-931">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-931">Nested Type</span></span>|<span data-ttu-id="37550-932">Não</span><span class="sxs-lookup"><span data-stu-id="37550-932">No</span></span>|<span data-ttu-id="37550-933">Não</span><span class="sxs-lookup"><span data-stu-id="37550-933">No</span></span>|  
|<span data-ttu-id="37550-934">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-934">Property</span></span>|<span data-ttu-id="37550-935">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-935">Not applicable</span></span>|<span data-ttu-id="37550-936">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-936">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-937">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-937">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-938">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-938">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-939">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-939">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-940">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-940">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-941">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-941">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-942">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-942">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-943">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-943">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-944">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-944">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-945">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-945">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-946">O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos, obtém todos os eventos para um `Button` de classe e exibe os nomes de evento.</span><span class="sxs-lookup"><span data-stu-id="37550-946">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="37550-947">Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:</span><span class="sxs-lookup"><span data-stu-id="37550-947">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-948">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-948">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-949">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-949">-or-</span></span> 
<span data-ttu-id="37550-950">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-950">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-951">Quando substituído em uma classe derivada, procura por eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-951">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-952">Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam todos os eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual, que corresponde às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-952">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="37550-953">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-953">-or-</span></span> 
<span data-ttu-id="37550-954">Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o <see cref="T:System.Type" /> atual não tiver eventos ou se nenhum dos eventos corresponderem às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-954">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-955">O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-955">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-956">Seu código não deve depender a ordem na qual os eventos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-956">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-957">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais eventos serão incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-957">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-958">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-958">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-959">Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-959">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="37550-960">Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-960">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="37550-961">Somente protegido e eventos internos em classes base são retornados; eventos privados em classes base não são retornados.</span><span class="sxs-lookup"><span data-stu-id="37550-961">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="37550-962">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-962">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-963">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-963">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-964">`BindingFlags.DeclaredOnly` Pesquisar apenas os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-964">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-965">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-965">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-966">Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-966">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="37550-967">Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-967">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-968">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-968">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-969">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-969">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-970">O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos que correspondem aos sinalizadores de associação especificadas, obtém todos os eventos para um `Button` de classe e exibe os nomes de evento.</span><span class="sxs-lookup"><span data-stu-id="37550-970">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="37550-971">Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:</span><span class="sxs-lookup"><span data-stu-id="37550-971">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-972">Obtém um campo específico do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-972">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-973">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-973">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="37550-974">Pesquisa o campo público com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-974">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-975">Um objeto que representa o campo público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-975">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-976">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-976">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-977">A pesquisa inclui os campos de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-977">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="37550-978">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-978">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-979">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-979">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-980">O exemplo a seguir obtém a `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo e exibe o valor do campo.</span><span class="sxs-lookup"><span data-stu-id="37550-980">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-981"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-981"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-982">Este objeto <see cref="T:System.Type" /> é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> cujo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método ainda não foi chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-982">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-983">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-983">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-984">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-984">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-985">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-985">-or-</span></span> 
<span data-ttu-id="37550-986">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-986">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-987">Pesquisa o campo especificado usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-987">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-988">Um objeto que representa o campo que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-988">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-989">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-989">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-990">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-990">Member Type</span></span>|<span data-ttu-id="37550-991">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-991">Static</span></span>|<span data-ttu-id="37550-992">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-992">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-993">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-993">Constructor</span></span>|<span data-ttu-id="37550-994">Não</span><span class="sxs-lookup"><span data-stu-id="37550-994">No</span></span>|<span data-ttu-id="37550-995">Não</span><span class="sxs-lookup"><span data-stu-id="37550-995">No</span></span>|  
|<span data-ttu-id="37550-996">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-996">Field</span></span>|<span data-ttu-id="37550-997">Não</span><span class="sxs-lookup"><span data-stu-id="37550-997">No</span></span>|<span data-ttu-id="37550-998">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-998">Yes.</span></span> <span data-ttu-id="37550-999">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-999">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1000">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1000">Event</span></span>|<span data-ttu-id="37550-1001">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1001">Not applicable</span></span>|<span data-ttu-id="37550-1002">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1002">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1003">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1003">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1004">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1004">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1005">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1005">Method</span></span>|<span data-ttu-id="37550-1006">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1006">No</span></span>|<span data-ttu-id="37550-1007">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1007">Yes.</span></span> <span data-ttu-id="37550-1008">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1008">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1009">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1009">Nested Type</span></span>|<span data-ttu-id="37550-1010">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1010">No</span></span>|<span data-ttu-id="37550-1011">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1011">No</span></span>|  
|<span data-ttu-id="37550-1012">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1012">Property</span></span>|<span data-ttu-id="37550-1013">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1013">Not applicable</span></span>|<span data-ttu-id="37550-1014">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1014">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1015">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1015">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1016">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1016">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1017">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1017">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1018">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1018">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1019">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1019">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1020">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1020">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1021">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1021">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1022">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos serão incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1022">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1023">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1023">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1024">Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1024">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="37550-1025">Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1025">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1026">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1026">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1027">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1027">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1028">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1028">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1029">`BindingFlags.DeclaredOnly` para pesquisar apenas os campos declarados no <xref:System.Type>, não de campos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1029">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1030">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1030">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1031">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1031">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1032">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1032">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1033">O exemplo a seguir obtém a `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo que coincide com os sinalizadores de associação especificadas e exibe o valor do campo.</span><span class="sxs-lookup"><span data-stu-id="37550-1033">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1034"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1034"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1035">Obtém os campos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1035">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1036">Retorna todos os campos públicos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1036">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1037">Uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos os campos públicos definidos para o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1037">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-1038">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1038">-or-</span></span> 
<span data-ttu-id="37550-1039">Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo público for definido para o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1039">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1040">O <xref:System.Type.GetFields%2A> método não retorna campos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1040">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1041">Seu código não deve depender a ordem na qual os campos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1041">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1042">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1042">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1043">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1043">Member Type</span></span>|<span data-ttu-id="37550-1044">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1044">Static</span></span>|<span data-ttu-id="37550-1045">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1045">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1046">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1046">Constructor</span></span>|<span data-ttu-id="37550-1047">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1047">No</span></span>|<span data-ttu-id="37550-1048">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1048">No</span></span>|  
|<span data-ttu-id="37550-1049">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1049">Field</span></span>|<span data-ttu-id="37550-1050">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1050">No</span></span>|<span data-ttu-id="37550-1051">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1051">Yes.</span></span> <span data-ttu-id="37550-1052">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1052">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1053">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1053">Event</span></span>|<span data-ttu-id="37550-1054">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1054">Not applicable</span></span>|<span data-ttu-id="37550-1055">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1055">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1056">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1056">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1057">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1057">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1058">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1058">Method</span></span>|<span data-ttu-id="37550-1059">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1059">No</span></span>|<span data-ttu-id="37550-1060">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1060">Yes.</span></span> <span data-ttu-id="37550-1061">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1061">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1062">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1062">Nested Type</span></span>|<span data-ttu-id="37550-1063">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1063">No</span></span>|<span data-ttu-id="37550-1064">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1064">No</span></span>|  
|<span data-ttu-id="37550-1065">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1065">Property</span></span>|<span data-ttu-id="37550-1066">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1066">Not applicable</span></span>|<span data-ttu-id="37550-1067">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1067">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1068">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1068">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1069">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1069">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1070">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1070">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1071">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1071">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1072">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1072">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1073">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1073">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1074">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1074">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1075">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1075">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1076">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1076">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1077">O exemplo a seguir mostra um uso do `GetFields()` método.</span><span class="sxs-lookup"><span data-stu-id="37550-1077">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-1078">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1078">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1079">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1079">-or-</span></span> 
<span data-ttu-id="37550-1080">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1080">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1081">Quando é substituído em uma classe derivada, pesquisa os campos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1081">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1082">Uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos os campos definidos para o <see cref="T:System.Type" /> atual que corresponde às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1082">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="37550-1083">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1083">-or-</span></span> 
<span data-ttu-id="37550-1084">Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo estiver definido para o <see cref="T:System.Type" /> atual ou se nenhum dos campos definidos corresponderem às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1084">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1085">O <xref:System.Type.GetFields%2A> método não retorna campos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1085">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1086">Seu código não deve depender a ordem na qual os campos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1086">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1087">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos serão incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1087">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1088">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1088">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1089">Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1089">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="37550-1090">Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1090">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="37550-1091">Somente protegido e campos internos em classes base são retornados; campos privados em classes base não são retornados.</span><span class="sxs-lookup"><span data-stu-id="37550-1091">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="37550-1092">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1092">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1093">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1093">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1094">`BindingFlags.DeclaredOnly` para pesquisar apenas os campos declarados no <xref:System.Type>, não de campos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1094">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1095">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1095">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1096">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1096">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1097">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1097">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1098">O exemplo a seguir mostra um uso do `GetFields(BindingFlags)` método.</span><span class="sxs-lookup"><span data-stu-id="37550-1098">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1099">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico fechado ou os parâmetros de tipo de uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1099">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="37550-1100">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1100">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="37550-1101">Retorna uma matriz vazia se o tipo atual não é um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1101">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1102">Os elementos da matriz são retornados na ordem em que aparecem na lista de argumentos de tipo para o tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1102">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="37550-1103">Se o tipo atual for um tipo construído fechado (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `false`), a matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método contém os tipos que foram atribuídos aos parâmetros de tipo genérico de definição de tipo genérico .</span><span class="sxs-lookup"><span data-stu-id="37550-1103">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="37550-1104">Se o tipo atual é uma definição de tipo genérico, a matriz contém os parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1104">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="37550-1105">Se o tipo atual for um tipo construído aberto (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`) em que tipos específicos não tem sido atribuídos a todos os parâmetros de tipo e parâmetros de tipo de circunscrição tipos ou métodos genéricos, a matriz contém tipos e parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1105">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="37550-1106">Use o <xref:System.Type.IsGenericParameter%2A> propriedade distingui-los.</span><span class="sxs-lookup"><span data-stu-id="37550-1106">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="37550-1107">Para ver uma demonstração desse cenário, consulte o exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1107">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1108">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1109">O seguinte exemplo de código usa o <xref:System.Type.GetGenericArguments%2A> método para exibir os argumentos de tipo de um tipo construído e os parâmetros de tipo de sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1109">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="37550-1110">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1110">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="37550-1111">Consulte o exemplo maior para a saída de exemplo.</span><span class="sxs-lookup"><span data-stu-id="37550-1111">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-1112">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1112">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="37550-1113">As classes derivadas devem fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-1113">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-1114">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-1114">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-1115">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-1115">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1116">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1116">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="37550-1117">Uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1117">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1118">Cada restrição em um parâmetro de tipo genérico é expressa como um <xref:System.Type> objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-1118">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="37550-1119">Use o <xref:System.Type.IsClass%2A> propriedade para determinar se uma restrição é a restrição de classe base; se a propriedade retornará `false`, a restrição é uma restrição de interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1119">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="37550-1120">Se um parâmetro de tipo tem nenhuma restrição de classe e sem restrições de interface, uma matriz vazia será retornada.</span><span class="sxs-lookup"><span data-stu-id="37550-1120">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="37550-1121">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1121">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1122">O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo que têm diferentes restrições.</span><span class="sxs-lookup"><span data-stu-id="37550-1122">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="37550-1123">Quando o programa é executado, as restrições são examinadas por meio de <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-1123">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-1124">O objeto <see cref="T:System.Type" /> atual não é um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1124">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="37550-1125">Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1125">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-1126">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-1126">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1127">Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico do qual o tipo genérico atual pode ser criado.</span><span class="sxs-lookup"><span data-stu-id="37550-1127">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="37550-1128">Um objeto <see cref="T:System.Type" /> que representa um tipo genérico do qual o tipo atual pode ser criado.</span><span class="sxs-lookup"><span data-stu-id="37550-1128">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1129">Uma definição de tipo genérico é um modelo do qual outros tipos podem ser construídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1129">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="37550-1130">Por exemplo, de definição de tipo genérico `G<T>` (expressa na sintaxe c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode construir e criar uma instância do tipo `G<int>` (`G(Of Integer)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1130">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="37550-1131">Considerando um <xref:System.Type> construída de objeto que representa esse tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1131">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="37550-1132">Se dois tipos construídos são criados da mesma definição de tipo genérico, usando os mesmos argumentos de tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna o mesmo <xref:System.Type> objeto para ambos os tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-1132">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="37550-1133">Se você chamar o <xref:System.Type.GetGenericTypeDefinition%2A> método em um <xref:System.Type> objeto que já representa uma definição de tipo genérico, ele retorna atual <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-1133">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="37550-1134">Uma matriz de tipos genéricos não é em si genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1134">An array of generic types is not itself generic.</span></span> <span data-ttu-id="37550-1135">No código c# `A<int>[] v;` ou o código do Visual Basic `Dim v() As A(Of Integer)`, o tipo de variável `v` não é genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1135">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="37550-1136">Use <xref:System.Type.IsGenericType%2A> para determinar se um tipo é genérico antes de chamar <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1136">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="37550-1137">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1137">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1138">O exemplo de código a seguir cria uma instância de um tipo construído usando a criação de comum de instância e, em seguida, usa o <xref:System.Type.GetType%2A> e <xref:System.Type.GetGenericTypeDefinition%2A> métodos para recuperar o tipo construído e definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1138">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="37550-1139">Este exemplo usa o genérico <xref:System.Collections.Generic.Dictionary%602> tipo; representa o tipo construído uma <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="37550-1139">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-1140">O tipo atual não é um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1140">The current type is not a generic type.</span></span>  <span data-ttu-id="37550-1141">Ou seja, <see cref="P:System.Type.IsGenericType" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1141">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-1142">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1142">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="37550-1143">As classes derivadas devem fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-1143">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-1144">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-1144">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-1145">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-1145">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1146">Retorna o código hash para essa instância.</span><span class="sxs-lookup"><span data-stu-id="37550-1146">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="37550-1147">O código hash para essa instância.</span><span class="sxs-lookup"><span data-stu-id="37550-1147">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1148">Este método substitui <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-1148">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1149">O exemplo a seguir exibe o código hash do `System.Windows.Forms.Button` classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1149">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1150">Obtém uma interface específica implementada ou herdada pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1150">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1151">A cadeia de caracteres que contém o nome da interface a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-1151">The string containing the name of the interface to get.</span></span> <span data-ttu-id="37550-1152">Para interfaces genéricas, este é o nome danificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1152">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="37550-1153">Pesquisa a interface com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1153">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-1154">Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1154">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1155">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1155">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="37550-1156">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1156">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1157">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1158">Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1158">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="37550-1159">Isso é verdadeiro para as definições de interface genérica e construídos interfaces genéricas.</span><span class="sxs-lookup"><span data-stu-id="37550-1159">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="37550-1160">Por exemplo, para encontrar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), pesquise ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="37550-1160">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1161">O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%29> método para pesquisar o <xref:System.Collections.Hashtable> de classe para o <xref:System.Runtime.Serialization.IDeserializationCallback> interface e lista os métodos da interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1161">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="37550-1162">O exemplo de código também demonstra a <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-1162">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1163"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1163"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1164">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="37550-1164">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1165">A cadeia de caracteres que contém o nome da interface a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-1165">The string containing the name of the interface to get.</span></span> <span data-ttu-id="37550-1166">Para interfaces genéricas, este é o nome danificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1166">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="37550-1167"><see langword="true" /> para ignorar a diferença entre maiúsculas e minúsculas dessa parte de <paramref name="name" /> que especifica o nome da interface simples (a parte que especifica se o namespace deve diferenciar maiúsculas e minúsculas corretamente).</span><span class="sxs-lookup"><span data-stu-id="37550-1167"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="37550-1168">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1168">-or-</span></span> 
 <span data-ttu-id="37550-1169"><see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para todas as partes de <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1169"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="37550-1170">Quando substituído em uma classe derivada, procura pela interface especificada, indicando se deseja fazer uma pesquisa que não diferencia maiúsculas de minúsculas pelo nome da interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1170">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="37550-1171">Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1171">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1172">O `ignoreCase` parâmetro aplica-se somente para o nome da interface simples, não para o namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-1172">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="37550-1173">A parte de `name` que especifica o namespace deve ter a capitalização correta ou a interface não será encontrada.</span><span class="sxs-lookup"><span data-stu-id="37550-1173">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="37550-1174">Por exemplo, a cadeia de caracteres "System. IComparable" localiza o <xref:System.IComparable> interface, mas a cadeia de caracteres "System. IComparable" não.</span><span class="sxs-lookup"><span data-stu-id="37550-1174">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="37550-1175">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1175">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1176">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1176">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1177">Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1177">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="37550-1178">Isso é verdadeiro para as definições de interface genérica e construídos interfaces genéricas.</span><span class="sxs-lookup"><span data-stu-id="37550-1178">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="37550-1179">Por exemplo, para encontrar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), pesquise `"IExample`1"'.</span><span class="sxs-lookup"><span data-stu-id="37550-1179">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1180">O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> método para realizar uma pesquisa não diferencia maiusculas da <xref:System.Collections.Hashtable> de classe para o <xref:System.Collections.IEnumerable> interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1180">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="37550-1181">O exemplo de código também demonstra a <xref:System.Type.GetInterface%28System.String%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-1181">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1182"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1182"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1183">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="37550-1183">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="37550-1184">O tipo de interface para o qual um mapeamento será recuperado.</span><span class="sxs-lookup"><span data-stu-id="37550-1184">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="37550-1185">Retorna um mapeamento de interface para o tipo de interface especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1185">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="37550-1186">Um objeto que representa o mapeamento de interface para <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1186">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1187">O mapa da interface indica como uma interface é mapeada para os membros reais em uma classe que implementa a interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1187">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="37550-1188">Se o atual <xref:System.Type> representa um tipo genérico construído, o tipo de parâmetros são substituídos pelos argumentos nos elementos do tipo apropriado a <xref:System.Reflection.InterfaceMapping> retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="37550-1188">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1189">A exemplo a seguir chama o <xref:System.Type.GetInterfaceMap%2A> método para determinar como o <xref:System.IFormatProvider> interface mapeia para <xref:System.Globalization.CultureInfo> métodos e como a <xref:System.IAppDomainSetup> interface é mapeado para <xref:System.AppDomainSetup> propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-1189">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="37550-1190">Observe que, como o <xref:System.IAppDomainSetup> interface define um conjunto de propriedades, retornados <xref:System.Reflection.InterfaceMapping> objeto inclui separado <xref:System.Reflection.MethodInfo> objetos para uma propriedade acessadores get e set.</span><span class="sxs-lookup"><span data-stu-id="37550-1190">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1191"><paramref name="interfaceType" /> não é implementado pelo tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1191"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="37550-1192">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1192">-or-</span></span> 
<span data-ttu-id="37550-1193">O argumento <paramref name="interfaceType" /> não faz referência a uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1193">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="37550-1194">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1194">-or-</span></span>

<span data-ttu-id="37550-1195">A instância atual ou argumento <paramref name="interfaceType" /> é um tipo genérico aberto. Ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1195">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="37550-1196">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1196">-or-</span></span>


 <span data-ttu-id="37550-1197"><paramref name="interfaceType" /> é uma interface genérica e o tipo atual é um tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-1197"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1198"><paramref name="interfaceType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1198"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-1199">O <see cref="T:System.Type" /> atual representa um parâmetro de tipo genérico, ou seja, <see cref="P:System.Type.IsGenericParameter" /> é <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1199">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-1200">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1200">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="37550-1201">As classes derivadas devem fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-1201">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1202">Quando substituído em uma classe derivada, obtém todas as interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1202">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1203">Uma matriz de objetos <see cref="T:System.Type" /> que representa todas as interfaces implementadas ou herdadas pela <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1203">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-1204">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1204">-or-</span></span> 
<span data-ttu-id="37550-1205">Uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhuma interface está implementada ou herdada pela <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1205">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1206">O <xref:System.Type.GetInterfaces%2A> método não retorna interfaces em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1206">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1207">Seu código não deve depender a ordem na qual as interfaces são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1207">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1208">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Type> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1209">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="37550-1209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1210">O exemplo a seguir obtém o tipo da classe especificada e exibe todas as interfaces que o tipo implementa ou herda.</span><span class="sxs-lookup"><span data-stu-id="37550-1210">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="37550-1211">Para compilar o exemplo do Visual Basic, use os seguintes comandos do compilador:</span><span class="sxs-lookup"><span data-stu-id="37550-1211">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-1212">Um inicializador estático é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-1212">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1213">Obtém os membros especificados do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1213">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1214">A cadeia de caracteres que contém o nome dos membros públicos a serem obtidos.</span><span class="sxs-lookup"><span data-stu-id="37550-1214">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="37550-1215">Pesquisa a propriedade pública com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1215">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-1216">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1216">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1217">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1217">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-1218">A pesquisa inclui os membros de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-1218">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="37550-1219">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-1219">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-1220">O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1220">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1221">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1221">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1222">Essa sobrecarga de método não localizará os inicializadores de classe (. cctor).</span><span class="sxs-lookup"><span data-stu-id="37550-1222">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="37550-1223">Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1223">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-1224">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1224">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1225">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1225">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1226">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1226">Member Type</span></span>|<span data-ttu-id="37550-1227">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1227">Static</span></span>|<span data-ttu-id="37550-1228">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1228">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1229">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1229">Constructor</span></span>|<span data-ttu-id="37550-1230">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1230">No</span></span>|<span data-ttu-id="37550-1231">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1231">No</span></span>|  
|<span data-ttu-id="37550-1232">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1232">Field</span></span>|<span data-ttu-id="37550-1233">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1233">No</span></span>|<span data-ttu-id="37550-1234">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1234">Yes.</span></span> <span data-ttu-id="37550-1235">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1235">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1236">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1236">Event</span></span>|<span data-ttu-id="37550-1237">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1237">Not applicable</span></span>|<span data-ttu-id="37550-1238">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1238">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1239">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1239">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1240">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1240">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1241">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1241">Method</span></span>|<span data-ttu-id="37550-1242">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1242">No</span></span>|<span data-ttu-id="37550-1243">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1243">Yes.</span></span> <span data-ttu-id="37550-1244">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1244">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1245">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1245">Nested Type</span></span>|<span data-ttu-id="37550-1246">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1246">No</span></span>|<span data-ttu-id="37550-1247">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1247">No</span></span>|  
|<span data-ttu-id="37550-1248">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1248">Property</span></span>|<span data-ttu-id="37550-1249">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1249">Not applicable</span></span>|<span data-ttu-id="37550-1250">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1250">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1251">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1251">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1252">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1252">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1253">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1253">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1254">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1254">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1255">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1255">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1256">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1256">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1257">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1257">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1258">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1258">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1259">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1259">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1260">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1260">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1261">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1261">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1262">O exemplo a seguir exibe todos os membros de `String` classe que começam com a letra C.</span><span class="sxs-lookup"><span data-stu-id="37550-1262">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1263"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1263"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1264">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</span><span class="sxs-lookup"><span data-stu-id="37550-1264">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1265">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1265">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1266">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1266">-or-</span></span> 
<span data-ttu-id="37550-1267">Zero, para retornar uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1267">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="37550-1268">Pesquisa os membros especificados usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1268">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1269">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1269">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1270">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-1270">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-1271">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-1271">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-1272">O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1272">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1273">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1273">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1274">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1274">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1275">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1275">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1276">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1276">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-1277">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1277">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1278">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1278">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1279">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1279">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1280">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1280">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1281">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1281">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1282">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1282">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1283">Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic) para `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="37550-1283">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="37550-1284">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1284">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1285">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1285">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1286">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1286">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1287">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1287">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1288">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1288">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1289">O exemplo a seguir exibe todos os membros estáticos públicos do `myString` classe que começam com a letra C.</span><span class="sxs-lookup"><span data-stu-id="37550-1289">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1290"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1290"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1291">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</span><span class="sxs-lookup"><span data-stu-id="37550-1291">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="37550-1292">O valor a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="37550-1292">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1293">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1293">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1294">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1294">-or-</span></span> 
<span data-ttu-id="37550-1295">Zero, para retornar uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1295">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="37550-1296">Pesquisa os membros especificados do tipo de membro especificado, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1296">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1297">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1297">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1298">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-1298">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-1299">O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1299">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1300">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1300">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1301">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1301">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1302">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1302">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1303">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1303">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-1304">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1304">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1305">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1305">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1306">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1306">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1307">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1307">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1308">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1308">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1309">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1309">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1310">Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> para `type`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> em Visual Basic) para `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="37550-1310">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="37550-1311">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1311">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1312">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1312">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1313">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1313">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1314">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1314">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1315">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1315">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1316">O exemplo a seguir exibe todos os métodos do `myString` classe que começam com a letra C.</span><span class="sxs-lookup"><span data-stu-id="37550-1316">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1317"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1317"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-1318">Uma classe derivada deve fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-1318">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1319">Obtém os membros (propriedades, métodos, campos, eventos e assim por diante) do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1319">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1320">Retorna todos os membros públicos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1320">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1321">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos os membros públicos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1321">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-1322">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1322">-or-</span></span> 
<span data-ttu-id="37550-1323">Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros públicos.</span><span class="sxs-lookup"><span data-stu-id="37550-1323">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1324">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-1324">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-1325">O <xref:System.Type.GetMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1325">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1326">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1326">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1327">Essa sobrecarga de método chama o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga de método, com <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1327">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-1328">Ele não localizará os inicializadores de classe (. cctor).</span><span class="sxs-lookup"><span data-stu-id="37550-1328">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="37550-1329">Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1329">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-1330">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1330">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1331">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1331">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1332">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1332">Member Type</span></span>|<span data-ttu-id="37550-1333">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1333">Static</span></span>|<span data-ttu-id="37550-1334">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1334">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1335">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1335">Constructor</span></span>|<span data-ttu-id="37550-1336">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1336">No</span></span>|<span data-ttu-id="37550-1337">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1337">No</span></span>|  
|<span data-ttu-id="37550-1338">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1338">Field</span></span>|<span data-ttu-id="37550-1339">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1339">No</span></span>|<span data-ttu-id="37550-1340">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1340">Yes.</span></span> <span data-ttu-id="37550-1341">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1341">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1342">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1342">Event</span></span>|<span data-ttu-id="37550-1343">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1343">Not applicable</span></span>|<span data-ttu-id="37550-1344">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1344">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1345">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1345">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1346">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1346">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1347">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1347">Method</span></span>|<span data-ttu-id="37550-1348">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1348">No</span></span>|<span data-ttu-id="37550-1349">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1349">Yes.</span></span> <span data-ttu-id="37550-1350">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1350">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1351">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1351">Nested Type</span></span>|<span data-ttu-id="37550-1352">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1352">No</span></span>|<span data-ttu-id="37550-1353">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1353">No</span></span>|  
|<span data-ttu-id="37550-1354">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1354">Property</span></span>|<span data-ttu-id="37550-1355">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1355">Not applicable</span></span>|<span data-ttu-id="37550-1356">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1356">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1357">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1357">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1358">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1358">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1359">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1359">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1360">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1360">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1361">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1361">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1362">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1362">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1363">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1363">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1364">Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1364">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1365">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1365">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1366">O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers> sobrecarga de método para coletar informações sobre todos os membros públicos de uma classe especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-1366">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-1367">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1367">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1368">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1368">-or-</span></span> 
<span data-ttu-id="37550-1369">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), para retornar uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-1369">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span></span></param>
        <summary><span data-ttu-id="37550-1370">Quando é substituído em uma classe derivada, pesquisa os membros definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1370">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1371">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> representando todos os membros definidos para o <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1371">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="37550-1372">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1372">-or-</span></span> 
<span data-ttu-id="37550-1373">Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se nenhum membro estiver definido para o atual <see cref="T:System.Type" /> ou se nenhum dos membros definidos corresponder às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1373">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1374">Entre os membros estão propriedades, campos, métodos, eventos etc.</span><span class="sxs-lookup"><span data-stu-id="37550-1374">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="37550-1375">O <xref:System.Type.GetMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1375">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1376">O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1376">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1377">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1377">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1378">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1378">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1379">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1379">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-1380">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1380">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="37550-1381">Somente protegido e membros internos em classes base são retornados; membros privados em classes base não são retornados.</span><span class="sxs-lookup"><span data-stu-id="37550-1381">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="37550-1382">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1382">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1383">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1384">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1385">Chamar esse método apenas com o `Public` sinalizador ou apenas o `NonPublic` sinalizador retornará os membros especificados e não requer quaisquer outros sinalizadores.</span><span class="sxs-lookup"><span data-stu-id="37550-1385">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="37550-1386">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1386">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1387">Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1387">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="37550-1388">Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1388">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="37550-1389">Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1390">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1391">O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga de método para coletar informações sobre todos os membros de instância pública de uma classe especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-1391">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1392">Obtém um método específico do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1392">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1393">A cadeia de caracteres que contém o nome do método público a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1393">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="37550-1394">Pesquisa o método público com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1394">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-1395">Um objeto que representa o método público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1395">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1396">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1396">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-1397">A pesquisa inclui os métodos de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-1397">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="37550-1398">Se um método está sobrecarregado e tem mais de um método público, o <xref:System.Type.GetMethod%28System.String%29> método lança um <xref:System.Reflection.AmbiguousMatchException> exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-1398">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="37550-1399">No exemplo a seguir, uma exceção é gerada porque não há mais de uma sobrecarga pública do <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="37550-1399">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="37550-1400">Por outro lado, pois o `Person.ToString` substituições de método <xref:System.Object.ToString%2A?displayProperty=nameWithType> e, portanto, não está sobrecarregado, o <xref:System.Type.GetMethod%28System.String%29> método é capaz de recuperar o <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-1400">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="37550-1401">Você pode fazer o seguinte para recuperar um método específico:</span><span class="sxs-lookup"><span data-stu-id="37550-1401">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="37550-1402">Chame o <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> método e especifique um `bindingAttr` argumento que identifica exclusivamente o método.</span><span class="sxs-lookup"><span data-stu-id="37550-1402">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="37550-1403">Por exemplo, se a exceção é lançada como um tipo tem um estático e uma sobrecarga de instância, você pode especificar uma `bindingAttr` argumento de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-1403">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="37550-1404">Chamar uma sobrecarga da <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.</span><span class="sxs-lookup"><span data-stu-id="37550-1404">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="37550-1405">Chamar o <xref:System.Type.GetMethods> método para recuperar uma matriz que contém todos os métodos públicos que pertencem a um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1405">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="37550-1406">Você pode iterá-lo para identificar os métodos duplicados denominados `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1406">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="37550-1407">Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1407">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1408">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1408">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1409">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1409">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1410">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1410">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1411">O exemplo a seguir obtém um método chamado `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="37550-1411">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1412">Foi encontrado mais de um método com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1412">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1413"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1413"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1414">A cadeia de caracteres que contém o nome do método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1414">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1415">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1415">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1416">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1416">-or-</span></span> 
<span data-ttu-id="37550-1417">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1417">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1418">Pesquisa o método especificado, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1418">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1419">Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1419">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1420">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1420">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1421">Você deve especificar <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1421">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1422">Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir métodos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1422">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="37550-1423">Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1423">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1424">Especifique <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1424">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1425">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1425">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1428">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1428">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1429">Se um método está sobrecarregado e mais de uma sobrecarga cumpre as restrições especificadas pelo `bindingAttr` argumento, o método lança um <xref:System.Reflection.AmbiguousMatchException> exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-1429">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="37550-1430">O exemplo a seguir, uma exceção é gerada porque:</span><span class="sxs-lookup"><span data-stu-id="37550-1430">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="37550-1431">O `TestClass` tipo tem duas sobrecargas de instância pública do `DisplayValue` método `DisplayValue(String)` e `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="37550-1431">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="37550-1432">O `TestClass` tipo tem duas sobrecargas de instância pública do `Equals` método, um deles é herdado do <xref:System.Object>: `Equals(TestClass)` e `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="37550-1432">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="37550-1433">Você pode fazer o seguinte para recuperar um método específico:</span><span class="sxs-lookup"><span data-stu-id="37550-1433">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="37550-1434">Altere as restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1434">Change the binding constraints.</span></span> <span data-ttu-id="37550-1435">No exemplo anterior, a tentativa de recuperar uma instância pública `Equals` recupera do método que é declarado pelo tipo e não herdado com êxito `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="37550-1435">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="37550-1436">Chamar uma sobrecarga da <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.</span><span class="sxs-lookup"><span data-stu-id="37550-1436">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="37550-1437">Chamar o <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> método para recuperar uma matriz que contém todos os métodos que pertencem a um tipo que têm os atributos de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1437">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="37550-1438">Você pode iterá-lo para identificar os métodos duplicados denominados `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1438">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="37550-1439">Essa abordagem é ilustrada no manipulador do exemplo anterior para o <xref:System.Reflection.AmbiguousMatchException> exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-1439">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="37550-1440">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1440">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1441">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1441">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1442">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1442">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1443">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1443">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1444">O exemplo a seguir obtém o método que corresponde a sinalizadores de associação especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1444">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1445">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1445">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1446"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1446"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1447">A cadeia de caracteres que contém o nome do método público a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1447">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="37550-1448">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1448">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="37550-1449">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1449">-or-</span></span> 
<span data-ttu-id="37550-1450">Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1450">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="37550-1451">Pesquisa o método público especificado cujos parâmetros correspondem aos tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1451">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="37550-1452">Um objeto que representa o método público cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1452">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1453">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1453">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-1454">A pesquisa inclui os métodos de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-1454">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1455">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1455">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1456">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1456">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1457">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1457">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1458">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1458">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1459">O `name` parâmetro não pode incluir os argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1459">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="37550-1460">Por exemplo, o código c# `GetMethod("MyGenericMethod<int>")` procura um método com o nome de texto "`MyGenericMethod<int>`", em vez de para um método chamado `MyGenericMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1460">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="37550-1461">Em vez disso, use `GetMethod("MyGenericMethod")` com o parâmetro apropriado no `types` matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-1461">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1462">O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar uma variedade de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="37550-1462">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1463">O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.</span><span class="sxs-lookup"><span data-stu-id="37550-1463">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="37550-1464">O exemplo a seguir recupera <xref:System.Reflection.MethodInfo> objetos que representam os `Add` métodos de um tipo não genérico (a <xref:System.Collections.ArrayList> classe), um tipo genérico aberto (o <xref:System.Collections.Generic.List%601> classe) e um tipo genérico fechado (o `List(Of String)` tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1464">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="37550-1465">O exemplo define uma `GetAddMethod` método que recupera apropriado <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-1465">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="37550-1466">Para fornecer a `types` argumento para um tipo genérico aberto, ele chama o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="37550-1466">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="37550-1467">Para fornecer a `types` argumento para um tipo genérico fechado, ele recupera o valor da <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1467">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1468">Foi encontrado mais de um método com o nome especificado e com os parâmetros especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1468">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1469"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1469"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1470">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1470">-or-</span></span> 
 <span data-ttu-id="37550-1471"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1471"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1472">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1472">-or-</span></span> 
<span data-ttu-id="37550-1473">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1473">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1474"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1474"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1475">A cadeia de caracteres que contém o nome do método público a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1475">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="37550-1476">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1476">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="37550-1477">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1477">-or-</span></span> 
<span data-ttu-id="37550-1478">Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1478">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-1479">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1479">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-1480">Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados.</span><span class="sxs-lookup"><span data-stu-id="37550-1480">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="37550-1481">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-1481">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-1482">Pesquisa o método público especificado cujos parâmetros correspondem aos modificadores e tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1482">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="37550-1483">Um objeto que representa o método público que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1483">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1484">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-1484">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-1485">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1485">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-1486">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1486">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-1487">A pesquisa inclui os métodos de instância pública de static e public.</span><span class="sxs-lookup"><span data-stu-id="37550-1487">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1488">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1488">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1489">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1489">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1490">Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1490">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1491">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1491">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1492">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1492">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1493">Por exemplo, o código do C# `GetMethod("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1493">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="37550-1494">Em vez disso, use `GetMethod("MyMethod")` com o parâmetro apropriado no `types` matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-1494">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1495">Foi encontrado mais de um método com o nome especificado e com os parâmetros especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1495">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1496"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1496"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1497">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1497">-or-</span></span> 
 <span data-ttu-id="37550-1498"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1498"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1499">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1499">-or-</span></span> 
<span data-ttu-id="37550-1500">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1500">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1501"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1501"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-1502">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1502">-or-</span></span> 
 <span data-ttu-id="37550-1503"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1503"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1504">A cadeia de caracteres que contém o nome do método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1504">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1505">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1505">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1506">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1506">-or-</span></span> 
<span data-ttu-id="37550-1507">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1507">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-1508">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-1508">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-1509">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1509">-or-</span></span> 
<span data-ttu-id="37550-1510">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1510">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="37550-1511">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="37550-1512">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1512">-or-</span></span> 
<span data-ttu-id="37550-1513">Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1513">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-1514">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1514">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-1515">Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados.</span><span class="sxs-lookup"><span data-stu-id="37550-1515">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="37550-1516">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-1516">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-1517">Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1517">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1518">Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1518">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1519">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-1519">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-1520">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1520">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-1521">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1521">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1522">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1522">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1523">Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1523">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="37550-1524">Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1524">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1525">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1525">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1526">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1526">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1527">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1527">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1528">`BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1528">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1529">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1529">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1530">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1530">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1531">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1531">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1532">Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1532">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1533">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1533">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1534">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1534">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1535">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1535">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1536">O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar restrições de associação e uma variedade de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="37550-1536">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1537">O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.</span><span class="sxs-lookup"><span data-stu-id="37550-1537">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1538">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1538">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1539"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1539"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1540">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1540">-or-</span></span> 
 <span data-ttu-id="37550-1541"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1541"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1542">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1542">-or-</span></span> 
<span data-ttu-id="37550-1543">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1543">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1544"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1544"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-1545">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1545">-or-</span></span> 
 <span data-ttu-id="37550-1546"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1546"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1547">A cadeia de caracteres que contém o nome do método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1547">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1548">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1548">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1549">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1549">-or-</span></span> 
<span data-ttu-id="37550-1550">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1550">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-1551">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-1551">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-1552">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1552">-or-</span></span> 
<span data-ttu-id="37550-1553">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1553">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="37550-1554">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a como o valor retornado é passado, quais registros são usados para argumentos e como a pilha é limpa.</span><span class="sxs-lookup"><span data-stu-id="37550-1554">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="37550-1555">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1555">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="37550-1556">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1556">-or-</span></span> 
<span data-ttu-id="37550-1557">Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1557">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-1558">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1558">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-1559">Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados.</span><span class="sxs-lookup"><span data-stu-id="37550-1559">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="37550-1560">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-1560">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-1561">Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-1561">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="37550-1562">Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1562">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1563">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-1563">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-1564">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1564">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-1565">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `GetXXX` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1565">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1566">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1566">Member Type</span></span>|<span data-ttu-id="37550-1567">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1567">Static</span></span>|<span data-ttu-id="37550-1568">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1568">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1569">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1569">Constructor</span></span>|<span data-ttu-id="37550-1570">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1570">No</span></span>|<span data-ttu-id="37550-1571">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1571">No</span></span>|  
|<span data-ttu-id="37550-1572">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1572">Field</span></span>|<span data-ttu-id="37550-1573">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1573">No</span></span>|<span data-ttu-id="37550-1574">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1574">Yes.</span></span> <span data-ttu-id="37550-1575">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1575">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1576">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1576">Event</span></span>|<span data-ttu-id="37550-1577">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1577">Not applicable</span></span>|<span data-ttu-id="37550-1578">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1578">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1579">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1579">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1580">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1580">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1581">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1581">Method</span></span>|<span data-ttu-id="37550-1582">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1582">No</span></span>|<span data-ttu-id="37550-1583">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1583">Yes.</span></span> <span data-ttu-id="37550-1584">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1584">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1585">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1585">Nested Type</span></span>|<span data-ttu-id="37550-1586">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1586">No</span></span>|<span data-ttu-id="37550-1587">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1587">No</span></span>|  
|<span data-ttu-id="37550-1588">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1588">Property</span></span>|<span data-ttu-id="37550-1589">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1589">Not applicable</span></span>|<span data-ttu-id="37550-1590">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1590">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1591">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1591">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1592">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1592">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1593">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1593">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1594">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1594">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1595">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1595">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1596">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1596">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1597">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1597">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1598">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1598">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1599">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1599">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1600">Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1600">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="37550-1601">Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1601">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1602">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1602">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1603">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1603">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1604">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1604">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1605">`BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1605">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1606">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1606">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1607">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1607">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1608">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1608">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1609">Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1609">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1610">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1610">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1611">Para métodos genéricos, não inclua os argumentos de tipo em `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1611">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="37550-1612">Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="37550-1612">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1613">O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar restrições de associação, convenções de chamada e uma variedade de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="37550-1613">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1614">O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.</span><span class="sxs-lookup"><span data-stu-id="37550-1614">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1615">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1615">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1616"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1616"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1617">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1617">-or-</span></span> 
 <span data-ttu-id="37550-1618"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1618"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-1619">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1619">-or-</span></span> 
<span data-ttu-id="37550-1620">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1620">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1621"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1621"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-1622">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1622">-or-</span></span> 
 <span data-ttu-id="37550-1623"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1623"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1624">A cadeia de caracteres que contém o nome do método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1624">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1625">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1625">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1626">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1626">-or-</span></span> 
<span data-ttu-id="37550-1627">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1627">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-1628">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-1628">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-1629">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1629">-or-</span></span> 
<span data-ttu-id="37550-1630">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1630">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="37550-1631">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a como o valor retornado é passado, quais registros são usados para argumentos e qual processo limpa a pilha.</span><span class="sxs-lookup"><span data-stu-id="37550-1631">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="37550-1632">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1632">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="37550-1633">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1633">-or-</span></span> 
<span data-ttu-id="37550-1634">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um método que não aceita parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1634">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="37550-1635">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1635">-or-</span></span> 
 <span data-ttu-id="37550-1636"><see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1636"><see langword="null" />.</span></span> <span data-ttu-id="37550-1637">Se <paramref name="types" /> for <see langword="null" />, os argumentos não serão correspondidos.</span><span class="sxs-lookup"><span data-stu-id="37550-1637">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-1638">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1638">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-1639">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-1639">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-1640">Quando substituído em uma classe derivada, pesquisa o método especificado, cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-1640">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="37550-1641">Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1641">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1642">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-1642">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-1643">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-1643">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-1644">Se `types` for `null`, os argumentos não serão correspondidos.</span><span class="sxs-lookup"><span data-stu-id="37550-1644">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="37550-1645">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1646">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1647">Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1647">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="37550-1648">Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1648">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1649">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1649">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1650">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1650">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1651">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1651">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1652">`BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1652">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1653">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1653">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1654">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1654">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1655"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1655"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-1656"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1656"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-1657">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1657">-or-</span></span> 
 <span data-ttu-id="37550-1658"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-1658"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-1659">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1659">-or-</span></span> 
 <span data-ttu-id="37550-1660"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-1660"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-1661">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1661">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1662">Obtém os métodos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1662">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1663">Retorna todos os métodos públicos do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1663">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1664">Uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam todos os métodos públicos definidos para o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1664">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-1665">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1665">-or-</span></span> 
<span data-ttu-id="37550-1666">Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método público for definido para o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1666">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1667">O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1667">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1668">Seu código não deve depender a ordem na qual os métodos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1668">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1669">Construtores não são incluídos na matriz de métodos retornados por essa chamada.</span><span class="sxs-lookup"><span data-stu-id="37550-1669">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="37550-1670">Fazer uma chamada separada para `GetConstructors()` para obter os métodos de construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-1670">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="37550-1671">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1671">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1672">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1672">Member Type</span></span>|<span data-ttu-id="37550-1673">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1673">Static</span></span>|<span data-ttu-id="37550-1674">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1674">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1675">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1675">Constructor</span></span>|<span data-ttu-id="37550-1676">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1676">No</span></span>|<span data-ttu-id="37550-1677">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1677">No</span></span>|  
|<span data-ttu-id="37550-1678">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1678">Field</span></span>|<span data-ttu-id="37550-1679">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1679">No</span></span>|<span data-ttu-id="37550-1680">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1680">Yes.</span></span> <span data-ttu-id="37550-1681">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1681">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1682">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1682">Event</span></span>|<span data-ttu-id="37550-1683">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1683">Not applicable</span></span>|<span data-ttu-id="37550-1684">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1684">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1685">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1685">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1686">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1686">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1687">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1687">Method</span></span>|<span data-ttu-id="37550-1688">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1688">No</span></span>|<span data-ttu-id="37550-1689">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1689">Yes.</span></span> <span data-ttu-id="37550-1690">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1690">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1691">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1691">Nested Type</span></span>|<span data-ttu-id="37550-1692">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1692">No</span></span>|<span data-ttu-id="37550-1693">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1693">No</span></span>|  
|<span data-ttu-id="37550-1694">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1694">Property</span></span>|<span data-ttu-id="37550-1695">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1695">Not applicable</span></span>|<span data-ttu-id="37550-1696">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1696">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1697">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1697">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1698">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1698">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1699">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1699">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1700">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1700">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1701">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1701">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1702">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1702">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1703">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1703">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1704">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1704">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1705">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1705">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1706">Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1706">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1707">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1707">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-1708">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1708">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1709">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1709">-or-</span></span> 
<span data-ttu-id="37550-1710">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1710">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1711">Quando é substituído em uma classe derivada, pesquisa os métodos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1711">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1712">Uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> representando todos os métodos definidos para o <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1712">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="37550-1713">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1713">-or-</span></span> 
<span data-ttu-id="37550-1714">Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método estiver definido para o atual <see cref="T:System.Type" />, ou se nenhum dos métodos definidos corresponder às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1714">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1715">O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1715">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1716">Seu código não deve depender a ordem na qual os métodos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1716">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1717">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1718">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1718">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1719">Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1719">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="37550-1720">Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1720">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="37550-1721">Somente protegido e métodos internos em classes base são retornados; métodos privados em classes base não são retornados.</span><span class="sxs-lookup"><span data-stu-id="37550-1721">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="37550-1722">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1722">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1723">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1723">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1724">`BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1724">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1725">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1725">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1726">Não é possível omitir parâmetros durante a pesquisa de construtores e métodos.</span><span class="sxs-lookup"><span data-stu-id="37550-1726">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="37550-1727">Só é possível omitir parâmetros durante a invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-1727">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="37550-1728">Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1728">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1729">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1729">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1730">O exemplo a seguir cria uma classe com dois métodos públicos e um método protegido, cria uma `Type` objeto correspondente `MyTypeClass`, obtém todos os métodos públicos e não públicos e exibe seus nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-1730">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1731">Obtém um tipo específico aninhado no <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1731">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1732">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1732">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="37550-1733">Pesquisa o tipo aninhado público com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1733">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-1734">Um objeto que representa o tipo aninhado público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1734">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1735">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1735">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="37550-1736">Use o nome simple da classe aninhada para `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1736">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="37550-1737">Não qualifique-o com o nome da classe externa.</span><span class="sxs-lookup"><span data-stu-id="37550-1737">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="37550-1738">Para uma classe aninhada genérica, use o nome danificado - ou seja, acrescente um acento grave e o número de argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-1738">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="37550-1739">Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico de classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1739">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="37550-1740">Não inclua a sintaxe específica da linguagem para parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1740">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="37550-1741">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1741">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1742">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1742">Member Type</span></span>|<span data-ttu-id="37550-1743">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1743">Static</span></span>|<span data-ttu-id="37550-1744">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1744">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1745">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1745">Constructor</span></span>|<span data-ttu-id="37550-1746">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1746">No</span></span>|<span data-ttu-id="37550-1747">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1747">No</span></span>|  
|<span data-ttu-id="37550-1748">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1748">Field</span></span>|<span data-ttu-id="37550-1749">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1749">No</span></span>|<span data-ttu-id="37550-1750">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1750">Yes.</span></span> <span data-ttu-id="37550-1751">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1751">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1752">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1752">Event</span></span>|<span data-ttu-id="37550-1753">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1753">Not applicable</span></span>|<span data-ttu-id="37550-1754">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1754">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1755">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1755">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1756">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1756">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1757">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1757">Method</span></span>|<span data-ttu-id="37550-1758">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1758">No</span></span>|<span data-ttu-id="37550-1759">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1759">Yes.</span></span> <span data-ttu-id="37550-1760">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1760">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1761">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1761">Nested Type</span></span>|<span data-ttu-id="37550-1762">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1762">No</span></span>|<span data-ttu-id="37550-1763">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1763">No</span></span>|  
|<span data-ttu-id="37550-1764">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1764">Property</span></span>|<span data-ttu-id="37550-1765">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1765">Not applicable</span></span>|<span data-ttu-id="37550-1766">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1766">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1767">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1767">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1768">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1768">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1769">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1769">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1770">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1770">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1771">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1771">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1772">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1772">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1773">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1773">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1774">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1774">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-1775">Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1775">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="37550-1776">Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-1776">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1777">Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios.</span><span class="sxs-lookup"><span data-stu-id="37550-1777">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="37550-1778">Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="37550-1778">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="37550-1779">Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1779">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1780"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1780"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1781">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-1781">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1782">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1782">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1783">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1783">-or-</span></span> 
<span data-ttu-id="37550-1784">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1784">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1785">Quando substituído em uma classe derivada, pesquisa as propriedades do tipo aninhado especificado, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1785">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1786">Um objeto que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1786">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1787">Use o nome simple da classe aninhada para `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1787">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="37550-1788">Não qualifique-o com o nome da classe externa.</span><span class="sxs-lookup"><span data-stu-id="37550-1788">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="37550-1789">Para uma classe aninhada genérica, use o nome danificado - ou seja, acrescente um acento grave e o número de parâmetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-1789">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="37550-1790">Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico de classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1790">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="37550-1791">Não inclua a sintaxe específica da linguagem para parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1791">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="37550-1792">O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1792">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1793">Você deve especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1793">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1794">Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1794">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="37550-1795">Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir tipos aninhados de não-públicos (ou seja, particulares, internos e protegidos tipos aninhados) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1795">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="37550-1796">Esse método retorna apenas os tipos aninhados do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1796">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="37550-1797">Ele pesquisa as classes base do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1797">It does not search the base classes of the current type.</span></span> <span data-ttu-id="37550-1798">Para localizar os tipos que estão aninhados em classes base, você deve movimentar a hierarquia de herança, chamar <xref:System.Type.GetNestedType%2A> em cada nível.</span><span class="sxs-lookup"><span data-stu-id="37550-1798">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="37550-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="37550-1800">Chamar esse método apenas com o <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.</span><span class="sxs-lookup"><span data-stu-id="37550-1800">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="37550-1801">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1801">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1802">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1802">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-1803">Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1803">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="37550-1804">Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-1804">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1805">Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios.</span><span class="sxs-lookup"><span data-stu-id="37550-1805">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="37550-1806">Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="37550-1806">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="37550-1807">Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1807">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1808"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1808"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1809">Obtém os tipos aninhados no <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1809">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1810">Retorna os tipos públicos aninhados no <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1810">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1811">Uma matriz de <see cref="T:System.Type" /> objetos que representam os tipos públicos aninhados no <see cref="T:System.Type" /> atual (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" /> se não há tipos públicos são aninhados no <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1811">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1812">O <xref:System.Type.GetNestedTypes%2A> método não retorna tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1812">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1813">Seu código não deve depender a ordem na qual os tipos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1813">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1814">Somente os tipos públicos aninhados imediatamente no tipo atual são retornados; a pesquisa não é recursiva.</span><span class="sxs-lookup"><span data-stu-id="37550-1814">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="37550-1815">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1815">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1816">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1816">Member Type</span></span>|<span data-ttu-id="37550-1817">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1817">Static</span></span>|<span data-ttu-id="37550-1818">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1818">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1819">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1819">Constructor</span></span>|<span data-ttu-id="37550-1820">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1820">No</span></span>|<span data-ttu-id="37550-1821">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1821">No</span></span>|  
|<span data-ttu-id="37550-1822">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1822">Field</span></span>|<span data-ttu-id="37550-1823">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1823">No</span></span>|<span data-ttu-id="37550-1824">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1824">Yes.</span></span> <span data-ttu-id="37550-1825">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1825">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1826">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1826">Event</span></span>|<span data-ttu-id="37550-1827">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1827">Not applicable</span></span>|<span data-ttu-id="37550-1828">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1828">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1829">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1829">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1830">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1830">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1831">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1831">Method</span></span>|<span data-ttu-id="37550-1832">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1832">No</span></span>|<span data-ttu-id="37550-1833">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1833">Yes.</span></span> <span data-ttu-id="37550-1834">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1834">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1835">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1835">Nested Type</span></span>|<span data-ttu-id="37550-1836">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1836">No</span></span>|<span data-ttu-id="37550-1837">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1837">No</span></span>|  
|<span data-ttu-id="37550-1838">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1838">Property</span></span>|<span data-ttu-id="37550-1839">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1839">Not applicable</span></span>|<span data-ttu-id="37550-1840">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1840">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1841">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1841">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1842">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1842">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1843">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1843">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1844">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1844">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1845">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1845">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1846">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1846">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1847">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1847">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1848">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1848">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-1849">Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1849">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="37550-1850">Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-1850">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1851">Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios.</span><span class="sxs-lookup"><span data-stu-id="37550-1851">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="37550-1852">Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="37550-1852">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="37550-1853">Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1853">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1854">O exemplo a seguir define uma classe aninhada e um `struct` na `MyClass`e, em seguida, obtém os objetos dos tipos aninhados usando o tipo do `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="37550-1854">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-1855">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1855">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1856">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1856">-or-</span></span> 
<span data-ttu-id="37550-1857">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1857">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1858">Quando é substituído em uma classe derivada, pesquisa as propriedades do <see cref="T:System.Type" /> atual, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1858">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1859">Uma matriz de objetos <see cref="T:System.Type" /> que representam todos os tipos aninhados no <see cref="T:System.Type" /> atual que coincidem com as restrições de associação especificadas (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhum dos tipos aninhados são encontrados que correspondem às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1859">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1860">A pesquisa por tipos aninhados não é recursiva.</span><span class="sxs-lookup"><span data-stu-id="37550-1860">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="37550-1861">O <xref:System.Type.GetNestedTypes%2A> método não retorna tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1861">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1862">Seu código não deve depender a ordem na qual os tipos são retornados, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1862">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1863">O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1863">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1864">Você deve especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1864">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1865">Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1865">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="37550-1866">Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir tipos aninhados de não-públicos (ou seja, particulares, internos e protegidos tipos aninhados) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1866">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="37550-1867">Esse método retorna apenas os tipos aninhados do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1867">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="37550-1868">Ele pesquisa as classes base do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1868">It does not search the base classes of the current type.</span></span> <span data-ttu-id="37550-1869">Para localizar os tipos que estão aninhados em classes base, você deve movimentar a hierarquia de herança, chamar <xref:System.Type.GetNestedTypes%2A> em cada nível.</span><span class="sxs-lookup"><span data-stu-id="37550-1869">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="37550-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="37550-1871">Chamar esse método apenas com o <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.</span><span class="sxs-lookup"><span data-stu-id="37550-1871">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="37550-1872">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1872">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1873">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1873">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-1874">Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-1874">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="37550-1875">Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-1875">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-1876">Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios.</span><span class="sxs-lookup"><span data-stu-id="37550-1876">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="37550-1877">Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="37550-1877">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="37550-1878">Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1878">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1879">O exemplo a seguir cria duas classes públicas aninhadas e duas classes aninhadas de protegido e exibe informações para as classes que correspondem às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1879">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1880">Obtém as propriedades do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1880">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-1881">Retorna todas as propriedades públicas do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1881">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-1882">Uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas as propriedades públicas do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1882">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="37550-1883">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1883">-or-</span></span> 
<span data-ttu-id="37550-1884">Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades públicas.</span><span class="sxs-lookup"><span data-stu-id="37550-1884">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1885">Chamar essa sobrecarga é equivalente a chamar o <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> sobrecarga com um `bindingAttr` argumento igual a `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` em c# e `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="37550-1885">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="37550-1886">Ele retorna todas as instância pública e propriedades estáticas, tanto aqueles definidos pelo tipo representado por atual <xref:System.Type> objeto, bem como aqueles herdados de seus tipos base.</span><span class="sxs-lookup"><span data-stu-id="37550-1886">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="37550-1887">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-1887">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-1888">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-1888">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-1889">O <xref:System.Type.GetProperties%2A> método não retorna as propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1889">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1890">Seu código não deve depender a ordem na qual as propriedades são retornadas, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1890">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1891">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1891">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-1892">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-1892">Member Type</span></span>|<span data-ttu-id="37550-1893">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-1893">Static</span></span>|<span data-ttu-id="37550-1894">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-1894">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-1895">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-1895">Constructor</span></span>|<span data-ttu-id="37550-1896">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1896">No</span></span>|<span data-ttu-id="37550-1897">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1897">No</span></span>|  
|<span data-ttu-id="37550-1898">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-1898">Field</span></span>|<span data-ttu-id="37550-1899">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1899">No</span></span>|<span data-ttu-id="37550-1900">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1900">Yes.</span></span> <span data-ttu-id="37550-1901">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1901">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1902">evento</span><span class="sxs-lookup"><span data-stu-id="37550-1902">Event</span></span>|<span data-ttu-id="37550-1903">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1903">Not applicable</span></span>|<span data-ttu-id="37550-1904">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1904">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1905">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1905">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1906">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1906">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-1907">Método</span><span class="sxs-lookup"><span data-stu-id="37550-1907">Method</span></span>|<span data-ttu-id="37550-1908">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1908">No</span></span>|<span data-ttu-id="37550-1909">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-1909">Yes.</span></span> <span data-ttu-id="37550-1910">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1910">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-1911">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-1911">Nested Type</span></span>|<span data-ttu-id="37550-1912">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1912">No</span></span>|<span data-ttu-id="37550-1913">Não</span><span class="sxs-lookup"><span data-stu-id="37550-1913">No</span></span>|  
|<span data-ttu-id="37550-1914">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-1914">Property</span></span>|<span data-ttu-id="37550-1915">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-1915">Not applicable</span></span>|<span data-ttu-id="37550-1916">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1916">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-1917">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1917">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1918">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-1918">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-1919">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1919">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-1920">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-1920">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-1921">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-1921">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-1922">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-1922">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-1923">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-1923">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-1924">Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1924">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1925">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1925">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1926">O exemplo a seguir demonstra o uso do método `GetProperties`.</span><span class="sxs-lookup"><span data-stu-id="37550-1926">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="37550-1927">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1927">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1928">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1928">-or-</span></span> 
<span data-ttu-id="37550-1929">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1929">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1930">Quando é substituído em uma classe derivada, pesquisa as propriedades do atual <see cref="T:System.Type" />, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1930">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1931">Uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas as propriedades do <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1931">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="37550-1932">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1932">-or-</span></span> 
<span data-ttu-id="37550-1933">Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades, ou se nenhuma das propriedades corresponderem às restrições de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-1933">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1934">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-1934">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-1935">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-1935">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-1936">O <xref:System.Type.GetProperties%2A> método não retorna as propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="37550-1936">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="37550-1937">Seu código não deve depender a ordem na qual as propriedades são retornadas, porque essa ordem varia.</span><span class="sxs-lookup"><span data-stu-id="37550-1937">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="37550-1938">O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1938">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1939">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1939">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1940">Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="37550-1941">Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1941">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="37550-1942">Somente protegido e propriedades internas em classes base são retornadas; as propriedades privadas em classes base não são retornadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1942">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="37550-1943">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1943">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1944">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1944">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1945">`BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1945">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-1946">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-1946">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-1947">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-1947">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-1948">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-1948">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-1949">Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="37550-1949">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1950">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1950">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1951">O exemplo a seguir define uma classe chamada `PropertyClass` que inclui seis propriedades: dois são públicos, um é privado, uma é protegida, um é interno (`Friend` no Visual Basic), e um está protegido interno (`Protected Friend` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1951">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="37550-1952">Ele então exibe algumas informações básicas de propriedade (o nome da propriedade e o tipo, se ele é leitura/gravação e a visibilidade de seu `get` e `set` acessadores) para as propriedades que correspondem às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1952">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-1953">Obtém uma propriedade específica do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-1953">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1954">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-1954">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="37550-1955">Pesquisa a propriedade pública com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1955">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="37550-1956">Um objeto que representa a propriedade pública com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1956">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1957">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-1957">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-1958">A pesquisa inclui propriedades de instância estática pública e pública.</span><span class="sxs-lookup"><span data-stu-id="37550-1958">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="37550-1959">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-1959">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-1960">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-1960">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-1961">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-1961">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-1962">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-1962">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-1963">Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-1963">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="37550-1964">Um tipo contém duas propriedades indexadas que têm o mesmo nome, mas diferentes números de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-1964">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="37550-1965">Para resolver a ambiguidade, use uma sobrecarga da <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-1965">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="37550-1966">Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-1966">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="37550-1967">Para resolver a ambiguidade, use o <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> sobrecarga de método e adicione o <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> sinalizador para restringir a pesquisa a membros que não são herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-1967">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-1968">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-1968">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-1970">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-1970">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-1971">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1971">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-1972">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-1972">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-1973">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-1973">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-1974">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-1974">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-1975">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-1975">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-1976">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-1976">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-1977">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-1977">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-1978">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-1978">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-1979">O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1979">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="37550-1980">Internamente, essa propriedade é chamada nos metadados com o nome "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-1980">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="37550-1981">Qualquer tentativa de obter `PropertyInfo` usando a reflexão deve especificar esse nome interno para retornar corretamente o `PropertyInfo` propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-1981">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-1982">Foi encontrada mais de uma propriedade com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-1982">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-1983"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1983"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-1984">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-1984">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-1985">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-1985">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-1986">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-1986">-or-</span></span> 
<span data-ttu-id="37550-1987">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1987">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="37550-1988">Pesquisa a propriedade especificada usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1988">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-1989">Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-1989">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-1990">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-1990">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-1991">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-1991">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-1992">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-1992">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-1993">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-1993">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-1994">Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1994">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="37550-1995">Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-1995">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="37550-1996">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-1996">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-1997">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-1997">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-1998">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-1998">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-1999">`BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.</span><span class="sxs-lookup"><span data-stu-id="37550-1999">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-2000">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-2000">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-2001">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2001">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2002">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2002">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="37550-2003">Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-2003">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="37550-2004">Um tipo contém duas propriedades indexadas que têm o mesmo nome, mas diferentes números de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-2004">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="37550-2005">Para resolver a ambiguidade, use uma sobrecarga da <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2005">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="37550-2006">Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-2006">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="37550-2007">Para resolver a ambiguidade, inclua <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para restringir a pesquisa a membros que não são herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-2007">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2008">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2008">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2010">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2010">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2011">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2011">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2012">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2012">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2013">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2013">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2014">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2014">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2015">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2015">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2016">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2016">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2017">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2017">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2018">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2018">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-2019">O exemplo a seguir recupera o tipo de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade de acordo com as restrições de associação especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2019">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2020">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2020">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2021"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2021"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2022">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2022">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="37550-2023">O tipo de retorno da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2023">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="37550-2024">Pesquisa a propriedade pública com o nome e tipo retornado especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2024">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="37550-2025">Um objeto que representa a propriedade pública com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2025">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2026">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-2026">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-2027">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2027">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-2028">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2028">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-2029">A pesquisa inclui propriedades de instância estática pública e pública.</span><span class="sxs-lookup"><span data-stu-id="37550-2029">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="37550-2030">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2030">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2031">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2031">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2032">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2032">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2034">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2034">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2035">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2035">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2036">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2036">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2037">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2037">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2038">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2038">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2039">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2039">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2040">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2040">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2041">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2041">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2042">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2042">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-2043">O exemplo a seguir define uma classe com uma propriedade e recupera o nome e o tipo da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2043">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2044">Foi encontrada mais de uma propriedade com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2044">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2045">O <paramref name="name" /> é <see langword="null" /> ou o <paramref name="returnType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2045"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2046">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2046">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="37550-2047">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2047">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="37550-2048">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2048">-or-</span></span> 
<span data-ttu-id="37550-2049">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</span><span class="sxs-lookup"><span data-stu-id="37550-2049">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="37550-2050">Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2050">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="37550-2051">Um objeto que representa a propriedade pública cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2051">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2052">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-2052">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-2053">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2053">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-2054">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2054">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-2055">A pesquisa inclui propriedades de instância estática pública e pública.</span><span class="sxs-lookup"><span data-stu-id="37550-2055">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="37550-2056">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2056">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2057">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2057">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2058">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2058">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2060">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2060">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2061">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2061">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2062">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2062">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2063">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2063">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2064">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2064">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2065">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2065">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2066">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2066">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2067">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2067">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2068">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2068">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-2069">O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera a propriedade dessa classe e exibe o nome da propriedade e o tipo da propriedade conforme especificado pelos argumentos passados para `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-2069">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2070">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2070">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2071"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2071"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2072">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2072">-or-</span></span> 
 <span data-ttu-id="37550-2073"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2073"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2074"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2074"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="37550-2075">Um elemento de <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2075">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2076">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2076">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="37550-2077">O tipo de retorno da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2077">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="37550-2078">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2078">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="37550-2079">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2079">-or-</span></span> 
<span data-ttu-id="37550-2080">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</span><span class="sxs-lookup"><span data-stu-id="37550-2080">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="37550-2081">Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2081">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="37550-2082">Um objeto que representa a propriedade pública cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2082">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2083">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-2083">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-2084">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2084">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-2085">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2085">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-2086">A pesquisa inclui propriedades de instância estática pública e pública.</span><span class="sxs-lookup"><span data-stu-id="37550-2086">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="37550-2087">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2087">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2088">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2088">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2089">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2089">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2091">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2091">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2092">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2092">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2093">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2093">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2094">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2094">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2095">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2095">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2096">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2096">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2097">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2097">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2098">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2098">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2099">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2099">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2100">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2100">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2101"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2101"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2102">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2102">-or-</span></span> 
 <span data-ttu-id="37550-2103"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2103"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2104"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2104"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="37550-2105">Um elemento de <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2105">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2106">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2106">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="37550-2107">O tipo de retorno da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2107">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="37550-2108">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2108">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="37550-2109">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2109">-or-</span></span> 
<span data-ttu-id="37550-2110">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</span><span class="sxs-lookup"><span data-stu-id="37550-2110">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-2111">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2111">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-2112">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2112">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-2113">Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento e modificadores especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2113">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="37550-2114">Um objeto que representa a propriedade pública que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2114">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2115">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-2115">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-2116">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2116">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-2117">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-2117">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-2118">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2118">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-2119">A pesquisa de `name` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2119">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="37550-2120">A pesquisa inclui propriedades de instância estática pública e pública.</span><span class="sxs-lookup"><span data-stu-id="37550-2120">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="37550-2121">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2121">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2122">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2122">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2123">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2123">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2125">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2125">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2126">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2126">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2127">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2127">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2128">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2128">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2129">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2129">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2130">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2130">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2131">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2131">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2132">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2132">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2133">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2133">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-2134">O exemplo a seguir obtém uma `Type` objeto correspondente `MyPropertyClass`, e a propriedade indexada dessa classe é recuperada usando os argumentos passados para o `GetProperty` método.</span><span class="sxs-lookup"><span data-stu-id="37550-2134">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2135">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento e modificadores especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2135">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2136"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2136"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2137">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2137">-or-</span></span> 
 <span data-ttu-id="37550-2138"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2138"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2139"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2139"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2140">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2140">-or-</span></span> 
 <span data-ttu-id="37550-2141"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2141"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2142">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2142">-or-</span></span> 
 <span data-ttu-id="37550-2143"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-2143"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="37550-2144">Um elemento de <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2144">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2145">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2145">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-2146">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-2146">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-2147">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2147">-or-</span></span> 
<span data-ttu-id="37550-2148">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2148">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-2149">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-2149">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-2150">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2150">-or-</span></span> 
<span data-ttu-id="37550-2151">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2151">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="37550-2152">O tipo de retorno da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2152">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="37550-2153">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2153">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="37550-2154">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2154">-or-</span></span> 
<span data-ttu-id="37550-2155">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</span><span class="sxs-lookup"><span data-stu-id="37550-2155">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-2156">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2156">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-2157">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2157">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-2158">Pesquisa a propriedade especificada cujos parâmetros correspondem aos modificadores e tipos de argumento especificados, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2158">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-2159">Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2159">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2160">Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público.</span><span class="sxs-lookup"><span data-stu-id="37550-2160">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="37550-2161">Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2161">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="37550-2162">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-2162">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-2163">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2163">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-2164">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2164">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-2165">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-2165">Member Type</span></span>|<span data-ttu-id="37550-2166">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-2166">Static</span></span>|<span data-ttu-id="37550-2167">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-2167">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-2168">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-2168">Constructor</span></span>|<span data-ttu-id="37550-2169">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2169">No</span></span>|<span data-ttu-id="37550-2170">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2170">No</span></span>|  
|<span data-ttu-id="37550-2171">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-2171">Field</span></span>|<span data-ttu-id="37550-2172">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2172">No</span></span>|<span data-ttu-id="37550-2173">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2173">Yes.</span></span> <span data-ttu-id="37550-2174">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2174">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2175">evento</span><span class="sxs-lookup"><span data-stu-id="37550-2175">Event</span></span>|<span data-ttu-id="37550-2176">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2176">Not applicable</span></span>|<span data-ttu-id="37550-2177">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2177">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2178">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2178">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2179">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2179">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-2180">Método</span><span class="sxs-lookup"><span data-stu-id="37550-2180">Method</span></span>|<span data-ttu-id="37550-2181">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2181">No</span></span>|<span data-ttu-id="37550-2182">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2182">Yes.</span></span> <span data-ttu-id="37550-2183">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2183">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2184">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-2184">Nested Type</span></span>|<span data-ttu-id="37550-2185">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2185">No</span></span>|<span data-ttu-id="37550-2186">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2186">No</span></span>|  
|<span data-ttu-id="37550-2187">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-2187">Property</span></span>|<span data-ttu-id="37550-2188">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2188">Not applicable</span></span>|<span data-ttu-id="37550-2189">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2189">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2190">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2190">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2191">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2191">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-2192">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2192">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-2193">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-2193">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-2194">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2194">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2195">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-2195">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-2196">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-2196">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-2197">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-2197">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-2198">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-2198">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-2199">Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-2199">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="37550-2200">Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-2200">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="37550-2201">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-2201">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-2202">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-2202">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-2203">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-2203">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-2204">`BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2204">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-2205">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-2205">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-2206">Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.</span><span class="sxs-lookup"><span data-stu-id="37550-2206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="37550-2207">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-2207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="37550-2208">Indexadores e propriedades padrão</span><span class="sxs-lookup"><span data-stu-id="37550-2208">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="37550-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="37550-2210">Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3.</span><span class="sxs-lookup"><span data-stu-id="37550-2210">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="37550-2211">É possível sobrecarregar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2211">You can overload the property.</span></span>  
  
 <span data-ttu-id="37550-2212">No C#, este recurso é chamado de indexador e não pode ser referenciado por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-2212">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="37550-2213">Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item".</span><span class="sxs-lookup"><span data-stu-id="37550-2213">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="37550-2214">No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-2214">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="37550-2215">Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2215">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="37550-2216">As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.</span><span class="sxs-lookup"><span data-stu-id="37550-2216">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="37550-2217">Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-2217">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="37550-2218">Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2218">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2219">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2219">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2220"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2220"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2221">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2221">-or-</span></span> 
 <span data-ttu-id="37550-2222"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2222"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2223"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2223"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2224">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2224">-or-</span></span> 
 <span data-ttu-id="37550-2225"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2225"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2226">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2226">-or-</span></span> 
 <span data-ttu-id="37550-2227"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-2227"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="37550-2228">Um elemento de <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2228">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-2229">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2229">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="37550-2230">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-2230">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="37550-2231">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2231">-or-</span></span> 
<span data-ttu-id="37550-2232">Zero, para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2232">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-2233">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um membro sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-2233">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-2234">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2234">-or-</span></span> 
<span data-ttu-id="37550-2235">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2235">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="37550-2236">O tipo de retorno da propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2236">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="37550-2237">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-2237">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="37550-2238">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2238">-or-</span></span> 
<span data-ttu-id="37550-2239">Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</span><span class="sxs-lookup"><span data-stu-id="37550-2239">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-2240">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2240">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="37550-2241">O associador padrão não processa este parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2241">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="37550-2242">Quando substituído em uma classe derivada, pesquisa a propriedade especificada cujos parâmetros correspondem aos modificadores e tipos de argumento especificados, usando as restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2242">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="37550-2243">Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2243">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2244">Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="37550-2244">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="37550-2245">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2245">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-2246">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-2246">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-2247">Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.</span><span class="sxs-lookup"><span data-stu-id="37550-2247">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="37550-2248">Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-2248">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="37550-2249">Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-2249">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="37550-2250">Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.</span><span class="sxs-lookup"><span data-stu-id="37550-2250">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="37550-2251">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-2251">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-2252">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-2252">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-2253">`BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2253">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-2254">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-2254">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-2255">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2255">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2256"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2256"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2257">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2257">-or-</span></span> 
 <span data-ttu-id="37550-2258"><paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2258"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-2259">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2259">-or-</span></span> 
<span data-ttu-id="37550-2260">Um dos elementos em <paramref name="types" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2260">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2261"><paramref name="types" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2261"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2262">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2262">-or-</span></span> 
 <span data-ttu-id="37550-2263"><paramref name="modifiers" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-2263"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="37550-2264">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2264">-or-</span></span> 
 <span data-ttu-id="37550-2265"><paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-2265"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-2266">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2266">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-2267">Obtém um objeto <see cref="T:System.Type" /> que representa o tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2267">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-2268">Obtém o <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-2268">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-2269">O <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-2269">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2270">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2270">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-2271">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-2271">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2272">O nome qualificado pelo assembly do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2272">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="37550-2273">Consulte <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2273">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="37550-2274">Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2274">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="37550-2275">Obtém o <see cref="T:System.Type" /> com o nome especificado, com a execução de uma pesquisa que diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2275">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="37550-2276">O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2276">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2277">Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="37550-2277">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="37550-2278"><xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`.</span><span class="sxs-lookup"><span data-stu-id="37550-2278"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="37550-2279">Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-2279">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="37550-2280">Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar no c#, <xref:System.Type.GetType%2A> no Visual Basic ou C++.</span><span class="sxs-lookup"><span data-stu-id="37550-2280">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2281">Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%29> retorno do método `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2281">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="37550-2282">Ele não gerará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2282">It does not throw an exception.</span></span> <span data-ttu-id="37550-2283">Para controlar se uma exceção é lançada, chame uma sobrecarga da <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2283">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="37550-2284"><xref:System.Type.GetType%2A> funciona somente em assemblies carregados do disco.</span><span class="sxs-lookup"><span data-stu-id="37550-2284"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="37550-2285">Se você chamar <xref:System.Type.GetType%2A> para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente.</span><span class="sxs-lookup"><span data-stu-id="37550-2285">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="37550-2286">O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-2286">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="37550-2287">Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2287">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="37550-2288">Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2288">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="37550-2289">`GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2289">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="37550-2290">Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar.</span><span class="sxs-lookup"><span data-stu-id="37550-2290">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="37550-2291">Caso contrário, você obterá duas cópias do assembly na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-2291">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="37550-2292">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2292">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-2293">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-2293">Member Type</span></span>|<span data-ttu-id="37550-2294">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-2294">Static</span></span>|<span data-ttu-id="37550-2295">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-2295">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-2296">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-2296">Constructor</span></span>|<span data-ttu-id="37550-2297">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2297">No</span></span>|<span data-ttu-id="37550-2298">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2298">No</span></span>|  
|<span data-ttu-id="37550-2299">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-2299">Field</span></span>|<span data-ttu-id="37550-2300">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2300">No</span></span>|<span data-ttu-id="37550-2301">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2301">Yes.</span></span> <span data-ttu-id="37550-2302">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2302">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2303">evento</span><span class="sxs-lookup"><span data-stu-id="37550-2303">Event</span></span>|<span data-ttu-id="37550-2304">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2304">Not applicable</span></span>|<span data-ttu-id="37550-2305">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2305">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2306">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2306">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2307">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2307">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-2308">Método</span><span class="sxs-lookup"><span data-stu-id="37550-2308">Method</span></span>|<span data-ttu-id="37550-2309">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2309">No</span></span>|<span data-ttu-id="37550-2310">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2310">Yes.</span></span> <span data-ttu-id="37550-2311">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2311">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2312">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-2312">Nested Type</span></span>|<span data-ttu-id="37550-2313">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2313">No</span></span>|<span data-ttu-id="37550-2314">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2314">No</span></span>|  
|<span data-ttu-id="37550-2315">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-2315">Property</span></span>|<span data-ttu-id="37550-2316">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2316">Not applicable</span></span>|<span data-ttu-id="37550-2317">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2317">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2318">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2318">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2319">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2319">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-2320">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2320">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-2321">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-2321">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-2322">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2322">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2323">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-2323">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-2324">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-2324">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-2325">Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2325">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="37550-2326">`typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2326">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="37550-2327">Consulte <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2327">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="37550-2328">Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem.</span><span class="sxs-lookup"><span data-stu-id="37550-2328">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="37550-2329">Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2329">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="37550-2330">Se o assembly tiver um nome forte, um nome de assembly completo é necessário.</span><span class="sxs-lookup"><span data-stu-id="37550-2330">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="37550-2331">O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2331">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="37550-2332">Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-2332">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2333">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2333">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="37550-2334">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="37550-2334">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="37550-2335">No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-2335">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="37550-2336">Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-2336">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="37550-2337">Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2337">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="37550-2338">Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-2338">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="37550-2339">Delimitador</span><span class="sxs-lookup"><span data-stu-id="37550-2339">Delimiter</span></span>|<span data-ttu-id="37550-2340">Significado</span><span class="sxs-lookup"><span data-stu-id="37550-2340">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="37550-2341">Barra invertida (\\)</span><span class="sxs-lookup"><span data-stu-id="37550-2341">Backslash (\\)</span></span>|<span data-ttu-id="37550-2342">Caractere de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2342">Escape character.</span></span>|  
|<span data-ttu-id="37550-2343">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="37550-2343">Backtick (\`)</span></span>|<span data-ttu-id="37550-2344">Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2344">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="37550-2345">Colchetes ([])</span><span class="sxs-lookup"><span data-stu-id="37550-2345">Brackets ([])</span></span>|<span data-ttu-id="37550-2346">Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2346">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="37550-2347">Vírgula (,)</span><span class="sxs-lookup"><span data-stu-id="37550-2347">Comma (,)</span></span>|<span data-ttu-id="37550-2348">Precede o nome Assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2348">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="37550-2349">Ponto final (.)</span><span class="sxs-lookup"><span data-stu-id="37550-2349">Period (.)</span></span>|<span data-ttu-id="37550-2350">Denota identificadores de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2350">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="37550-2351">Sinal de adição (+)</span><span class="sxs-lookup"><span data-stu-id="37550-2351">Plus sign (+)</span></span>|<span data-ttu-id="37550-2352">Precede uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="37550-2352">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="37550-2353">Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:</span><span class="sxs-lookup"><span data-stu-id="37550-2353">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2354">Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="37550-2354">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="37550-2355">A reflexão emite essa cadeia de caracteres da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2355">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2356">Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".</span><span class="sxs-lookup"><span data-stu-id="37550-2356">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="37550-2357">Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-2357">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="37550-2358">Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2358">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="37550-2359"><xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System.</span><span class="sxs-lookup"><span data-stu-id="37550-2359"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="37550-2360"><xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2360"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="37550-2361">Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2361">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="37550-2362">Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2362">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="37550-2363">Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2363">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="37550-2364">No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-2364">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="37550-2365">O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2365">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="37550-2366">A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo.</span><span class="sxs-lookup"><span data-stu-id="37550-2366">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="37550-2367">Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.</span><span class="sxs-lookup"><span data-stu-id="37550-2367">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="37550-2368">Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="37550-2368">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="37550-2369">Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2369">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="37550-2370">Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2370">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="37550-2371">Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes.</span><span class="sxs-lookup"><span data-stu-id="37550-2371">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="37550-2372">Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação.</span><span class="sxs-lookup"><span data-stu-id="37550-2372">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="37550-2373">Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` fromMyAssembly.dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2373">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="37550-2374">Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2374">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="37550-2375">As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2375">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="37550-2376">Tipos anuláveis são um caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-2376">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="37550-2377">Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="37550-2377">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2378">No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2378">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="37550-2379">Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="37550-2379">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="37550-2380">A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-2380">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="37550-2381">Para obter</span><span class="sxs-lookup"><span data-stu-id="37550-2381">To Get</span></span>|<span data-ttu-id="37550-2382">Use</span><span class="sxs-lookup"><span data-stu-id="37550-2382">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="37550-2383">Um valor anulável <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="37550-2383">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="37550-2384">Um ponteiro não gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2384">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="37550-2385">Um ponteiro não gerenciado em um ponteiro para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2385">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="37550-2386">Um ponteiro ou referência gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2386">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="37550-2387">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="37550-2387">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="37550-2388">Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.</span><span class="sxs-lookup"><span data-stu-id="37550-2388">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="37550-2389">Uma classe pai e uma classe aninhada</span><span class="sxs-lookup"><span data-stu-id="37550-2389">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="37550-2390">Uma matriz unidimensional com um limite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="37550-2390">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="37550-2391">Uma matriz unidimensional com um limite inferior desconhecido</span><span class="sxs-lookup"><span data-stu-id="37550-2391">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="37550-2392">Uma matriz de n-dimensional</span><span class="sxs-lookup"><span data-stu-id="37550-2392">An n-dimensional array</span></span>|<span data-ttu-id="37550-2393">Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1.</span><span class="sxs-lookup"><span data-stu-id="37550-2393">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="37550-2394">Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2394">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="37550-2395">Uma matriz de matrizes unidimensionais</span><span class="sxs-lookup"><span data-stu-id="37550-2395">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="37550-2396">Uma matriz bidimensional retangular com limites inferiores desconhecidos</span><span class="sxs-lookup"><span data-stu-id="37550-2396">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="37550-2397">Um tipo genérico com um argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2397">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="37550-2398">Um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2398">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="37550-2399">Um tipo genérico com dois argumentos de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2399">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="37550-2400">Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2400">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="37550-2401">' Type. GetType ("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</span><span class="sxs-lookup"><span data-stu-id="37550-2401">\`\`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</span></span>|  
|<span data-ttu-id="37550-2402">Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2402">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="37550-2403">' Type. GetType ("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")'</span><span class="sxs-lookup"><span data-stu-id="37550-2403">\`\`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")\`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="37550-2404">O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade de `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="37550-2404">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2405"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2405"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2406">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2406">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2407"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2407"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-2408">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2408">-or-</span></span> 
 <span data-ttu-id="37550-2409"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2409"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-2410">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2410">-or-</span></span> 
 <span data-ttu-id="37550-2411"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-2411"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-2412"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2412"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="37550-2413">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2413">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="37550-2414">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2414">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-2415">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-2415">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-2416">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2416">-or-</span></span> 
<span data-ttu-id="37550-2417">A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-2417">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-2418">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-2418">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2419">O nome qualificado pelo assembly do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2419">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="37550-2420">Consulte <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2420">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="37550-2421">Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2421">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-2422"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2422"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="37550-2423">A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="37550-2423">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="37550-2424">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2424">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="37550-2425">Obtém o <see cref="T:System.Type" /> com o nome especificado, realizando uma pesquisa que diferencia minúsculas e maiúsculas e especificando se deve ou não lançar uma exceção se o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2425">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="37550-2426">O tipo com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2426">The type with the specified name.</span></span> <span data-ttu-id="37550-2427">Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="37550-2427">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="37550-2428">Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2428">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="37550-2429">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2429">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2430">Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="37550-2430">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="37550-2431"><xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`.</span><span class="sxs-lookup"><span data-stu-id="37550-2431"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="37550-2432">Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-2432">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="37550-2433">Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.</span><span class="sxs-lookup"><span data-stu-id="37550-2433">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="37550-2434">`GetType` funciona somente em assemblies carregados do disco.</span><span class="sxs-lookup"><span data-stu-id="37550-2434">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="37550-2435">Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente.</span><span class="sxs-lookup"><span data-stu-id="37550-2435">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="37550-2436">O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-2436">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="37550-2437">Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2437">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="37550-2438">Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2438">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="37550-2439">`GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2439">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="37550-2440">Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar.</span><span class="sxs-lookup"><span data-stu-id="37550-2440">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="37550-2441">Caso contrário, você obterá duas cópias do assembly na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-2441">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="37550-2442">O `throwOnError` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2442">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="37550-2443">Algumas exceções são geradas, independentemente do valor de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="37550-2443">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="37550-2444">Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é gerada, mesmo que `throwOnError` é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-2444">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="37550-2445">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2445">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-2446">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-2446">Member Type</span></span>|<span data-ttu-id="37550-2447">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-2447">Static</span></span>|<span data-ttu-id="37550-2448">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-2448">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-2449">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-2449">Constructor</span></span>|<span data-ttu-id="37550-2450">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2450">No</span></span>|<span data-ttu-id="37550-2451">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2451">No</span></span>|  
|<span data-ttu-id="37550-2452">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-2452">Field</span></span>|<span data-ttu-id="37550-2453">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2453">No</span></span>|<span data-ttu-id="37550-2454">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2454">Yes.</span></span> <span data-ttu-id="37550-2455">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2455">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2456">evento</span><span class="sxs-lookup"><span data-stu-id="37550-2456">Event</span></span>|<span data-ttu-id="37550-2457">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2457">Not applicable</span></span>|<span data-ttu-id="37550-2458">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2458">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2459">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2459">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2460">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2460">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-2461">Método</span><span class="sxs-lookup"><span data-stu-id="37550-2461">Method</span></span>|<span data-ttu-id="37550-2462">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2462">No</span></span>|<span data-ttu-id="37550-2463">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2463">Yes.</span></span> <span data-ttu-id="37550-2464">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2464">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2465">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-2465">Nested Type</span></span>|<span data-ttu-id="37550-2466">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2466">No</span></span>|<span data-ttu-id="37550-2467">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2467">No</span></span>|  
|<span data-ttu-id="37550-2468">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-2468">Property</span></span>|<span data-ttu-id="37550-2469">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2469">Not applicable</span></span>|<span data-ttu-id="37550-2470">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2470">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2471">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2471">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2472">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2472">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-2473">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2473">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-2474">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-2474">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-2475">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2475">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2476">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-2476">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-2477">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-2477">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-2478">Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2478">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="37550-2479">`typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2479">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="37550-2480">Consulte <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2480">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="37550-2481">Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem.</span><span class="sxs-lookup"><span data-stu-id="37550-2481">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="37550-2482">Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2482">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="37550-2483">Se o assembly tiver um nome forte, um nome de assembly completo é necessário.</span><span class="sxs-lookup"><span data-stu-id="37550-2483">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="37550-2484">O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-2484">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="37550-2485">Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-2485">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2486">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2486">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="37550-2487">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="37550-2487">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="37550-2488">No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-2488">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="37550-2489">Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-2489">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="37550-2490">Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2490">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="37550-2491">Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-2491">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="37550-2492">Delimitador</span><span class="sxs-lookup"><span data-stu-id="37550-2492">Delimiter</span></span>|<span data-ttu-id="37550-2493">Significado</span><span class="sxs-lookup"><span data-stu-id="37550-2493">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="37550-2494">Barra invertida (\\)</span><span class="sxs-lookup"><span data-stu-id="37550-2494">Backslash (\\)</span></span>|<span data-ttu-id="37550-2495">Caractere de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2495">Escape character.</span></span>|  
|<span data-ttu-id="37550-2496">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="37550-2496">Backtick (\`)</span></span>|<span data-ttu-id="37550-2497">Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2497">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="37550-2498">Colchetes ([])</span><span class="sxs-lookup"><span data-stu-id="37550-2498">Brackets ([])</span></span>|<span data-ttu-id="37550-2499">Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2499">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="37550-2500">Vírgula (,)</span><span class="sxs-lookup"><span data-stu-id="37550-2500">Comma (,)</span></span>|<span data-ttu-id="37550-2501">Precede o nome Assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2501">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="37550-2502">Ponto final (.)</span><span class="sxs-lookup"><span data-stu-id="37550-2502">Period (.)</span></span>|<span data-ttu-id="37550-2503">Denota identificadores de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2503">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="37550-2504">Sinal de adição (+)</span><span class="sxs-lookup"><span data-stu-id="37550-2504">Plus sign (+)</span></span>|<span data-ttu-id="37550-2505">Precede uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="37550-2505">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="37550-2506">Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:</span><span class="sxs-lookup"><span data-stu-id="37550-2506">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2507">Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="37550-2507">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="37550-2508">A reflexão emite essa cadeia de caracteres da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2508">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2509">Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".</span><span class="sxs-lookup"><span data-stu-id="37550-2509">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="37550-2510">Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-2510">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="37550-2511">Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2511">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="37550-2512"><xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System.</span><span class="sxs-lookup"><span data-stu-id="37550-2512"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="37550-2513"><xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2513"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="37550-2514">Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2514">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="37550-2515">Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2515">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="37550-2516">Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2516">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="37550-2517">No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-2517">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="37550-2518">O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2518">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="37550-2519">A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo.</span><span class="sxs-lookup"><span data-stu-id="37550-2519">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="37550-2520">Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.</span><span class="sxs-lookup"><span data-stu-id="37550-2520">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="37550-2521">Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="37550-2521">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="37550-2522">Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2522">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="37550-2523">Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2523">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="37550-2524">Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes.</span><span class="sxs-lookup"><span data-stu-id="37550-2524">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="37550-2525">Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação.</span><span class="sxs-lookup"><span data-stu-id="37550-2525">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="37550-2526">Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` de myAssembly. dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2526">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="37550-2527">Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2527">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="37550-2528">As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2528">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="37550-2529">Tipos anuláveis são um caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-2529">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="37550-2530">Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="37550-2530">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2531">No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2531">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="37550-2532">Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="37550-2532">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="37550-2533">A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-2533">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="37550-2534">Para obter</span><span class="sxs-lookup"><span data-stu-id="37550-2534">To Get</span></span>|<span data-ttu-id="37550-2535">Use</span><span class="sxs-lookup"><span data-stu-id="37550-2535">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="37550-2536">Um valor anulável <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="37550-2536">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="37550-2537">Um ponteiro não gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2537">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="37550-2538">Um ponteiro não gerenciado em um ponteiro para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2538">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="37550-2539">Um ponteiro ou referência gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2539">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="37550-2540">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="37550-2540">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="37550-2541">Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.</span><span class="sxs-lookup"><span data-stu-id="37550-2541">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="37550-2542">Uma classe pai e uma classe aninhada</span><span class="sxs-lookup"><span data-stu-id="37550-2542">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="37550-2543">Uma matriz unidimensional com um limite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="37550-2543">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="37550-2544">Uma matriz unidimensional com um limite inferior desconhecido</span><span class="sxs-lookup"><span data-stu-id="37550-2544">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="37550-2545">Uma matriz de n-dimensional</span><span class="sxs-lookup"><span data-stu-id="37550-2545">An n-dimensional array</span></span>|<span data-ttu-id="37550-2546">Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1.</span><span class="sxs-lookup"><span data-stu-id="37550-2546">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="37550-2547">Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2547">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="37550-2548">Uma matriz bidimensional</span><span class="sxs-lookup"><span data-stu-id="37550-2548">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="37550-2549">Uma matriz bidimensional retangular com limites inferiores desconhecidos</span><span class="sxs-lookup"><span data-stu-id="37550-2549">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="37550-2550">Um tipo genérico com um argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2550">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="37550-2551">Um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2551">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="37550-2552">Um tipo genérico com dois argumentos de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2552">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="37550-2553">Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2553">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="37550-2554">Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2554">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="37550-2555">O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade de `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="37550-2555">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="37550-2556">Se um objeto do tipo se refere a um assembly que não existe, este exemplo gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2556">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2557"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2557"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2558">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2558">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-2559"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2559"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="37550-2560">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2560">-or-</span></span> 
 <span data-ttu-id="37550-2561"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.</span><span class="sxs-lookup"><span data-stu-id="37550-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="37550-2562">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2562">-or-</span></span> 
 <span data-ttu-id="37550-2563"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-2563"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="37550-2564">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2564">-or-</span></span> 
 <span data-ttu-id="37550-2565"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2565"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="37550-2566">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2566">-or-</span></span> 
 <span data-ttu-id="37550-2567"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2567"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2568"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida.</span><span class="sxs-lookup"><span data-stu-id="37550-2568"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="37550-2569">Por exemplo, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="37550-2569">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="37550-2570">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2570">-or-</span></span> 
 <span data-ttu-id="37550-2571"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2571"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-2572">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2572">-or-</span></span> 
 <span data-ttu-id="37550-2573"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2573"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-2574">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2574">-or-</span></span> 
 <span data-ttu-id="37550-2575"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-2575"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="37550-2576"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2576"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="37550-2577">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2577">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="37550-2578">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2578">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-2579">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-2579">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-2580">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2580">-or-</span></span> 
<span data-ttu-id="37550-2581">A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-2581">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-2582">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-2582">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2583">O nome qualificado pelo assembly do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2583">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="37550-2584">Consulte <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2584">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="37550-2585">Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2585">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-2586"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2586"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="37550-2587">A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="37550-2587">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="37550-2588">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2588">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="37550-2589"><see langword="true" /> para executar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2589"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="37550-2590">Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deve ou não lançar uma exceção se o tipo não for encontrado e se deseja executar uma pesquisa diferenciando maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="37550-2590">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="37550-2591">O tipo com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2591">The type with the specified name.</span></span> <span data-ttu-id="37550-2592">Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="37550-2592">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="37550-2593">Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2593">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="37550-2594">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2594">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2595">Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="37550-2595">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="37550-2596"><xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`.</span><span class="sxs-lookup"><span data-stu-id="37550-2596"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="37550-2597">Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-2597">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="37550-2598">Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.</span><span class="sxs-lookup"><span data-stu-id="37550-2598">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="37550-2599">`GetType` funciona somente em assemblies carregados do disco.</span><span class="sxs-lookup"><span data-stu-id="37550-2599">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="37550-2600">Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente.</span><span class="sxs-lookup"><span data-stu-id="37550-2600">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="37550-2601">O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-2601">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="37550-2602">Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2602">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="37550-2603">Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2603">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="37550-2604">`GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2604">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="37550-2605">Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar.</span><span class="sxs-lookup"><span data-stu-id="37550-2605">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="37550-2606">Caso contrário, você obterá duas cópias do assembly na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-2606">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="37550-2607">O `throwOnError` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2607">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="37550-2608">Algumas exceções são geradas, independentemente do valor de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="37550-2608">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="37550-2609">Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é gerada, mesmo que `throwOnError` é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-2609">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="37550-2610">A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2610">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="37550-2611">Tipo do membro</span><span class="sxs-lookup"><span data-stu-id="37550-2611">Member Type</span></span>|<span data-ttu-id="37550-2612">Estático</span><span class="sxs-lookup"><span data-stu-id="37550-2612">Static</span></span>|<span data-ttu-id="37550-2613">Não estático</span><span class="sxs-lookup"><span data-stu-id="37550-2613">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="37550-2614">Construtor</span><span class="sxs-lookup"><span data-stu-id="37550-2614">Constructor</span></span>|<span data-ttu-id="37550-2615">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2615">No</span></span>|<span data-ttu-id="37550-2616">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2616">No</span></span>|  
|<span data-ttu-id="37550-2617">Campo</span><span class="sxs-lookup"><span data-stu-id="37550-2617">Field</span></span>|<span data-ttu-id="37550-2618">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2618">No</span></span>|<span data-ttu-id="37550-2619">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2619">Yes.</span></span> <span data-ttu-id="37550-2620">Um campo permanece sempre oculto por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2620">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2621">evento</span><span class="sxs-lookup"><span data-stu-id="37550-2621">Event</span></span>|<span data-ttu-id="37550-2622">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2622">Not applicable</span></span>|<span data-ttu-id="37550-2623">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2624">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2625">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2625">See note 2 below.</span></span>|  
|<span data-ttu-id="37550-2626">Método</span><span class="sxs-lookup"><span data-stu-id="37550-2626">Method</span></span>|<span data-ttu-id="37550-2627">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2627">No</span></span>|<span data-ttu-id="37550-2628">Sim.</span><span class="sxs-lookup"><span data-stu-id="37550-2628">Yes.</span></span> <span data-ttu-id="37550-2629">Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2629">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="37550-2630">Tipo aninhado</span><span class="sxs-lookup"><span data-stu-id="37550-2630">Nested Type</span></span>|<span data-ttu-id="37550-2631">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2631">No</span></span>|<span data-ttu-id="37550-2632">Não</span><span class="sxs-lookup"><span data-stu-id="37550-2632">No</span></span>|  
|<span data-ttu-id="37550-2633">Propriedade</span><span class="sxs-lookup"><span data-stu-id="37550-2633">Property</span></span>|<span data-ttu-id="37550-2634">Não aplicável</span><span class="sxs-lookup"><span data-stu-id="37550-2634">Not applicable</span></span>|<span data-ttu-id="37550-2635">A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2635">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="37550-2636">Reflexão trata propriedades como ocultas por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2636">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2637">Consulte a observação 2 abaixo.</span><span class="sxs-lookup"><span data-stu-id="37550-2637">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="37550-2638">Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas.</span><span class="sxs-lookup"><span data-stu-id="37550-2638">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="37550-2639">Esta é uma comparação binária.</span><span class="sxs-lookup"><span data-stu-id="37550-2639">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="37550-2640">Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura.</span><span class="sxs-lookup"><span data-stu-id="37550-2640">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="37550-2641">Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-2641">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="37550-2642">Atributos personalizados não fazem parte do sistema de tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-2642">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="37550-2643">Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2643">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="37550-2644">`typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2644">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="37550-2645">Consulte <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-2645">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="37550-2646">Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem.</span><span class="sxs-lookup"><span data-stu-id="37550-2646">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="37550-2647">Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2647">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="37550-2648">Se o assembly tiver um nome forte, um nome de assembly completo é necessário.</span><span class="sxs-lookup"><span data-stu-id="37550-2648">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="37550-2649">O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2649">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="37550-2650">Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-2650">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2651">No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2651">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="37550-2652">Por exemplo, "ProcessorArchitecture=msil".</span><span class="sxs-lookup"><span data-stu-id="37550-2652">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="37550-2653">No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-2653">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="37550-2654">Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-2654">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="37550-2655">Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2655">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="37550-2656">Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-2656">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="37550-2657">Delimitador</span><span class="sxs-lookup"><span data-stu-id="37550-2657">Delimiter</span></span>|<span data-ttu-id="37550-2658">Significado</span><span class="sxs-lookup"><span data-stu-id="37550-2658">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="37550-2659">Barra invertida (\\)</span><span class="sxs-lookup"><span data-stu-id="37550-2659">Backslash (\\)</span></span>|<span data-ttu-id="37550-2660">Caractere de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2660">Escape character.</span></span>|  
|<span data-ttu-id="37550-2661">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="37550-2661">Backtick (\`)</span></span>|<span data-ttu-id="37550-2662">Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2662">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="37550-2663">Colchetes ([])</span><span class="sxs-lookup"><span data-stu-id="37550-2663">Brackets ([])</span></span>|<span data-ttu-id="37550-2664">Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2664">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="37550-2665">Vírgula (,)</span><span class="sxs-lookup"><span data-stu-id="37550-2665">Comma (,)</span></span>|<span data-ttu-id="37550-2666">Precede o nome Assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2666">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="37550-2667">Ponto final (.)</span><span class="sxs-lookup"><span data-stu-id="37550-2667">Period (.)</span></span>|<span data-ttu-id="37550-2668">Denota identificadores de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2668">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="37550-2669">Sinal de adição (+)</span><span class="sxs-lookup"><span data-stu-id="37550-2669">Plus sign (+)</span></span>|<span data-ttu-id="37550-2670">Precede uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="37550-2670">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="37550-2671">Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:</span><span class="sxs-lookup"><span data-stu-id="37550-2671">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2672">Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="37550-2672">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="37550-2673">A reflexão emite essa cadeia de caracteres da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2673">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="37550-2674">Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".</span><span class="sxs-lookup"><span data-stu-id="37550-2674">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="37550-2675">Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-2675">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="37550-2676">Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2676">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="37550-2677"><xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System.</span><span class="sxs-lookup"><span data-stu-id="37550-2677"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="37550-2678"><xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2678"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="37550-2679">Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2679">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="37550-2680">Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2680">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="37550-2681">Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2681">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="37550-2682">No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.</span><span class="sxs-lookup"><span data-stu-id="37550-2682">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="37550-2683">O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2683">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="37550-2684">A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo.</span><span class="sxs-lookup"><span data-stu-id="37550-2684">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="37550-2685">Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.</span><span class="sxs-lookup"><span data-stu-id="37550-2685">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="37550-2686">Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas.</span><span class="sxs-lookup"><span data-stu-id="37550-2686">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="37550-2687">Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2687">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="37550-2688">Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2688">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="37550-2689">Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes.</span><span class="sxs-lookup"><span data-stu-id="37550-2689">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="37550-2690">Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação.</span><span class="sxs-lookup"><span data-stu-id="37550-2690">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="37550-2691">Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` de myAssembly. dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-2691">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="37550-2692">Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2692">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="37550-2693">As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.</span><span class="sxs-lookup"><span data-stu-id="37550-2693">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="37550-2694">Tipos anuláveis são um caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-2694">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="37550-2695">Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="37550-2695">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2696">No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2696">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="37550-2697">Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="37550-2697">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="37550-2698">A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.</span><span class="sxs-lookup"><span data-stu-id="37550-2698">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="37550-2699">Para obter</span><span class="sxs-lookup"><span data-stu-id="37550-2699">To Get</span></span>|<span data-ttu-id="37550-2700">Use</span><span class="sxs-lookup"><span data-stu-id="37550-2700">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="37550-2701">Um valor anulável <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="37550-2701">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="37550-2702">Um ponteiro não gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2702">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="37550-2703">Um ponteiro não gerenciado em um ponteiro para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2703">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="37550-2704">Um ponteiro ou referência gerenciado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="37550-2704">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="37550-2705">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="37550-2705">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="37550-2706">Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.</span><span class="sxs-lookup"><span data-stu-id="37550-2706">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="37550-2707">Uma classe pai e uma classe aninhada</span><span class="sxs-lookup"><span data-stu-id="37550-2707">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="37550-2708">Uma matriz unidimensional com um limite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="37550-2708">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="37550-2709">Uma matriz unidimensional com um limite inferior desconhecido</span><span class="sxs-lookup"><span data-stu-id="37550-2709">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="37550-2710">Uma matriz de n-dimensional</span><span class="sxs-lookup"><span data-stu-id="37550-2710">An n-dimensional array</span></span>|<span data-ttu-id="37550-2711">Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1.</span><span class="sxs-lookup"><span data-stu-id="37550-2711">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="37550-2712">Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-2712">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="37550-2713">Uma matriz bidimensional</span><span class="sxs-lookup"><span data-stu-id="37550-2713">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="37550-2714">Uma matriz bidimensional retangular com limites inferiores desconhecidos</span><span class="sxs-lookup"><span data-stu-id="37550-2714">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="37550-2715">Um tipo genérico com um argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2715">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="37550-2716">Um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2716">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="37550-2717">Um tipo genérico com dois argumentos de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2717">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="37550-2718">Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2718">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="37550-2719">Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2719">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2720"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2720"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2721">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2721">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-2722"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2722"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="37550-2723">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2723">-or-</span></span> 
 <span data-ttu-id="37550-2724"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.</span><span class="sxs-lookup"><span data-stu-id="37550-2724"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="37550-2725">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2725">-or-</span></span> 
 <span data-ttu-id="37550-2726"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-2726"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="37550-2727">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2727">-or-</span></span> 
 <span data-ttu-id="37550-2728"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2728"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="37550-2729">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2729">-or-</span></span> 
 <span data-ttu-id="37550-2730"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2730"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2731"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida.</span><span class="sxs-lookup"><span data-stu-id="37550-2731"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="37550-2732">Por exemplo, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="37550-2732">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="37550-2733">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2733">-or-</span></span> 
 <span data-ttu-id="37550-2734"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2734"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-2735">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2735">-or-</span></span> 
 <span data-ttu-id="37550-2736"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2736"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-2737">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2737">-or-</span></span> 
 <span data-ttu-id="37550-2738"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-2738"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="37550-2739"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2739"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="37550-2740">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2740">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-2741">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-2741">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-2742">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2742">-or-</span></span> 
<span data-ttu-id="37550-2743">A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-2743">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-2744">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-2744">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2745">O nome do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2745">The name of the type to get.</span></span> <span data-ttu-id="37550-2746">Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver.</span><span class="sxs-lookup"><span data-stu-id="37550-2746">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="37550-2747">Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2747">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="37550-2748">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2748">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="37550-2749">O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2749">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="37550-2750">Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-2750">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="37550-2751">Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2751">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="37550-2752">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2752">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="37550-2753">Isso poderá resultar na elevação de privilégio de código mal-intencionado.</span><span class="sxs-lookup"><span data-stu-id="37550-2753">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="37550-2754">Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</span><span class="sxs-lookup"><span data-stu-id="37550-2754">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="37550-2755">Um método que localiza e retorna o tipo especificado pelo <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2755">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="37550-2756">Se nenhum assembly for fornecido, o método <paramref name="typeResolver" /> poderá fornecer um.</span><span class="sxs-lookup"><span data-stu-id="37550-2756">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="37550-2757">O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2757">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="37550-2758">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2758">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="37550-2759">Obtém o tipo com o nome especificado, fornecendo opcionalmente métodos personalizados para resolver o assembly e o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2759">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="37550-2760">O tipo com o nome especificado ou <see langword="null" /> se o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2760">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2761">Cenários de uso para esse método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="37550-2761">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2762">Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> retorno do método `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2762">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="37550-2763">Ele não gerará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2763">It does not throw an exception.</span></span> <span data-ttu-id="37550-2764">Para controlar se uma exceção é lançada, chame uma sobrecarga da <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2764">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="37550-2765">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `throwOnError` e `ignoreCase` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-2765">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2766"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2766"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2767">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2767">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2768">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).</span><span class="sxs-lookup"><span data-stu-id="37550-2768">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="37550-2769">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2769">-or-</span></span> 
 <span data-ttu-id="37550-2770"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2770"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-2771">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2771">-or-</span></span> 
 <span data-ttu-id="37550-2772"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2772"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-2773">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2773">-or-</span></span> 
 <span data-ttu-id="37550-2774"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-2774"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-2775"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2775"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="37550-2776">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2776">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="37550-2777">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2777">-or-</span></span> 
 <span data-ttu-id="37550-2778"><paramref name="typeName" /> contém um nome de assembly inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2778"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="37550-2779">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2779">-or-</span></span> 
 <span data-ttu-id="37550-2780"><paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2780"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-2781">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-2781">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-2782">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2782">-or-</span></span> 
<span data-ttu-id="37550-2783">O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="37550-2783">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2784">O nome do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2784">The name of the type to get.</span></span> <span data-ttu-id="37550-2785">Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver.</span><span class="sxs-lookup"><span data-stu-id="37550-2785">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="37550-2786">Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2786">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="37550-2787">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2787">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="37550-2788">O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2788">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="37550-2789">Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-2789">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="37550-2790">Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2790">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="37550-2791">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2791">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="37550-2792">Isso poderá resultar na elevação de privilégio de código mal-intencionado.</span><span class="sxs-lookup"><span data-stu-id="37550-2792">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="37550-2793">Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</span><span class="sxs-lookup"><span data-stu-id="37550-2793">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="37550-2794">Um método que localiza e retorna o tipo especificado por <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2794">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="37550-2795">Se nenhum assembly for indicado, o método poderá fornecer um.</span><span class="sxs-lookup"><span data-stu-id="37550-2795">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="37550-2796">O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2796">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="37550-2797">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2797">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-2798"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2798"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="37550-2799">A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="37550-2799">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="37550-2800">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2800">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="37550-2801">Obtém o tipo com o nome definido, especificando se deverá ser lançada uma exceção se o tipo não for encontrado e, opcionalmente, fornecendo métodos personalizados para resolver o assembly e o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2801">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="37550-2802">O tipo com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2802">The type with the specified name.</span></span> <span data-ttu-id="37550-2803">Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="37550-2803">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="37550-2804">Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2804">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="37550-2805">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2805">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2806">Cenários de uso para esse método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="37550-2806">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="37550-2807">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `ignoreCase` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2807">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2808"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2808"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-2809">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-2809">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-2810"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2810"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="37550-2811">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2811">-or-</span></span> 
 <span data-ttu-id="37550-2812"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.</span><span class="sxs-lookup"><span data-stu-id="37550-2812"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="37550-2813">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2813">-or-</span></span> 
 <span data-ttu-id="37550-2814"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-2814"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="37550-2815">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2815">-or-</span></span> 
 <span data-ttu-id="37550-2816"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2816"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="37550-2817">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2817">-or-</span></span> 
 <span data-ttu-id="37550-2818"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2818"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-2819">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).</span><span class="sxs-lookup"><span data-stu-id="37550-2819">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="37550-2820">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2820">-or-</span></span> 
 <span data-ttu-id="37550-2821"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="37550-2821"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="37550-2822">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2822">-or-</span></span> 
 <span data-ttu-id="37550-2823"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2823"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-2824">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2824">-or-</span></span> 
 <span data-ttu-id="37550-2825"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2825"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-2826">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2826">-or-</span></span> 
 <span data-ttu-id="37550-2827"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-2827"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="37550-2828"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-2828"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="37550-2829">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2829">-or-</span></span> 
 <span data-ttu-id="37550-2830"><paramref name="typeName" /> contém um nome de assembly inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2830"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="37550-2831">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2831">-or-</span></span> 
 <span data-ttu-id="37550-2832"><paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2832"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="37550-2833">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-2833">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-2834">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-2834">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-2835">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-2835">-or-</span></span> 
<span data-ttu-id="37550-2836">O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="37550-2836">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-2837">O nome do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-2837">The name of the type to get.</span></span> <span data-ttu-id="37550-2838">Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver.</span><span class="sxs-lookup"><span data-stu-id="37550-2838">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="37550-2839">Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-2839">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="37550-2840">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2840">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="37550-2841">O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2841">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="37550-2842">Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-2842">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="37550-2843">Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2843">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="37550-2844">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2844">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="37550-2845">Isso poderá resultar na elevação de privilégio de código mal-intencionado.</span><span class="sxs-lookup"><span data-stu-id="37550-2845">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="37550-2846">Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</span><span class="sxs-lookup"><span data-stu-id="37550-2846">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="37550-2847">Um método que localiza e retorna o tipo especificado por <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2847">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="37550-2848">Se nenhum assembly for indicado, o método poderá fornecer um.</span><span class="sxs-lookup"><span data-stu-id="37550-2848">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="37550-2849">O método também utiliza um parâmetro que especifica se deve executar uma pesquisa que diferencia maiúsculas de minúsculas. O valor de <paramref name="ignoreCase" /> é passado para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2849">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="37550-2850">Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2850">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-2851"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2851"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="37550-2852">A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="37550-2852">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="37550-2853">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2853">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="37550-2854"><see langword="true" /> para executar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2854"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="37550-2855">Obtém o tipo com o nome definido, especificando se uma pesquisa que diferencia maiúsculas de minúsculas deverá ser realizada e se uma exceção deverá ser gerada se o tipo não for encontrado, com a opção de também fornecer métodos personalizados para resolver o assembly e o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2855">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="37550-2856">O tipo com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-2856">The type with the specified name.</span></span> <span data-ttu-id="37550-2857">Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="37550-2857">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="37550-2858">Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2858">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="37550-2859">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-2859">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-2860">Use essa sobrecarga de método e suas sobrecargas associadas (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> e <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) para substituir a implementação padrão da <xref:System.Type.GetType%2A> método com implementações mais flexíveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2860">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="37550-2861">Ao fornecer seus próprios métodos que resolvem nomes de tipo e os nomes dos assemblies que contêm-los, você pode fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-2861">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="37550-2862">Controle qual versão de um assembly de um tipo é carregado do.</span><span class="sxs-lookup"><span data-stu-id="37550-2862">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="37550-2863">Forneça outro local para procurar um nome de tipo que não inclua um nome de assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2863">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="37550-2864">Carregar assemblies usando nomes de assembly parciais.</span><span class="sxs-lookup"><span data-stu-id="37550-2864">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="37550-2865">Retornar as subclasses de <xref:System.Type?displayProperty=nameWithType> que não são criados pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="37550-2865">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="37550-2866">Por exemplo, na serialização tolerantes à versão esse método permite que você pesquise um assembly de "melhor ajuste" usando um nome parcial.</span><span class="sxs-lookup"><span data-stu-id="37550-2866">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="37550-2867">Outras sobrecargas do <xref:System.Type.GetType%2A> método exigir um nome de tipo qualificado pelo assembly, que inclui o número de versão.</span><span class="sxs-lookup"><span data-stu-id="37550-2867">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="37550-2868">Talvez seja necessário retornar subclasses de implementações alternativas do sistema de tipo <xref:System.Type?displayProperty=nameWithType> que não são criados pelo CLR; todos os tipos que são retornados por outras sobrecargas do <xref:System.Type.GetType%2A> método são tipos de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-2868">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="37550-2869">Notas de uso</span><span class="sxs-lookup"><span data-stu-id="37550-2869">Usage Notes</span></span>  
 <span data-ttu-id="37550-2870">Essa sobrecarga de método e suas sobrecargas associadas analisam `typeName` no nome de um tipo e o nome de um assembly e, em seguida, resolver os nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-2870">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="37550-2871">Resolução do nome do assembly ocorre antes da resolução do nome do tipo, porque um nome de tipo deve ser resolvido no contexto de um assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2871">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2872">Se você estiver familiarizado com o conceito de nomes de tipo qualificado pelo assembly, consulte o <xref:System.Type.AssemblyQualifiedName%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-2872">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="37550-2873">Se `typeName` não é um nome qualificado pelo assembly, resolução de assembly é ignorada.</span><span class="sxs-lookup"><span data-stu-id="37550-2873">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="37550-2874">Nomes de tipo não qualificado podem ser resolvidos no contexto de mscorlib. dll ou o assembly em execução no momento ou, opcionalmente, você pode fornecer um assembly no `typeResolver` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-2874">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="37550-2875">Os efeitos de incluir ou omitir o nome do assembly para tipos diferentes de resolução de nomes são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção.</span><span class="sxs-lookup"><span data-stu-id="37550-2875">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="37550-2876">Observações de uso geral:</span><span class="sxs-lookup"><span data-stu-id="37550-2876">General usage notes:</span></span>  
  
-   <span data-ttu-id="37550-2877">Não passe métodos a serem `assemblyResolver` ou `typeResolver` que elas venham de chamadores desconhecidos ou não confiáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-2877">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="37550-2878">Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</span><span class="sxs-lookup"><span data-stu-id="37550-2878">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="37550-2879">Usando métodos de chamadores desconhecidos ou não confiáveis pode resultar em elevação de privilégio de código mal-intencionado.</span><span class="sxs-lookup"><span data-stu-id="37550-2879">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="37550-2880">Se você omitir a `assemblyResolver` e/ou `typeResolver` parâmetros, o valor da `throwOnError` parâmetro é passado para os métodos que realizam a resolução padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2880">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="37550-2881">Se `throwOnError` está `true`, esse método lança uma <xref:System.TypeLoadException> quando `typeResolver` retorna `null`e uma <xref:System.IO.FileNotFoundException> quando `assemblyResolver` retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2881">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="37550-2882">Esse método não capturará exceções geradas pelo `assemblyResolver` e `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="37550-2882">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="37550-2883">Você é responsável por todas as exceções que são geradas pelos métodos resolvedor.</span><span class="sxs-lookup"><span data-stu-id="37550-2883">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="37550-2884">Resolvendo assemblies</span><span class="sxs-lookup"><span data-stu-id="37550-2884">Resolving Assemblies</span></span>  
 <span data-ttu-id="37550-2885">O `assemblyResolver` método recebe um <xref:System.Reflection.AssemblyName> objeto, que é produzido por analisar o nome do assembly de cadeia de caracteres que está incluído no `typeName`.</span><span class="sxs-lookup"><span data-stu-id="37550-2885">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="37550-2886">Se `typeName` não contém um nome de assembly `assemblyResolver` não é chamado e `null` é passado para `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="37550-2886">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="37550-2887">Se `assemblyResolver` não for fornecida, o padrão de montagem de investigação é usada para localizar o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2887">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="37550-2888">Se `assemblyResolver` for fornecido, o <xref:System.Type.GetType%2A> método não faz a investigação padrão; nesse caso, você deve garantir que seu `assemblyResolver` pode lidar com todos os assemblies que você passa para ele.</span><span class="sxs-lookup"><span data-stu-id="37550-2888">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="37550-2889">O `assemblyResolver` método deverá retornar `null` se o assembly não pode ser resolvido.</span><span class="sxs-lookup"><span data-stu-id="37550-2889">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="37550-2890">Se `assemblyResolver` retorna `null`, `typeResolver` não é chamado e nenhum processamento adicional ocorre; Além disso, se `throwOnError` está `true`, um <xref:System.IO.FileNotFoundException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="37550-2890">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="37550-2891">Se o <xref:System.Reflection.AssemblyName> que é passado para `assemblyResolver` é um parcial nome, uma ou mais das suas partes são `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2891">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="37550-2892">Por exemplo, se ele não tem versão, o <xref:System.Reflection.AssemblyName.Version%2A> é de propriedade `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-2892">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="37550-2893">Se o <xref:System.Reflection.AssemblyName.Version%2A> propriedade, o <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriedade e o <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> método retornam `null`, em seguida, apenas o nome simples do assembly foi fornecido.</span><span class="sxs-lookup"><span data-stu-id="37550-2893">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="37550-2894">O `assemblyResolver` método pode usar ou ignorar todas as partes do nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2894">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="37550-2895">Os efeitos das opções de resolução de assembly diferente são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2895">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="37550-2896">Resolvendo tipos</span><span class="sxs-lookup"><span data-stu-id="37550-2896">Resolving Types</span></span>  
 <span data-ttu-id="37550-2897">Se `typeName` não especifica um nome de assembly, `typeResolver` sempre é chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-2897">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="37550-2898">Se `typeName` Especifica um nome de assembly, `typeResolver` é chamada somente quando o nome do assembly é resolvido com êxito.</span><span class="sxs-lookup"><span data-stu-id="37550-2898">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="37550-2899">Se `assemblyResolver` ou o assembly padrão investigação retorna `null`, `typeResolver` não é chamado.</span><span class="sxs-lookup"><span data-stu-id="37550-2899">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="37550-2900">O `typeResolver` método recebe três argumentos:</span><span class="sxs-lookup"><span data-stu-id="37550-2900">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="37550-2901">O assembly para pesquisar ou `null` se `typeName` não contém um nome de assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2901">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="37550-2902">O nome simples do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2902">The simple name of the type.</span></span> <span data-ttu-id="37550-2903">No caso de um tipo aninhado, esse é o tipo de recipiente mais externo.</span><span class="sxs-lookup"><span data-stu-id="37550-2903">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="37550-2904">No caso de um tipo genérico, este é o nome simples do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-2904">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="37550-2905">Um valor booliano que é `true` se o caso de nomes de tipo será ignorada.</span><span class="sxs-lookup"><span data-stu-id="37550-2905">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="37550-2906">A implementação determina a maneira como esses argumentos são usados.</span><span class="sxs-lookup"><span data-stu-id="37550-2906">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="37550-2907">O `typeResolver` método deverá retornar `null` se ele não puder resolver o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2907">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="37550-2908">Se `typeResolver` retorna `null` e `throwOnError` é `true`, essa sobrecarga do <xref:System.Type.GetType%2A> lança um <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="37550-2908">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="37550-2909">Os efeitos das opções de resolução de tipo diferentes são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2909">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="37550-2910">Resolvendo tipos aninhados</span><span class="sxs-lookup"><span data-stu-id="37550-2910">Resolving Nested Types</span></span>  
 <span data-ttu-id="37550-2911">Se `typeName` é um tipo aninhado, somente o nome do mais externo que contém o tipo é passado para `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="37550-2911">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="37550-2912">Quando `typeResolver` retorna esse tipo, o <xref:System.Type.GetNestedType%2A> método é chamado repetidamente até que o tipo aninhado interno foi resolvido.</span><span class="sxs-lookup"><span data-stu-id="37550-2912">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="37550-2913">Resolvendo tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-2913">Resolving Generic Types</span></span>  
 <span data-ttu-id="37550-2914">O <xref:System.Type.GetType%2A> é chamada recursivamente para resolver tipos genéricos: Primeiro, para resolver o tipo genérico em si e, em seguida, para resolver seus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2914">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="37550-2915">Se um argumento de tipo for genérico, <xref:System.Type.GetType%2A> é chamada recursivamente para resolver seus argumentos de tipo e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="37550-2915">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="37550-2916">A combinação de `assemblyResolver` e `typeResolver` que você fornece deve ser capaz de resolver todos os níveis dessa recursão.</span><span class="sxs-lookup"><span data-stu-id="37550-2916">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="37550-2917">Por exemplo, suponha que você fornecer um `assemblyResolver` que controla o carregamento de `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="37550-2917">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="37550-2918">Suponha que você deseja resolver o tipo genérico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-2918">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="37550-2919">Você pode passar o nome de tipo genérico a seguir:</span><span class="sxs-lookup"><span data-stu-id="37550-2919">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="37550-2920">Observe que `MyType` é o argumento de tipo qualificado do assembly apenas.</span><span class="sxs-lookup"><span data-stu-id="37550-2920">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="37550-2921">Os nomes dos <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String> classes não são qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2921">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="37550-2922">Sua `typeResolver` deve ser capaz de identificador de um assembly ou `null`, pois ela receberá `null` para <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="37550-2922">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="37550-2923">Ele pode lidar com esse caso, chamando uma sobrecarga da <xref:System.Type.GetType%2A> método que usa uma cadeia de caracteres, como os dois nomes de tipo não qualificados são em mscorlib. dll:</span><span class="sxs-lookup"><span data-stu-id="37550-2923">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="37550-2924">O `assemblyResolver` método não é chamado para o tipo de dicionário e o tipo de cadeia de caracteres, porque esses nomes de tipo não são qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2924">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="37550-2925">Agora suponha que, em vez de `System.String`, é o primeiro tipo de argumento genérico `YourType`, de `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="37550-2925">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="37550-2926">Como este assembly é nem mscorlib. dll, nem o assembly em execução no momento, não é possível resolver `YourType` sem um nome qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2926">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="37550-2927">Porque seu `assemblyResolve` será chamada recursivamente, deve ser capaz de lidar com isso.</span><span class="sxs-lookup"><span data-stu-id="37550-2927">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="37550-2928">Em vez de retornar `null` para assemblies diferente `MyAssembly`, ele agora executa um carregamento de assembly usando o <xref:System.Reflection.AssemblyName> objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-2928">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="37550-2929">Voltar ao [Observações sobre uso](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="37550-2929">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="37550-2930">Resolvendo nomes de tipo com caracteres especiais</span><span class="sxs-lookup"><span data-stu-id="37550-2930">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="37550-2931">Determinados caracteres têm significados especiais em nomes qualificados pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2931">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="37550-2932">Se um nome de tipo simples contém esses caracteres, os caracteres causam erros de análise quando o nome simples faz parte de um nome qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2932">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="37550-2933">Para evitar os erros de análise, você deve escapar os caracteres especiais com uma barra invertida antes de você pode passar o nome qualificado do assembly para o <xref:System.Type.GetType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-2933">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="37550-2934">Por exemplo, se um tipo é nomeado `Strange]Type`, o caractere de escape deve ser adicionado à frente o colchete quadrado da seguinte maneira: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="37550-2934">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-2935">Nomes com caracteres especiais, não podem ser criados no Visual Basic ou c#, mas podem ser criados usando o Microsoft intermediate language (MSIL) ou emitindo assemblies dinâmicos.</span><span class="sxs-lookup"><span data-stu-id="37550-2935">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="37550-2936">A tabela a seguir mostra os caracteres especiais para nomes de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2936">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="37550-2937">Caractere</span><span class="sxs-lookup"><span data-stu-id="37550-2937">Character</span></span>|<span data-ttu-id="37550-2938">Significado</span><span class="sxs-lookup"><span data-stu-id="37550-2938">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="37550-2939">`,` (vírgula)</span><span class="sxs-lookup"><span data-stu-id="37550-2939">`,` (comma)</span></span>|<span data-ttu-id="37550-2940">Delimitador de nomes qualificados pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2940">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="37550-2941">`[]` (os colchetes)</span><span class="sxs-lookup"><span data-stu-id="37550-2941">`[]` (square brackets)</span></span>|<span data-ttu-id="37550-2942">Como um par de sufixo, indica um tipo de matriz; como um par de delimitadores, inclui listas de argumentos genéricos e nomes qualificados pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2942">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="37550-2943">`&` (e comercial)</span><span class="sxs-lookup"><span data-stu-id="37550-2943">`&` (ampersand)</span></span>|<span data-ttu-id="37550-2944">Como um sufixo, indica que um tipo é um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="37550-2944">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="37550-2945">`*` (asterisco)</span><span class="sxs-lookup"><span data-stu-id="37550-2945">`*` (asterisk)</span></span>|<span data-ttu-id="37550-2946">Como um sufixo, indica que um tipo é um tipo de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="37550-2946">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="37550-2947">`+` (adição)</span><span class="sxs-lookup"><span data-stu-id="37550-2947">`+` (plus)</span></span>|<span data-ttu-id="37550-2948">Delimitador de tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-2948">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="37550-2949">`\` (barra invertida)</span><span class="sxs-lookup"><span data-stu-id="37550-2949">`\` (backslash)</span></span>|<span data-ttu-id="37550-2950">Caractere de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2950">Escape character.</span></span>|  
  
 <span data-ttu-id="37550-2951">Propriedades, como <xref:System.Type.AssemblyQualifiedName%2A> retorno corretamente cadeias de caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2951">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="37550-2952">Você deve passar cadeias de caracteres de escapadas corretamente para o <xref:System.Type.GetType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-2952">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="37550-2953">Por sua vez, o <xref:System.Type.GetType%2A> método passa os nomes de escape corretamente para `typeResolver` e para os métodos de resolução de tipo padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-2953">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="37550-2954">Se você precisa comparar um nome para um nome sem escape no `typeResolver`, você deve remover os caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="37550-2954">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="37550-2955">Voltar ao [Observações sobre uso](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="37550-2955">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="37550-2956">Resolução de nome misto</span><span class="sxs-lookup"><span data-stu-id="37550-2956">Mixed Name Resolution</span></span>  
 <span data-ttu-id="37550-2957">A tabela a seguir resume as interações entre `assemblyResolver`, `typeResolver`e a resolução de nomes padrão, para todas as combinações de nome de tipo e nome do assembly na `typeName`:</span><span class="sxs-lookup"><span data-stu-id="37550-2957">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="37550-2958">Conteúdo do nome do tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2958">Contents of type name</span></span>|<span data-ttu-id="37550-2959">Método do resolvedor de assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2959">Assembly resolver method</span></span>|<span data-ttu-id="37550-2960">Método do resolvedor de tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2960">Type resolver method</span></span>|<span data-ttu-id="37550-2961">Resultado</span><span class="sxs-lookup"><span data-stu-id="37550-2961">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="37550-2962">tipo, assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2962">type, assembly</span></span>|<span data-ttu-id="37550-2963">nulo</span><span class="sxs-lookup"><span data-stu-id="37550-2963">null</span></span>|<span data-ttu-id="37550-2964">nulo</span><span class="sxs-lookup"><span data-stu-id="37550-2964">null</span></span>|<span data-ttu-id="37550-2965">Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="37550-2965">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="37550-2966">tipo, assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2966">type, assembly</span></span>|<span data-ttu-id="37550-2967">fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2967">provided</span></span>|<span data-ttu-id="37550-2968">nulo</span><span class="sxs-lookup"><span data-stu-id="37550-2968">null</span></span>|<span data-ttu-id="37550-2969">`assemblyResolver` Retorna o assembly ou `null` se ele não é possível resolver o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2969">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="37550-2970">Se o assembly for resolvido, o <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método é usada para carregar o tipo do assembly; caso contrário, não há nenhuma tentativa de resolver o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2970">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="37550-2971">tipo, assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2971">type, assembly</span></span>|<span data-ttu-id="37550-2972">nulo</span><span class="sxs-lookup"><span data-stu-id="37550-2972">null</span></span>|<span data-ttu-id="37550-2973">fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2973">provided</span></span>|<span data-ttu-id="37550-2974">Equivalente a converter o nome do assembly para um <xref:System.Reflection.AssemblyName> objeto e chamar o <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> sobrecarga de método para obter o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2974">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="37550-2975">Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2975">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="37550-2976">tipo, assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2976">type, assembly</span></span>|<span data-ttu-id="37550-2977">fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2977">provided</span></span>|<span data-ttu-id="37550-2978">fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2978">provided</span></span>|<span data-ttu-id="37550-2979">`assemblyResolver` Retorna o assembly ou `null` se ele não é possível resolver o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2979">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="37550-2980">Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-2980">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="37550-2981">tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2981">type</span></span>|<span data-ttu-id="37550-2982">nulo, fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2982">null, provided</span></span>|<span data-ttu-id="37550-2983">nulo</span><span class="sxs-lookup"><span data-stu-id="37550-2983">null</span></span>|<span data-ttu-id="37550-2984">Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="37550-2984">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="37550-2985">Porque o nome do assembly não for fornecido, apenas mscorlib. dll e o assembly em execução no momento são pesquisados.</span><span class="sxs-lookup"><span data-stu-id="37550-2985">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="37550-2986">Se `assemblyResolver` for fornecido, ele será ignorado.</span><span class="sxs-lookup"><span data-stu-id="37550-2986">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="37550-2987">tipo</span><span class="sxs-lookup"><span data-stu-id="37550-2987">type</span></span>|<span data-ttu-id="37550-2988">nulo, fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2988">null, provided</span></span>|<span data-ttu-id="37550-2989">fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2989">provided</span></span>|<span data-ttu-id="37550-2990">`typeResolver` é chamado, e `null` é passado para o assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2990">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="37550-2991">`typeResolver` pode fornecer um tipo de qualquer assembly, incluindo assemblies, que ele carrega o propósito.</span><span class="sxs-lookup"><span data-stu-id="37550-2991">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="37550-2992">Se `assemblyResolver` for fornecido, ele será ignorado.</span><span class="sxs-lookup"><span data-stu-id="37550-2992">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="37550-2993">assembly</span><span class="sxs-lookup"><span data-stu-id="37550-2993">assembly</span></span>|<span data-ttu-id="37550-2994">nulo, fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2994">null, provided</span></span>|<span data-ttu-id="37550-2995">nulo, fornecido</span><span class="sxs-lookup"><span data-stu-id="37550-2995">null, provided</span></span>|<span data-ttu-id="37550-2996">Um <xref:System.IO.FileLoadException> for gerada, porque o nome do assembly é analisado como se fosse um nome de tipo qualificado pelo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-2996">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="37550-2997">Isso resulta em um nome de assembly inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-2997">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="37550-2998">De volta para: [Notas de uso](#usage_notes), [Resolvendo Assemblies](#resolving_assemblies), [Resolvendo tipos](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="37550-2998">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-2999"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-2999"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-3000">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-3000">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-3001"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-3001"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="37550-3002">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3002">-or-</span></span> 
 <span data-ttu-id="37550-3003"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.</span><span class="sxs-lookup"><span data-stu-id="37550-3003"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="37550-3004">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3004">-or-</span></span> 
 <span data-ttu-id="37550-3005"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-3005"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="37550-3006">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3006">-or-</span></span> 
 <span data-ttu-id="37550-3007"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-3007"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="37550-3008">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3008">-or-</span></span> 
 <span data-ttu-id="37550-3009"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3009"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3010">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).</span><span class="sxs-lookup"><span data-stu-id="37550-3010">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="37550-3011">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3011">-or-</span></span> 
 <span data-ttu-id="37550-3012"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="37550-3012"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="37550-3013">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3013">-or-</span></span> 
 <span data-ttu-id="37550-3014"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3014"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-3015">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3015">-or-</span></span> 
 <span data-ttu-id="37550-3016"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3016"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-3017">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3017">-or-</span></span> 
 <span data-ttu-id="37550-3018"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-3018"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="37550-3019"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-3019"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="37550-3020">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-3020">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="37550-3021">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3021">-or-</span></span> 
 <span data-ttu-id="37550-3022"><paramref name="typeName" /> contém um nome de assembly inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-3022"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="37550-3023">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3023">-or-</span></span> 
 <span data-ttu-id="37550-3024"><paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3024"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-3025">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3025">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-3026">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3026">-or-</span></span> 
<span data-ttu-id="37550-3027">O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="37550-3027">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="37550-3028">Uma matriz de objetos cujos tipos devem ser determinados.</span><span class="sxs-lookup"><span data-stu-id="37550-3028">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="37550-3029">Obtém os tipos dos objetos na matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-3029">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="37550-3030">Uma matriz de objetos <see cref="T:System.Type" /> que representa os tipos de elementos correspondentes em <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3030">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37550-3031">O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetTypeArray%2A> método para listar os tipos dos elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3031">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3032"><paramref name="args" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3032"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-3033">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3033">-or-</span></span> 
<span data-ttu-id="37550-3034">Um ou mais dos elementos no <paramref name="args" /> são <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3034">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-3035">Os inicializadores de classe são invocados e pelo menos um gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-3035">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="37550-3036">O tipo cujo código de tipo subjacente será obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3036">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="37550-3037">Obtém o código de tipo subjacente do <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3037">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-3038">O código do tipo subjacente ou <see cref="F:System.TypeCode.Empty" /> se <paramref name="type" /> for <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3038">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3039">Quando você herda <xref:System.Type>, você pode alterar o comportamento desse método, substituindo o <xref:System.Type.GetTypeCodeImpl%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3039">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3040">O exemplo de código a seguir demonstra como o <xref:System.TypeCode> enumeração pode ser usada.</span><span class="sxs-lookup"><span data-stu-id="37550-3040">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="37550-3041">Em um bloco de decisão dentro de `WriteObjectInfo` método, o <xref:System.TypeCode> de um <xref:System.Object> parâmetro é examinado e uma mensagem apropriada é gravada no console.</span><span class="sxs-lookup"><span data-stu-id="37550-3041">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3042">Retorna o código de tipo subjacente desta instância <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3042">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="37550-3043">O código de tipo do tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="37550-3043">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3044">Esse método fornece a implementação para o `static` (em c#) ou `Shared` (no Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3044">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="37550-3045">Quando você herda <xref:System.Type>, você pode substituir esse método para fornecer sua própria implementação de <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-3045">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-3046">Obtém o tipo associado ao identificador de classe especificado (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3046">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="37550-3047">O CLSID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3047">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="37550-3048">Obtém o tipo associado ao identificador de classe especificado (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3048">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="37550-3049"><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3049"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3050">O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3050">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="37550-3051">Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro.</span><span class="sxs-lookup"><span data-stu-id="37550-3051">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="37550-3052">Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3052">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="37550-3053">Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.</span><span class="sxs-lookup"><span data-stu-id="37550-3053">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="37550-3054">Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:</span><span class="sxs-lookup"><span data-stu-id="37550-3054">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="37550-3055">Obter um <xref:System.Type> objeto que representa o`__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3055">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="37550-3056">Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3056">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="37550-3057">Consulte o exemplo para obter uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="37550-3057">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="37550-3058">O <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> sobrecarga ignora qualquer exceção que pode ocorrer ao instanciar um <xref:System.Type> objeto com base no `clsid` argumento.</span><span class="sxs-lookup"><span data-stu-id="37550-3058">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="37550-3059">Observe que nenhuma exceção é lançada se `clsid` não for encontrado no registro.</span><span class="sxs-lookup"><span data-stu-id="37550-3059">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3060">O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="37550-3060">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="37550-3061">Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="37550-3061">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="37550-3062">Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3062">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="37550-3063">Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3063">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="37550-3064">Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-3064">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="37550-3065">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="37550-3065">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="37550-3066">Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3066">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="37550-3067">O CLSID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3067">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-3068"><see langword="true" /> para lançar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3068"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="37550-3069">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3069">-or-</span></span> 
 <span data-ttu-id="37550-3070"><see langword="false" /> para ignorar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3070"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="37550-3071">Obtém o tipo associado ao CLSID (identificador de classe) especificado, especificando se deverá gerar uma exceção se ocorrer um erro ao carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3071">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="37550-3072"><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3072"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3073">O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3073">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="37550-3074">Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro.</span><span class="sxs-lookup"><span data-stu-id="37550-3074">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="37550-3075">Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3075">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="37550-3076">Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.</span><span class="sxs-lookup"><span data-stu-id="37550-3076">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="37550-3077">Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:</span><span class="sxs-lookup"><span data-stu-id="37550-3077">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="37550-3078">Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3078">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="37550-3079">Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3079">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="37550-3080">Consulte o exemplo para obter uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="37550-3080">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="37550-3081">Exceções, como <xref:System.OutOfMemoryException> será gerada ao especificar `true` para `throwOnError`, mas não falhará para CLSIDs cancelados.</span><span class="sxs-lookup"><span data-stu-id="37550-3081">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3082">O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="37550-3082">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="37550-3083">Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="37550-3083">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="37550-3084">Uma exceção é lançada se ocorrer um erro ao carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3084">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="37550-3085">Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3085">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="37550-3086">Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3086">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="37550-3087">Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-3087">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="37550-3088">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="37550-3088">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="37550-3089">Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3089">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="37550-3090">O CLSID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3090">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="37550-3091">O servidor do qual carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3091">The server from which to load the type.</span></span> <span data-ttu-id="37550-3092">Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</span><span class="sxs-lookup"><span data-stu-id="37550-3092">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="37550-3093">Obtém o tipo associado ao CLSID (identificador de classe) especificado do servidor especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3093">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="37550-3094"><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3094"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3095">O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3095">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="37550-3096">Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro.</span><span class="sxs-lookup"><span data-stu-id="37550-3096">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="37550-3097">Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3097">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="37550-3098">Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.</span><span class="sxs-lookup"><span data-stu-id="37550-3098">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="37550-3099">Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:</span><span class="sxs-lookup"><span data-stu-id="37550-3099">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="37550-3100">Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3100">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="37550-3101">Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3101">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3102">O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="37550-3102">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="37550-3103">Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="37550-3103">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="37550-3104">Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3104">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="37550-3105">Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3105">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="37550-3106">Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-3106">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="37550-3107">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="37550-3107">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="37550-3108">Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3108">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="37550-3109">O CLSID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3109">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="37550-3110">O servidor do qual carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3110">The server from which to load the type.</span></span> <span data-ttu-id="37550-3111">Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</span><span class="sxs-lookup"><span data-stu-id="37550-3111">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-3112"><see langword="true" /> para lançar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3112"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="37550-3113">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3113">-or-</span></span> 
 <span data-ttu-id="37550-3114"><see langword="false" /> para ignorar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3114"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="37550-3115">Obtém o tipo associado ao CLSID (identificador de classe) especificado do servidor especificado, determinando se uma exceção deverá ser gerada se ocorrer um erro durante o carregamento do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3115">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="37550-3116"><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3116"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3117">O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="37550-3117">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="37550-3118">Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro.</span><span class="sxs-lookup"><span data-stu-id="37550-3118">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="37550-3119">Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3119">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="37550-3120">Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.</span><span class="sxs-lookup"><span data-stu-id="37550-3120">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="37550-3121">Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:</span><span class="sxs-lookup"><span data-stu-id="37550-3121">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="37550-3122">Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3122">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="37550-3123">Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3123">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="37550-3124">Exceções, como <xref:System.OutOfMemoryException> será gerada ao especificar `true` para `throwOnError`, mas não falhará para CLSIDs cancelados.</span><span class="sxs-lookup"><span data-stu-id="37550-3124">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3125">O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="37550-3125">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="37550-3126">Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="37550-3126">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="37550-3127">Uma exceção é lançada se ocorrer um erro ao carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3127">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="37550-3128">Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3128">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="37550-3129">Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3129">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="37550-3130">Embora o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> método retorna um <see cref="T:System.Type" /> objeto que corresponde ao GUID de um determinado objeto gerenciado, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como o exemplo a seguir programas.</span><span class="sxs-lookup"><span data-stu-id="37550-3130">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="37550-3131">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="37550-3131">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="37550-3132">Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3132">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="37550-3133">O objeto que se refere ao tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3133">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="37550-3134">Obtém o tipo referenciado pelo identificador do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3134">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="37550-3135">O tipo referenciado pelo <see cref="T:System.RuntimeTypeHandle" /> especificado ou <see langword="null" />, se a propriedade <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> for <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3135">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3136">Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</span><span class="sxs-lookup"><span data-stu-id="37550-3136">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3137">O exemplo a seguir usa o <xref:System.Type.GetTypeFromHandle%2A> método para obter uma <xref:System.Type> do objeto de uma <xref:System.RuntimeTypeHandle> fornecidos pelo <xref:System.Type.GetTypeHandle%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3137">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-3138">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-3138">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-3139">Obtém o tipo associado com o ProgID (identificador programático) especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3139">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="37550-3140">O ProgID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3140">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="37550-3141">Obtém o tipo associado ao identificador de programa (ProgID) especificado, retornando null se for encontrado um erro ao carregar o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3141">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-3142">O tipo associado ao ProgID especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo for associado a ele; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3142">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3143">Este método é fornecido para suporte COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3143">This method is provided for COM support.</span></span> <span data-ttu-id="37550-3144">ProgIDs não são usados no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-3144">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3145"><paramref name="progID" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3145"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="37550-3146">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="37550-3146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="37550-3147">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="37550-3148">O ProgID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3148">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-3149"><see langword="true" /> para lançar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3149"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="37550-3150">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3150">-or-</span></span> 
 <span data-ttu-id="37550-3151"><see langword="false" /> para ignorar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3151"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="37550-3152">Obtém o tipo associado ao ProgID (identificador de programa) especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro ao carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3152">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="37550-3153">O tipo associado ao ProgID (identificador de programa) especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo estiver associado a ele; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3153">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3154">Este método é fornecido para suporte COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3154">This method is provided for COM support.</span></span> <span data-ttu-id="37550-3155">Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3156">O exemplo a seguir recupera um tipo, passando um ProgID, especificando se é necessário lançar uma exceção se o ProgID é inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-3156">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="37550-3157">O exemplo, em seguida, exibe ClassID relacionado a ProgID, juntamente com qualquer mensagem de exceção aplicável.</span><span class="sxs-lookup"><span data-stu-id="37550-3157">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3158"><paramref name="progID" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3158"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="37550-3159">O ProgID especificado não está registrado.</span><span class="sxs-lookup"><span data-stu-id="37550-3159">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="37550-3160">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="37550-3160">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="37550-3161">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="37550-3162">O progID do tipo a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3162">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="37550-3163">O servidor do qual carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3163">The server from which to load the type.</span></span> <span data-ttu-id="37550-3164">Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</span><span class="sxs-lookup"><span data-stu-id="37550-3164">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="37550-3165">Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, retornando nulo caso seja encontrado algum erro ao carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3165">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="37550-3166">O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3166">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3167">Este método é fornecido para suporte COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3167">This method is provided for COM support.</span></span> <span data-ttu-id="37550-3168">Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-3168">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3169">O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor.</span><span class="sxs-lookup"><span data-stu-id="37550-3169">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="37550-3170">O exemplo exibe ClassID relacionado como o ProgID ou gera uma exceção se o ProgID ou o nome do servidor é inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-3170">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3171"><paramref name="prodID" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3171"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="37550-3172">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="37550-3172">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="37550-3173">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3173">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="37550-3174">A progID do <see cref="T:System.Type" /> a ser obtida.</span><span class="sxs-lookup"><span data-stu-id="37550-3174">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="37550-3175">O servidor do qual carregar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3175">The server from which to load the type.</span></span> <span data-ttu-id="37550-3176">Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</span><span class="sxs-lookup"><span data-stu-id="37550-3176">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="37550-3177"><see langword="true" /> para lançar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3177"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="37550-3178">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3178">-or-</span></span> 
 <span data-ttu-id="37550-3179"><see langword="false" /> para ignorar qualquer exceção que ocorra.</span><span class="sxs-lookup"><span data-stu-id="37550-3179"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="37550-3180">Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro durante o carregamento do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3180">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="37550-3181">O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3181">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3182">Este método é fornecido para suporte COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3182">This method is provided for COM support.</span></span> <span data-ttu-id="37550-3183">Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-3183">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3184">O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor.</span><span class="sxs-lookup"><span data-stu-id="37550-3184">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="37550-3185">O exemplo, em seguida, exibe o ClassID relacionado a ProgID, especificando se é necessário lançar uma exceção se o ProgID ou o nome do servidor é inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-3185">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3186"><paramref name="progID" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3186"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="37550-3187">A progID especificada não está registrada.</span><span class="sxs-lookup"><span data-stu-id="37550-3187">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="37550-3188">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="37550-3188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="37550-3189">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="37550-3190">O objeto para o qual o identificador de tipo será obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-3190">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="37550-3191">Obtém o identificador para o <see cref="T:System.Type" /> de um objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3191">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="37550-3192">O identificador para o <see cref="T:System.Type" /> do <see cref="T:System.Object" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3192">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3193">Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</span><span class="sxs-lookup"><span data-stu-id="37550-3193">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3194">O exemplo a seguir define a classe `MyClass1`, obtém uma instância dele e recupera o identificador de tempo de execução do objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-3194">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3195"><paramref name="o" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3195"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3196">Obtém o GUID associado ao <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3196">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-3197">O GUID associado ao <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3197">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3198">Um GUID é associado a um tipo usando o <xref:System.Runtime.InteropServices.GuidAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="37550-3198">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3199">O exemplo a seguir cria a classe `MyClass1` com um método público, cria um `Type` objeto correspondente `MyClass1`e obtém os <xref:System.Guid> estrutura usando o `GUID` propriedade do `Type` classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3199">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3200">Obtém um valor que indica se o <see cref="T:System.Type" /> atual abrange ou se refere a outro tipo; ou seja, se o <see cref="T:System.Type" /> atual é uma matriz, um ponteiro ou é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3200">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="37550-3201"><see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3201"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3202">Por exemplo, Type.GetType("Int32[]"). Retorna HasElementType `true`, mas Type.GetType("Int32"). Retorna HasElementType `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3202">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="37550-3203">Também retorna HasElementType `true` para Int32 "\*" e "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="37550-3203">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="37550-3204">Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3204">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3205">O exemplo a seguir retorna `true` ou `false` dependendo se o objeto é uma matriz, um tipo de referência ou um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="37550-3205">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3206">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.HasElementType" /> e determina se o <see cref="T:System.Type" /> atual abrange ou se refere a outro tipo, ou seja, se o <see cref="T:System.Type" /> atual é uma matriz, um ponteiro ou é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3206">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="37550-3207"><see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3207"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3208">Por exemplo, Type.GetType("Int32[]"). Retorna HasElementTypeImpl `true`, mas Type.GetType("Int32"). Retorna HasElementTypeImpl `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3208">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="37550-3209">Também retorna HasElementTypeImpl `true` para Int32 "\*" e "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="37550-3209">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3210">O exemplo a seguir define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método.</span><span class="sxs-lookup"><span data-stu-id="37550-3210">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="37550-3211">Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3211">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-3212">Invoca um membro específico do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3212">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-3213">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.</span><span class="sxs-lookup"><span data-stu-id="37550-3213">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="37550-3214">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3214">-or-</span></span> 
<span data-ttu-id="37550-3215">Uma cadeia de caracteres vazia ("") para invocar o membro padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-3215">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="37550-3216">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3216">-or-</span></span> 
<span data-ttu-id="37550-3217">Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="37550-3217">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="37550-3218">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-3218">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="37550-3219">O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="37550-3219">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="37550-3220">O tipo de pesquisa não precisa ser especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3220">The type of lookup need not be specified.</span></span> <span data-ttu-id="37550-3221">Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</span><span class="sxs-lookup"><span data-stu-id="37550-3221">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-3222">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-3222">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-3223">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3223">-or-</span></span> 
<span data-ttu-id="37550-3224">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3224">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="37550-3225">Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</span><span class="sxs-lookup"><span data-stu-id="37550-3225">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="37550-3226">O objeto no qual invocar o membro especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3226">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="37550-3227">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3227">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="37550-3228">Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos especificada.</span><span class="sxs-lookup"><span data-stu-id="37550-3228">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="37550-3229">Um objeto que representa o valor retornado do membro invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3229">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="37550-3230">Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3230">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="37550-3231">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-3231">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-3232">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3232">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-3233">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3233">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="37550-3234">Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.</span><span class="sxs-lookup"><span data-stu-id="37550-3234">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="37550-3235">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-3235">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-3236">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-3236">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-3237">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-3237">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-3238">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:</span><span class="sxs-lookup"><span data-stu-id="37550-3238">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="37550-3239">`CreateInstance` para invocar um construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-3239">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="37550-3240">`name` é ignorado.</span><span class="sxs-lookup"><span data-stu-id="37550-3240">`name` is ignored.</span></span> <span data-ttu-id="37550-3241">Não é válido com outros sinalizadores de invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-3241">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="37550-3242">`InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3242">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="37550-3243">Não é válido com `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3243">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="37550-3244">Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.</span><span class="sxs-lookup"><span data-stu-id="37550-3244">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="37550-3245">`GetField` Para obter o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3245">`GetField` to get the value of a field.</span></span> <span data-ttu-id="37550-3246">Não é válido com `SetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3246">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="37550-3247">`SetField` Para definir o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3247">`SetField` to set the value of a field.</span></span> <span data-ttu-id="37550-3248">Não é válido com `GetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3248">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="37550-3249">`GetProperty` Para obter uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3249">`GetProperty` to get a property.</span></span> <span data-ttu-id="37550-3250">Não é válido com `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3250">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="37550-3251">`SetProperty` Para definir uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3251">`SetProperty` to set a property.</span></span> <span data-ttu-id="37550-3252">Não é válido com `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3252">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="37550-3253">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-3253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-3254">Um método será invocado se ambas as seguintes condições forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="37550-3254">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="37550-3255">O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).</span><span class="sxs-lookup"><span data-stu-id="37550-3255">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="37550-3256">O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-3256">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="37550-3257">O associador encontrará todos os métodos correspondentes.</span><span class="sxs-lookup"><span data-stu-id="37550-3257">The binder will find all of the matching methods.</span></span> <span data-ttu-id="37550-3258">Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="37550-3258">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="37550-3259">O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.</span><span class="sxs-lookup"><span data-stu-id="37550-3259">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="37550-3260">Depois que o método é selecionado, ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3260">After the method is selected, it is invoked.</span></span> <span data-ttu-id="37550-3261">Acessibilidade é verificada nesse momento.</span><span class="sxs-lookup"><span data-stu-id="37550-3261">Accessibility is checked at that point.</span></span> <span data-ttu-id="37550-3262">A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método.</span><span class="sxs-lookup"><span data-stu-id="37550-3262">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="37550-3263">O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3263">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="37550-3264">O associador padrão seleciona a correspondência mais específica.</span><span class="sxs-lookup"><span data-stu-id="37550-3264">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="37550-3265">Restrições de acesso são ignoradas em código totalmente confiável; ou seja, construtores particulares, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3265">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="37550-3266">Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-3266">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37550-3267">Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String`, você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3267">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="37550-3268">Se F é um `String[]`, você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3268">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="37550-3269">que inicializará o campo F para essa nova matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3269">which will initialize the field F to this new array.</span></span> <span data-ttu-id="37550-3270">Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-3270">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="37550-3271">Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".</span><span class="sxs-lookup"><span data-stu-id="37550-3271">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="37550-3272">Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="37550-3272">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="37550-3273">Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="37550-3273">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="37550-3274">Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-3274">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="37550-3275">Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.</span><span class="sxs-lookup"><span data-stu-id="37550-3275">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3276">Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="37550-3276">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="37550-3277">(Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="37550-3277">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="37550-3278">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-3278">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3279">O exemplo a seguir usa `InvokeMember` para acessar membros de um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3279">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3280"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3280"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3281"><paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3281"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="37550-3282">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3282">-or-</span></span> 
 <span data-ttu-id="37550-3283"><paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3283"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3284">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3284">-or-</span></span> 
 <span data-ttu-id="37550-3285"><paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3285"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3286">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3286">-or-</span></span> 
 <span data-ttu-id="37550-3287"><paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3287"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="37550-3288">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3288">-or-</span></span> 
 <span data-ttu-id="37550-3289"><paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3289"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3290">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3290">-or-</span></span> 
 <span data-ttu-id="37550-3291"><paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3291"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3292">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3292">-or-</span></span> 
 <span data-ttu-id="37550-3293"><paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="37550-3293"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="37550-3294">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3294">-or-</span></span> 
<span data-ttu-id="37550-3295">Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3295">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="37550-3296">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3296">-or-</span></span> 
<span data-ttu-id="37550-3297">Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3297">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="37550-3298">O membro especificado é um inicializador de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3298">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="37550-3299">Não é possível encontrar o campo nem a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3299">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="37550-3300">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3300">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="37550-3301">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3301">-or-</span></span> 
<span data-ttu-id="37550-3302">O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3302">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="37550-3303">O membro especificado não pode ser invocado no <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3303">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-3304">Mais de um método corresponde aos critérios de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-3304">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-3305">No momento, o .NET Compact Framework não dá suporte a esse método.</span><span class="sxs-lookup"><span data-stu-id="37550-3305">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-3306">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3306">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="37550-3307">Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3307">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="37550-3308">para acessar membros não públicos independentemente do conjunto de concessões.</span><span class="sxs-lookup"><span data-stu-id="37550-3308">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="37550-3309">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="37550-3309">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="37550-3310">para chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3310">to call unmanaged code.</span></span> <span data-ttu-id="37550-3311">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="37550-3311">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-3312">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.</span><span class="sxs-lookup"><span data-stu-id="37550-3312">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="37550-3313">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3313">-or-</span></span> 
<span data-ttu-id="37550-3314">Uma cadeia de caracteres vazia ("") para invocar o membro padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-3314">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="37550-3315">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3315">-or-</span></span> 
<span data-ttu-id="37550-3316">Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="37550-3316">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="37550-3317">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-3317">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="37550-3318">O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="37550-3318">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="37550-3319">O tipo de pesquisa não precisa ser especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3319">The type of lookup need not be specified.</span></span> <span data-ttu-id="37550-3320">Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</span><span class="sxs-lookup"><span data-stu-id="37550-3320">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-3321">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-3321">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-3322">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3322">-or-</span></span> 
<span data-ttu-id="37550-3323">Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3323">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="37550-3324">Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</span><span class="sxs-lookup"><span data-stu-id="37550-3324">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="37550-3325">O objeto no qual invocar o membro especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3325">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="37550-3326">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3326">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="37550-3327">O objeto que representa a localidade de globalização a ser usada, que pode ser necessária para realizar conversões específicas de localidade, como converter uma <see cref="T:System.String" /> numérica em uma <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3327">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="37550-3328">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3328">-or-</span></span> 
<span data-ttu-id="37550-3329">Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3329">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="37550-3330">Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos e cultura especificadas.</span><span class="sxs-lookup"><span data-stu-id="37550-3330">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="37550-3331">Um objeto que representa o valor retornado do membro invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3331">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3332">Embora o associador padrão não processe <xref:System.Globalization.CultureInfo> (o parâmetro `culture` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `culture`.</span><span class="sxs-lookup"><span data-stu-id="37550-3332">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3333">Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3333">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="37550-3334">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-3334">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-3335">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3335">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-3336">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3336">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="37550-3337">Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.</span><span class="sxs-lookup"><span data-stu-id="37550-3337">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="37550-3338">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-3338">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-3339">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-3339">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-3340">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-3340">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-3341">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:</span><span class="sxs-lookup"><span data-stu-id="37550-3341">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="37550-3342">`CreateInstance` para invocar um construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-3342">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="37550-3343">`name` é ignorado.</span><span class="sxs-lookup"><span data-stu-id="37550-3343">`name` is ignored.</span></span> <span data-ttu-id="37550-3344">Não é válido com outros sinalizadores de invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-3344">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="37550-3345">`InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3345">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="37550-3346">Não é válido com `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3346">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="37550-3347">Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.</span><span class="sxs-lookup"><span data-stu-id="37550-3347">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="37550-3348">`GetField` Para obter o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3348">`GetField` to get the value of a field.</span></span> <span data-ttu-id="37550-3349">Não é válido com `SetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3349">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="37550-3350">`SetField` Para definir o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3350">`SetField` to set the value of a field.</span></span> <span data-ttu-id="37550-3351">Não é válido com `GetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3351">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="37550-3352">`GetProperty` Para obter uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3352">`GetProperty` to get a property.</span></span> <span data-ttu-id="37550-3353">Não é válido com `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3353">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="37550-3354">`SetProperty` Para definir uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3354">`SetProperty` to set a property.</span></span> <span data-ttu-id="37550-3355">Não é válido com `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3355">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="37550-3356">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-3356">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-3357">Um método será invocado se ambas as seguintes condições forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="37550-3357">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="37550-3358">O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).</span><span class="sxs-lookup"><span data-stu-id="37550-3358">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="37550-3359">O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-3359">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="37550-3360">O associador encontrará todos os métodos correspondentes.</span><span class="sxs-lookup"><span data-stu-id="37550-3360">The binder will find all of the matching methods.</span></span> <span data-ttu-id="37550-3361">Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="37550-3361">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="37550-3362">O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.</span><span class="sxs-lookup"><span data-stu-id="37550-3362">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="37550-3363">Depois que o método é selecionado, ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3363">After the method is selected, it is invoked.</span></span> <span data-ttu-id="37550-3364">Acessibilidade é verificada nesse momento.</span><span class="sxs-lookup"><span data-stu-id="37550-3364">Accessibility is checked at that point.</span></span> <span data-ttu-id="37550-3365">A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método.</span><span class="sxs-lookup"><span data-stu-id="37550-3365">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="37550-3366">O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3366">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="37550-3367">O associador padrão seleciona a correspondência mais específica.</span><span class="sxs-lookup"><span data-stu-id="37550-3367">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="37550-3368">Restrições de acesso são ignoradas em código totalmente confiável; ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocadas por meio de reflexão, sempre que o código é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3368">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="37550-3369">Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-3369">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37550-3370">Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String` você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3370">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="37550-3371">Se F é um `String[]`, você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3371">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="37550-3372">que inicializará o campo F para essa nova matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3372">which will initialize the field F to this new array.</span></span> <span data-ttu-id="37550-3373">Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-3373">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="37550-3374">Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".</span><span class="sxs-lookup"><span data-stu-id="37550-3374">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="37550-3375">Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="37550-3375">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="37550-3376">Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="37550-3376">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="37550-3377">Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-3377">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="37550-3378">Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.</span><span class="sxs-lookup"><span data-stu-id="37550-3378">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3379">Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="37550-3379">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="37550-3380">(Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="37550-3380">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="37550-3381">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-3381">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3382"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3382"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3383"><paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3383"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="37550-3384">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3384">-or-</span></span> 
 <span data-ttu-id="37550-3385"><paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3385"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3386">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3386">-or-</span></span> 
 <span data-ttu-id="37550-3387"><paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3387"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3388">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3388">-or-</span></span> 
 <span data-ttu-id="37550-3389"><paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3389"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="37550-3390">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3390">-or-</span></span> 
 <span data-ttu-id="37550-3391"><paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3391"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3392">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3392">-or-</span></span> 
 <span data-ttu-id="37550-3393"><paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3393"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3394">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3394">-or-</span></span> 
 <span data-ttu-id="37550-3395"><paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="37550-3395"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="37550-3396">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3396">-or-</span></span> 
<span data-ttu-id="37550-3397">Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3397">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="37550-3398">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3398">-or-</span></span> 
<span data-ttu-id="37550-3399">Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3399">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="37550-3400">O membro especificado é um inicializador de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3400">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="37550-3401">Não é possível encontrar o campo nem a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3401">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="37550-3402">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3402">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="37550-3403">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3403">-or-</span></span> 
<span data-ttu-id="37550-3404">O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3404">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="37550-3405">O membro especificado não pode ser invocado no <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3405">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-3406">Mais de um método corresponde aos critérios de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-3406">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-3407">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3407">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="37550-3408">Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3408">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="37550-3409">para acessar membros não públicos independentemente do conjunto de concessões.</span><span class="sxs-lookup"><span data-stu-id="37550-3409">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="37550-3410">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="37550-3410">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="37550-3411">para chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3411">to call unmanaged code.</span></span> <span data-ttu-id="37550-3412">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="37550-3412">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="37550-3413">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.</span><span class="sxs-lookup"><span data-stu-id="37550-3413">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="37550-3414">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3414">-or-</span></span> 
<span data-ttu-id="37550-3415">Uma cadeia de caracteres vazia ("") para invocar o membro padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-3415">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="37550-3416">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3416">-or-</span></span> 
<span data-ttu-id="37550-3417">Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="37550-3417">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="37550-3418">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span><span class="sxs-lookup"><span data-stu-id="37550-3418">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="37550-3419">O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="37550-3419">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="37550-3420">O tipo de pesquisa não precisa ser especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3420">The type of lookup need not be specified.</span></span> <span data-ttu-id="37550-3421">Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</span><span class="sxs-lookup"><span data-stu-id="37550-3421">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="37550-3422">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-3422">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="37550-3423">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3423">-or-</span></span> 
<span data-ttu-id="37550-3424">Uma referência nula (Nothing no Visual Basic) para usar o <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3424">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="37550-3425">Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</span><span class="sxs-lookup"><span data-stu-id="37550-3425">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="37550-3426">O objeto no qual invocar o membro especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3426">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="37550-3427">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3427">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="37550-3428">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3428">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="37550-3429">Os atributos associados ao parâmetro são armazenados na assinatura do membro.</span><span class="sxs-lookup"><span data-stu-id="37550-3429">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="37550-3430">O associador padrão processa este parâmetro somente ao chamar um componente COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3430">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="37550-3431">O objeto <see cref="T:System.Globalization.CultureInfo" /> que representa a localidade de globalização a ser usada, que pode ser necessária para realizar conversões específicas de localidade, como converter uma String numérica em uma Double.</span><span class="sxs-lookup"><span data-stu-id="37550-3431">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="37550-3432">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3432">-or-</span></span> 
<span data-ttu-id="37550-3433">Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3433">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="37550-3434">Uma matriz que contém os nomes dos parâmetros para os quais os valores na matriz <paramref name="args" /> são passados.</span><span class="sxs-lookup"><span data-stu-id="37550-3434">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="37550-3435">Quando substituído em uma classe derivada, invoca o membro especificado usando as restrições de associação especificadas e correspondendo a cultura, modificadores e lista de argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3435">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="37550-3436">Um objeto que representa o valor retornado do membro invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3436">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3437">`InvokeMember` chama um membro do construtor ou um método, obtém ou define um membro de propriedade, obtém ou define um membro de campo de dados, ou obtém ou define um elemento de um membro da matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3437">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3438">Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3438">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="37550-3439">Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="37550-3439">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="37550-3440">Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="37550-3440">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="37550-3441">Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome.</span><span class="sxs-lookup"><span data-stu-id="37550-3441">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="37550-3442">Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.</span><span class="sxs-lookup"><span data-stu-id="37550-3442">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="37550-3443">Embora o associador padrão não processa <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (o `modifiers` e `culture` parâmetros), você pode usar o resumo <xref:System.Reflection.Binder?displayProperty=nameWithType> classe para gravar um associador personalizado que processam `modifiers` e `culture`.</span><span class="sxs-lookup"><span data-stu-id="37550-3443">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="37550-3444">`ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3444">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="37550-3445">Cada parâmetro na matriz `namedParameters` obtém o valor no elemento correspondente na matriz `args`.</span><span class="sxs-lookup"><span data-stu-id="37550-3445">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="37550-3446">Se o comprimento de `args` for maior que o de `namedParameters`, os valores de argumento restantes serão passados em ordem.</span><span class="sxs-lookup"><span data-stu-id="37550-3446">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="37550-3447">O `namedParameters` matriz pode ser usada para alterar a ordem dos argumentos em uma matriz de entrada.</span><span class="sxs-lookup"><span data-stu-id="37550-3447">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="37550-3448">Por exemplo, considerando o método `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` no Visual Basic) e a matriz de entrada `{ 42, "x" }`, a matriz de entrada pode ser passada inalterada para `args` se a matriz `{ "b", "a" }` for fornecido para `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="37550-3448">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="37550-3449">Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:</span><span class="sxs-lookup"><span data-stu-id="37550-3449">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="37550-3450">Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3450">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="37550-3451">Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="37550-3451">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="37550-3452">Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.</span><span class="sxs-lookup"><span data-stu-id="37550-3452">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="37550-3453">Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:</span><span class="sxs-lookup"><span data-stu-id="37550-3453">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="37550-3454">`BindingFlags.IgnoreCase` para ignorar o caso de `name`.</span><span class="sxs-lookup"><span data-stu-id="37550-3454">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="37550-3455">`BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.</span><span class="sxs-lookup"><span data-stu-id="37550-3455">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="37550-3456">O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:</span><span class="sxs-lookup"><span data-stu-id="37550-3456">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="37550-3457">`CreateInstance` para invocar um construtor.</span><span class="sxs-lookup"><span data-stu-id="37550-3457">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="37550-3458">`name` é ignorado.</span><span class="sxs-lookup"><span data-stu-id="37550-3458">`name` is ignored.</span></span> <span data-ttu-id="37550-3459">Não é válido com outros sinalizadores de invocação.</span><span class="sxs-lookup"><span data-stu-id="37550-3459">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="37550-3460">`InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3460">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="37550-3461">Não é válido com `SetField` ou `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3461">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="37550-3462">Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.</span><span class="sxs-lookup"><span data-stu-id="37550-3462">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="37550-3463">`GetField` Para obter o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3463">`GetField` to get the value of a field.</span></span> <span data-ttu-id="37550-3464">Não é válido com `SetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3464">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="37550-3465">`SetField` Para definir o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="37550-3465">`SetField` to set the value of a field.</span></span> <span data-ttu-id="37550-3466">Não é válido com `GetField`.</span><span class="sxs-lookup"><span data-stu-id="37550-3466">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="37550-3467">`GetProperty` Para obter uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3467">`GetProperty` to get a property.</span></span> <span data-ttu-id="37550-3468">Não é válido com `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3468">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="37550-3469">`SetProperty` Para definir uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3469">`SetProperty` to set a property.</span></span> <span data-ttu-id="37550-3470">Não é válido com `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="37550-3470">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="37550-3471">Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="37550-3471">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="37550-3472">Um método será invocado se ambas as seguintes condições forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="37550-3472">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="37550-3473">O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).</span><span class="sxs-lookup"><span data-stu-id="37550-3473">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="37550-3474">O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-3474">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="37550-3475">O associador encontrará todos os métodos correspondentes.</span><span class="sxs-lookup"><span data-stu-id="37550-3475">The binder will find all of the matching methods.</span></span> <span data-ttu-id="37550-3476">Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="37550-3476">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="37550-3477">O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.</span><span class="sxs-lookup"><span data-stu-id="37550-3477">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="37550-3478">Depois que o método é selecionado, ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3478">After the method is selected, it is invoked.</span></span> <span data-ttu-id="37550-3479">Acessibilidade é verificada nesse momento.</span><span class="sxs-lookup"><span data-stu-id="37550-3479">Accessibility is checked at that point.</span></span> <span data-ttu-id="37550-3480">A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método.</span><span class="sxs-lookup"><span data-stu-id="37550-3480">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="37550-3481">O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="37550-3481">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="37550-3482">O associador padrão seleciona a correspondência mais específica.</span><span class="sxs-lookup"><span data-stu-id="37550-3482">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="37550-3483">`InvokeMember` pode ser usado para invocar métodos com parâmetros que têm valores padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-3483">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="37550-3484">Para vincular a esses métodos, reflexão requer <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> seja especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-3484">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="37550-3485">Para um parâmetro que tem um valor padrão, você pode fornecer um valor diferente, ou fornecer <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> para usar o valor padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-3485">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="37550-3486">Por exemplo, considere um método como MyMethod (int x, y float = 2.0).</span><span class="sxs-lookup"><span data-stu-id="37550-3486">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="37550-3487">Para invocar esse método com somente o primeiro argumento MyMethod(4), passar um dos sinalizadores de associação acima e passar dois argumentos, ou seja, 4 para o primeiro argumento e `Missing.Value` para o segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="37550-3487">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="37550-3488">A menos que você use `Missing.Value`, você não pode omitir parâmetros opcionais com o `Invoke` método.</span><span class="sxs-lookup"><span data-stu-id="37550-3488">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="37550-3489">Se você deve fazer isso, use `InvokeMember` em vez disso.</span><span class="sxs-lookup"><span data-stu-id="37550-3489">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="37550-3490">Restrições de acesso são ignoradas em código totalmente confiável; ou seja, construtores particulares, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3490">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="37550-3491">Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-3491">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37550-3492">Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String`, você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3492">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="37550-3493">Se F é um `String[]`, você pode usar código como:</span><span class="sxs-lookup"><span data-stu-id="37550-3493">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="37550-3494">que inicializará o campo F para essa nova matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3494">which will initialize the field F to this new array.</span></span> <span data-ttu-id="37550-3495">Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="37550-3495">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="37550-3496">Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".</span><span class="sxs-lookup"><span data-stu-id="37550-3496">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3497">Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="37550-3497">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="37550-3498">(Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="37550-3498">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="37550-3499">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="37550-3499">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3500"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3500"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3501"><paramref name="args" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</span><span class="sxs-lookup"><span data-stu-id="37550-3501"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="37550-3502">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3502">-or-</span></span> 
 <span data-ttu-id="37550-3503"><paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="37550-3503"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="37550-3504">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3504">-or-</span></span> 
 <span data-ttu-id="37550-3505"><paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3505"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3506">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3506">-or-</span></span> 
 <span data-ttu-id="37550-3507"><paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3507"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3508">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3508">-or-</span></span> 
 <span data-ttu-id="37550-3509"><paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3509"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="37550-3510">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3510">-or-</span></span> 
 <span data-ttu-id="37550-3511"><paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3511"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3512">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3512">-or-</span></span> 
 <span data-ttu-id="37550-3513"><paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3513"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="37550-3514">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3514">-or-</span></span> 
 <span data-ttu-id="37550-3515"><paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="37550-3515"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="37550-3516">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3516">-or-</span></span> 
<span data-ttu-id="37550-3517">A matriz de parâmetros nomeados é maior que a matriz de argumentos.</span><span class="sxs-lookup"><span data-stu-id="37550-3517">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="37550-3518">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3518">-or-</span></span> 
<span data-ttu-id="37550-3519">Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3519">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="37550-3520">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3520">-or-</span></span> 
<span data-ttu-id="37550-3521">Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3521">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="37550-3522">O membro especificado é um inicializador de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3522">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="37550-3523">Não é possível encontrar o campo nem a propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3523">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="37550-3524">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3524">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="37550-3525">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3525">-or-</span></span> 
<span data-ttu-id="37550-3526">Não foi possível encontrar nenhum membro com os nomes de argumentos fornecidos em <paramref name="namedParameters" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3526">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="37550-3527">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-3527">-or-</span></span> 
<span data-ttu-id="37550-3528">O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3528">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="37550-3529">O membro especificado não pode ser invocado no <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3529">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="37550-3530">Mais de um método corresponde aos critérios de associação.</span><span class="sxs-lookup"><span data-stu-id="37550-3530">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-3531">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3531">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="37550-3532">Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3532">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="37550-3533">para acessar membros não públicos independentemente do conjunto de concessões.</span><span class="sxs-lookup"><span data-stu-id="37550-3533">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="37550-3534">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="37550-3534">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="37550-3535">para chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-3535">to call unmanaged code.</span></span> <span data-ttu-id="37550-3536">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="37550-3536">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3537">Obtém um valor que indica se o <see cref="T:System.Type" /> é abstrato e deve ser substituído.</span><span class="sxs-lookup"><span data-stu-id="37550-3537">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="37550-3538"><see langword="true" /> se o <see cref="T:System.Type" /> for abstrato; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3538"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3539">O <xref:System.Type.IsAbstract%2A> propriedade retorna `true` nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="37550-3539">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="37550-3540">O tipo atual for abstrato; ou seja, ele não pode ser instanciado, mas só pode servir como a classe base para classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="37550-3540">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="37550-3541">No c#, as classes abstratas são marcadas com o [abstrata](~/docs/csharp/language-reference/keywords/abstract.md) palavra-chave; no Visual Basic, são marcados com o [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="37550-3541">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="37550-3542">O tipo atual é uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-3542">The current type is an interface.</span></span>  
  
 <span data-ttu-id="37550-3543">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3543">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3544">O exemplo a seguir cria uma matriz de <xref:System.Type> objetos que representam os seguintes tipos: contém retornos de tipo `true` se o objeto especificado for `abstract`; caso contrário, ele retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3544">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="37550-3545">`AbstractClass`, uma classe abstrata (uma classe marcada como `abstract` em c# e `MustInherit` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-3545">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="37550-3546">`DerivedClass`, uma classe que herda de `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="37550-3546">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="37550-3547">`SingleClass`, uma classe não herdável.</span><span class="sxs-lookup"><span data-stu-id="37550-3547">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="37550-3548">Ele é definido como `sealed` em c# e `NotInheritable` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="37550-3548">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="37550-3549">`ITypeInfo`, uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-3549">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="37550-3550">`ImplementingClass`, uma classe que implementa o `ITypeInfo` interface.</span><span class="sxs-lookup"><span data-stu-id="37550-3550">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="37550-3551">O método retornará `true` apenas para `AbstractClass`, a classe abstrata, e `ITypeInfo`, a interface.</span><span class="sxs-lookup"><span data-stu-id="37550-3551">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3552">Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> está selecionado para o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3552">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-3553"><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3553"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3554">O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="37550-3554">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="37550-3555">Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.</span><span class="sxs-lookup"><span data-stu-id="37550-3555">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="37550-3556">Se o atual <xref:System.Type> representa um tipo genérico, essa propriedade se refere à definição de tipo genérico do qual o tipo foi criado.</span><span class="sxs-lookup"><span data-stu-id="37550-3556">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3557">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3557">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3558">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3558">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3559">O exemplo a seguir obtém as informações de campo e verifica o `AnsiClass` atributo.</span><span class="sxs-lookup"><span data-stu-id="37550-3559">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3560">Obtém um valor que indica se o tipo é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3560">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="37550-3561"><see langword="true" /> se o tipo atual for uma matriz; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3561"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3562">O <xref:System.Type.IsArray%2A> propriedade retorna `false` para o <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3562">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="37550-3563">Ele também retorna `false` se a instância atual é um <xref:System.Type> objeto que representa um tipo de coleção ou uma interface projetada para trabalhar com coleções, como <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="37550-3563">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="37550-3564">Para verificar se há uma matriz, use códigos como:</span><span class="sxs-lookup"><span data-stu-id="37550-3564">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="37550-3565">Se o tipo atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3565">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3566">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-3566">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3567">O exemplo a seguir demonstra como usar o <xref:System.Type.IsArray%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3567">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3568">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsArray" /> e determina se o <see cref="T:System.Type" /> é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3568">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="37550-3569"><see langword="true" /> se <see cref="T:System.Type" /> for uma matriz. Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3569"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3570">Uma instância das <xref:System.Array> deve retornar a classe `false` porque ele é um objeto, não é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3570">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3571">O exemplo a seguir substitui o `IsArrayImpl` método no `MyTypeDelegator` classe verifica se uma variável é uma matriz e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3571">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="37550-3572">O tipo a ser comparado com o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3572">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="37550-3573">Determina se uma instância de um tipo especificado pode ser atribuída a uma instância do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3573">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span></span></summary>
        <returns><span data-ttu-id="37550-3574"><see langword="true" /> se qualquer uma das seguintes condições for verdadeira:</span><span class="sxs-lookup"><span data-stu-id="37550-3574"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="37550-3575">
-   <paramref name="c" /> e a instância atual representam o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3575">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="37550-3576">
-   <paramref name="c" /> é derivado direta ou indiretamente da instância atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3576">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="37550-3577"><paramref name="c" /> será derivado diretamente da instância atual se herdar da instância atual; <paramref name="c" /> será derivado indiretamente da instância atual se herdar de uma sucessão de uma ou mais classes que herdam da instância atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3577"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="37550-3578">-   A instância atual é uma interface implementada por <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3578">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="37550-3579">
-   <paramref name="c" /> é um parâmetro de tipo genérico, e a instância atual representa uma das restrições de <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3579">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="37550-3580">No exemplo a seguir, a instância atual é um objeto <see cref="T:System.Type" /> que representa a classe <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3580">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="37550-3581"><c>GenericWithConstraint</c> é um tipo genérico cujo parâmetro de tipo genérico deve ser do tipo <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3581"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="37550-3582">Passar o parâmetro de tipo genérico para o <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indica que uma instância do parâmetro de tipo genérico pode ser atribuída a um objeto <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3582">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="37550-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="37550-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="37550-3584">
-   <paramref name="c" /> representa um tipo de valor e a instância atual representa <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-3584">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-3585"><see langword="false" /> se nenhuma dessas condições for verdadeira, ou se <paramref name="c" /> for <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3585"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3586">O <xref:System.Type.IsAssignableFrom%2A> método pode ser usado para determinar se uma instância de `c` pode ser atribuído a uma instância do tipo atual, o método é mais útil quando você estiver tratando objetos cujos tipos não são conhecidos em tempo de design e permite condicional atribuição, como o exemplo a seguir mostra.</span><span class="sxs-lookup"><span data-stu-id="37550-3586">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="37550-3587">Esse método, assim, garante que uma linha de código, como a seguir executará em tempo de execução sem gerar uma <xref:System.InvalidCastException> exceção ou uma exceção semelhante:</span><span class="sxs-lookup"><span data-stu-id="37550-3587">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="37550-3588">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-3588">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3589">Uma definição de tipo genérico não é atribuível de um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-3589">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="37550-3590">Ou seja, você não é possível atribuir o tipo construído fechado `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) a uma variável do tipo `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3590">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="37550-3591">Se o `c` parâmetro é do tipo <xref:System.Reflection.Emit.TypeBuilder>, o resultado é baseado no tipo que deve ser criada.</span><span class="sxs-lookup"><span data-stu-id="37550-3591">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="37550-3592">O exemplo de código a seguir demonstra isso usando um tipo interno chamado `B`.</span><span class="sxs-lookup"><span data-stu-id="37550-3592">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="37550-3593">O exemplo a seguir demonstra o `IsAssignableFrom` usando o método definido em classes, matrizes de inteiros e genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-3593">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3594">Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> está selecionado para o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3594">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-3595"><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3595"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3596">O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="37550-3596">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="37550-3597">Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.</span><span class="sxs-lookup"><span data-stu-id="37550-3597">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="37550-3598">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3598">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3599">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3599">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3600">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3600">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3601">Obtém um valor que indica se os campos do tipo atual são apresentados automaticamente pelo Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="37550-3601">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="37550-3602"><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3602"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3603">Esta propriedade é fornecida como uma conveniência.</span><span class="sxs-lookup"><span data-stu-id="37550-3603">This property is provided as a convenience.</span></span> <span data-ttu-id="37550-3604">Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-3604">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="37550-3605">O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-3605">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="37550-3606">Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> quando você cria o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3606">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="37550-3607">No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valor de enumeração para o tipo, para permitir que o tempo de execução determinar a maneira apropriada para dispor a classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3607">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3608">Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3608">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="37550-3609">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3609">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3610">Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="37550-3610">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="37550-3611">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3612">O exemplo a seguir cria uma instância do tipo e exibe o <xref:System.Type.IsAutoLayout%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3612">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="37550-3613">Metadados e componentes autodescritivos</span><span class="sxs-lookup"><span data-stu-id="37550-3613">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3614">Obtém um valor que indica se o <see cref="T:System.Type" /> é aprovado por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3614">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="37550-3615"><see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3615"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3616">Para obter o tipo real, desreferenciar o tipo que foi passado por referência e, em seguida, chamar <xref:System.Type.GetElementType%2A> nesse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3616">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3617">O exemplo a seguir demonstra um uso do `IsByRef` propriedade para verificar se um tipo especificado é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3617">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="37550-3618">O exemplo define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método.</span><span class="sxs-lookup"><span data-stu-id="37550-3618">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="37550-3619">Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3619">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3620">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsByRef" /> e determina se o <see cref="T:System.Type" /> é passado por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3620">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="37550-3621"><see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3621"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3622">Obtém um valor que indica se o <see cref="T:System.Type" /> é uma classe ou um delegado; ou seja, não um tipo de valor ou interface.</span><span class="sxs-lookup"><span data-stu-id="37550-3622">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="37550-3623"><see langword="true" /> se o <see cref="T:System.Type" /> for uma classe; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3623"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3624">Essa propriedade retorna `true` para classes, bem como delegados.</span><span class="sxs-lookup"><span data-stu-id="37550-3624">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="37550-3625">Ele retorna `false` para tipos de valor (para estruturas e enumerações), mesmo se eles são boxed.</span><span class="sxs-lookup"><span data-stu-id="37550-3625">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="37550-3626">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `true`. Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna `true` se a definição de tipo genérico é uma definição de classe; ou seja, ele não define uma interface ou um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-3626">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3627">Essa propriedade retornará `true` para `Type` instâncias que representam as <xref:System.Enum> e <xref:System.ValueType> classes.</span><span class="sxs-lookup"><span data-stu-id="37550-3627">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="37550-3628">Essas duas classes são tipos de base para enumerações e tipos de valor, respectivamente, mas eles não são tipos de valor em si ou enumerações.</span><span class="sxs-lookup"><span data-stu-id="37550-3628">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="37550-3629">Para obter mais informações, consulte o <xref:System.Type.IsValueType%2A> e <xref:System.Type.IsEnum%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-3629">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="37550-3630">O <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor de enumeração distingue uma declaração de tipo como classe ou interface. No entanto, as classes e tipos de valor são marcados com o <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atributo.</span><span class="sxs-lookup"><span data-stu-id="37550-3630">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="37550-3631">Se você recuperar o valor da propriedade Attributes e uso de um tipo de <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor para determinar se um tipo é uma classe em vez de um tipo de valor, você também deve chamar o <xref:System.Type.IsValueType%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3631">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="37550-3632">O exemplo para o <xref:System.Reflection.TypeAttributes> enumeração contém informações adicionais, bem como anexample.</span><span class="sxs-lookup"><span data-stu-id="37550-3632">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="37550-3633">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-3633">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3634">O exemplo a seguir cria uma instância de um tipo e indica se o tipo é uma classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3634">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3635">Obtém um valor que indica se o <see cref="T:System.Type" /> é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3635">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="37550-3636"><see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3636"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3637">Esse método retorna `false` para interfaces de COM, porque eles não são objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-3637">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="37550-3638">Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3638">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="37550-3639">Você também pode carregar uma classe COM e obter um `Type` objeto dessa classe COM usando o [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta.</span><span class="sxs-lookup"><span data-stu-id="37550-3639">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="37550-3640">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3640">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3641">Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int`> (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3641">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3642">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3643">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsCOMObject" /> e determina se o <see cref="T:System.Type" /> é um objeto COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3643">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="37550-3644"><see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3644"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3645">Esse método retorna `false` para interfaces de COM, porque eles não são objetos.</span><span class="sxs-lookup"><span data-stu-id="37550-3645">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="37550-3646">Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="37550-3646">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3647">Obtém um valor que indica se este objeto representa um tipo genérico construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3647">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="37550-3648">Você pode criar instâncias de um tipo genérico construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3648">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="37550-3649"><see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3649"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3650">Um tipo genérico construído teve tipos explícitos fornecidos para todos os seus parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3650">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="37550-3651">Ele também é chamado como um tipo genérico fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-3651">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="37550-3652">Quando essa propriedade é `true`, você pode criar instâncias do tipo atual; quando ele for `false`, não é possível.</span><span class="sxs-lookup"><span data-stu-id="37550-3652">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3653">Obtém um valor que indica se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</span><span class="sxs-lookup"><span data-stu-id="37550-3653">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="37550-3654"><see langword="true" /> se o <see cref="T:System.Type" /> puder ser hospedado em um contexto; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3654"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3655">Um contexto intercepta as chamadas para os membros da classe e impõe políticas que são aplicadas à classe, como sincronização.</span><span class="sxs-lookup"><span data-stu-id="37550-3655">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="37550-3656">Para obter mais informações sobre os contextos de comunicação remota, consulte <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="37550-3656">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="37550-3657">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3657">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3658">O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3658">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="37550-3659">Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.</span><span class="sxs-lookup"><span data-stu-id="37550-3659">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3660">Implementa a propriedade <see cref="P:System.Type.IsContextful" /> e determina se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</span><span class="sxs-lookup"><span data-stu-id="37550-3660">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="37550-3661"><see langword="true" /> se o <see cref="T:System.Type" /> puder ser hospedado em um contexto; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3661"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3662">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-3662">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="37550-3663">Um contexto intercepta as chamadas para os membros da classe e impor políticas que são aplicadas à classe, como sincronização.</span><span class="sxs-lookup"><span data-stu-id="37550-3663">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3664">O exemplo a seguir demonstra um uso do `IsContextfulImpl` método.</span><span class="sxs-lookup"><span data-stu-id="37550-3664">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3665">Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-3665">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="37550-3666"><see langword="true" /> se o <see cref="T:System.Type" /> atual representar uma enumeração; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3666"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3667">Essa propriedade retornará `true` para uma enumeração, mas não para o <xref:System.Enum> próprio tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3667">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="37550-3668">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3668">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3669">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3669">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3670">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3670">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3671">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-3671">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3672">O exemplo a seguir demonstra como usar o `IsEnum` propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3672">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="37550-3673">O valor a ser testado.</span><span class="sxs-lookup"><span data-stu-id="37550-3673">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="37550-3674">Retorna um valor que indica se o valor especificado existe no tipo de enumeração atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3674">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="37550-3675"><see langword="true" /> se o valor especificado for um membro do tipo de enumeração atual; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3675"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-3676">O tipo atual não é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-3676">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-3677"><paramref name="value" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3677"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-3678"><paramref name="value" /> é de um tipo que não pode ser o tipo subjacente de uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-3678"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="37550-3679">A equivalência do tipo de COM é testado em relação ao tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3679">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="37550-3680">Determina se dois tipos COM têm a mesma identidade e são elegíveis para equivalência de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3680">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="37550-3681"><see langword="true" /> se os tipos COM forem equivalentes; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3681"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="37550-3682">Esse método também retornará <see langword="false" />, se for um tipo for um assembly que é carregado para execução e o outro está em um assembly que é carregado no contexto de somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-3682">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3683">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o common language runtime dá suporte à inserção de informações de tipo para tipos COM diretamente em assemblies gerenciados, em vez de exigir que os assemblies gerenciados obter informações de tipo para tipos COM de interoperabilidade assemblies.</span><span class="sxs-lookup"><span data-stu-id="37550-3683">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="37550-3684">Como as informações de tipo inserido incluem somente os tipos e os membros que são realmente usados por um assembly gerenciado, dois assemblies gerenciados podem ter exibições muito diferentes do mesmo tipo COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3684">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="37550-3685">Cada assembly gerenciado tem um objeto <xref:System.Type> diferente para representar sua exibição do tipo COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3685">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="37550-3686">O Common Language Runtime dá suporte à equivalência de tipo entre essas exibições diferentes para interfaces, estruturas, enumerações e representantes.</span><span class="sxs-lookup"><span data-stu-id="37550-3686">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="37550-3687">Equivalência de tipo significa que um objeto COM que é passado de um assembly gerenciado para outro pode ser convertido no tipo gerenciado apropriado no assembly receptor.</span><span class="sxs-lookup"><span data-stu-id="37550-3687">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="37550-3688">O <xref:System.Type.IsEquivalentTo%2A> método permite que um assembly determinar se um objeto COM obtido de outro assembly tem a mesma identidade COM um dos tipos de interoperabilidade do primeiro assembly próprio inserido e, portanto, pode ser convertido para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3688">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="37550-3689">Para obter mais informações, consulte [equivalência de tipo e tipos de interoperabilidade inseridos](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="37550-3689">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3690">Obtém um valor que indica se os campos do tipo atual são apresentados em deslocamentos explicitamente especificados.</span><span class="sxs-lookup"><span data-stu-id="37550-3690">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="37550-3691"><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3691"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3692">Esta propriedade é fornecida como uma conveniência.</span><span class="sxs-lookup"><span data-stu-id="37550-3692">This property is provided as a convenience.</span></span> <span data-ttu-id="37550-3693">Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-3693">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="37550-3694">O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-3694">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="37550-3695">Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> quando você cria o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3695">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="37550-3696">No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que os deslocamentos na qual iniciar os campos são especificados explicitamente.</span><span class="sxs-lookup"><span data-stu-id="37550-3696">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3697">Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3697">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="37550-3698">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3698">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3699">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3699">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3700">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3700">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3701">O exemplo a seguir cria uma instância de um tipo e exibe o valor da sua <xref:System.Type.IsExplicitLayout%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3701">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="37550-3702">Ele usa o `MySystemTime` classe, que também está no código de exemplo para <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-3702">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="37550-3703">Metadados e componentes autodescritivos</span><span class="sxs-lookup"><span data-stu-id="37550-3703">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3704">Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo na definição de um tipo ou método genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3704">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="37550-3705"><see langword="true" /> se o objeto <see cref="T:System.Type" /> representar um parâmetro de tipo de uma definição de tipo genérico ou de método genérico; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3705"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3706"><xref:System.Type> objetos que representam os parâmetros de tipo genérico podem ser obtidos chamando o <xref:System.Type.GetGenericArguments%2A> método de um <xref:System.Type> objeto que representa uma definição de tipo genérico, ou o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método de um <xref:System.Reflection.MethodInfo> objeto que representa um método genérico definição.</span><span class="sxs-lookup"><span data-stu-id="37550-3706"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="37550-3707">Para um tipo genérico ou definição de método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para cada elemento da matriz resultante.</span><span class="sxs-lookup"><span data-stu-id="37550-3707">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="37550-3708">Para um tipo construído fechado ou método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `false` para cada elemento da matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3708">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="37550-3709">Para um tipo construído aberto ou método, alguns elementos da matriz podem ser tipos específicos e outras podem ser parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3709">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="37550-3710"><xref:System.Type.IsGenericParameter%2A> Retorna `false` para os tipos e `true` para os parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3710"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="37550-3711">O exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade demonstra uma classe genérica com uma mistura de tipos e parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3711">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="37550-3712">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-3712">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3713">O exemplo a seguir usa o <xref:System.Type.IsGenericParameter%2A> propriedade a ser testada para parâmetros de tipo genérico em um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3713">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-3714">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-3714">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-3715">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-3715">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3716">Obtém um valor que indica se o tipo atual é um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3716">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="37550-3717"><see langword="true" /> Se o tipo atual é um tipo genérico; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3717"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3718">Use o <xref:System.Type.IsGenericType%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3718">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="37550-3719">Use o <xref:System.Type.ContainsGenericParameters%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo construído aberto ou um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-3719">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3720">O <xref:System.Type.IsGenericType%2A> propriedade retorna `false` se o tipo imediato não for genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3720">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="37550-3721">Por exemplo, uma matriz cujos elementos são do tipo `A<int>` (`A(Of Integer)` no Visual Basic) é um tipo genérico, não em si.</span><span class="sxs-lookup"><span data-stu-id="37550-3721">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="37550-3722">A tabela a seguir resume as condições invariáveis para termos comuns usados na reflexão genérica.</span><span class="sxs-lookup"><span data-stu-id="37550-3722">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="37550-3723">Termo</span><span class="sxs-lookup"><span data-stu-id="37550-3723">Term</span></span>|<span data-ttu-id="37550-3724">Constante</span><span class="sxs-lookup"><span data-stu-id="37550-3724">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="37550-3725">definição de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="37550-3725">generic type definition</span></span>|<span data-ttu-id="37550-3726">A propriedade <xref:System.Type.IsGenericTypeDefinition%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3726">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3727">Define um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3727">Defines a generic type.</span></span> <span data-ttu-id="37550-3728">Um tipo construído é criado chamando o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> objeto que representa uma definição de tipo genérico e especificando uma matriz de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3728">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="37550-3729"><xref:System.Type.MakeGenericType%2A> pode ser chamado apenas em definições de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3729"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="37550-3730">Qualquer definição de tipo genérico é um tipo genérico (a <xref:System.Type.IsGenericType%2A> é de propriedade `true`), mas o inverso não é verdadeiro.</span><span class="sxs-lookup"><span data-stu-id="37550-3730">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="37550-3731">tipo genérico</span><span class="sxs-lookup"><span data-stu-id="37550-3731">generic type</span></span>|<span data-ttu-id="37550-3732">A propriedade <xref:System.Type.IsGenericType%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3732">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3733">Pode ser uma definição de tipo genérico, um tipo construído aberto ou um tipo construído fechado.</span><span class="sxs-lookup"><span data-stu-id="37550-3733">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="37550-3734">Observe que uma matriz cujo tipo de elemento de tipo é genérico não é propriamente um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3734">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="37550-3735">O mesmo é verdadeiro para um <xref:System.Type> objeto que representa um ponteiro para um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3735">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="37550-3736">Abra o tipo construído</span><span class="sxs-lookup"><span data-stu-id="37550-3736">open constructed type</span></span>|<span data-ttu-id="37550-3737">A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3737">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3738">Os exemplos são um tipo genérico que tem não atribuídos a parâmetros de tipo, um tipo que está aninhado em uma definição de tipo genérico ou em um tipo construído aberto ou um tipo genérico que tem um argumento de tipo para o qual o <xref:System.Type.ContainsGenericParameters%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3738">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3739">Não é possível criar uma instância de um tipo construído aberto.</span><span class="sxs-lookup"><span data-stu-id="37550-3739">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="37550-3740">Observe que os tipos construídos abertos não todos são genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-3740">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="37550-3741">Por exemplo, uma matriz cujo tipo de elemento é uma definição de tipo genérico não é genérica e um ponteiro para um tipo construído aberto não é genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3741">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="37550-3742">tipo construído fechado</span><span class="sxs-lookup"><span data-stu-id="37550-3742">closed constructed type</span></span>|<span data-ttu-id="37550-3743">A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3743">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="37550-3744">Quando o examinado recursivamente, o tipo não tem nenhum parâmetro genérico não atribuído.</span><span class="sxs-lookup"><span data-stu-id="37550-3744">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="37550-3745">parâmetro de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="37550-3745">generic type parameter</span></span>|<span data-ttu-id="37550-3746">A propriedade <xref:System.Type.IsGenericParameter%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3746">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3747">A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3747">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3748">Em uma definição de tipo genérico, um espaço reservado para um tipo que será atribuído posteriormente.</span><span class="sxs-lookup"><span data-stu-id="37550-3748">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="37550-3749">argumento de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="37550-3749">generic type argument</span></span>|<span data-ttu-id="37550-3750">Pode ser qualquer tipo, incluindo um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3750">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="37550-3751">Argumentos de tipo são especificados como uma matriz de <xref:System.Type> os objetos passados para o <xref:System.Type.MakeGenericType%2A> método durante a criação de um tipo genérico construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3751">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="37550-3752">Se as instâncias do tipo resultante devem ser criados, o <xref:System.Type.ContainsGenericParameters%2A> propriedade deve ser `false` para todos os argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3752">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="37550-3753">O exemplo de código e a tabela a seguir ilustram alguns desses termos e as invariáveis.</span><span class="sxs-lookup"><span data-stu-id="37550-3753">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="37550-3754">O `Derived` classe é de particular interesse porque seu tipo base é um tipo construído que tem uma mistura de tipos e parâmetros de tipo na lista de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3754">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="37550-3755">A tabela a seguir exemplos de mostra que usam e de compilação nas classes `Base`, `Derived`, e `G`.</span><span class="sxs-lookup"><span data-stu-id="37550-3755">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="37550-3756">Quando o código C++ e c# é o mesmo, é mostrada apenas uma entrada.</span><span class="sxs-lookup"><span data-stu-id="37550-3756">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="37550-3757">Exemplo</span><span class="sxs-lookup"><span data-stu-id="37550-3757">Example</span></span>|<span data-ttu-id="37550-3758">Invariáveis</span><span class="sxs-lookup"><span data-stu-id="37550-3758">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="37550-3759">Para este tipo:</span><span class="sxs-lookup"><span data-stu-id="37550-3759">For this type:</span></span><br /><br /> <span data-ttu-id="37550-3760"><xref:System.Type.IsGenericType%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3761"><xref:System.Type.IsGenericTypeDefinition%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3762"><xref:System.Type.ContainsGenericParameters%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3762"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="37550-3763">Para este tipo:</span><span class="sxs-lookup"><span data-stu-id="37550-3763">For this type:</span></span><br /><br /> <span data-ttu-id="37550-3764"><xref:System.Type.IsGenericType%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3764"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3765"><xref:System.Type.IsGenericTypeDefinition%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3765"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="37550-3766"><xref:System.Type.ContainsGenericParameters%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3766"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="37550-3767">Para o tipo de variável `d`:</span><span class="sxs-lookup"><span data-stu-id="37550-3767">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="37550-3768"><xref:System.Type.IsGenericType%2A> está `false` porque `d` é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-3768"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="37550-3769"><xref:System.Type.IsGenericTypeDefinition%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3769"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="37550-3770"><xref:System.Type.ContainsGenericParameters%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3770"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="37550-3771">`T`, `U`, e `V` (em qualquer lugar que eles aparecem)</span><span class="sxs-lookup"><span data-stu-id="37550-3771">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="37550-3772"><xref:System.Type.IsGenericParameter%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3772"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3773"><xref:System.Type.IsGenericType%2A> é `false` porque não há nenhuma maneira de restringir um parâmetro de tipo para tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-3773"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="37550-3774"><xref:System.Type.IsGenericTypeDefinition%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3774"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="37550-3775"><xref:System.Type.ContainsGenericParameters%2A> está `true` porque `T`, `U`, e `V` são parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3775"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="37550-3776">Isso não significa nada sobre os argumentos de tipo que são atribuídos a eles mais tarde.</span><span class="sxs-lookup"><span data-stu-id="37550-3776">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="37550-3777">O tipo de campo `F`</span><span class="sxs-lookup"><span data-stu-id="37550-3777">The type of field `F`</span></span>|<span data-ttu-id="37550-3778"><xref:System.Type.IsGenericType%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="37550-3779"><xref:System.Type.IsGenericTypeDefinition%2A> está `false` porque um tipo foi designado para o parâmetro de tipo `G`.</span><span class="sxs-lookup"><span data-stu-id="37550-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="37550-3780">Observe que isso é equivalente a ter chamado o <xref:System.Type.MakeGenericType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-3780">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="37550-3781"><xref:System.Type.ContainsGenericParameters%2A> está `true` porque o tipo de campo `F` tem um argumento de tipo que é um tipo construído aberto.</span><span class="sxs-lookup"><span data-stu-id="37550-3781"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="37550-3782">O tipo construído é aberto porque seu argumento de tipo (ou seja, `Base`) é uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3782">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="37550-3783">Isso ilustra a natureza recursiva do <xref:System.Type.IsGenericType%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3783">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="37550-3784">A classe aninhada `Nested`</span><span class="sxs-lookup"><span data-stu-id="37550-3784">The nested class `Nested`</span></span>|<span data-ttu-id="37550-3785"><xref:System.Type.IsGenericType%2A> está `true`, mesmo que o `Nested` classe não tem nenhum parâmetro de tipo genérico de por conta própria, porque ela está aninhada em um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3785"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="37550-3786"><xref:System.Type.IsGenericTypeDefinition%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3786"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="37550-3787">Ou seja, você pode chamar o <xref:System.Type.MakeGenericType%2A> método e fornecer o parâmetro de tipo do tipo delimitador, `Derived`.</span><span class="sxs-lookup"><span data-stu-id="37550-3787">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="37550-3788"><xref:System.Type.ContainsGenericParameters%2A> está `true` porque o tipo de circunscrição, `Derived`, tem parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3788"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="37550-3789">Isso ilustra a natureza recursiva do <xref:System.Type.ContainsGenericParameters%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3789">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="37550-3790">O exemplo de código a seguir exibe o valor da <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, e <xref:System.Type.ContainsGenericParameters%2A> propriedades para os tipos descritos na seção comentários.</span><span class="sxs-lookup"><span data-stu-id="37550-3790">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="37550-3791">Para obter explicações sobre os valores de propriedade, consulte a tabela que acompanha este artigo nos comentários.</span><span class="sxs-lookup"><span data-stu-id="37550-3791">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-3792">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-3792">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-3793">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-3793">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3794">Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</span><span class="sxs-lookup"><span data-stu-id="37550-3794">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="37550-3795"><see langword="true" /> se o objeto <see cref="T:System.Type" /> representar uma definição de tipo genérico, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3795"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3796">Uma definição de tipo genérico é um modelo do qual outros tipos podem ser construídos.</span><span class="sxs-lookup"><span data-stu-id="37550-3796">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="37550-3797">Por exemplo, de definição de tipo genérico `G<T>` (expressa na sintaxe c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode construir e criar uma instância do tipo `G<int>` (`G(Of Integer)` no Visual Basic), chamando o <xref:System.Type.MakeGenericType%2A> método com uma lista de argumento genérico que contém o <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3797">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="37550-3798">Considerando um <xref:System.Type> construída de objeto que representa esse tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método obtém a definição de tipo genérico volta novamente.</span><span class="sxs-lookup"><span data-stu-id="37550-3798">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="37550-3799">Use o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade para determinar se você pode criar novos tipos do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3799">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="37550-3800">Se o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade retorna `true`, você pode chamar o <xref:System.Type.MakeGenericType%2A> método para criar novos tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-3800">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="37550-3801">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-3801">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3802">O exemplo a seguir exibe informações sobre um tipo, incluindo se ele é uma definição de tipo genérico ou não.</span><span class="sxs-lookup"><span data-stu-id="37550-3802">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="37550-3803">Informações são exibidas para um tipo construído, sua definição de tipo genérico e um tipo comum.</span><span class="sxs-lookup"><span data-stu-id="37550-3803">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-3804">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-3804">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-3805">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-3805">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3806">Obtém um valor que indica se o <see cref="T:System.Type" /> tem um atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> aplicado, indicando que ele foi importado de uma biblioteca de tipos COM.</span><span class="sxs-lookup"><span data-stu-id="37550-3806">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="37550-3807"><see langword="true" /> Se o <see cref="T:System.Type" /> tem uma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3807"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3808">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3808">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3809">Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="37550-3809">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="37550-3810">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3810">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="37550-3811">O objeto a ser comparado com o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3811">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="37550-3812">Determina se o objeto especificado é uma instância do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-3812">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-3813"><see langword="true" /> se o <see langword="Type" /> atual estiver na hierarquia de herança do objeto representado pelo <paramref name="o" /> ou se o <see langword="Type" /> atual for uma interface implementada por <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3813"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="37550-3814"><see langword="false" /> se nenhuma dessas condições for verdadeira, se <paramref name="o" /> for <see langword="null" /> ou se o <see langword="Type" /> atual for um tipo genérico aberto (ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</span><span class="sxs-lookup"><span data-stu-id="37550-3814"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3815">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-3815">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3816">Um tipo construído não é uma instância de sua definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-3816">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="37550-3817">Ou seja, `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) não é uma instância de `MyGenericList<T>` (`MyGenericList(Of T)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-3817">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3818">O exemplo a seguir demonstra o uso do método `IsInstanceOfType`.</span><span class="sxs-lookup"><span data-stu-id="37550-3818">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3819">Obtém um valor que indica se o <see cref="T:System.Type" /> é uma interface, ou seja, não é uma classe ou um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-3819">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="37550-3820"><see langword="true" /> se o <see cref="T:System.Type" /> é uma interface; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3820"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3821">O <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue uma declaração de tipo como tipo de classe, interface ou valor.</span><span class="sxs-lookup"><span data-stu-id="37550-3821">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="37550-3822">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3822">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3823">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-3823">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3824">O exemplo a seguir cria uma interface, verifica o tipo de interface e indica se uma classe tem o `IsInterface` conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-3824">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3825">Obtém um valor que indica se os campos do tipo atual são apresentados em sequência, na ordem em que foram definidos ou emitidos para os metadados.</span><span class="sxs-lookup"><span data-stu-id="37550-3825">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="37550-3826"><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3826"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3827">Esta propriedade é fornecida como uma conveniência.</span><span class="sxs-lookup"><span data-stu-id="37550-3827">This property is provided as a convenience.</span></span> <span data-ttu-id="37550-3828">Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-3828">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="37550-3829">O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.</span><span class="sxs-lookup"><span data-stu-id="37550-3829">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="37550-3830">Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> quando você cria o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3830">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="37550-3831">No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que o layout é sequencial.</span><span class="sxs-lookup"><span data-stu-id="37550-3831">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3832">Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3832">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="37550-3833">Para obter mais informações, consulte a seção 9.1.2 da especificação para a documentação do Common Language Infrastructure (CLI), "partição II: Definição de metadados e semântica".</span><span class="sxs-lookup"><span data-stu-id="37550-3833">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="37550-3834">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="37550-3834">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="37550-3835">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-3835">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-3836">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-3836">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-3837">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3837">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3838">O exemplo a seguir cria uma instância de uma classe para o qual o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeração na <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe tiver sido definida, verifica o <xref:System.Type.IsLayoutSequential%2A> propriedade e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3838">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="37550-3839">Metadados e componentes autodescritivos</span><span class="sxs-lookup"><span data-stu-id="37550-3839">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3840">Obtém um valor que indica se é realizado marshal no <see cref="T:System.Type" /> por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3840">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="37550-3841"><see langword="true" /> se for realizado marshal no <see cref="T:System.Type" /> por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3841"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37550-3842">O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3842">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="37550-3843">Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.</span><span class="sxs-lookup"><span data-stu-id="37550-3843">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3844">Implementa a propriedade <see cref="P:System.Type.IsMarshalByRef" /> e determina se é realizado marshal no <see cref="T:System.Type" /> por referência.</span><span class="sxs-lookup"><span data-stu-id="37550-3844">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="37550-3845"><see langword="true" /> se for realizado marshal no <see cref="T:System.Type" /> por referência; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3845"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3846">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-3846">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3847">O exemplo a seguir determina se o tipo fornecido é empacotado por referência e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3847">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3848">Obtém um valor que indica se o objeto atual <see cref="T:System.Type" /> representa um tipo cuja definição está aninhada dentro da definição de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3848">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="37550-3849"><see langword="true" /> se o <see cref="T:System.Type" /> está aninhado dentro de outro tipo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3849"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3850">O <xref:System.Type.IsNested%2A> propriedade retorna `true` para todos os tipos, independentemente da visibilidade aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3850">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="37550-3851">Para testar o aninhamento e visibilidade ao mesmo tempo, use as propriedades relacionadas <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-3851">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3852">O <xref:System.Reflection.TypeAttributes.VisibilityMask> membro de enumeração seleciona os atributos de visibilidade para um tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3852">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3853">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3853">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3854">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3854">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3855">Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visível somente dentro de seu próprio assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3855">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="37550-3856"><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visível somente dentro de seu próprio assembly; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3856"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3857">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3859">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3859">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3860">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3860">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3861">Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visíveis somente para classes que pertencem à sua própria família e ao seu próprio assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3861">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="37550-3862"><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visíveis somente para classes que pertencem à sua própria família e seu próprio assembly; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3862"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3863">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3863">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-3865">As linguagens c# e Visual Basic não têm a semântica que permitem que você defina um tipo aninhado que é visível somente para tipos protegidos em seu próprio assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3865">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="37550-3866">`protected internal` visibilidade em c# e `Protected Friend` visibilidade no Visual Basic define um tipo aninhado que é visível para tipos protegidos e a tipos no mesmo assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3866">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="37550-3867">Um <xref:System.Type> família do objeto é definida como todos os objetos do mesmo <xref:System.Type> e de seus subtipos.</span><span class="sxs-lookup"><span data-stu-id="37550-3867">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3868">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3868">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3869">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3869">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3870">Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visível somente dentro de sua própria família.</span><span class="sxs-lookup"><span data-stu-id="37550-3870">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="37550-3871"><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visível somente dentro de sua própria família; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3871"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3872">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3872">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="37550-3874">Um <xref:System.Type> família do objeto é definida como todos os objetos da exato mesmo <xref:System.Type> e de seus subtipos.</span><span class="sxs-lookup"><span data-stu-id="37550-3874">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3875">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3875">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3876">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3876">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3877">Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visíveis somente para classes que pertençam à sua própria família ou ao seu próprio assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3877">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="37550-3878"><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visíveis somente para classes que pertencem à sua própria família ou ao seu próprio assembly; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3878"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3879">Se a visibilidade de um tipo é `protected internal` em c# ou `Protected Friend` no Visual Basic, o <xref:System.Type.IsNestedFamORAssem%2A> propriedade retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3879">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="37550-3880">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3880">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="37550-3882">Um <xref:System.Type> família do objeto é definida como todos os objetos da exato mesmo <xref:System.Type> e de seus subtipos.</span><span class="sxs-lookup"><span data-stu-id="37550-3882">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3883">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3883">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3884">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3884">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3885">Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e declarado privado.</span><span class="sxs-lookup"><span data-stu-id="37550-3885">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="37550-3886"><see langword="true" /> Se o <see cref="T:System.Type" /> é aninhado e declarado privado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3886"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3887">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3887">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3889">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3890">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3891">Obtém um valor que indica se uma classe é aninhada e declarada pública.</span><span class="sxs-lookup"><span data-stu-id="37550-3891">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="37550-3892"><see langword="true" /> Se a classe aninhada e declarada pública; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3892"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3893">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3893">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3895">O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3895">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="37550-3896">Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-3896">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3897">Obtém um valor que indica se o <see cref="T:System.Type" /> não está declarado como público.</span><span class="sxs-lookup"><span data-stu-id="37550-3897">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="37550-3898"><see langword="true" /> Se o <see cref="T:System.Type" /> não está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3898"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3899">Não use essa propriedade com os tipos aninhados; Use o <xref:System.Type.IsNestedPublic%2A> propriedade em vez disso.</span><span class="sxs-lookup"><span data-stu-id="37550-3899">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="37550-3900">Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3900">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3901">Este usa os de exemplo `IsNotPublic` propriedade para obter a visibilidade do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-3901">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="37550-3902">O exemplo de código a seguir demonstra por que não é possível usar `IsPublic` e `IsNotPublic` para classes aninhadas.</span><span class="sxs-lookup"><span data-stu-id="37550-3902">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="37550-3903">Para classes aninhadas, ignorar os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas aos resultados de `IsNestedPublic` e `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="37550-3903">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="37550-3904">A saída de reflexão para este fragmento de código seria da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="37550-3904">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="37550-3905">Classe</span><span class="sxs-lookup"><span data-stu-id="37550-3905">Class</span></span>|<span data-ttu-id="37550-3906">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="37550-3906">IsNotPublic</span></span>|<span data-ttu-id="37550-3907">IsPublic</span><span class="sxs-lookup"><span data-stu-id="37550-3907">IsPublic</span></span>|<span data-ttu-id="37550-3908">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="37550-3908">IsNestedPublic</span></span>|<span data-ttu-id="37550-3909">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="37550-3909">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="37550-3910">Um</span><span class="sxs-lookup"><span data-stu-id="37550-3910">A</span></span>|<span data-ttu-id="37550-3911">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3911">FALSE</span></span>|<span data-ttu-id="37550-3912">TRUE</span><span class="sxs-lookup"><span data-stu-id="37550-3912">TRUE</span></span>|<span data-ttu-id="37550-3913">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3913">FALSE</span></span>|<span data-ttu-id="37550-3914">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3914">FALSE</span></span>|  
|<span data-ttu-id="37550-3915">B</span><span class="sxs-lookup"><span data-stu-id="37550-3915">B</span></span>|<span data-ttu-id="37550-3916">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3916">FALSE</span></span>|<span data-ttu-id="37550-3917">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3917">FALSE</span></span>|<span data-ttu-id="37550-3918">TRUE</span><span class="sxs-lookup"><span data-stu-id="37550-3918">TRUE</span></span>|<span data-ttu-id="37550-3919">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3919">FALSE</span></span>|  
|<span data-ttu-id="37550-3920">C</span><span class="sxs-lookup"><span data-stu-id="37550-3920">C</span></span>|<span data-ttu-id="37550-3921">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3921">FALSE</span></span>|<span data-ttu-id="37550-3922">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3922">FALSE</span></span>|<span data-ttu-id="37550-3923">FALSE</span><span class="sxs-lookup"><span data-stu-id="37550-3923">FALSE</span></span>|<span data-ttu-id="37550-3924">TRUE</span><span class="sxs-lookup"><span data-stu-id="37550-3924">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3925">Obtém um valor que indica se o <see cref="T:System.Type" /> é um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="37550-3925">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="37550-3926"><see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3926"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3927">Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3927">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="37550-3928">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-3928">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3929">O exemplo a seguir mostra um uso do `IsPointer` propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-3929">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3930">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsPointer" /> e determina se o <see cref="T:System.Type" /> é um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="37550-3930">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="37550-3931"><see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3931"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3932">Obtém um valor que indica se o <see cref="T:System.Type" /> é um dos tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="37550-3932">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="37550-3933"><see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3933"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3934">São os tipos primitivos <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="37550-3934">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="37550-3935">Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3935">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3936">O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="37550-3936">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="37550-3937">Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.</span><span class="sxs-lookup"><span data-stu-id="37550-3937">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-3938">Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsPrimitive" /> e determina se o <see cref="T:System.Type" /> é um dos tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="37550-3938">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="37550-3939"><see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3939"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3940">São os tipos primitivos <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="37550-3940">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3941">O exemplo a seguir determina se o tipo fornecido é um tipo primitivo e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3941">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3942">Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado como público.</span><span class="sxs-lookup"><span data-stu-id="37550-3942">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="37550-3943"><see langword="true" /> Se o <see cref="T:System.Type" /> está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3943"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3944">Não use com tipos aninhados; Use <xref:System.Type.IsNestedPublic%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="37550-3944">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="37550-3945">Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3945">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="37550-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="37550-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3947">O exemplo a seguir cria uma instância do `MyTestClass`, verifica o `IsPublic` propriedade e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3947">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="37550-3948">Para classes aninhadas, ignorar os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas aos resultados de <xref:System.Type.IsNestedPublic%2A> e <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-3948">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3949">Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado selado.</span><span class="sxs-lookup"><span data-stu-id="37550-3949">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="37550-3950"><see langword="true" /> Se o <see cref="T:System.Type" /> é declarado selado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3950"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3951">Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-3951">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-3952">O exemplo a seguir cria uma instância de um `sealed` classe procura o `IsSealed` propriedade e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-3952">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3953">Obtém um valor que indica se o tipo atual é crítico para segurança ou crítico para segurança e disponível no código transparente no nível de confiança atual e, portanto, pode realizar operações críticas.</span><span class="sxs-lookup"><span data-stu-id="37550-3953">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="37550-3954"><see langword="true" /> Se o tipo atual é crítico para segurança ou segurança-seguro-crítica no nível de confiança atual; <see langword="false" /> se for transparente.</span><span class="sxs-lookup"><span data-stu-id="37550-3954"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3955">O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="37550-3955">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="37550-3956">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="37550-3956">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="37550-3957">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="37550-3957">Security level</span></span>|<span data-ttu-id="37550-3958">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="37550-3958">IsSecurityCritical</span></span>|<span data-ttu-id="37550-3959">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="37550-3959">IsSecuritySafeCritical</span></span>|<span data-ttu-id="37550-3960">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="37550-3960">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="37550-3961">Crítico</span><span class="sxs-lookup"><span data-stu-id="37550-3961">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="37550-3962">Segurança crítica</span><span class="sxs-lookup"><span data-stu-id="37550-3962">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="37550-3963">Transparente</span><span class="sxs-lookup"><span data-stu-id="37550-3963">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="37550-3964">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-3964">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="37550-3965">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3965">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="37550-3966">Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3966">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="37550-3967">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="37550-3967">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="37550-3968">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="37550-3968">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="37550-3969">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3969">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="37550-3970">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-3970">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="37550-3971">Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="37550-3971">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="37550-3972">Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="37550-3972">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="37550-3973">Considerações sobre segurança relacionadas à reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-3973">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="37550-3974">Alterações na segurança do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="37550-3974">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3975">Obtém um valor que indica se o tipo é crítico para segurança e disponível no código transparente no nível de confiança atual, ou seja, se ele pode realizar operações críticas e ser acessado por código transparente.</span><span class="sxs-lookup"><span data-stu-id="37550-3975">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="37550-3976"><see langword="true" /> Se o tipo atual é segurança-seguro-crítica no nível de confiança atual; <see langword="false" /> se ele é crítico para segurança ou transparente.</span><span class="sxs-lookup"><span data-stu-id="37550-3976"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3977">O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="37550-3977">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="37550-3978">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="37550-3978">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="37550-3979">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="37550-3979">Security level</span></span>|<span data-ttu-id="37550-3980">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="37550-3980">IsSecurityCritical</span></span>|<span data-ttu-id="37550-3981">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="37550-3981">IsSecuritySafeCritical</span></span>|<span data-ttu-id="37550-3982">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="37550-3982">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="37550-3983">Crítico</span><span class="sxs-lookup"><span data-stu-id="37550-3983">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="37550-3984">Segurança crítica</span><span class="sxs-lookup"><span data-stu-id="37550-3984">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="37550-3985">Transparente</span><span class="sxs-lookup"><span data-stu-id="37550-3985">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="37550-3986">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-3986">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="37550-3987">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3987">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="37550-3988">Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-3988">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="37550-3989">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="37550-3989">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="37550-3990">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="37550-3990">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="37550-3991">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-3991">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="37550-3992">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-3992">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="37550-3993">Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="37550-3993">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="37550-3994">Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="37550-3994">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="37550-3995">Considerações sobre segurança relacionadas à reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-3995">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="37550-3996">Alterações na segurança do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="37550-3996">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-3997">Obtém um valor que indica que se o tipo atual é transparente no nível de confiança atual e, portanto, não pode realizar operações críticas.</span><span class="sxs-lookup"><span data-stu-id="37550-3997">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="37550-3998"><see langword="true" /> Se o tipo é transparente de segurança no nível de confiança atual; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-3998"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-3999">Se essa propriedade retornará `true`, o <xref:System.Type.IsSecurityCritical%2A> e <xref:System.Type.IsSecuritySafeCritical%2A> retornam propriedades `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-3999">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="37550-4000">O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="37550-4000">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="37550-4001">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-4001">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="37550-4002">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4002">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="37550-4003">Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4003">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="37550-4004">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="37550-4004">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="37550-4005">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="37550-4005">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="37550-4006">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="37550-4006">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="37550-4007">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-4007">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="37550-4008">Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="37550-4008">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="37550-4009">Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="37550-4009">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="37550-4010">Considerações sobre segurança relacionadas à reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-4010">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="37550-4011">Alterações na segurança do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="37550-4011">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4012">Obtém um valor que indica se o <see cref="T:System.Type" /> é serializável.</span><span class="sxs-lookup"><span data-stu-id="37550-4012">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="37550-4013"><see langword="true" /> se o <see cref="T:System.Type" /> for serializável; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4013"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="37550-4014">Tipos que são definidos no .NET Standard não são marcados com <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37550-4014">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="37550-4015">Em vez disso, cada implementação do .NET determina se um tipo é serializável.</span><span class="sxs-lookup"><span data-stu-id="37550-4015">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="37550-4016">Em tempo de execução, você pode usar o <xref:System.Type.IsSerializable%2A> propriedade para determinar se essa implementação dá suporte à serialização de uma instância do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4016">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="37550-4017">Para obter mais informações e um exemplo, consulte [como determinar se um objeto .NET padrão é serializável](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="37550-4017">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="37550-4018">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-4018">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-4019">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-4019">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-4020">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-4020">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4021">O exemplo a seguir cria uma instância do `MyTestClass` classe, define o atributo [Serializable] e verifica o `IsSerializable` propriedade `true` ou `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-4021">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4022">Obtém um valor que indica se o tipo tem um nome que exige tratamento especial.</span><span class="sxs-lookup"><span data-stu-id="37550-4022">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="37550-4023"><see langword="true" /> se o tipo tiver um nome que exige tratamento especial; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4023"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4024">Os nomes que começam com ou contenham um caractere de sublinhado (_), os acessadores de propriedade e métodos de sobrecarga de operador são exemplos de tipos que podem exigir tratamento especial por alguns compiladores.</span><span class="sxs-lookup"><span data-stu-id="37550-4024">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="37550-4025">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-4025">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-4026">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-4026">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-4027">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-4027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="37550-4028">O tipo a ser comparado com o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4028">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="37550-4029">Determina se o <see cref="T:System.Type" /> atual deriva do <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-4029">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-4030"><see langword="true" /> se o <see langword="Type" /> atual derivar de <paramref name="c" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4030"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="37550-4031">Esse método também retorna <see langword="false" /> se <paramref name="c" /> e o <see langword="Type" /> atual forem iguais.</span><span class="sxs-lookup"><span data-stu-id="37550-4031">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4032">Você pode chamar o <xref:System.Type.IsSubclassOf%2A> método para determinar qualquer um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="37550-4032">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="37550-4033">Se uma classe derivada de outra.</span><span class="sxs-lookup"><span data-stu-id="37550-4033">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="37550-4034">Se um tipo derivado de <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="37550-4034">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="37550-4035">No entanto, o <xref:System.Type.IsValueType%2A> é uma maneira mais eficiente para determinar se um tipo é um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-4035">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="37550-4036">Se um tipo derivado de <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="37550-4036">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="37550-4037">No entanto, o <xref:System.Type.IsEnum%2A> método é uma maneira mais eficiente para determinar se um tipo é uma enumeração.</span><span class="sxs-lookup"><span data-stu-id="37550-4037">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="37550-4038">Se um tipo é um delegado, ou seja, se ele deriva de uma <xref:System.Delegate> ou <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="37550-4038">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="37550-4039">O <xref:System.Type.IsSubclassOf%2A> método não pode ser usado para determinar se uma interface deriva de outra interface ou se uma classe implementa uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-4039">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="37550-4040">Use o <xref:System.Type.IsAssignableFrom%2A> método para essa finalidade, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-4040">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="37550-4041">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, ela deriva de sua restrição de classe ou de <xref:System.Object?displayProperty=nameWithType> se ele tiver nenhuma restrição de classe.</span><span class="sxs-lookup"><span data-stu-id="37550-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-4042">Exceto quando usado com interfaces, <xref:System.Type.IsSubclassOf%2A> é o oposto de <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-4042">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="37550-4043">Ou seja, se `t1.IsSubclassOf(t2)` está `true`, em seguida, `t2.IsAssignableFrom(t1)` também é `true`.</span><span class="sxs-lookup"><span data-stu-id="37550-4043">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="37550-4044">Este método pode ser substituído por uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="37550-4044">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4045">O exemplo a seguir cria uma classe chamada `Class1` e uma classe derivada chamada `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="37550-4045">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="37550-4046">Ele chama o <xref:System.Type.IsSubclassOf%2A> método para mostrar que `DerivedC1` é uma subclasse de `Class1`.</span><span class="sxs-lookup"><span data-stu-id="37550-4046">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-4047"><paramref name="c" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4047"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4048">Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> está selecionado para o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4048">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-4049"><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4049"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4050">O <xref:System.Reflection.TypeAttributes.StringFormatMask> é usado para selecionar os atributos de formato de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="37550-4050">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="37550-4051">Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.</span><span class="sxs-lookup"><span data-stu-id="37550-4051">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="37550-4052">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-4052">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-4053">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-4053">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-4054">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-4054">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4055">Obtém um valor que indica se o <see cref="T:System.Type" /> é um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-4055">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="37550-4056"><see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4056"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4057">Tipos de valor são tipos que são representados como sequências de bits; tipos de valor não são classes ou interfaces.</span><span class="sxs-lookup"><span data-stu-id="37550-4057">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="37550-4058">Tipos de valor são chamados de "structs" em algumas linguagens de programação.</span><span class="sxs-lookup"><span data-stu-id="37550-4058">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="37550-4059">Enumerações são um caso especial de tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-4059">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="37550-4060">Essa propriedade retornará `false` para o <xref:System.ValueType> classe, pois <xref:System.ValueType> não é um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-4060">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="37550-4061">É a classe base para todos os tipos de valor e, portanto, qualquer tipo de valor pode ser atribuído a ele.</span><span class="sxs-lookup"><span data-stu-id="37550-4061">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="37550-4062">Isso não seria possível se <xref:System.ValueType> em si foi um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="37550-4062">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="37550-4063">Tipos de valor são boxed quando eles forem atribuídos a um campo do tipo <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="37550-4063">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="37550-4064">Essa propriedade retornará `true` para enumerações, mas não para o <xref:System.Enum> próprio tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4064">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="37550-4065">Para obter um exemplo que demonstra esse comportamento, consulte <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-4065">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="37550-4066">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-4066">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4067">O exemplo a seguir cria uma variável do tipo `MyEnum`, verifica o `IsValueType` propriedade e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="37550-4067">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-4068">Implementa a propriedade <see cref="P:System.Type.IsValueType" /> e determina se o <see cref="T:System.Type" /> é um tipo de valor, ou seja, não é uma classe nem uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-4068">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="37550-4069"><see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4069"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4070">Este método é fornecido para habilitar a implementação de sistemas de tipo alternativo.</span><span class="sxs-lookup"><span data-stu-id="37550-4070">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="37550-4071">Ele não é geralmente usado no código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="37550-4071">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4072">Obtém um valor que indica se <see cref="T:System.Type" /> pode ser acessado pelo código fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4072">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="37550-4073"><see langword="true" /> se o <see cref="T:System.Type" /> atual é um tipo público ou um tipo público aninhado, de modo que todos os tipos de delimitadores são públicos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4073"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4074">Use essa propriedade para determinar se um tipo é parte da interface pública de um assembly do componente.</span><span class="sxs-lookup"><span data-stu-id="37550-4074">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4075">O exemplo de código a seguir testa as duas classes, apenas um deles é visível fora do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4075">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="37550-4076">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4076">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-4077">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</span><span class="sxs-lookup"><span data-stu-id="37550-4077">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="37550-4078">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</span><span class="sxs-lookup"><span data-stu-id="37550-4078">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4079">O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira para gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-4079">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="37550-4080">**Observação** o common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseados em zero) e matrizes multidimensionais.</span><span class="sxs-lookup"><span data-stu-id="37550-4080">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="37550-4081">Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional que tem apenas uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="37550-4081">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="37550-4082">Essa sobrecarga de método só pode ser usada para criar tipos de vetor e é a única maneira de criar um tipo de vetor.</span><span class="sxs-lookup"><span data-stu-id="37550-4082">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="37550-4083">Use o <xref:System.Type.MakeArrayType%28System.Int32%29> sobrecarga de método para criar tipos de matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="37550-4083">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4084">O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.</span><span class="sxs-lookup"><span data-stu-id="37550-4084">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4085">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4085">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="37550-4086">As classes derivadas devem fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-4086">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-4087">O tipo atual é <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4087">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="37550-4088">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4088">-or-</span></span> 
<span data-ttu-id="37550-4089">O tipo atual é um tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4089">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="37550-4090">Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="37550-4091">O número de dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-4091">The number of dimensions for the array.</span></span> <span data-ttu-id="37550-4092">Esse número deve ser menor ou igual a 32.</span><span class="sxs-lookup"><span data-stu-id="37550-4092">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="37550-4093">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-4093">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="37550-4094">Um objeto que representa uma matriz do tipo atual, com o número de dimensões especificado.</span><span class="sxs-lookup"><span data-stu-id="37550-4094">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4095">O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira para gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="37550-4095">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-4096">O common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseados em zero) e matrizes multidimensionais.</span><span class="sxs-lookup"><span data-stu-id="37550-4096">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="37550-4097">Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional que tem apenas uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="37550-4097">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="37550-4098">Você não pode usar essa sobrecarga de método para criar um tipo de vetor; Se `rank` for 1, essa sobrecarga de método retorna um tipo de matriz multidimensional que acaba tendo uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="37550-4098">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="37550-4099">Use o <xref:System.Type.MakeArrayType> sobrecarga de método para criar tipos de vetor.</span><span class="sxs-lookup"><span data-stu-id="37550-4099">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4100">O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.</span><span class="sxs-lookup"><span data-stu-id="37550-4100">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="37550-4101"><paramref name="rank" /> é inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-4101"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="37550-4102">Por exemplo, 0 ou negativo.</span><span class="sxs-lookup"><span data-stu-id="37550-4102">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4103">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4103">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-4104">O tipo atual é <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4104">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="37550-4105">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4105">-or-</span></span> 
<span data-ttu-id="37550-4106">O tipo atual é um tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4106">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="37550-4107">Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4107">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="37550-4108">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4108">-or-</span></span> 
 <span data-ttu-id="37550-4109"><paramref name="rank" /> é maior que 32.</span><span class="sxs-lookup"><span data-stu-id="37550-4109"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-4110">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-4110">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="37550-4111">Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-4111">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4112">O <xref:System.Type.MakeByRefType%2A> método fornece uma maneira de gerar `ref` tipos (`ByRef` no Visual Basic) para o parâmetro de lista.</span><span class="sxs-lookup"><span data-stu-id="37550-4112">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="37550-4113">Usando a sintaxe da Microsoft intermediate language (MSIL), se o atual <xref:System.Type> objeto representa <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="37550-4113">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4114">O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.</span><span class="sxs-lookup"><span data-stu-id="37550-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4115">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4115">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-4116">O tipo atual é <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4116">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="37550-4117">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4117">-or-</span></span> 
<span data-ttu-id="37550-4118">O tipo atual é um tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4118">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="37550-4119">Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4119">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="37550-4120">Uma matriz de tipos a serem substituídos pelos parâmetros de tipo do tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4120">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="37550-4121">Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna um objeto <see cref="T:System.Type" /> que representa o tipo construído resultante.</span><span class="sxs-lookup"><span data-stu-id="37550-4121">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="37550-4122">Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4122">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4123">O <xref:System.Type.MakeGenericType%2A> método permite que você escreva código que atribui tipos específicos para os parâmetros de tipo de uma definição de tipo genérico, criando assim um <xref:System.Type> objeto que representa um tipo construído específico.</span><span class="sxs-lookup"><span data-stu-id="37550-4123">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="37550-4124">Você pode usar isso <xref:System.Type> objeto para criar instâncias de tempo de execução do tipo construído.</span><span class="sxs-lookup"><span data-stu-id="37550-4124">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="37550-4125">Tipos construídos com <xref:System.Type.MakeGenericType%2A> podem ser abertos, ou seja, alguns dos argumentos de tipo podem ser parâmetros de tipo de circunscrição tipos ou métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-4125">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="37550-4126">Você pode usar esses tipos construídos abertos quando você emite assemblies dinâmicos.</span><span class="sxs-lookup"><span data-stu-id="37550-4126">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="37550-4127">Por exemplo, considere as classes `Base` e `Derived` no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="37550-4127">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="37550-4128">Para gerar `Derived` em um assembly dinâmico, é necessário construir seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="37550-4128">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="37550-4129">Para fazer isso, chame o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> que representa a classe de objeto `Base`, usando os argumentos de tipo genérico <xref:System.Int32> e o parâmetro de tipo `V` de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="37550-4129">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="37550-4130">Como tipos e parâmetros de tipo genérico são representados por <xref:System.Type> objetos, uma matriz que contém ambos pode ser passada para o <xref:System.Type.MakeGenericType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-4130">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-4131">Um tipo construído, como `Base<int, V>` é útil para emitir o código, mas você não pode chamar o <xref:System.Type.MakeGenericType%2A> método neste tipo porque ele não é uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-4131">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="37550-4132">Para criar um tipo construído fechado que pode ser instanciado, primeiro chame o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter uma <xref:System.Type> do objeto que representa a definição de tipo genérico e, em seguida, chamar <xref:System.Type.MakeGenericType%2A> com os argumentos de tipo desejado.</span><span class="sxs-lookup"><span data-stu-id="37550-4132">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="37550-4133">O <xref:System.Type> objeto retornado por <xref:System.Type.MakeGenericType%2A> é o mesmo que o <xref:System.Type> obtido chamando o <xref:System.Object.GetType%2A> método resultantes construído tipo, ou o <xref:System.Object.GetType%2A> construído de método de qualquer tipo que foi criado da mesma genérico usando os mesmos argumentos de tipo de definição de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4133">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37550-4134">Uma matriz de tipos genéricos não é propriamente um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-4134">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="37550-4135">Você não pode chamar <xref:System.Type.MakeGenericType%2A> em uma matriz de tipo como `C<T>[]` (`Dim ac() As C(Of T)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-4135">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="37550-4136">Para construir um tipo genérico fechado de `C<T>[]`, chame <xref:System.Type.GetElementType%2A> para obter a definição de tipo genérico `C<T>`; chamar <xref:System.Type.MakeGenericType%2A> na definição de tipo genérico para criar o tipo construído; e, finalmente, chame o <xref:System.Type.MakeArrayType%2A> método em o tipo construído para criar o tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="37550-4136">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="37550-4137">O mesmo é verdadeiro de tipos de ponteiro e `ref` tipos (`ByRef` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="37550-4137">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="37550-4138">Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="37550-4138">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="37550-4139">Tipos aninhados</span><span class="sxs-lookup"><span data-stu-id="37550-4139">Nested Types</span></span>  
 <span data-ttu-id="37550-4140">Se um tipo genérico é definido usando c#, C++ ou Visual Basic, seus tipos aninhados são todos genéricos.</span><span class="sxs-lookup"><span data-stu-id="37550-4140">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="37550-4141">Isso é verdadeiro mesmo se os tipos aninhados não tem nenhum parâmetro de tipo próprios, porque todos os três linguagens incluem os parâmetros de tipo de tipos de delimitadores nas listas de parâmetros de tipo de tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-4141">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="37550-4142">Considere as seguintes classes:</span><span class="sxs-lookup"><span data-stu-id="37550-4142">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="37550-4143">Lista de parâmetros de tipo da classe aninhada `Inner` tem dois parâmetros de tipo `T` e `U`, o primeiro deles é o parâmetro de tipo de sua classe delimitadora.</span><span class="sxs-lookup"><span data-stu-id="37550-4143">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="37550-4144">Da mesma forma, a lista de parâmetros de tipo da classe aninhada `Innermost1` tem três parâmetros de tipo `T`, `U`, e `V`, com `T` e `U` provenientes de suas classes de delimitadores.</span><span class="sxs-lookup"><span data-stu-id="37550-4144">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="37550-4145">A classe aninhada `Innermost2` tem dois parâmetros de tipo `T` e `U`, que vêm de suas classes de delimitadores.</span><span class="sxs-lookup"><span data-stu-id="37550-4145">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="37550-4146">Se a lista de parâmetros do tipo delimitador tem mais de um parâmetro de tipo, todos os parâmetros de tipo na ordem são incluídos na lista de parâmetros de tipo do tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="37550-4146">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="37550-4147">Para construir um tipo genérico com base na definição de tipo genérico para um tipo aninhado, chame o <xref:System.Type.MakeGenericType%2A> método com a matriz formado pela concatenação de matrizes de argumento de tipo de todos os tipos de delimitador, começando com o tipo genérico mais externo e terminando com o tipo de matriz de argumentos do tipo aninhado em si, se ele tem parâmetros de tipo próprios.</span><span class="sxs-lookup"><span data-stu-id="37550-4147">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="37550-4148">Para criar uma instância do `Innermost1`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém três tipos, a ser atribuído ao T, U e V. Para criar uma instância do `Innermost2`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém dois tipos, a ser atribuído ao T e U.</span><span class="sxs-lookup"><span data-stu-id="37550-4148">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="37550-4149">Os idiomas propagam os parâmetros de tipo de tipos de delimitadores dessa maneira para que você pode usar os parâmetros de tipo de um tipo de delimitador para definir os campos de tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-4149">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="37550-4150">Caso contrário, os parâmetros de tipo não seria no escopo em que os corpos dos tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="37550-4150">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="37550-4151">É possível definir tipos aninhados sem propagar os parâmetros de tipo de tipos de delimitadores, pela emissão do código em assemblies dinâmicos ou usando o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="37550-4151">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="37550-4152">Considere o seguinte código para o assembler MSIL:</span><span class="sxs-lookup"><span data-stu-id="37550-4152">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="37550-4153">Neste exemplo, não é possível definir um campo do tipo `T` ou `U` na classe `Innermost`, porque esses parâmetros de tipo não estão no escopo.</span><span class="sxs-lookup"><span data-stu-id="37550-4153">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="37550-4154">O seguinte código de assembler define classes aninhadas que se comportam da forma que fariam se definida em C++, Visual Basic e c#:</span><span class="sxs-lookup"><span data-stu-id="37550-4154">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="37550-4155">Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar as classes aninhadas definidas em linguagens de alto nível e observar esse esquema de nomenclatura.</span><span class="sxs-lookup"><span data-stu-id="37550-4155">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4156">O exemplo a seguir usa o <xref:System.Type.MakeGenericType%2A> método para criar um tipo construído da definição de tipo genérico para o <xref:System.Collections.Generic.Dictionary%602> tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4156">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="37550-4157">Representa o tipo construído uma <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="37550-4157">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="37550-4158">O tipo atual não representa uma definição de tipo genérica.</span><span class="sxs-lookup"><span data-stu-id="37550-4158">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="37550-4159">Ou seja, <see cref="P:System.Type.IsGenericTypeDefinition" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4159">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-4160"><paramref name="typeArguments" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4160"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="37550-4161">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4161">-or-</span></span> 
<span data-ttu-id="37550-4162">Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4162">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-4163">O número de elementos em <paramref name="typeArguments" /> não é igual ao número de parâmetros de tipo na definição de tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4163">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="37550-4164">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4164">-or-</span></span> 
<span data-ttu-id="37550-4165">Nenhum elemento do <paramref name="typeArguments" /> satisfaz as restrições especificadas para o parâmetro de tipo correspondente do tipo genérico atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4165">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="37550-4166">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4166">-or-</span></span> 
 <span data-ttu-id="37550-4167"><paramref name="typeArguments" /> contém um elemento que é um tipo de ponteiro (<see cref="P:System.Type.IsPointer" /> retorna <see langword="true" />), um tipo by-ref (<see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />) ou <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4167"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4168">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4168">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="37550-4169">As classes derivadas devem fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="37550-4169">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="37550-4170">Reflexão e tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="37550-4170">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="37550-4171">Como examinar tipos genéricos e criar instâncias deles com a reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-4171">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-4172">Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4172">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="37550-4173">Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4173">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4174">O <xref:System.Type.MakePointerType%2A> método fornece uma maneira para gerar tipos de ponteiro para listas de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="37550-4174">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="37550-4175">Usando a sintaxe da Microsoft intermediate language (MSIL), se o atual <xref:System.Type> objeto representa <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="37550-4175">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4176">O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.</span><span class="sxs-lookup"><span data-stu-id="37550-4176">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4177">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4177">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-4178">O tipo atual é <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4178">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="37550-4179">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4179">-or-</span></span> 
<span data-ttu-id="37550-4180">O tipo atual é um tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4180">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="37550-4181">Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4181">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4182">Obtém um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="37550-4182">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="37550-4183">Um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="37550-4183">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4184">Esta propriedade substitui <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-4184">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37550-4185">Portanto, quando você examinar um conjunto de <xref:System.Reflection.MemberInfo> objetos, por exemplo, a matriz retornada por <xref:System.Type.GetMembers%2A> - o <xref:System.Reflection.MemberInfo.MemberType%2A> propriedade retorna <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quando um determinado membro é um tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="37550-4185">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="37550-4186">Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído.</span><span class="sxs-lookup"><span data-stu-id="37550-4186">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="37550-4187">Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="37550-4187">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="37550-4188">Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37550-4188">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4189">O seguinte exemplo de código mostra a `MemberType` campo como um parâmetro para o `GetMember` método:</span><span class="sxs-lookup"><span data-stu-id="37550-4189">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4190">Representa um valor ausente nas informações <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4190">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="37550-4191">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="37550-4191">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4192">Use o `Missing` field para invocação por meio de reflexão para obter o valor padrão de um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-4192">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="37550-4193">Se o `Missing` campo é passado para um valor de parâmetro e não há nenhum valor padrão para esse parâmetro, um <xref:System.ArgumentException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="37550-4193">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4194">O exemplo de código a seguir mostra o uso do `Missing` campo para invocar um método com argumentos padrão.</span><span class="sxs-lookup"><span data-stu-id="37550-4194">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="37550-4195">Esse código gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="37550-4195">This code produces the following output:</span></span>  
  
 <span data-ttu-id="37550-4196">um = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="37550-4196">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="37550-4197">um = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="37550-4197">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="37550-4198">um = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="37550-4198">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4199">Obtém o módulo (a DLL) no qual o <see cref="T:System.Type" /> atual está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-4199">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="37550-4200">O módulo no qual o <see cref="T:System.Type" /> atual está definido.</span><span class="sxs-lookup"><span data-stu-id="37550-4200">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4201">Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna o módulo no qual a definição de tipo genérico foi definida.</span><span class="sxs-lookup"><span data-stu-id="37550-4201">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="37550-4202">Por exemplo, se você criar uma instância do `MyGenericStack<int>`, o <xref:System.Type.Module%2A> propriedade para o tipo construído retorna o módulo no qual `MyGenericStack<T>` é definido.</span><span class="sxs-lookup"><span data-stu-id="37550-4202">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="37550-4203">Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="37550-4203">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4204">Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e `Module` propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-4204">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4205">Obtém o namespace do <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4205">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-4206">O namespace do <see cref="T:System.Type" />; <see langword="null" /> se a instância atual não tiver nenhum namespace ou representar um parâmetro genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-4206">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4207">Um namespace é uma lógica de tempo de design nomenclatura conveniência, usada principalmente para definir o escopo em um aplicativo e organizar as classes e outros tipos em uma única estrutura hierárquica.</span><span class="sxs-lookup"><span data-stu-id="37550-4207">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="37550-4208">Do ponto de vista do tempo de execução, não há nenhum namespace.</span><span class="sxs-lookup"><span data-stu-id="37550-4208">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="37550-4209">Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna o namespace que contém a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="37550-4209">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="37550-4210">Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o namespace que contém a definição de tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="37550-4210">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="37550-4211">Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-4211">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4212">Este exemplo a seguir demonstra um uso do `Namespace` e <xref:System.Type.Module%2A> propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-4212">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-4213">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-4213">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="37550-4214">O primeiro objeto a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="37550-4214">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="37550-4215">O segundo objeto a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="37550-4215">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="37550-4216">Indica se dois objetos <see cref="T:System.Type" /> são iguais.</span><span class="sxs-lookup"><span data-stu-id="37550-4216">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="37550-4217"><see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4217"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="37550-4218">O primeiro objeto a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="37550-4218">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="37550-4219">O segundo objeto a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="37550-4219">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="37550-4220">Indica se dois objetos <see cref="T:System.Type" /> não são iguais.</span><span class="sxs-lookup"><span data-stu-id="37550-4220">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="37550-4221"><see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4221"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4222">Obtém o objeto de classe que foi usado para obter esse membro.</span><span class="sxs-lookup"><span data-stu-id="37550-4222">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="37550-4223">O objeto <see langword="Type" /> por meio do qual este objeto <see cref="T:System.Type" /> foi obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-4223">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4224">Para <xref:System.Type> objetos, o valor dessa propriedade é sempre o mesmo que o valor da <xref:System.Type.DeclaringType%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-4224">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4225">Este exemplo exibe o tipo refletido de uma classe aninhada.</span><span class="sxs-lookup"><span data-stu-id="37550-4225">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="37550-4226">O nome qualificado pelo assembly do <see cref="T:System.Type" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-4226">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="37550-4227"><see langword="true" /> para gerar uma <see cref="T:System.TypeLoadException" /> se não for possível encontrar o tipo, <see langword="false" /> para retornar <see langword="null" /> se não for possível encontrar o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4227"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="37550-4228">A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas.</span><span class="sxs-lookup"><span data-stu-id="37550-4228">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="37550-4229">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-4229">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="37550-4230"><see langword="true" /> para executar uma pesquisa que não diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4230"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="37550-4231">Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deverá realizar uma pesquisa que diferencia maiúsculas de minúsculas e se deverá gerar uma exceção se o tipo não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-4231">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="37550-4232">O tipo é carregado para reflexão apenas, não para execução.</span><span class="sxs-lookup"><span data-stu-id="37550-4232">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="37550-4233">O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4233">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="37550-4234">Caso o tipo não seja encontrado, o parâmetro <paramref name="throwIfNotFound" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="37550-4234">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="37550-4235">Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwIfNotFound" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4235">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="37550-4236">Consulte a seção Exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-4236">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4237">Se o assembly que contém o tipo já não estiver carregado no contexto somente reflexão, usando o <xref:System.Type.ReflectionOnlyGetType%2A> método é equivalente ao primeiro carregar o assembly para reflexão apenas, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método e, em seguida, carregar o tipo chamando o um assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="37550-4237">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="37550-4238">Para obter informações sobre nomes de assembly qualificado, consulte o <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-4238">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="37550-4239">Para obter mais detalhes sobre como especificar nomes de tipo, consulte o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="37550-4239">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="37550-4240">Se o assembly já foi carregado para execução, outra cópia é carregada no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="37550-4240">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="37550-4241">O `throwIfNotFound` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções.</span><span class="sxs-lookup"><span data-stu-id="37550-4241">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="37550-4242">Algumas exceções são geradas, independentemente do valor de `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="37550-4242">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="37550-4243">Por exemplo, se o assembly não for válido, uma <xref:System.BadImageFormatException> é gerada, mesmo que `throwIfNotFound` é `false`.</span><span class="sxs-lookup"><span data-stu-id="37550-4243">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="37550-4244">Para obter mais informações sobre como usar o contexto de somente reflexão, consulte [como: carregar assemblies no contexto somente de reflexão](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="37550-4244">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="37550-4245"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4245"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="37550-4246">Um inicializador de classe é invocado e lança uma exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-4246">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="37550-4247"><paramref name="throwIfNotFound" /> é <see langword="true" /> e o tipo não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-4247"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="37550-4248">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4248">-or-</span></span> 
 <span data-ttu-id="37550-4249"><paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.</span><span class="sxs-lookup"><span data-stu-id="37550-4249"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="37550-4250">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4250">-or-</span></span> 
 <span data-ttu-id="37550-4251"><paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="37550-4251"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="37550-4252">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4252">-or-</span></span> 
 <span data-ttu-id="37550-4253"><paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.</span><span class="sxs-lookup"><span data-stu-id="37550-4253"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="37550-4254">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4254">-or-</span></span> 
 <span data-ttu-id="37550-4255"><paramref name="typeName" /> representa uma matriz de objetos <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4255"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="37550-4256"><paramref name="typeName" /> não inclui o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4256"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="37550-4257">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4257">-or-</span></span> 
 <span data-ttu-id="37550-4258"><paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida, por exemplo, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="37550-4258"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="37550-4259">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4259">-or-</span></span> 
 <span data-ttu-id="37550-4260"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4260"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="37550-4261">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4261">-or-</span></span> 
 <span data-ttu-id="37550-4262"><paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4262"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="37550-4263">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4263">-or-</span></span> 
 <span data-ttu-id="37550-4264"><paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="37550-4264"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="37550-4265"><paramref name="throwIfNotFound" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="37550-4265"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="37550-4266">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-4266">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="37550-4267">O assembly ou uma de suas dependências não é válido.</span><span class="sxs-lookup"><span data-stu-id="37550-4267">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="37550-4268">- ou -</span><span class="sxs-lookup"><span data-stu-id="37550-4268">-or-</span></span> 
<span data-ttu-id="37550-4269">O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="37550-4269">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="37550-4270">Especificando nomes de tipo totalmente qualificados</span><span class="sxs-lookup"><span data-stu-id="37550-4270">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="37550-4271">Como carregar assemblies no contexto de somente reflexão</span><span class="sxs-lookup"><span data-stu-id="37550-4271">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4272">Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve o layout do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4272">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="37550-4273">Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve os recursos de layout bruto do tipo atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4273">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4274"><xref:System.Runtime.InteropServices.StructLayoutAttribute> não é retornado pelo <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="37550-4274"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="37550-4275">Em vez disso, use essa propriedade para obtê-lo.</span><span class="sxs-lookup"><span data-stu-id="37550-4275">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4276">O exemplo de código a seguir primeiro define uma classe, uma estrutura e uma estrutura com atributos de layout especial (as estruturas são aninhadas dentro da classe).</span><span class="sxs-lookup"><span data-stu-id="37550-4276">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="37550-4277">O exemplo usa o <xref:System.Type.StructLayoutAttribute%2A> propriedade para obter um <xref:System.Runtime.InteropServices.StructLayoutAttribute> para cada tipo e exibe as propriedades dos atributos.</span><span class="sxs-lookup"><span data-stu-id="37550-4277">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4278">O método chamado não é suportado na classe base.</span><span class="sxs-lookup"><span data-stu-id="37550-4278">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="37550-4279">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="37550-4279">Reserved for future use.</span></span> <span data-ttu-id="37550-4280">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="37550-4280">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="37550-4281">Matriz passada de nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="37550-4281">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="37550-4282">Contagem dos nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="37550-4282">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="37550-4283">O contexto de localidade no qual interpretar os nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-4283">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="37550-4284">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</span><span class="sxs-lookup"><span data-stu-id="37550-4284">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="37550-4285">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</span><span class="sxs-lookup"><span data-stu-id="37550-4285">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4286">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-4286">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="37550-4287">Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="37550-4287">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="37550-4288">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="37550-4288">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="37550-4289">As informações de tipo a serem retornadas.</span><span class="sxs-lookup"><span data-stu-id="37550-4289">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="37550-4290">O identificador de localidade das informações do tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4290">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="37550-4291">Um ponteiro para o objeto de informações de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="37550-4291">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="37550-4292">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</span><span class="sxs-lookup"><span data-stu-id="37550-4292">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4293">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-4293">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="37550-4294">Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="37550-4294">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="37550-4295">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="37550-4295">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="37550-4296">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-4296">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="37550-4297">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</span><span class="sxs-lookup"><span data-stu-id="37550-4297">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4298">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-4298">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="37550-4299">Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="37550-4299">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="37550-4300">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="37550-4300">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="37550-4301">Identifica o membro.</span><span class="sxs-lookup"><span data-stu-id="37550-4301">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="37550-4302">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="37550-4302">Reserved for future use.</span></span> <span data-ttu-id="37550-4303">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="37550-4303">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="37550-4304">O contexto de localidade no qual interpretar argumentos.</span><span class="sxs-lookup"><span data-stu-id="37550-4304">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="37550-4305">Sinalizadores que descrevem o contexto da chamada.</span><span class="sxs-lookup"><span data-stu-id="37550-4305">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="37550-4306">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</span><span class="sxs-lookup"><span data-stu-id="37550-4306">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="37550-4307">Ponteiro para o local onde o resultado deve ser armazenado.</span><span class="sxs-lookup"><span data-stu-id="37550-4307">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="37550-4308">Ponteiro para uma estrutura que contém informações de exceção.</span><span class="sxs-lookup"><span data-stu-id="37550-4308">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="37550-4309">O índice do primeiro argumento que tem um erro.</span><span class="sxs-lookup"><span data-stu-id="37550-4309">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="37550-4310">Fornece acesso a propriedades e métodos expostos por um objeto.</span><span class="sxs-lookup"><span data-stu-id="37550-4310">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4311">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="37550-4311">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="37550-4312">Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="37550-4312">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="37550-4313">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="37550-4313">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="37550-4314">Retorna uma <see langword="String" /> que representa o nome da <see langword="Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4314">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="37550-4315">Uma <see cref="T:System.String" /> que representa o nome da <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4315">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4316">Esse método retorna o nome para todos os tipos primitivos e totalmente qualificado namespace common language runtime.</span><span class="sxs-lookup"><span data-stu-id="37550-4316">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="37550-4317">Por exemplo, a c# instrução, `(long)0.Type().ToString()` retorna "System.Int64" em vez de simplesmente "Int64".</span><span class="sxs-lookup"><span data-stu-id="37550-4317">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="37550-4318">Se o atual <xref:System.Type> representa um tipo genérico, o tipo e argumentos de tipo são qualificados por namespace e pelo tipo aninhado, mas não por assembly.</span><span class="sxs-lookup"><span data-stu-id="37550-4318">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="37550-4319">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método retorna o nome não qualificado do parâmetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4319">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4320">Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e <xref:System.Type.Module%2A> propriedades e o `ToString` método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="37550-4320">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="37550-4321">O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="37550-4321">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4322">Obtém o identificador do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4322">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="37550-4323">O identificador do <see cref="T:System.Type" /> atual.</span><span class="sxs-lookup"><span data-stu-id="37550-4323">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4324">`TypeHandle` encapsula um ponteiro para uma estrutura de dados interna que representa o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4324">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="37550-4325">Esse identificador é exclusivo durante o tempo de vida do processo.</span><span class="sxs-lookup"><span data-stu-id="37550-4325">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="37550-4326">O identificador é válido somente no domínio do aplicativo no qual ele foi obtido.</span><span class="sxs-lookup"><span data-stu-id="37550-4326">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37550-4327">O exemplo a seguir retorna o identificador do tipo correspondente e transmite o identificador para um método que obtém o tipo do identificador e o exibe.</span><span class="sxs-lookup"><span data-stu-id="37550-4327">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="37550-4328">No momento, o .NET Compact Framework não dá suporte a essa propriedade.</span><span class="sxs-lookup"><span data-stu-id="37550-4328">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4329">Obtém o inicializador para o tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4329">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="37550-4330">Um objeto que contém o nome do construtor da classe para o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4330">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37550-4331">Inicializadores de classe também estão disponíveis por meio de <xref:System.Type.FindMembers%2A> método, ou por meio de sobrecargas do <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, e <xref:System.Type.GetConstructors%2A> métodos que usam <xref:System.Reflection.BindingFlags> como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="37550-4331">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="37550-4332">Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade retornará `null`.</span><span class="sxs-lookup"><span data-stu-id="37550-4332">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="37550-4333">Indica o tipo fornecido pelo Common Language Runtime que representa esse tipo.</span><span class="sxs-lookup"><span data-stu-id="37550-4333">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="37550-4334">O tipo de sistema subjacente para o <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="37550-4334">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
