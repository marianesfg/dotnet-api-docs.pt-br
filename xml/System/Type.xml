<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ce935b208a9daf902be2ab01dcf3ded2e5dd052e" /><Meta Name="ms.sourcegitcommit" Value="a489a0c68ea6b109393f1400bbd772073b4befd4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="01/20/2019" /><Meta Name="ms.locfileid" Value="54417067" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa as declarações de tipo: tipos de classe, tipos de interface, tipos de matriz, tipos de valor, tipos de enumeração, parâmetros de tipo, definições de tipo genérico e tipos genéricos construídos abertos ou fechados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` é a raiz do <xref:System.Reflection> funcionalidade e é a principal maneira de acessar os metadados. Usar os membros de <xref:System.Type> para obter informações sobre uma declaração de tipo, sobre os membros de um tipo (como os construtores, métodos, campos, propriedades e eventos de uma classe), bem como o módulo e o assembly no qual a classe seja implantada.  
  
 Nenhuma permissão é necessária para o código usar a reflexão para obter informações sobre tipos e seus membros, independentemente de seus níveis de acesso. Nenhuma permissão é necessária para o código usar a reflexão para acessar os membros públicos ou outros membros cujos níveis de acesso devem torná-las visíveis durante a compilação normal. No entanto, para que seu código para usar a reflexão para acessar os membros que normalmente seriam inacessíveis, tais como métodos privados ou internos ou protegidos por campos de um tipo não herda sua classe, seu código deve ter <xref:System.Security.Permissions.ReflectionPermission>. Ver [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` é uma classe base abstrata que permite várias implementações. O sistema sempre fornecerá a classe derivada `RuntimeType`. Reflexão, começando com a palavra tempo de execução de todas as classes são criadas apenas uma vez por objeto nas operações de comparação de sistema e suporte.  
  
> [!NOTE]
>  Em cenários de multithreading não bloqueiam <xref:System.Type> objetos para sincronizar o acesso ao `static` dados. Outro código, em que você não tem controle, também pode bloquear seu tipo de classe. Isso pode resultar em um deadlock. Em vez disso, sincronizar o acesso a dados estáticos, bloqueando uma privada `static` objeto.  
  
> [!NOTE]
>  Uma classe derivada pode acessar membros protegidos de classes de base do código de chamada. Além disso, o acesso é permitido para membros do assembly do assembly do código de chamada. Como regra, se a permissão de acesso no código de associação inicial, em seguida, você também podem acessar no código de associação tardia.  
  
> [!NOTE]
>  Interfaces que estendem as outras interfaces não herdam os métodos definidos nas interfaces estendidas.  
  
 Nesta seção:  
  
 [Quais tipos representa um objeto do tipo?](#WhatTypes)   
 [Recuperando um objeto de tipo](#Retrieve)   
 [Comparando objetos de tipo de igualdade](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Quais tipos representa um objeto do tipo?  
 Essa classe é thread-safe; vários threads simultaneamente podem ler de uma instância desse tipo. Uma instância da <xref:System.Type> classe pode representar qualquer um dos seguintes tipos:  
  
-   Classes  
  
-   Tipos de valor  
  
-   Matrizes  
  
-   Interfaces  
  
-   Enumerações  
  
-   Delegados  
  
-   Tipos genéricos construídos e definições de tipo genérico  
  
-   Argumentos de tipo e parâmetros de tipo de tipos genéricos construídos, definições de tipo genérico e definições de método genérico  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Recuperando um objeto de tipo  
 O <xref:System.Type> associado com um tipo específico de objeto pode ser obtido das seguintes maneiras:  
  
-   A instância <xref:System.Object.GetType%2A?displayProperty=nameWithType> método retorna um <xref:System.Type> objeto que representa o tipo de uma instância. Como todos os tipos gerenciados derivam <xref:System.Object>, o <xref:System.Object.GetType%2A> método pode ser chamado em uma instância de qualquer tipo.  
  
     A exemplo a seguir chama o <xref:System.Object.GetType%2A?displayProperty=nameWithType> método para determinar o tipo de tempo de execução de cada objeto em uma matriz de objetos.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Estático <xref:System.Type.GetType%2A?displayProperty=nameWithType> métodos retornam um <xref:System.Type> objeto que representa um tipo especificado pelo seu nome totalmente qualificado.  
  
-   O <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> métodos retornam `Type` objetos que representam os tipos definidos em um módulo. O primeiro método pode ser usado para obter uma matriz de <xref:System.Type> objetos para todos os tipos de públicos e privados definidos em um módulo. (Você pode obter uma instância do `Module` por meio de <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> método, ou por meio o <xref:System.Type.Module%2A?displayProperty=nameWithType> propriedade.)  
  
-   O <xref:System.Reflection.Assembly?displayProperty=nameWithType> objeto contém uma série de métodos para recuperar as classes definidas em um assembly, incluindo <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   O <xref:System.Type.FindInterfaces%2A> método retorna uma lista filtrada de tipos de interface com suporte por um tipo.  
  
-   O <xref:System.Type.GetElementType%2A> método retorna um `Type` objeto que representa o elemento.  
  
-   O <xref:System.Type.GetInterfaces%2A> e <xref:System.Type.GetInterface%2A> métodos retornam <xref:System.Type> objetos que representam os tipos de interface com suporte por um tipo.  
  
-   O <xref:System.Type.GetTypeArray%2A> método retorna uma matriz de <xref:System.Type> objetos que representam os tipos especificados por um conjunto arbitrário de objetos. Os objetos são especificados com uma matriz do tipo <xref:System.Object>.  
  
-   O <xref:System.Type.GetTypeFromProgID%2A> e <xref:System.Type.GetTypeFromCLSID%2A> métodos são fornecidos para a interoperabilidade COM. Elas retornam um <xref:System.Type> objeto que representa o tipo especificado por um `ProgID` ou `CLSID`.  
  
-   O <xref:System.Type.GetTypeFromHandle%2A> método é fornecido para fins de interoperabilidade. Ele retorna um `Type` objeto que representa o tipo especificado por um identificador de classe.  
  
-   O c# `typeof` operador, o C++ `typeid` operador e o Visual Basic `GetType` operador obter a `Type` objeto para um tipo.  
  
-   O <xref:System.Type.MakeGenericType%2A> método retorna um <xref:System.Type> objeto que representa um tipo genérico construído, o que é um tipo construído aberto se seus <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, e um tipo construído caso contrário. Um tipo genérico pode ser instanciado somente se ele estiver fechado.  
  
-   O <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, e <xref:System.Type.MakeByRefType%2A> métodos retornam <xref:System.Type> objetos que representam, respectivamente, uma matriz de um tipo especificado, um ponteiro para um tipo especificado e o tipo de um parâmetro de referência (`ref` no c#, `ByRef`no Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Comparando objetos de tipo de igualdade  
 Um <xref:System.Type> objeto que representa um tipo é exclusivo; ou seja, duas <xref:System.Type> referências de objeto se referem ao mesmo objeto se e somente se eles representarem o mesmo tipo. Isso permite a comparação de <xref:System.Type> objetos usando a igualdade de referência. O exemplo a seguir compara o <xref:System.Type> objetos que representam um número de valores inteiros para determinar se eles são do mesmo tipo.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir mostra alguns recursos representativos de <xref:System.Type>. O c# `typeof` operador (`GetType` operador no Visual Basic `typeid` operador no Visual C++) é usado para obter uma <xref:System.Type> objeto representando <xref:System.String>. Neste <xref:System.Type> objeto, o <xref:System.Type.GetMethod%2A> método é usado para obter uma <xref:System.Reflection.MethodInfo> que representa o <xref:System.String.Substring%2A> sobrecarga que utiliza um local inicial e um comprimento.  
  
 Para identificar a assinatura de sobrecarga, o exemplo de código cria uma matriz temporária que contém duas <xref:System.Type> objetos que representam `int` (`Integer` no Visual Basic).  
  
> [!NOTE]
>  Para ser preciso, a matriz contém duas referências à instância do <xref:System.Type> que representa `int` no domínio do aplicativo atual. Para qualquer tipo, há apenas uma instância de <xref:System.Type> por domínio de aplicativo.  
  
 O exemplo de código usa o <xref:System.Reflection.MethodInfo> para invocar o <xref:System.String.Substring%2A> método na cadeia de caracteres "Olá, mundo!" e exibe o resultado.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <block subset="none" type="overrides"><para>Ao herdar da <see langword="Type" />, você deve substituir os seguintes membros: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Exibindo informações de tipo</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado por classes derivadas durante a construção de objetos do tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo é declarado. Para tipos genéricos, obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo genérico é definido.</summary>
        <value>Uma instância de <see cref="T:System.Reflection.Assembly" /> que descreve o assembly que contém o tipo atual. Para tipos genéricos, a instância descreve o assembly que contém a definição de tipo genérico, não o assembly que cria e usa um tipo construído específico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> objeto representa um tipo genérico construído, essa propriedade retorna o assembly que contém a definição de tipo genérico. Por exemplo, suponha que você cria um assembly denominado MyGenerics.dll que contém a definição de tipo genérico `MyGenericStack<T>` (`MyGenericStack(Of T)` no Visual Basic, `generic<T> ref class MyGenericStack` em C++). Se você criar uma instância do `MyGenericStack<int>` (`MyGenericStack(Of Integer)` no Visual Basic) em outro assembly, o <xref:System.Type.Assembly%2A> propriedade para o tipo construído retorna um <xref:System.Reflection.Assembly> objeto que representa o MyGenerics.dll.  
  
 Da mesma forma, se o atual <xref:System.Type> objeto representa um parâmetro genérico não atribuído `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.  
  
 Se o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade não está disponível em uma implementação específica do .NET, como .NET Core ou a plataforma Universal do Windows, use o <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriedade em vez disso.      
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do tipo qualificado pelo assembly, que inclui o nome do assembly do qual este objeto <see cref="T:System.Type" /> foi carregado.</summary>
        <value>O nome qualificado pelo assembly do <see cref="T:System.Type" />, que inclui o nome do assembly do qual o <see cref="T:System.Type" /> foi carregado, ou <see langword="null" /> se a instância atual representa um parâmetro de tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome qualificado pelo assembly de um tipo consiste do nome do tipo, incluindo o namespace, seguido por uma vírgula, seguida pelo nome de exibição do assembly. O nome de exibição de um assembly é obtido usando o <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 O nome simples de uma classe aninhada da emissão de todos os compiladores que dão suporte a common language runtime e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Colchetes ([])|Depois de um nome de tipo, indica uma matriz desse tipo.<br /><br /> - ou -<br /><br /> Para um tipo genérico, inclui a lista de argumentos de tipo genérico.<br /><br /> - ou -<br /><br /> Dentro de uma lista de argumentos de tipo, inclui um tipo qualificado pelo assembly.|  
  
 Por exemplo, o nome qualificado do assembly para uma classe pode ser assim:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Se o namespace contivesse um sinal de adição, por exemplo, TopNamespace.Sub+Namespace, então, no sinal de adição (+) deve ser precedido por um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento. Seria a emissão de reflexão essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 Argumentos genéricos de tipos genéricos são as próprias qualificado pelo nome do assembly. Por exemplo, no nome de tipo qualificado pelo assembly `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic), `int` é expandido para o nome de tipo qualificado pelo assembly <xref:System.Int32>.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os atributos associados ao <see cref="T:System.Type" />.</summary>
        <value>Um objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa o conjunto de atributos do <see cref="T:System.Type" />, a menos que <see cref="T:System.Type" /> represente um parâmetro de tipo genérico; nesse caso, o valor não é especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns membros o <xref:System.Reflection.TypeAttributes> enumeração são máscaras que representam um grupo de valores. Cada grupo inclui um membro cujo valor subjacente for zero. Por exemplo, o valor subjacente do <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membro na <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupo for zero, como é o <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membro no <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupo. Por isso, você deve usar a máscara antes de testar para obter esses valores. O exemplo fornece uma ilustração.  
  
> [!TIP]
>  Para a maioria das finalidades, as propriedades como <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, e <xref:System.Type.IsSpecialName%2A> são mais fáceis de usar do que os atributos de tipo.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna os atributos da definição de tipo genérico. Por exemplo, os atributos retornados para `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic) são os atributos do `MyGenericClass<T>` (`MyGenericClass(Of T)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico - ou seja, se o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` : a <xref:System.Reflection.TypeAttributes> valor retornado por essa propriedade não for especificado.  
  
   
  
## Examples  
 A seguir usa de exemplo os <xref:System.Type.Attributes%2A> propriedade.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do qual o <see cref="T:System.Type" /> atual é herdado diretamente.</summary>
        <value>O <see cref="T:System.Type" /> do qual o <see cref="T:System.Type" /> atual é herdado diretamente ou <see langword="null" /> se o <see langword="Type" /> atual representar a classe <see cref="T:System.Object" /> ou uma interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo base é o tipo do qual o tipo atual herda diretamente. <xref:System.Object> é o único tipo que não tem um tipo base, portanto `null` é retornado como o tipo base do <xref:System.Object>.  
  
 Interfaces de herdam de interfaces de base zero ou mais; Portanto, essa propriedade retornará `null` se o `Type` objeto representa uma interface. As interfaces base podem ser determinadas com <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, o tipo base reflete os argumentos genéricos. Por exemplo, considere as declarações a seguir:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Para o tipo construído `C<int>` (`C(Of Integer)` no Visual Basic), o <xref:System.Type.BaseType%2A> propriedade retorna `B<int>`.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de uma definição de tipo genérico, <xref:System.Type.BaseType%2A> retorna a restrição de classe, ou seja, a classe que o parâmetro de tipo deve herdar. Se não houver nenhuma restrição de classe <xref:System.Type.BaseType%2A> retorna <xref:System.Object?displayProperty=nameWithType>.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Type.BaseType%2A> propriedade.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 O exemplo a seguir usa a recursão para listar a hierarquia completa de herança de cada classe encontrado em um assembly. O exemplo define uma classe chamada `C` que deriva de uma classe chamada `B`, que, por sua vez, deriva uma classe chamada `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto <see cref="T:System.Type" /> atual tem parâmetros de tipo que não foram substituídos por tipos específicos.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> objeto é um parâmetro de tipo genérico ou tem parâmetros de tipo para os quais tipos específicos não foram fornecidos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um tipo, não deve haver definições de tipo genérico ou tipos construídos abertos nos argumentos de tipo do tipo em si, em quaisquer tipos genéricos ou em todos os elementos do tipo. Outra maneira de dizer isso é que, quando examinada recursivamente, o tipo não deve conter nenhum parâmetro de tipo genérico.  
  
 Como tipos podem ser arbitrariamente complexos, é difícil tomar essa decisão. Para conveniência e para reduzir a chance de erro, o <xref:System.Type.ContainsGenericParameters%2A> propriedade fornece uma maneira padrão para distinguir entre tipos construídos fechados, que podem ser instanciados e aberta construído tipos, que não é possível. Se o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, o tipo não pode ser instanciado.  
  
 O <xref:System.Type.ContainsGenericParameters%2A> propriedade pesquisa recursivamente para parâmetros de tipo. Por exemplo, ele retorna `true` para uma matriz cujos elementos são o tipo `A<T>` (`A(Of T)` no Visual Basic), mesmo que a matriz não é em si genérico. Compare isso com o comportamento do <xref:System.Type.IsGenericType%2A> propriedade, que retorna `false` para matrizes.  
  
 Para um conjunto de classes de exemplo e uma tabela que mostra os valores de <xref:System.Type.ContainsGenericParameters%2A> propriedade, consulte <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e, em seguida, define uma segunda classe genérica que deriva de primeira classe. Classe base a classe derivada da tem dois argumentos de tipo: o primeiro é <xref:System.Int32> e o segundo é um parâmetro de tipo do tipo derivado. O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo, se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico.</summary>
        <value>Se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico, um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método declarativo é uma definição de método genérico. Ou seja, se <xref:System.Type.DeclaringMethod%2A> não retorna `null`, em seguida, `DeclaringMethod.IsGenericMethodDefinition` retorna `true`.  
  
 O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico no qual o parâmetro de tipo genérico foi originalmente definido:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.  
  
-   Introdução a <xref:System.Type.DeclaringMethod%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Reflection.MethodBase> que é retornado pela <xref:System.Type.DeclaringMethod%2A> propriedade é um <xref:System.Reflection.MethodInfo> no caso de um método genérico, ou um <xref:System.Reflection.ConstructorInfo> no caso de um construtor genérico.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, não há suporte para construtores genéricos.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define uma classe que tem um método genérico, atribui um argumento de tipo para o método e invoca o método genérico construído resultante. Ele também exibe informações sobre a definição de método genérico e o método construído. Ao exibir informações sobre os parâmetros de tipo da definição de método genérico, na `DisplayGenericMethodInfo` método, o código de exemplo mostra o valor da <xref:System.Type.DeclaringMethod%2A> propriedade para o parâmetro de tipo genérico do método.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo que declara o tipo aninhado atual ou o parâmetro de tipo genérico.</summary>
        <value>Um objeto <see cref="T:System.Type" /> que representará o tipo de delimitador se o tipo atual for um tipo aninhado, a definição de tipo genérico se o tipo atual for um parâmetro de tipo de um tipo genérico ou o tipo que declara o método genérico se o tipo atual for um parâmetro de tipo de um método genérico. Caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico, essa propriedade retorna a definição de tipo genérico.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um método genérico, essa propriedade retorna o tipo que contém a definição de método genérico. Se o tipo for genérico, definição de tipo genérico é retornada. Ou seja, o código a seguir retorna a definição de tipo genérico de <xref:System.Collections.Generic.List%601> classe genérica, que contém o <xref:System.Collections.Generic.List%601.ConvertAll%2A> método genérico:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, o <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico em que o parâmetro de tipo genérico foi originalmente definido:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.  
  
-   Introdução a <xref:System.Type.DeclaringType%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Este exemplo exibe o tipo de declaração de um método em uma classe derivada.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao associador padrão, que implementa regras internas para selecionar os membros adequados a serem chamados por <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Uma referência ao associador padrão usado pelo sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O associador padrão fornecido com o common language runtime é aplicável em todas, exceto as circunstâncias mais especializadas. Se você precisar de um associador que segue as regras que diferem do associador padrão fornecido, definem um tipo derivado do <xref:System.Reflection.Binder> de classe e passar uma instância desse tipo usando o `binder` parâmetro de um do <xref:System.Type.InvokeMember%2A> sobrecargas.  
  
 Reflexão modela as regras de acessibilidade do common type system. Por exemplo, se o chamador estiver no mesmo assembly, o chamador não precisar permissões especiais para membros internos. Caso contrário, o chamador precisa <xref:System.Security.Permissions.ReflectionPermission>. Isso é consistente com a pesquisa de membros que são protegidas, privadas e assim por diante.  
  
 O princípio geral é que <xref:System.Reflection.Binder.ChangeType%2A> deve executar somente conversões, que nunca perdem dados de ampliação. Um exemplo de uma conversão de ampliação está convertendo um valor que é um inteiro com sinal de 32 bits para um valor que é um inteiro com sinal de 64 bits. Isso é diferenciado de uma conversão de estreitamento, que poderá perder dados. Um exemplo de uma conversão redutora é converter um inteiro com sinal de 64 bits em um inteiro com sinal de 32 bits.  
  
 A tabela a seguir lista as conversões com suporte pelo associador de padrão.  
  
|Tipo de fonte|Tipo de destino|  
|-----------------|-----------------|  
|Qualquer tipo|Seu tipo base.|  
|Qualquer tipo|A interface que ele implementa.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single e Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single e Double|  
|SByte|Int16, Int32, Int64, Single e Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single e Double|  
|Int16|Int32, Int64, Single e Double|  
|UInt32|UInt64, Int64, Single e Double|  
|Int32|Int64, Single e Double|  
|UInt64|Single e Double|  
|Int64|Single e Double|  
|Simples|Duplo|  
|Não referência|Por referência.|  
  
   
  
## Examples  
 O exemplo a seguir obtém o associador padrão a `DefaultBinder` propriedade e invoca um membro de MyClass, passando a `DefaultBinder` valor como um parâmetro para <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Separa nomes no namespace de <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa uma matriz vazia do tipo <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código mostra a `EmptyTypes` campo usado em uma da `GetConstructor` métodos para obter um construtor sem parâmetros.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o tipo de sistema subjacente do <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Object" /> ou <see cref="T:System.Type" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />. Para que a comparação seja bem-sucedida, <paramref name="o" /> deve ser capaz de ser convertido em um objeto do tipo <see cref="T:System.Type" />.</param>
        <summary>Determina se o tipo de sistema subjacente do objeto <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Object" /> especificado.</summary>
        <returns><see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />. Esse método sempre retorna <see langword="false" /> se: .  
  
-   <paramref name="o" /> é <see langword="null" />.  
  
-   <paramref name="o" /> não pode ser convertido em um objeto <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Ele projeta `o` a um objeto do tipo <xref:System.Type> e chama o <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Type.Equals%28System.Object%29> para comparar vários <xref:System.Type> objeto instâncias com vários <xref:System.Object> instâncias.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Duas coisas são particularmente vale a pena observar sobre o exemplo:  
  
-   A comparação de um <xref:System.Type> objeto que representa um inteiro com um <xref:System.Reflection.TypeInfo> objeto que representa um inteiro de retorno `true` porque <xref:System.Reflection.TypeInfo> é derivado de <xref:System.Type>.  
  
-   A comparação de um <xref:System.Type> objeto que representa uma <xref:System.Collections.Generic.IList%601> objeto (um tipo genérico aberto) com um `List(Of String)` retorna o objeto (um tipo genérico fechado) `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />.</param>
        <summary>Determina se o tipo de sistema subjacente do <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> especificado.</summary>
        <returns><see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa `Equals` para comparar dois tipos.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro usado em atributos. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` pode ser atribuído o valor de qualquer um dos campos nas classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.  
  
 Por exemplo, o `Object` pode ser atribuído o valor de um campo de `FieldAttributes` como público. Nesse caso, quando o `FilterAttribute` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto é decorado com o atributo de campo público nos metadados.  
  
   
  
## Examples  
 O exemplo a seguir obtém a `FilterAttribute` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os membros especificados e seus atributos.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro, que diferencia maiúsculas de minúsculas, usado nos nomes. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "*" caractere curinga. Correspondência de cadeia de caracteres de final de curinga só tem suporte.  
  
 Por exemplo, o `Object` pode ser atribuído o valor de "Byte *". Nesse caso, quando o `FilterName` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "Byte".  
  
   
  
## Examples  
 O exemplo de código a seguir obtém os métodos associados definido pelo usuário `Application` tipo.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro, que não diferencia maiúsculas de minúsculas, usado nos nomes. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência ao delegado usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por esse delegado utiliza dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "*" caractere curinga. Correspondência de cadeia de caracteres de final de curinga só tem suporte.  
  
 Por exemplo, o `Object` pode ser atribuído o valor de "ByTe *". Nesse caso, quando o `FilterName` delegado é invocado, ele retornará true somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "byte", ignorando maiusculas e minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir obtém a `MemberFilter` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os métodos e seus atributos do `String` classe que começam com a letra "c", desconsiderando o caso.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">O delegado que compara as interfaces com <paramref name="filterCriteria" />.</param>
        <param name="filterCriteria">Os critérios de pesquisa que determinam se uma interface deve ser incluída na matriz retornada.</param>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representa uma lista filtrada das interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam uma lista filtrada das interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual ou uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhuma interface correspondente ao filtro estiver implementada ou for herdada pelo <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 O <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> e <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegados fornecidos pelo <xref:System.Reflection.Module?displayProperty=nameWithType> classe também pode ser usada, substitui o <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegar.  
  
 Todas as interfaces implementadas por esta classe são consideradas durante a pesquisa se declaradas por essa classe em si ou uma classe base.  
  
 Esse método pesquisará a hierarquia de classe base, retornando cada uma das interfaces correspondentes que cada classe implemente, bem como todas as correspondentes interfaces de cada uma implementa essas interfaces (ou seja, o fechamento transitivo de interfaces de correspondência é retornado). Interfaces não duplicado será retornado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, <xref:System.Type.FindInterfaces%2A> pesquisas de todas as interfaces declaradas dentro das restrições no parâmetro de tipo, e todas as interfaces herdadas por meio de interfaces declarado dentro das restrições. Se o atual <xref:System.Type> representa um argumento de tipo de um tipo genérico, <xref:System.Type.FindInterfaces%2A> pesquisará todas as interfaces implementadas pelo tipo, se eles corresponderem às restrições.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> pode retornar as interfaces genéricas, mesmo em tipos não genéricos. Por exemplo, um tipo não genérico pode implementar `IEnumerable<int>` (`IEnumerable(Of Integer)` no Visual Basic).  
  
   
  
## Examples  
 O exemplo a seguir localiza a interface especificada implementada ou herdada pelo tipo especificado e, em seguida, exibe os nomes de interface.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador estático é invocado e lança uma exceção.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Um objeto que indica o tipo de membro a ser pesquisado.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="filter">O delegado que faz as comparações, retornando <see langword="true" /> se o membro inspecionado no momento corresponder ao <paramref name="filterCriteria" />. Caso contrário, <see langword="false" />. Use os delegados <see langword="FilterAttribute" />, <see langword="FilterName" /> e <see langword="FilterNameIgnoreCase" /> fornecidos por essa classe. O primeiro usa os campos <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> como critérios de pesquisa e os outros dois delegados usam objetos <see langword="String" /> como critérios de pesquisa.</param>
        <param name="filterCriteria">Os critérios de pesquisa que determinam se um membro é retornado na matriz de objetos <see langword="MemberInfo" />.  
  
Os campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> podem ser usados em conjunto com o delegado <see langword="FilterAttribute" /> fornecido por essa classe.</param>
        <summary>Retorna uma matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> do tipo do membro especificado.</summary>
        <returns>Uma matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> do tipo de membro especificado.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros do tipo <paramref name="memberType" /> que correspondem aos critérios de filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Instance` para incluir membros de instância na pesquisa.  
  
-   Especifique `BindingFlags.Static` para incluir membros estáticos na pesquisa.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Os valores válidos para <xref:System.Type.MemberType%2A> são definidos em <xref:System.Reflection.MemberInfo>. Se nenhum desses membros forem encontrados, uma matriz vazia será retornada.  
  
 Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico ou método genérico, <xref:System.Type.FindMembers%2A> processa todos os membros declarados pela restrição de classe e as restrições de interface do parâmetro de tipo.  
  
   
  
## Examples  
 O exemplo a seguir localiza todos os membros em uma classe que correspondem aos critérios de pesquisa especificados e, em seguida, exibe os membros correspondentes.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly.</summary>
        <value>O nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly; ou <see langword="null" />, se a instância atual representar um parâmetro de tipo genérico, um tipo de matriz, um tipo de ponteiro ou um tipo <see langword="byref" /> baseado em um parâmetro de tipo, ou um tipo genérico que não é uma definição de tipo genérica, mas que contém parâmetros de tipo não resolvidos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, o nome totalmente qualificado do <xref:System.String> é do tipo `System.String`. Compare isso com o nome qualificado pelo assembly retornado pelo <xref:System.Type.AssemblyQualifiedName%2A> propriedade, que consiste o nome completo e o nome completo do assembly.  
  
 Se o tipo atual representa um tipo genérico fechado, os argumentos de tipo na cadeia de caracteres retornada pelo <xref:System.Type.FullName%2A> propriedade são qualificados por seu nome completo do assembly, mesmo que a representação de cadeia de caracteres do tipo genérico em si não está qualificada pelo seu completo nome do assembly. O exemplo a seguir ilustra a diferença na propriedade FullName para um tipo que representa a definição de tipo genérico e um que representa um tipo genérico fechado.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Essa propriedade retorna `null` se:  
  
-   Atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico.  
  
     O exemplo a seguir recupera o parâmetro de tipo de <xref:System.Nullable%601> tipo e tenta exibir seu <xref:System.Type.FullName%2A> propriedade.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   O atual <xref:System.Type> objeto representa um tipo de matriz, um tipo de ponteiro ou um `byref` tipo com base em um parâmetro de tipo genérico.  
  
     O exemplo a seguir define um tipo genérico, `Generictype1<T>`, com três métodos: `Display(T[])`, que é passado a uma matriz do tipo T; `HandleT(T)`, que é passado um objeto T; e `ChangeValue(ref T)`, que é passado um objeto T por referência. Como c# e Visual Basic não permitem definir T como um ponteiro na `HandleT` método, precisamos chamar o <xref:System.Type.MakePointerType%2A> método no <xref:System.Type> objeto que representa o tipo de parâmetro do método para criar um ponteiro para um tipo genérico. A saída do exemplo mostra que em todos os três casos, o <xref:System.Type.FullName%2A> é de propriedade `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   O tipo atual contém parâmetros de tipo genérico que não foram substituídos por tipos específicos (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`), mas o tipo não é uma definição de tipo genérico (ou seja, o <xref:System.Type.IsGenericTypeDefinition%2A> retorna de propriedade `false`  
  
     No exemplo a seguir `Derived<T>` herda de `Base<T>`. O <xref:System.Type.BaseType%2A> propriedade obtém o <xref:System.Type> objeto que representa o tipo base `Derived<T>`e sua <xref:System.Type.FullName%2A> propriedade retorna `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Para obter um <xref:System.Type.FullName%2A> que não é `null`, você pode usar o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter a definição de tipo genérico, como mostra o exemplo.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome completo do tipo especificado.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma combinação de <see cref="T:System.Reflection.GenericParameterAttributes" /> sinalizadores que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</summary>
        <value>Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa propriedade contém sinalizadores que descrevem se o parâmetro de tipo genérico atual é covariante e sinalizadores que descrevem a quaisquer restrições especiais. Use o <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valor para selecionar os sinalizadores de covariância e, em seguida, use o <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valor para selecionar os sinalizadores de restrição.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo que têm diferentes restrições. Quando o programa é executado, as restrições são examinadas por meio de <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O objeto <see cref="T:System.Type" /> atual não é um parâmetro de tipo genérico. Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a posição do parâmetro de tipo, na lista de parâmetros de tipo, do tipo genérico ou do método que declarou o parâmetro, quando o objeto <see cref="T:System.Type" /> representa um parâmetro de tipo de um tipo genérico ou método genérico.</summary>
        <value>A posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico ou método que define o parâmetro. Números de posição começam em 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GenericParameterPosition%2A> propriedade retorna a posição de um parâmetro de tipo na lista de parâmetros da definição de tipo genérico ou definição de método genérico, em que o parâmetro de tipo foi originalmente definido. O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo ou método genérica:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, a <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> que representa uma definição de tipo genérico e atual do objeto <xref:System.Type> objeto representa um parâmetro de tipo desse tipo genérico definição.  
  
 Para fornecer o contexto correto para o valor da <xref:System.Type.GenericParameterPosition%2A> propriedade, é necessário identificar o tipo ou método genérico pertence um parâmetro de tipo. Por exemplo, considere o valor de retorno do método genérico `GetSomething` no código a seguir:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 O tipo retornado por `GetSomething` depende dos argumentos de tipo fornecidos a classe `A` e, ao `GetSomething` em si. Você pode obter um <xref:System.Reflection.MethodInfo> para `GetSomething`, e que você pode obter o tipo de retorno. Quando você examina os parâmetros de tipo do tipo de retorno, <xref:System.Type.GenericParameterPosition%2A> retorna 0 para ambos. A posição do `V` é 0 porque `V` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para a classe `A`. A posição do `X` é 0 porque `X` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para `GetSomething`.  
  
> [!NOTE]
>  Chamar o <xref:System.Type.GenericParameterPosition%2A> propriedade faz com que uma exceção se o atual <xref:System.Type> não representa um parâmetro de tipo. Quando você examinar os argumentos de tipo de um tipo construído aberto, use o <xref:System.Type.IsGenericParameter%2A> propriedade dizer que são parâmetros de tipo e que são tipos. O <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para um parâmetro de tipo; em seguida, você pode usar o <xref:System.Type.GenericParameterPosition%2A> método obter sua posição e usar os <xref:System.Type.DeclaringMethod%2A> e <xref:System.Type.DeclaringType%2A> propriedades para determinar o método genérico ou definição que o define de tipo .  
  
   
  
## Examples  
 O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e define uma segunda classe genérica que deriva de primeira classe. Classe base a classe derivada da tem dois argumentos de tipo: o primeiro é <xref:System.Int32>, e o segundo é um parâmetro de tipo do tipo derivado. O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não representa um parâmetro de tipo. Ou seja, <see cref="P:System.Type.IsGenericParameter" /> retorna <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma matriz dos argumentos de tipo genérico para esse tipo.</summary>
        <value>Uma matriz dos argumentos de tipo genérico para esse tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade obtém apenas os argumentos de tipo genérico; ou seja, os tipos que foram especificados para os parâmetros de tipo genérico do tipo atual. Se o tipo atual é uma definição de tipo genérico, essa propriedade retorna uma matriz vazia.  
  
> [!NOTE]
>  Se um tipo genérico for usado em um método genérico ou em outro tipo genérico, alguns dos seus argumentos de tipo genérico podem ser parâmetros de tipo genérico do método ou tipo delimitador.  
  
 Para obter os parâmetros de tipo genérico de um tipo que representa uma definição de tipo genérico, use o <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriedade. Para obter um <xref:System.Reflection.TypeInfo> objeto atual <xref:System.Type> do objeto, use o <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> método de extensão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o número de dimensões em uma matriz.</summary>
        <returns>Um inteiro que contém o número de dimensões no tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o número de dimensões em uma matriz.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a funcionalidade desse método na classe base. Em vez disso, ela deve ser implementada em uma classe derivada.</exception>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma matriz.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.Attributes" /> e obtém um bitmask que indica os atributos associados com o <see cref="T:System.Type" />.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa o conjunto de atributos do <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um construtor específico do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor desejado.  
  
- ou - 
Uma matriz vazia de objetos <see cref="T:System.Type" />, para obter um construtor que não aceita parâmetros. Tal matriz vazia é fornecida pelo campo <see langword="static" /> de <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Pesquisa um construtor de instância pública cujos parâmetros correspondem aos tipos na matriz especificada.</summary>
        <returns>Um objeto que representa o construtor de instância pública cujos parâmetros correspondem aos tipos na matriz de tipos de parâmetro, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método procura por construtores de instância pública e não pode ser usada para obter um inicializador de classe (. cctor). Para obter um inicializador de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o construtor solicitado é não público, esse método retorna `null`.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo de `MyClass`, obtém o <xref:System.Reflection.ConstructorInfo> de objeto e exibe a assinatura do construtor.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.  
  
- ou - 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz de tipo de parâmetro. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor que corresponde aos requisitos especificados, se encontrados, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.  
  
   
  
## Examples  
 O programa a seguir obtém o tipo de `MyClass1` classe, obtém o <xref:System.Reflection.ConstructorInfo> os sinalizadores de associação especificadas de correspondência de objeto e exibe a assinatura do construtor.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a maneira como o valor retornado é passado, a quais registros são usados para argumentos e à forma que a pilha é limpa.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa por um construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o construtor que corresponde aos requisitos especificados, se encontrado, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método sempre retorna `null`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo de `MyClass1`, obtém o <xref:System.Reflection.ConstructorInfo> objeto que coincide com os sinalizadores de associação especificadas e exibe a assinatura do construtor.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a maneira como o valor retornado é passado, a quais registros são usados para argumentos e à forma que a pilha é limpa.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor obter.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa por um construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor que corresponde aos requisitos especificados, se encontrados, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Esse método implementa <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os construtores do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os construtores públicos definidos para o <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa todos os construtores de instância pública definidos para o <see cref="T:System.Type" /> atual, mas não incluindo o inicializador de tipo (construtor estático). Se nenhum construtor de instância pública for definido para o <see cref="T:System.Type" /> atual ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo ou método genérico, uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração. Seu código não deve depender a ordem em que os construtores são retornados, porque essa ordem varia.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Essa sobrecarga de método chama o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga de método, com <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> no Visual Basic). Ele não localizará os inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.  
  
   
  
## Examples  
 Este exemplo mostra a saída do <xref:System.Type.GetConstructors%2A> de sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 A saída desse código é:  
  
 2  
  
 False  
  
 False  
  
 Porque o <xref:System.Type.GetConstructors> sobrecarga usa apenas <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, o construtor estático não é contado pela `for` expressão nem avaliadas pelo `IsStatic`.  
  
 Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarregar e passar a combinação (lógicas `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Agora, a saída é:  
  
 3  
  
 False  
  
 verdadeiro  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa os construtores definidos para o <see cref="T:System.Type" /> atual usando os <see langword="BindingFlags" /> especificados.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> representando todos os construtores definidos para o <see cref="T:System.Type" /> atual que corresponde às restrições de associação especificadas, incluindo o inicializador de tipo, se ele estiver definido. Retorna uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> se nenhum construtor estiver definido para o <see cref="T:System.Type" /> atual, se nenhum dos construtores definidos corresponderem às restrições de associação ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo genérico ou método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração. Seu código não deve depender a ordem em que os construtores são retornados, porque essa ordem varia.  
  
 `bindingAttr` pode ser usado para especificar se deseja retornar apenas os construtores públicos ou construtores público e não públicos.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa. Construtores de classes base não são retornados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.  
  
   
  
## Examples  
 Este exemplo mostra a saída do <xref:System.Type.GetConstructors> de sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 A saída desse código é:  
  
 2  
  
 False  
  
 False  
  
 Porque o <xref:System.Type.GetConstructors%2A> sobrecarga usa apenas <xref:System.Reflection.BindingFlags.Public> e <xref:System.Reflection.BindingFlags.Instance>, o construtor estático não é contado pela `for` expressão nem avaliadas pelo `IsStatic`.  
  
 Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%2A> sobrecarregar e passá-lo a combinação (OR lógico) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Agora, a saída é:  
  
 3  
  
 False  
  
 verdadeiro  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Procura os membros definidos para o <see cref="T:System.Type" /> atual, cujo <see cref="T:System.Reflection.DefaultMemberAttribute" /> está definido.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos os membros padrão do <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetDefaultMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem uma propriedade `P` que retorna `T`, chamar <xref:System.Type.GetDefaultMembers%2A> na `C<int>` retorna `int P` em c# (`Property P As Integer` no Visual Basic).  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém as informações do membro padrão de `MyClass` e exibe os membros padrão.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna o <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de matriz, ponteiro ou tipo de referência.</summary>
        <returns>O <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de referência, ponteiro ou matriz atual ou <see langword="null" /> se <see cref="T:System.Type" /> atual não é uma matriz ou um ponteiro ou não é passado por referência ou representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará `null` para o <xref:System.Array> classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `GetElementType` método.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujo nome deverá ser recuperado.</param>
        <summary>Retorna o nome da constante que tem o valor especificado para o tipo de enumeração atual.</summary>
        <returns>O nome do membro do tipo de enumeração atual que tem o valor especificado ou <see langword="null" />, se tal constante não for encontrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.  
  
- ou - 
 <paramref name="value" /> não é do tipo atual, nem tem o mesmo tipo subjacente que o tipo atual.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os nomes dos membros do tipo de enumeração atual.</summary>
        <returns>Uma matriz que contém os nomes dos membros da enumeração.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz de valores de retorno são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes enumeradas. Se a matriz contém constantes enumeradas com o mesmo valor, a ordem de seus nomes correspondentes é especificada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o tipo subjacente do tipo de enumeração atual.</summary>
        <returns>O tipo subjacente da enumeração atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o tipo subjacente de uma enumeração no c# e Visual Basic é <xref:System.Int32>. Outros tipos de inteiro podem ser especificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.  
  
- ou - 
O tipo de enumeração não é válido, pois contém mais de um campo de instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de valores das constantes no tipo de enumeração especificado.</summary>
        <returns>Uma matriz que contém os valores. Os elementos da matriz são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes de enumeração.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um evento específico declarado ou herdado pelo <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome de um evento que é declarado ou herdado pelo <see cref="T:System.Type" /> atual.</param>
        <summary>Retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento público especificado.</summary>
        <returns>O objeto que representa o evento público especificado, o qual é declarado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui eventos de instância pública de static e public.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.EventInfo> de objeto e obtém o evento para uma classe de botão para o evento especificado.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome de um evento declarado ou herdado pelo <see cref="T:System.Type" /> atual.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento especificado, usando as restrições de associação especificadas.</summary>
        <returns>O objeto que representa o evento especificado, o qual é declarado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais eventos serão incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pesquisar apenas os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> método para pesquisar um tipo para um público ou não público evento chamado "Click" que não seja `static` (`Shared` no Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o <see cref="T:System.Type" /> atual não tiver eventos públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os eventos são retornados, porque essa ordem varia.  
  
 Este método pode ser substituído por uma classe derivada.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos, obtém todos os eventos para um `Button` de classe e exibe os nomes de evento. Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, procura por eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam todos os eventos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual, que corresponde às restrições de associação especificadas.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o <see cref="T:System.Type" /> atual não tiver eventos ou se nenhum dos eventos corresponderem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os eventos são retornados, porque essa ordem varia.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais eventos serão incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos particulares, internos e protegidos) na pesquisa. Somente protegido e eventos internos em classes base são retornados; eventos privados em classes base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` Pesquisar apenas os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos que correspondem aos sinalizadores de associação especificadas, obtém todos os eventos para um `Button` de classe e exibe os nomes de evento. Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um campo específico do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</param>
        <summary>Pesquisa o campo público com o nome especificado.</summary>
        <returns>Um objeto que representa o campo público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui os campos de instância pública de static e public.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém a `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo e exibe o valor do campo.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Este objeto <see cref="T:System.Type" /> é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> cujo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método ainda não foi chamado.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa o campo especificado usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o campo que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos serão incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para pesquisar apenas os campos declarados no <xref:System.Type>, não de campos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém a `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo que coincide com os sinalizadores de associação especificadas e exibe o valor do campo.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os campos do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os campos públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos os campos públicos definidos para o <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo público for definido para o <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetFields%2A> método não retorna campos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os campos são retornados, porque essa ordem varia.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso do `GetFields()` método.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa os campos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos os campos definidos para o <see cref="T:System.Type" /> atual que corresponde às restrições de associação especificadas.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo estiver definido para o <see cref="T:System.Type" /> atual ou se nenhum dos campos definidos corresponderem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetFields%2A> método não retorna campos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os campos são retornados, porque essa ordem varia.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos serão incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos particulares, internos e protegidos) na pesquisa. Somente protegido e campos internos em classes base são retornados; campos privados em classes base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para pesquisar apenas os campos declarados no <xref:System.Type>, não de campos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso do `GetFields(BindingFlags)` método.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico fechado ou os parâmetros de tipo de uma definição de tipo genérico.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico. Retorna uma matriz vazia se o tipo atual não é um tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz são retornados na ordem em que aparecem na lista de argumentos de tipo para o tipo genérico.  
  
-   Se o tipo atual for um tipo construído fechado (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `false`), a matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método contém os tipos que foram atribuídos aos parâmetros de tipo genérico de definição de tipo genérico .  
  
-   Se o tipo atual é uma definição de tipo genérico, a matriz contém os parâmetros de tipo.  
  
-   Se o tipo atual for um tipo construído aberto (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`) em que tipos específicos não tem sido atribuídos a todos os parâmetros de tipo e parâmetros de tipo de circunscrição tipos ou métodos genéricos, a matriz contém tipos e parâmetros de tipo. Use o <xref:System.Type.IsGenericParameter%2A> propriedade distingui-los. Para ver uma demonstração desse cenário, consulte o exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetGenericArguments%2A> método para exibir os argumentos de tipo de um tipo construído e os parâmetros de tipo de sua definição de tipo genérico.  
  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade. Consulte o exemplo maior para a saída de exemplo.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada restrição em um parâmetro de tipo genérico é expressa como um <xref:System.Type> objeto. Use o <xref:System.Type.IsClass%2A> propriedade para determinar se uma restrição é a restrição de classe base; se a propriedade retornará `false`, a restrição é uma restrição de interface. Se um parâmetro de tipo tem nenhuma restrição de classe e sem restrições de interface, uma matriz vazia será retornada.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo que têm diferentes restrições. Quando o programa é executado, as restrições são examinadas por meio de <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O objeto <see cref="T:System.Type" /> atual não é um parâmetro de tipo genérico. Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico do qual o tipo genérico atual pode ser criado.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa um tipo genérico do qual o tipo atual pode ser criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma definição de tipo genérico é um modelo do qual outros tipos podem ser construídos. Por exemplo, de definição de tipo genérico `G<T>` (expressa na sintaxe c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode construir e criar uma instância do tipo `G<int>` (`G(Of Integer)` no Visual Basic). Considerando um <xref:System.Type> construída de objeto que representa esse tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna a definição de tipo genérico.  
  
 Se dois tipos construídos são criados da mesma definição de tipo genérico, usando os mesmos argumentos de tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna o mesmo <xref:System.Type> objeto para ambos os tipos.  
  
 Se você chamar o <xref:System.Type.GetGenericTypeDefinition%2A> método em um <xref:System.Type> objeto que já representa uma definição de tipo genérico, ele retorna atual <xref:System.Type>.  
  
> [!IMPORTANT]
>  Uma matriz de tipos genéricos não é em si genérico. No código c# `A<int>[] v;` ou o código do Visual Basic `Dim v() As A(Of Integer)`, o tipo de variável `v` não é genérico. Use <xref:System.Type.IsGenericType%2A> para determinar se um tipo é genérico antes de chamar <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma instância de um tipo construído usando a criação de comum de instância e, em seguida, usa o <xref:System.Type.GetType%2A> e <xref:System.Type.GetGenericTypeDefinition%2A> métodos para recuperar o tipo construído e definição de tipo genérico. Este exemplo usa o genérico <xref:System.Collections.Generic.Dictionary%602> tipo; representa o tipo construído uma <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não é um tipo genérico.  Ou seja, <see cref="P:System.Type.IsGenericType" /> retorna <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>O código hash para essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir exibe o código hash do `System.Windows.Forms.Button` classe.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma interface específica implementada ou herdada pelo <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da interface a ser obtida. Para interfaces genéricas, este é o nome danificado.</param>
        <summary>Pesquisa a interface com o nome especificado.</summary>
        <returns>Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
> [!NOTE]
>  Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo. Isso é verdadeiro para as definições de interface genérica e construídos interfaces genéricas. Por exemplo, para encontrar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), pesquise ``"IExample`1"``.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%29> método para pesquisar o <xref:System.Collections.Hashtable> de classe para o <xref:System.Runtime.Serialization.IDeserializationCallback> interface e lista os métodos da interface.  
  
 O exemplo de código também demonstra a <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da interface a ser obtida. Para interfaces genéricas, este é o nome danificado.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar a diferença entre maiúsculas e minúsculas dessa parte de <paramref name="name" /> que especifica o nome da interface simples (a parte que especifica se o namespace deve diferenciar maiúsculas e minúsculas corretamente).  
  
- ou - 
 <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para todas as partes de <paramref name="name" />.</param>
        <summary>Quando substituído em uma classe derivada, procura pela interface especificada, indicando se deseja fazer uma pesquisa que não diferencia maiúsculas de minúsculas pelo nome da interface.</summary>
        <returns>Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ignoreCase` parâmetro aplica-se somente para o nome da interface simples, não para o namespace. A parte de `name` que especifica o namespace deve ter a capitalização correta ou a interface não será encontrada. Por exemplo, a cadeia de caracteres "System. IComparable" localiza o <xref:System.IComparable> interface, mas a cadeia de caracteres "System. IComparable" não.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
> [!NOTE]
>  Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo. Isso é verdadeiro para as definições de interface genérica e construídos interfaces genéricas. Por exemplo, para encontrar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), pesquise `"IExample`1"'.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> método para realizar uma pesquisa não diferencia maiusculas da <xref:System.Collections.Hashtable> de classe para o <xref:System.Collections.IEnumerable> interface.  
  
 O exemplo de código também demonstra a <xref:System.Type.GetInterface%28System.String%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">O tipo de interface para o qual um mapeamento será recuperado.</param>
        <summary>Retorna um mapeamento de interface para o tipo de interface especificado.</summary>
        <returns>Um objeto que representa o mapeamento de interface para <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mapa da interface indica como uma interface é mapeada para os membros reais em uma classe que implementa a interface.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, o tipo de parâmetros são substituídos pelos argumentos nos elementos do tipo apropriado a <xref:System.Reflection.InterfaceMapping> retornado por esse método.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Type.GetInterfaceMap%2A> método para determinar como o <xref:System.IFormatProvider> interface mapeia para <xref:System.Globalization.CultureInfo> métodos e como a <xref:System.IAppDomainSetup> interface é mapeado para <xref:System.AppDomainSetup> propriedades. Observe que, como o <xref:System.IAppDomainSetup> interface define um conjunto de propriedades, retornados <xref:System.Reflection.InterfaceMapping> objeto inclui separado <xref:System.Reflection.MethodInfo> objetos para uma propriedade acessadores get e set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> não é implementado pelo tipo atual.  
  
- ou - 
O argumento <paramref name="interfaceType" /> não faz referência a uma interface.  
  
- ou -

A instância atual ou argumento <paramref name="interfaceType" /> é um tipo genérico aberto. Ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.

- ou -


 <paramref name="interfaceType" /> é uma interface genérica e o tipo atual é um tipo de matriz.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Type" /> atual representa um parâmetro de tipo genérico, ou seja, <see cref="P:System.Type.IsGenericParameter" /> é <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém todas as interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa todas as interfaces implementadas ou herdadas pela <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhuma interface está implementada ou herdada pela <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetInterfaces%2A> método não retorna interfaces em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual as interfaces são retornados, porque essa ordem varia.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Type> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo da classe especificada e exibe todas as interfaces que o tipo implementa ou herda. Para compilar o exemplo do Visual Basic, use os seguintes comandos do compilador:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador estático é invocado e lança uma exceção.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os membros especificados do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros públicos a serem obtidos.</param>
        <summary>Pesquisa a propriedade pública com o nome especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui os membros de instância pública de static e public.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Essa sobrecarga de método não localizará os inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os membros de `String` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar uma matriz vazia.</param>
        <summary>Pesquisa os membros especificados usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic) para `bindingAttr`. Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os membros estáticos públicos do `myString` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</param>
        <param name="type">O valor a ser procurado.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar uma matriz vazia.</param>
        <summary>Pesquisa os membros especificados do tipo de membro especificado, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> para `type`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> em Visual Basic) para `bindingAttr`. Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os métodos do `myString` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Uma classe derivada deve fornecer uma implementação.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os membros (propriedades, métodos, campos, eventos e assim por diante) do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os membros públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos os membros públicos do <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Essa sobrecarga de método chama o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga de método, com <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> no Visual Basic). Ele não localizará os inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers> sobrecarga de método para coletar informações sobre todos os membros públicos de uma classe especificada.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), para retornar uma matriz vazia.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa os membros definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> representando todos os membros definidos para o <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se nenhum membro estiver definido para o atual <see cref="T:System.Type" /> ou se nenhum dos membros definidos corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMembers%2A> método não retorna os membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa. Somente protegido e membros internos em classes base são retornados; membros privados em classes base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Chamar esse método apenas com o `Public` sinalizador ou apenas o `NonPublic` sinalizador retornará os membros especificados e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> no Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga de método para coletar informações sobre todos os membros de instância pública de uma classe especificada.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um método específico do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <summary>Pesquisa o método público com o nome especificado.</summary>
        <returns>Um objeto que representa o método público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui os métodos de instância pública de static e public.  
  
 Se um método está sobrecarregado e tem mais de um método público, o <xref:System.Type.GetMethod%28System.String%29> método lança um <xref:System.Reflection.AmbiguousMatchException> exceção. No exemplo a seguir, uma exceção é gerada porque não há mais de uma sobrecarga pública do <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  Por outro lado, pois o `Person.ToString` substituições de método <xref:System.Object.ToString%2A?displayProperty=nameWithType> e, portanto, não está sobrecarregado, o <xref:System.Type.GetMethod%28System.String%29> método é capaz de recuperar o <xref:System.Reflection.MethodInfo> objeto.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Você pode fazer o seguinte para recuperar um método específico:  
  
-   Chame o <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> método e especifique um `bindingAttr` argumento que identifica exclusivamente o método. Por exemplo, se a exceção é lançada como um tipo tem um estático e uma sobrecarga de instância, você pode especificar uma `bindingAttr` argumento de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Chamar uma sobrecarga da <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.  
  
-   Chamar o <xref:System.Type.GetMethods> método para recuperar uma matriz que contém todos os métodos públicos que pertencem a um tipo. Você pode iterá-lo para identificar os métodos duplicados denominados `name`.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir obtém um método chamado `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa o método especificado, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir métodos públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> para ignorar o caso de `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Se um método está sobrecarregado e mais de uma sobrecarga cumpre as restrições especificadas pelo `bindingAttr` argumento, o método lança um <xref:System.Reflection.AmbiguousMatchException> exceção. O exemplo a seguir, uma exceção é gerada porque:  
  
-   O `TestClass` tipo tem duas sobrecargas de instância pública do `DisplayValue` método `DisplayValue(String)` e `DisplayValue(String, Object[])`.  
  
-   O `TestClass` tipo tem duas sobrecargas de instância pública do `Equals` método, um deles é herdado do <xref:System.Object>: `Equals(TestClass)` e `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Você pode fazer o seguinte para recuperar um método específico:  
  
-   Altere as restrições de associação. No exemplo anterior, a tentativa de recuperar uma instância pública `Equals` recupera do método que é declarado pelo tipo e não herdado com êxito `Equals(TestClass)`.  
  
-   Chamar uma sobrecarga da <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.  
  
-   Chamar o <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> método para recuperar uma matriz que contém todos os métodos que pertencem a um tipo que têm os atributos de associação especificadas. Você pode iterá-lo para identificar os métodos duplicados denominados `name`. Essa abordagem é ilustrada no manipulador do exemplo anterior para o <xref:System.Reflection.AmbiguousMatchException> exceção.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o método que corresponde a sinalizadores de associação especificados.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
- ou - 
Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <summary>Pesquisa o método público especificado cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa o método público cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui os métodos de instância pública de static e public.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  O `name` parâmetro não pode incluir os argumentos de tipo. Por exemplo, o código c# `GetMethod("MyGenericMethod<int>")` procura um método com o nome de texto "`MyGenericMethod<int>`", em vez de para um método chamado `MyGenericMethod` que tem um argumento genérico do tipo `int`. Em vez disso, use `GetMethod("MyGenericMethod")` com o parâmetro apropriado no `types` matriz.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 O exemplo a seguir recupera <xref:System.Reflection.MethodInfo> objetos que representam os `Add` métodos de um tipo não genérico (a <xref:System.Collections.ArrayList> classe), um tipo genérico aberto (o <xref:System.Collections.Generic.List%601> classe) e um tipo genérico fechado (o `List(Of String)` tipo.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 O exemplo define uma `GetAddMethod` método que recupera apropriado <xref:System.Reflection.MethodInfo> objeto. Para fornecer a `types` argumento para um tipo genérico aberto, ele chama o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método. Para fornecer a `types` argumento para um tipo genérico fechado, ele recupera o valor da <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método com o nome especificado e com os parâmetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
- ou - 
Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método público especificado cujos parâmetros correspondem aos modificadores e tipos de argumento especificados.</summary>
        <returns>Um objeto que representa o método público que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui os métodos de instância pública de static e public.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMethod("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`. Em vez disso, use `GetMethod("MyMethod")` com o parâmetro apropriado no `types` matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método com o nome especificado e com os parâmetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
- ou - 
Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar restrições de associação e uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a como o valor retornado é passado, quais registros são usados para argumentos e como a pilha é limpa.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
- ou - 
Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `GetXXX` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas do `MethodA`, especificar restrições de associação, convenções de chamada e uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a ser usado em relação à ordem e ao layout dos argumentos, a como o valor retornado é passado, quais registros são usados para argumentos e qual processo limpa a pilha.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um método que não aceita parâmetros.  
  
- ou - 
 <see langword="null" />. Se <paramref name="types" /> for <see langword="null" />, os argumentos não serão correspondidos.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa o método especificado, cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se `types` for `null`, os argumentos não serão correspondidos.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os métodos do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os métodos públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam todos os métodos públicos definidos para o <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método público for definido para o <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os métodos são retornados, porque essa ordem varia.  
  
 Construtores não são incluídos na matriz de métodos retornados por essa chamada. Fazer uma chamada separada para `GetConstructors()` para obter os métodos de construtor.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa os métodos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> representando todos os métodos definidos para o <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método estiver definido para o atual <see cref="T:System.Type" />, ou se nenhum dos métodos definidos corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os métodos são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir métodos não públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa. Somente protegido e métodos internos em classes base são retornados; métodos privados em classes base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe com dois métodos públicos e um método protegido, cria uma `Type` objeto correspondente `MyTypeClass`, obtém todos os métodos públicos e não públicos e exibe seus nomes.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um tipo específico aninhado no <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</param>
        <summary>Pesquisa o tipo aninhado público com o nome especificado.</summary>
        <returns>Um objeto que representa o tipo aninhado público com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas.  
  
 Use o nome simple da classe aninhada para `name`. Não qualifique-o com o nome da classe externa. Para uma classe aninhada genérica, use o nome danificado - ou seja, acrescente um acento grave e o número de argumentos genéricos. Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico de classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic). Não inclua a sintaxe específica da linguagem para parâmetros de tipo.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa as propriedades do tipo aninhado especificado, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o nome simple da classe aninhada para `name`. Não qualifique-o com o nome da classe externa. Para uma classe aninhada genérica, use o nome danificado - ou seja, acrescente um acento grave e o número de parâmetros genéricos. Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico de classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic). Não inclua a sintaxe específica da linguagem para parâmetros de tipo.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir tipos aninhados de não-públicos (ou seja, particulares, internos e protegidos tipos aninhados) na pesquisa.  
  
 Esse método retorna apenas os tipos aninhados do tipo atual. Ele pesquisa as classes base do tipo atual. Para localizar os tipos que estão aninhados em classes base, você deve movimentar a hierarquia de herança, chamar <xref:System.Type.GetNestedType%2A> em cada nível.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> são ignorados.  
  
 Chamar esse método apenas com o <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém os tipos aninhados no <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os tipos públicos aninhados no <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de <see cref="T:System.Type" /> objetos que representam os tipos públicos aninhados no <see cref="T:System.Type" /> atual (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" /> se não há tipos públicos são aninhados no <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetNestedTypes%2A> método não retorna tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os tipos são retornados, porque essa ordem varia.  
  
 Somente os tipos públicos aninhados imediatamente no tipo atual são retornados; a pesquisa não é recursiva.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe aninhada e um `struct` na `MyClass`e, em seguida, obtém os objetos dos tipos aninhados usando o tipo do `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa as propriedades do <see cref="T:System.Type" /> atual, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam todos os tipos aninhados no <see cref="T:System.Type" /> atual que coincidem com as restrições de associação especificadas (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhum dos tipos aninhados são encontrados que correspondem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa por tipos aninhados não é recursiva.  
  
 O <xref:System.Type.GetNestedTypes%2A> método não retorna tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual os tipos são retornados, porque essa ordem varia.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir tipos aninhados de não-públicos (ou seja, particulares, internos e protegidos tipos aninhados) na pesquisa.  
  
 Esse método retorna apenas os tipos aninhados do tipo atual. Ele pesquisa as classes base do tipo atual. Para localizar os tipos que estão aninhados em classes base, você deve movimentar a hierarquia de herança, chamar <xref:System.Type.GetNestedTypes%2A> em cada nível.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> são ignorados.  
  
 Chamar esse método apenas com o <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro de tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir cria duas classes públicas aninhadas e duas classes aninhadas de protegido e exibe informações para as classes que correspondem às restrições de associação especificadas.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém as propriedades do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todas as propriedades públicas do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas as propriedades públicas do <see cref="T:System.Type" /> atual.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades públicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga é equivalente a chamar o <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> sobrecarga com um `bindingAttr` argumento igual a `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` em c# e `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` no Visual Basic. Ele retorna todas as instância pública e propriedades estáticas, tanto aqueles definidos pelo tipo representado por atual <xref:System.Type> objeto, bem como aqueles herdados de seus tipos base.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetProperties%2A> método não retorna as propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual as propriedades são retornadas, porque essa ordem varia.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do método `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa as propriedades do atual <see cref="T:System.Type" />, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas as propriedades do <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades, ou se nenhuma das propriedades corresponderem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetProperties%2A> método não retorna as propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código não deve depender a ordem na qual as propriedades são retornadas, porque essa ordem varia.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de filtro flags pode ser usado para definir qual aninhados para incluir na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa. Somente protegido e propriedades internas em classes base são retornadas; as propriedades privadas em classes base não são retornadas.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Se o T:System.Type atual representa um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe chamada `PropertyClass` que inclui seis propriedades: dois são públicos, um é privado, uma é protegida, um é interno (`Friend` no Visual Basic), e um está protegido interno (`Protected Friend` no Visual Basic). Ele então exibe algumas informações básicas de propriedade (o nome da propriedade e o tipo, se ele é leitura/gravação e a visibilidade de seu `get` e `set` acessadores) para as propriedades que correspondem às restrições de associação especificadas.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma propriedade específica do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <summary>Pesquisa a propriedade pública com o nome especificado.</summary>
        <returns>Um objeto que representa a propriedade pública com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
 Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:  
  
-   Um tipo contém duas propriedades indexadas que têm o mesmo nome, mas diferentes números de parâmetros. Para resolver a ambiguidade, use uma sobrecarga da <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.  
  
-   Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic). Para resolver a ambiguidade, use o <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> sobrecarga de método e adicione o <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> sinalizador para restringir a pesquisa a membros que não são herdados.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Internamente, essa propriedade é chamada nos metadados com o nome "Item". Qualquer tentativa de obter `PropertyInfo` usando a reflexão deve especificar esse nome interno para retornar corretamente o `PropertyInfo` propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa a propriedade especificada usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
 Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:  
  
-   Um tipo contém duas propriedades indexadas que têm o mesmo nome, mas diferentes números de parâmetros. Para resolver a ambiguidade, use uma sobrecarga da <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.  
  
-   Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic). Para resolver a ambiguidade, inclua <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para restringir a pesquisa a membros que não são herdados.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade de acordo com as restrições de associação especificado.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <summary>Pesquisa a propriedade pública com o nome e tipo retornado especificados.</summary>
        <returns>Um objeto que representa a propriedade pública com o nome especificado, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe com uma propriedade e recupera o nome e o tipo da propriedade.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="name" /> é <see langword="null" /> ou o <paramref name="returnType" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa a propriedade pública cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera a propriedade dessa classe e exibe o nome da propriedade e o tipo da propriedade conforme especificado pelos argumentos passados para `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento especificados.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa a propriedade pública cujos parâmetros correspondem aos tipos de argumento especificados, se encontrado, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento especificados.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento e modificadores especificados.</summary>
        <returns>Um objeto que representa a propriedade pública que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma `Type` objeto correspondente `MyPropertyClass`, e a propriedade indexada dessa classe é recuperada usando os argumentos passados para o `GetProperty` método.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e que corresponde aos tipos de argumento e modificadores especificados.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa a propriedade especificada cujos parâmetros correspondem aos modificadores e tipos de argumento especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada particular e você deve usar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (no Visual Basic, combina os valores usando `Or`) para obtê-lo.  
  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# é exibido nos metadados como uma propriedade indexada chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
- ou - 
Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um membro sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
- ou - 
Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="types" />. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa a propriedade especificada cujos parâmetros correspondem aos modificadores e tipos de argumento especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa a propriedade que corresponde aos requisitos especificados, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais propriedades a serem incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> é multidimensional.  
  
- ou - 
 <paramref name="modifiers" /> é multidimensional.  
  
- ou - 
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Type" /> que representa o tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o <see cref="T:System.Type" /> atual.</summary>
        <returns>O <see cref="T:System.Type" /> atual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, com a execução de uma pesquisa que diferencia maiúsculas de minúsculas.</summary>
        <returns>O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos. Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar no c#, <xref:System.Type.GetType%2A> no Visual Basic ou C++.  
  
> [!NOTE]
>  Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%29> retorno do método `null`. Ele não gerará uma exceção. Para controlar se uma exceção é lançada, chame uma sobrecarga da <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.  
  
 <xref:System.Type.GetType%2A> funciona somente em assemblies carregados do disco. Se você chamar <xref:System.Type.GetType%2A> para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly. Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`. `GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem. Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado. Se o assembly tiver um nome forte, um nome de assembly completo é necessário.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos de tipo genérico. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento. A reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` fromMyAssembly.dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor anulável <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Um ponteiro não gerenciado para `MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado em um ponteiro para `MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro ou referência gerenciado para `MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyType[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyType[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Uma matriz de matrizes unidimensionais|`Type.GetType("MyType[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores desconhecidos|`Type.GetType("MyType[,]")`|  
|Um tipo genérico com um argumento de tipo|``Type.GetType("MyGenericType`1[MyType]")``|  
|Um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Um tipo genérico com dois argumentos de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade de `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</param>
        <param name="throwOnError"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, realizando uma pesquisa que diferencia minúsculas e maiúsculas e especificando se deve ou não lançar uma exceção se o tipo não for encontrado.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos. Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.  
  
 `GetType` funciona somente em assemblies carregados do disco. Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly. Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`. `GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 O `throwOnError` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções. Algumas exceções são geradas, independentemente do valor de `throwOnError`. Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é gerada, mesmo que `throwOnError` é `false`.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem. Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado. Se o assembly tiver um nome forte, um nome de assembly completo é necessário.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos genéricos. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento. A reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` de myAssembly. dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor anulável <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Um ponteiro não gerenciado para `MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado em um ponteiro para `MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro ou referência gerenciado para `MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyArray[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyArray[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Uma matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores desconhecidos|`Type.GetType("MyArray[,]")`|  
|Um tipo genérico com um argumento de tipo|``Type.GetType("MyGenericType`1[MyType]")``|  
|Um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Um tipo genérico com dois argumentos de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade de `System.Int32`. Se um objeto do tipo se refere a um assembly que não existe, este exemplo gera uma exceção.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida. 
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
- ou - 
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida. Por exemplo, "MyType[,*,]".  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo estiver no assembly em execução no momento ou em Mscorlib.dll, ele será suficiente para fornecer o nome de tipo qualificado pelo namespace.</param>
        <param name="throwOnError"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase"><see langword="true" /> para executar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deve ou não lançar uma exceção se o tipo não for encontrado e se deseja executar uma pesquisa diferenciando maiúsculas de minúsculas.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter uma <xref:System.Type> do objeto para um tipo em outro assembly, se você souber que seu nome qualificado pelo assembly que pode ser obtido no <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos dos <xref:System.Reflection.Assembly> classe para obter <xref:System.Type> objetos. Se for um tipo em um assembly conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.  
  
 `GetType` funciona somente em assemblies carregados do disco. Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> serviços, você poderá obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criado usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de localizar o assembly salvo em disco, esse assembly é carregado e recupera o tipo desse assembly. Se o assembly não tiver sido salvo para disco quando `GetType` é chamado, o método retorna `null`. `GetType` não entende os assemblies dinâmicos transitórios; Portanto, chamar `GetType` para recuperar um tipo de transitório retornará o assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 O `throwOnError` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções. Algumas exceções são geradas, independentemente do valor de `throwOnError`. Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é gerada, mesmo que `throwOnError` é `false`.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Tipos COM ou matrizes não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName` pode ser o nome do tipo qualificado por seu namespace ou um nome qualificado pelo assembly que inclui uma especificação de nome do assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa apenas o assembly do objeto de chamada e o mscorlib. dll, nessa ordem. Se o typeName é totalmente qualificado com o nome do assembly parcial ou completa, esse método pesquisará no assembly especificado. Se o assembly tiver um nome forte, um nome de assembly completo é necessário.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e os argumentos de tipo. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos com a criação de um <xref:System.Reflection.AssemblyName> objeto e passá-la para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado pelo assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace fosse TopNamespace.Sub+Namespace, em seguida, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ela seja interpretado como um separador de aninhamento. A reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Um "+ +" torna-se "\\+\\+" e um "\\"torna-se"\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade dessa desconfiguração de nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, a reflexão retorna os nomes desconfigurados `Tuple`1` and `tupla`2` entre os métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e a tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo é colocada entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> dos `MyType` com as chaves do tipo <xref:System.String> pode ser representada da seguinte maneira:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado pelo assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado pelo assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, uma <xref:System.Collections.Generic.Dictionary%602> dos `MyType` de myAssembly. dll, com chaves de tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado pelo assembly pode estar entre colchetes somente quando aparece dentro de uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para os tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor anulável <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o que permite valor nulo <xref:System.Boolean> tipo é retornado por `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor anulável <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Um ponteiro não gerenciado para `MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado em um ponteiro para `MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro ou referência gerenciado para `MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyArray[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyArray[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes em que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Uma matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores desconhecidos|`Type.GetType("MyArray[,]")`|  
|Um tipo genérico com um argumento de tipo|``Type.GetType("MyGenericType`1[MyType]")``|  
|Um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Um tipo genérico com dois argumentos de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Um tipo genérico qualificado pelo assembly com um argumento de tipo qualificado pelo assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida. 
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
- ou - 
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida. Por exemplo, "MyType[,*,]".  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver. Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />. O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />. Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado. Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado pelo <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão. Se nenhum assembly for fornecido, o método <paramref name="typeResolver" /> poderá fornecer um. O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <summary>Obtém o tipo com o nome especificado, fornecendo opcionalmente métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado ou <see langword="null" /> se o tipo não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cenários de uso para esse método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.  
  
> [!NOTE]
>  Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> retorno do método `null`. Ele não gerará uma exceção. Para controlar se uma exceção é lançada, chame uma sobrecarga da <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `throwOnError` e `ignoreCase` parâmetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.  
  
- ou - 
 <paramref name="typeName" /> contém um nome de assembly inválido.  
  
- ou - 
 <paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver. Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />. O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />. Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado. Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado por <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão. Se nenhum assembly for indicado, o método poderá fornecer um. O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <param name="throwOnError"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <summary>Obtém o tipo com o nome definido, especificando se deverá ser lançada uma exceção se o tipo não for encontrado e, opcionalmente, fornecendo métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cenários de uso para esse método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `ignoreCase` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida. 
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
- ou - 
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,*,]").  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.  
  
- ou - 
 <paramref name="typeName" /> contém um nome de assembly inválido.  
  
- ou - 
 <paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o parâmetro <paramref name="typeResolver" /> for fornecido, o nome do tipo poderá ser qualquer cadeia de caracteres que <paramref name="typeResolver" /> possa resolver. Se o parâmetro <paramref name="assemblyResolver" /> for fornecido ou se a resolução de tipo padrão for usada, <paramref name="typeName" /> deverá ser um nome qualificado do assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo esteja no assembly em execução no momento ou em Mscorlib.dll, quando então será suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o assembly especificado em <paramref name="typeName" />. O nome do assembly é passado para <paramref name="assemblyResolver" /> como um objeto <see cref="T:System.Reflection.AssemblyName" />. Se <paramref name="typeName" /> não contiver o nome de um assembly, o <paramref name="assemblyResolver" /> não será chamado. Se o <paramref name="assemblyResolver" /> não for fornecido, será executada a resolução de assembly padrão.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado por <paramref name="typeName" /> do assembly que é retornado pelo <paramref name="assemblyResolver" /> ou pela resolução de assembly padrão. Se nenhum assembly for indicado, o método poderá fornecer um. O método também utiliza um parâmetro que especifica se deve executar uma pesquisa que diferencia maiúsculas de minúsculas. O valor de <paramref name="ignoreCase" /> é passado para esse parâmetro.  
  
Cuidado! Não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <param name="throwOnError"><see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase"><see langword="true" /> para executar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</param>
        <summary>Obtém o tipo com o nome definido, especificando se uma pesquisa que diferencia maiúsculas de minúsculas deverá ser realizada e se uma exceção deverá ser gerada se o tipo não for encontrado, com a opção de também fornecer métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método e suas sobrecargas associadas (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> e <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) para substituir a implementação padrão da <xref:System.Type.GetType%2A> método com implementações mais flexíveis. Ao fornecer seus próprios métodos que resolvem nomes de tipo e os nomes dos assemblies que contêm-los, você pode fazer o seguinte:  
  
-   Controle qual versão de um assembly de um tipo é carregado do.  
  
-   Forneça outro local para procurar um nome de tipo que não inclua um nome de assembly.  
  
-   Carregar assemblies usando nomes de assembly parciais.  
  
-   Retornar as subclasses de <xref:System.Type?displayProperty=nameWithType> que não são criados pelo common language runtime (CLR).  
  
 Por exemplo, na serialização tolerantes à versão esse método permite que você pesquise um assembly de "melhor ajuste" usando um nome parcial. Outras sobrecargas do <xref:System.Type.GetType%2A> método exigir um nome de tipo qualificado pelo assembly, que inclui o número de versão.  
  
 Talvez seja necessário retornar subclasses de implementações alternativas do sistema de tipo <xref:System.Type?displayProperty=nameWithType> que não são criados pelo CLR; todos os tipos que são retornados por outras sobrecargas do <xref:System.Type.GetType%2A> método são tipos de tempo de execução.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Notas de uso  
 Essa sobrecarga de método e suas sobrecargas associadas analisam `typeName` no nome de um tipo e o nome de um assembly e, em seguida, resolver os nomes. Resolução do nome do assembly ocorre antes da resolução do nome do tipo, porque um nome de tipo deve ser resolvido no contexto de um assembly.  
  
> [!NOTE]
>  Se você estiver familiarizado com o conceito de nomes de tipo qualificado pelo assembly, consulte o <xref:System.Type.AssemblyQualifiedName%2A> propriedade.  
  
 Se `typeName` não é um nome qualificado pelo assembly, resolução de assembly é ignorada. Nomes de tipo não qualificado podem ser resolvidos no contexto de mscorlib. dll ou o assembly em execução no momento ou, opcionalmente, você pode fornecer um assembly no `typeResolver` parâmetro. Os efeitos de incluir ou omitir o nome do assembly para tipos diferentes de resolução de nomes são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção.  
  
 Observações de uso geral:  
  
-   Não passe métodos a serem `assemblyResolver` ou `typeResolver` que elas venham de chamadores desconhecidos ou não confiáveis. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.  
  
    > [!CAUTION]
    >  Usando métodos de chamadores desconhecidos ou não confiáveis pode resultar em elevação de privilégio de código mal-intencionado.  
  
-   Se você omitir a `assemblyResolver` e/ou `typeResolver` parâmetros, o valor da `throwOnError` parâmetro é passado para os métodos que realizam a resolução padrão.  
  
-   Se `throwOnError` está `true`, esse método lança uma <xref:System.TypeLoadException> quando `typeResolver` retorna `null`e uma <xref:System.IO.FileNotFoundException> quando `assemblyResolver` retorna `null`.  
  
-   Esse método não capturará exceções geradas pelo `assemblyResolver` e `typeResolver`. Você é responsável por todas as exceções que são geradas pelos métodos resolvedor.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Resolvendo assemblies  
 O `assemblyResolver` método recebe um <xref:System.Reflection.AssemblyName> objeto, que é produzido por analisar o nome do assembly de cadeia de caracteres que está incluído no `typeName`. Se `typeName` não contém um nome de assembly `assemblyResolver` não é chamado e `null` é passado para `typeResolver`.  
  
 Se `assemblyResolver` não for fornecida, o padrão de montagem de investigação é usada para localizar o assembly. Se `assemblyResolver` for fornecido, o <xref:System.Type.GetType%2A> método não faz a investigação padrão; nesse caso, você deve garantir que seu `assemblyResolver` pode lidar com todos os assemblies que você passa para ele.  
  
 O `assemblyResolver` método deverá retornar `null` se o assembly não pode ser resolvido. Se `assemblyResolver` retorna `null`, `typeResolver` não é chamado e nenhum processamento adicional ocorre; Além disso, se `throwOnError` está `true`, um <xref:System.IO.FileNotFoundException> é gerada.  
  
 Se o <xref:System.Reflection.AssemblyName> que é passado para `assemblyResolver` é um parcial nome, uma ou mais das suas partes são `null`. Por exemplo, se ele não tem versão, o <xref:System.Reflection.AssemblyName.Version%2A> é de propriedade `null`. Se o <xref:System.Reflection.AssemblyName.Version%2A> propriedade, o <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriedade e o <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> método retornam `null`, em seguida, apenas o nome simples do assembly foi fornecido. O `assemblyResolver` método pode usar ou ignorar todas as partes do nome do assembly.  
  
 Os efeitos das opções de resolução de assembly diferente são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Resolvendo tipos  
 Se `typeName` não especifica um nome de assembly, `typeResolver` sempre é chamado. Se `typeName` Especifica um nome de assembly, `typeResolver` é chamada somente quando o nome do assembly é resolvido com êxito. Se `assemblyResolver` ou o assembly padrão investigação retorna `null`, `typeResolver` não é chamado.  
  
 O `typeResolver` método recebe três argumentos:  
  
-   O assembly para pesquisar ou `null` se `typeName` não contém um nome de assembly.  
  
-   O nome simples do tipo. No caso de um tipo aninhado, esse é o tipo de recipiente mais externo. No caso de um tipo genérico, este é o nome simples do tipo genérico.  
  
-   Um valor booliano que é `true` se o caso de nomes de tipo será ignorada.  
  
 A implementação determina a maneira como esses argumentos são usados. O `typeResolver` método deverá retornar `null` se ele não puder resolver o tipo. Se `typeResolver` retorna `null` e `throwOnError` é `true`, essa sobrecarga do <xref:System.Type.GetType%2A> lança um <xref:System.TypeLoadException>.  
  
 Os efeitos das opções de resolução de tipo diferentes são exibidos como uma tabela na [resolução de nome misto](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.  
  
#### <a name="resolving-nested-types"></a>Resolvendo tipos aninhados  
 Se `typeName` é um tipo aninhado, somente o nome do mais externo que contém o tipo é passado para `typeResolver`. Quando `typeResolver` retorna esse tipo, o <xref:System.Type.GetNestedType%2A> método é chamado repetidamente até que o tipo aninhado interno foi resolvido.  
  
#### <a name="resolving-generic-types"></a>Resolvendo tipos genéricos  
 O <xref:System.Type.GetType%2A> é chamada recursivamente para resolver tipos genéricos: Primeiro, para resolver o tipo genérico em si e, em seguida, para resolver seus argumentos de tipo. Se um argumento de tipo for genérico, <xref:System.Type.GetType%2A> é chamada recursivamente para resolver seus argumentos de tipo e assim por diante.  
  
 A combinação de `assemblyResolver` e `typeResolver` que você fornece deve ser capaz de resolver todos os níveis dessa recursão. Por exemplo, suponha que você fornecer um `assemblyResolver` que controla o carregamento de `MyAssembly`. Suponha que você deseja resolver o tipo genérico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` no Visual Basic). Você pode passar o nome de tipo genérico a seguir:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Observe que `MyType` é o argumento de tipo qualificado do assembly apenas. Os nomes dos <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String> classes não são qualificado pelo assembly. Sua `typeResolver` deve ser capaz de identificador de um assembly ou `null`, pois ela receberá `null` para <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String>. Ele pode lidar com esse caso, chamando uma sobrecarga da <xref:System.Type.GetType%2A> método que usa uma cadeia de caracteres, como os dois nomes de tipo não qualificados são em mscorlib. dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 O `assemblyResolver` método não é chamado para o tipo de dicionário e o tipo de cadeia de caracteres, porque esses nomes de tipo não são qualificado pelo assembly.  
  
 Agora suponha que, em vez de `System.String`, é o primeiro tipo de argumento genérico `YourType`, de `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Como este assembly é nem mscorlib. dll, nem o assembly em execução no momento, não é possível resolver `YourType` sem um nome qualificado pelo assembly. Porque seu `assemblyResolve` será chamada recursivamente, deve ser capaz de lidar com isso. Em vez de retornar `null` para assemblies diferente `MyAssembly`, ele agora executa um carregamento de assembly usando o <xref:System.Reflection.AssemblyName> objeto.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Voltar ao [Observações sobre uso](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Resolvendo nomes de tipo com caracteres especiais  
 Determinados caracteres têm significados especiais em nomes qualificados pelo assembly. Se um nome de tipo simples contém esses caracteres, os caracteres causam erros de análise quando o nome simples faz parte de um nome qualificado pelo assembly. Para evitar os erros de análise, você deve escapar os caracteres especiais com uma barra invertida antes de você pode passar o nome qualificado do assembly para o <xref:System.Type.GetType%2A> método. Por exemplo, se um tipo é nomeado `Strange]Type`, o caractere de escape deve ser adicionado à frente o colchete quadrado da seguinte maneira: `Strange\]Type`.  
  
> [!NOTE]
>  Nomes com caracteres especiais, não podem ser criados no Visual Basic ou c#, mas podem ser criados usando o Microsoft intermediate language (MSIL) ou emitindo assemblies dinâmicos.  
  
 A tabela a seguir mostra os caracteres especiais para nomes de tipo.  
  
|Caractere|Significado|  
|---------------|-------------|  
|`,` (vírgula)|Delimitador de nomes qualificados pelo assembly.|  
|`[]` (os colchetes)|Como um par de sufixo, indica um tipo de matriz; como um par de delimitadores, inclui listas de argumentos genéricos e nomes qualificados pelo assembly.|  
|`&` (e comercial)|Como um sufixo, indica que um tipo é um tipo de referência.|  
|`*` (asterisco)|Como um sufixo, indica que um tipo é um tipo de ponteiro.|  
|`+` (adição)|Delimitador de tipos aninhados.|  
|`\` (barra invertida)|Caractere de escape.|  
  
 Propriedades, como <xref:System.Type.AssemblyQualifiedName%2A> retorno corretamente cadeias de caracteres de escape. Você deve passar cadeias de caracteres de escapadas corretamente para o <xref:System.Type.GetType%2A> método. Por sua vez, o <xref:System.Type.GetType%2A> método passa os nomes de escape corretamente para `typeResolver` e para os métodos de resolução de tipo padrão. Se você precisa comparar um nome para um nome sem escape no `typeResolver`, você deve remover os caracteres de escape.  
  
 Voltar ao [Observações sobre uso](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Resolução de nome misto  
 A tabela a seguir resume as interações entre `assemblyResolver`, `typeResolver`e a resolução de nomes padrão, para todas as combinações de nome de tipo e nome do assembly na `typeName`:  
  
|Conteúdo do nome do tipo|Método do resolvedor de assembly|Método do resolvedor de tipo|Resultado|  
|---------------------------|------------------------------|--------------------------|------------|  
|tipo, assembly|nulo|nulo|Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método.|  
|tipo, assembly|fornecido|nulo|`assemblyResolver` Retorna o assembly ou `null` se ele não é possível resolver o assembly. Se o assembly for resolvido, o <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método é usada para carregar o tipo do assembly; caso contrário, não há nenhuma tentativa de resolver o tipo.|  
|tipo, assembly|nulo|fornecido|Equivalente a converter o nome do assembly para um <xref:System.Reflection.AssemblyName> objeto e chamar o <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> sobrecarga de método para obter o assembly. Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.|  
|tipo, assembly|fornecido|fornecido|`assemblyResolver` Retorna o assembly ou `null` se ele não é possível resolver o assembly. Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.|  
|tipo|nulo, fornecido|nulo|Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método. Porque o nome do assembly não for fornecido, apenas mscorlib. dll e o assembly em execução no momento são pesquisados. Se `assemblyResolver` for fornecido, ele será ignorado.|  
|tipo|nulo, fornecido|fornecido|`typeResolver` é chamado, e `null` é passado para o assembly. `typeResolver` pode fornecer um tipo de qualquer assembly, incluindo assemblies, que ele carrega o propósito. Se `assemblyResolver` for fornecido, ele será ignorado.|  
|assembly|nulo, fornecido|nulo, fornecido|Um <xref:System.IO.FileLoadException> for gerada, porque o nome do assembly é analisado como se fosse um nome de tipo qualificado pelo assembly. Isso resulta em um nome de assembly inválido.|  
  
 De volta para: [Notas de uso](#usage_notes), [Resolvendo Assemblies](#resolving_assemblies), [Resolvendo tipos](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida. 
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
- ou - 
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
- ou - 
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,*,]").  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.  
  
- ou - 
 <paramref name="typeName" /> contém um nome de assembly inválido.  
  
- ou - 
 <paramref name="typeName" /> é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objetos cujos tipos devem ser determinados.</param>
        <summary>Obtém os tipos dos objetos na matriz especificada.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa os tipos de elementos correspondentes em <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetTypeArray%2A> método para listar os tipos dos elementos de uma matriz.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos elementos no <paramref name="args" /> são <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Os inicializadores de classe são invocados e pelo menos um gera uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo cujo código de tipo subjacente será obtido.</param>
        <summary>Obtém o código de tipo subjacente do <see cref="T:System.Type" /> especificado.</summary>
        <returns>O código do tipo subjacente ou <see cref="F:System.TypeCode.Empty" /> se <paramref name="type" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você herda <xref:System.Type>, você pode alterar o comportamento desse método, substituindo o <xref:System.Type.GetTypeCodeImpl%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como o <xref:System.TypeCode> enumeração pode ser usada. Em um bloco de decisão dentro de `WriteObjectInfo` método, o <xref:System.TypeCode> de um <xref:System.Object> parâmetro é examinado e uma mensagem apropriada é gravada no console.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código de tipo subjacente desta instância <see cref="T:System.Type" />.</summary>
        <returns>O código de tipo do tipo subjacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fornece a implementação para o `static` (em c#) ou `Shared` (no Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> método. Quando você herda <xref:System.Type>, você pode substituir esse método para fornecer sua própria implementação de <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém o tipo associado ao identificador de classe especificado (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <summary>Obtém o tipo associado ao identificador de classe especificado (CLSID).</summary>
        <returns><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o`__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Consulte o exemplo para obter uma ilustração.  
  
 O <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> sobrecarga ignora qualquer exceção que pode ocorrer ao instanciar um <xref:System.Type> objeto com base no `clsid` argumento. Observe que nenhuma exceção é lançada se `clsid` não for encontrado no registro.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word. Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="throwOnError"><see langword="true" /> para lançar qualquer exceção que ocorra.  
  
- ou - 
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao CLSID (identificador de classe) especificado, especificando se deverá gerar uma exceção se ocorrer um erro ao carregar o tipo.</summary>
        <returns><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Consulte o exemplo para obter uma ilustração.  
  
 Exceções, como <xref:System.OutOfMemoryException> será gerada ao especificar `true` para `throwOnError`, mas não falhará para CLSIDs cancelados.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word. Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método. Uma exceção é lançada se ocorrer um erro ao carregar o tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <summary>Obtém o tipo associado ao CLSID (identificador de classe) especificado do servidor especificado.</summary>
        <returns><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com. Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <param name="throwOnError"><see langword="true" /> para lançar qualquer exceção que ocorra.  
  
- ou - 
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao CLSID (identificador de classe) especificado do servidor especificado, determinando se uma exceção deverá ser gerada se ocorrer um erro durante o carregamento do tipo.</summary>
        <returns><see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia a objetos COM não gerenciados de aplicativos do .NET Framework quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor da <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acesso de associação tardia para COM objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando uma instância de um objeto COM não gerenciado de sua CLSID é um processo em duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Exceções, como <xref:System.OutOfMemoryException> será gerada ao especificar `true` para `throwOnError`, mas não falhará para CLSIDs cancelados.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com. Em seguida, cria uma instância do tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e fecha-lo chamando o [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método. Uma exceção é lançada se ocorrer um erro ao carregar o tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Esse método se destina para uso ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> método retorna um <see cref="T:System.Type" /> objeto que corresponde ao GUID de um determinado objeto gerenciado, você não poderá usar esse <see cref="T:System.Type" /> objeto para criar uma instância do tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como o exemplo a seguir programas.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">O objeto que se refere ao tipo.</param>
        <summary>Obtém o tipo referenciado pelo identificador do tipo especificado.</summary>
        <returns>O tipo referenciado pelo <see cref="T:System.RuntimeTypeHandle" /> especificado ou <see langword="null" />, se a propriedade <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.GetTypeFromHandle%2A> método para obter uma <xref:System.Type> do objeto de uma <xref:System.RuntimeTypeHandle> fornecidos pelo <xref:System.Type.GetTypeHandle%2A> método.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém o tipo associado com o ProgID (identificador programático) especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">O ProgID do tipo a ser obtido.</param>
        <summary>Obtém o tipo associado ao identificador de programa (ProgID) especificado, retornando null se for encontrado um erro ao carregar o <see cref="T:System.Type" />.</summary>
        <returns>O tipo associado ao ProgID especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo for associado a ele; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. ProgIDs não são usados no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">O ProgID do tipo a ser obtido.</param>
        <param name="throwOnError"><see langword="true" /> para lançar qualquer exceção que ocorra.  
  
- ou - 
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao ProgID (identificador de programa) especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro ao carregar o tipo.</summary>
        <returns>O tipo associado ao ProgID (identificador de programa) especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo estiver associado a ele; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um ProgID, especificando se é necessário lançar uma exceção se o ProgID é inválido. O exemplo, em seguida, exibe ClassID relacionado a ProgID, juntamente com qualquer mensagem de exceção aplicável.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">O ProgID especificado não está registrado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">O progID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <summary>Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, retornando nulo caso seja encontrado algum erro ao carregar o tipo.</summary>
        <returns>O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor. O exemplo exibe ClassID relacionado como o ProgID ou gera uma exceção se o ProgID ou o nome do servidor é inválido.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">A progID do <see cref="T:System.Type" /> a ser obtida.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <param name="throwOnError"><see langword="true" /> para lançar qualquer exceção que ocorra.  
  
- ou - 
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro durante o carregamento do tipo.</summary>
        <returns>O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. Identificações de programa não são usadas no Microsoft .NET Framework porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor. O exemplo, em seguida, exibe o ClassID relacionado a ProgID, especificando se é necessário lançar uma exceção se o ProgID ou o nome do servidor é inválido.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">A progID especificada não está registrada.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto para o qual o identificador de tipo será obtido.</param>
        <summary>Obtém o identificador para o <see cref="T:System.Type" /> de um objeto especificado.</summary>
        <returns>O identificador para o <see cref="T:System.Type" /> do <see cref="T:System.Object" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.  
  
   
  
## Examples  
 O exemplo a seguir define a classe `MyClass1`, obtém uma instância dele e recupera o identificador de tempo de execução do objeto.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o GUID associado ao <see cref="T:System.Type" />.</summary>
        <value>O GUID associado ao <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um GUID é associado a um tipo usando o <xref:System.Runtime.InteropServices.GuidAttribute> atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria a classe `MyClass1` com um método público, cria um `Type` objeto correspondente `MyClass1`e obtém os <xref:System.Guid> estrutura usando o `GUID` propriedade do `Type` classe.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual abrange ou se refere a outro tipo; ou seja, se o <see cref="T:System.Type" /> atual é uma matriz, um ponteiro ou é passado por referência.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, Type.GetType("Int32[]"). Retorna HasElementType `true`, mas Type.GetType("Int32"). Retorna HasElementType `false`. Também retorna HasElementType `true` para Int32 "*" e "Int32 &".  
  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir retorna `true` ou `false` dependendo se o objeto é uma matriz, um tipo de referência ou um ponteiro.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.HasElementType" /> e determina se o <see cref="T:System.Type" /> atual abrange ou se refere a outro tipo, ou seja, se o <see cref="T:System.Type" /> atual é uma matriz, um ponteiro ou é passado por referência.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, Type.GetType("Int32[]"). Retorna HasElementTypeImpl `true`, mas Type.GetType("Int32"). Retorna HasElementTypeImpl `false`. Também retorna HasElementTypeImpl `true` para Int32 "*" e "Int32 &".  
  
   
  
## Examples  
 O exemplo a seguir define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método. Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca um membro específico do <see cref="T:System.Type" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
- ou - 
Uma cadeia de caracteres vazia ("") para invocar o membro padrão.  
  
- ou - 
Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <summary>Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos especificada.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:  
  
-   `CreateInstance` para invocar um construtor. `name` é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField` Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField` Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty` Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty` Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será invocado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.  
  
 Depois que o método é selecionado, ele é invocado. Acessibilidade é verificada nesse momento. A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 Restrições de acesso são ignoradas em código totalmente confiável; ou seja, construtores particulares, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String`, você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Se F é um `String[]`, você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 que inicializará o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]". Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod". Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome. Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir usa `InvokeMember` para acessar membros de um tipo.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
- ou - 
 <paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
- ou - 
Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
- ou - 
Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
- ou - 
O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.NotSupportedException">No momento, o .NET Compact Framework não dá suporte a esse método.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
- ou - 
Uma cadeia de caracteres vazia ("") para invocar o membro padrão.  
  
- ou - 
Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <param name="culture">O objeto que representa a localidade de globalização a ser usada, que pode ser necessária para realizar conversões específicas de localidade, como converter uma <see cref="T:System.String" /> numérica em uma <see cref="T:System.Double" />.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
        <summary>Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos e cultura especificadas.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Globalization.CultureInfo> (o parâmetro `culture` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `culture`.  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:  
  
-   `CreateInstance` para invocar um construtor. `name` é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField` Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField` Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty` Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty` Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será invocado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.  
  
 Depois que o método é selecionado, ele é invocado. Acessibilidade é verificada nesse momento. A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 Restrições de acesso são ignoradas em código totalmente confiável; ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocadas por meio de reflexão, sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String` você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Se F é um `String[]`, você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 que inicializará o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]". Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod". Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome. Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
- ou - 
 <paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
- ou - 
Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
- ou - 
Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
- ou - 
O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
- ou - 
Uma cadeia de caracteres vazia ("") para invocar o membro padrão.  
  
- ou - 
Para membros <see langword="IDispatch" />, uma cadeia de caracteres que representa a DispID, por exemplo "[DispID=3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser um dos <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de pesquisa for omitido, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> serão usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
- ou - 
Uma referência nula (Nothing no Visual Basic) para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que a definição explícita de um objeto <see cref="T:System.Reflection.Binder" /> poderá ser necessária para invocar com êxito sobrecargas de método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <param name="modifiers">Uma matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representam os atributos associados ao elemento correspondente na matriz <paramref name="args" />. Os atributos associados ao parâmetro são armazenados na assinatura do membro.  
  
O associador padrão processa este parâmetro somente ao chamar um componente COM.</param>
        <param name="culture">O objeto <see cref="T:System.Globalization.CultureInfo" /> que representa a localidade de globalização a ser usada, que pode ser necessária para realizar conversões específicas de localidade, como converter uma String numérica em uma Double.  
  
- ou - 
Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
        <param name="namedParameters">Uma matriz que contém os nomes dos parâmetros para os quais os valores na matriz <paramref name="args" /> são passados.</param>
        <summary>Quando substituído em uma classe derivada, invoca o membro especificado usando as restrições de associação especificadas e correspondendo a cultura, modificadores e lista de argumentos especificados.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` chama um membro do construtor ou um método, obtém ou define um membro de propriedade, obtém ou define um membro de campo de dados, ou obtém ou define um elemento de um membro da matriz.  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DISPID=3 = # #]". Por exemplo, se o DispID de MyComMethod for 3, você pode especificar a cadeia de caracteres "[DISPID=3 = 3]", em vez de "MyComMethod". Invocar um membro DISPID é mais rápido do que pesquisar o membro por nome. Em cenários de agregação complexa, o DispID, às vezes, é a única maneira de invocar o membro desejado.  
  
 Embora o associador padrão não processa <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (o `modifiers` e `culture` parâmetros), você pode usar o resumo <xref:System.Reflection.Binder?displayProperty=nameWithType> classe para gravar um associador personalizado que processam `modifiers` e `culture`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Cada parâmetro na matriz `namedParameters` obtém o valor no elemento correspondente na matriz `args`. Se o comprimento de `args` for maior que o de `namedParameters`, os valores de argumento restantes serão passados em ordem.  
  
 O `namedParameters` matriz pode ser usada para alterar a ordem dos argumentos em uma matriz de entrada. Por exemplo, considerando o método `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` no Visual Basic) e a matriz de entrada `{ 42, "x" }`, a matriz de entrada pode ser passada inalterada para `args` se a matriz `{ "b", "a" }` for fornecido para `namedParameters`.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de invocação podem ser usados para indicar qual ação tomar com o membro:  
  
-   `CreateInstance` para invocar um construtor. `name` é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod` para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField` Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField` Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty` Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty` Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será invocado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos na `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos no associador.  
  
 Depois que o método é selecionado, ele é invocado. Acessibilidade é verificada nesse momento. A pesquisa pode controlar qual conjunto de métodos são pesquisados com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método da <xref:System.Reflection.Binder> classe é responsável por selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 `InvokeMember` pode ser usado para invocar métodos com parâmetros que têm valores padrão. Para vincular a esses métodos, reflexão requer <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> seja especificado. Para um parâmetro que tem um valor padrão, você pode fornecer um valor diferente, ou fornecer <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> para usar o valor padrão.  
  
 Por exemplo, considere um método como MyMethod (int x, y float = 2.0). Para invocar esse método com somente o primeiro argumento MyMethod(4), passar um dos sinalizadores de associação acima e passar dois argumentos, ou seja, 4 para o primeiro argumento e `Missing.Value` para o segundo argumento. A menos que você use `Missing.Value`, você não pode omitir parâmetros opcionais com o `Invoke` método. Se você deve fazer isso, use `InvokeMember` em vez disso.  
  
 Restrições de acesso são ignoradas em código totalmente confiável; ou seja, construtores particulares, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública chamado F na classe C e F é um `String`, você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Se F é um `String[]`, você pode usar código como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 que inicializará o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Isso irá alterar a cadeia de caracteres "z" na matriz que contém os F para a cadeia de caracteres "b".  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizar e se o conjunto de concessões dos membros não públicos é restrito para o chamador conceder o conjunto ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> não contém <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.  
  
- ou - 
 <paramref name="invokeAttr" /> não é um atributo <see cref="T:System.Reflection.BindingFlags" /> válido.  
  
- ou - 
 <paramref name="invokeAttr" /> não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetField" /> e <see langword="SetField" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
- ou - 
 <paramref name="invokeAttr" /> contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
- ou - 
A matriz de parâmetros nomeados é maior que a matriz de argumentos.  
  
- ou - 
Esse método é chamado em um objeto COM e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
- ou - 
Uma das matrizes de parâmetro nomeadas contém uma cadeia de caracteres que é <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
- ou - 
Não foi possível encontrar nenhum membro com os nomes de argumentos fornecidos em <paramref name="namedParameters" />.  
  
- ou - 
O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é abstrato e deve ser substituído.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for abstrato; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsAbstract%2A> propriedade retorna `true` nos seguintes casos:  
  
-   O tipo atual for abstrato; ou seja, ele não pode ser instanciado, mas só pode servir como a classe base para classes derivadas. No c#, as classes abstratas são marcadas com o [abstrata](~/docs/csharp/language-reference/keywords/abstract.md) palavra-chave; no Visual Basic, são marcados com o [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) palavra-chave.  
  
-   O tipo atual é uma interface.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Type> objetos que representam os seguintes tipos: contém retornos de tipo `true` se o objeto especificado for `abstract`; caso contrário, ele retorna `false`.  
  
-   `AbstractClass`, uma classe abstrata (uma classe marcada como `abstract` em c# e `MustInherit` no Visual Basic).  
  
-   `DerivedClass`, uma classe que herda de `AbstractClass`.  
  
-   `SingleClass`, uma classe não herdável. Ele é definido como `sealed` em c# e `NotInheritable` no Visual Basic.  
  
-   `ITypeInfo`, uma interface.  
  
-   `ImplementingClass`, uma classe que implementa o `ITypeInfo` interface.  
  
 O método retornará `true` apenas para `AbstractClass`, a classe abstrata, e `ITypeInfo`, a interface.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Se o atual <xref:System.Type> representa um tipo genérico, essa propriedade se refere à definição de tipo genérico do qual o tipo foi criado. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir obtém as informações de campo e verifica o `AnsiClass` atributo.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo é uma matriz.</summary>
        <value><see langword="true" /> se o tipo atual for uma matriz; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsArray%2A> propriedade retorna `false` para o <xref:System.Array> classe. Ele também retorna `false` se a instância atual é um <xref:System.Type> objeto que representa um tipo de coleção ou uma interface projetada para trabalhar com coleções, como <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Para verificar se há uma matriz, use códigos como:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Se o tipo atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Type.IsArray%2A> propriedade.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsArray" /> e determina se o <see cref="T:System.Type" /> é uma matriz.</summary>
        <returns><see langword="true" /> se <see cref="T:System.Type" /> for uma matriz. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma instância das <xref:System.Array> deve retornar a classe `false` porque ele é um objeto, não é uma matriz.  
  
   
  
## Examples  
 O exemplo a seguir substitui o `IsArrayImpl` método no `MyTypeDelegator` classe verifica se uma variável é uma matriz e exibe o resultado.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">O tipo a ser comparado com o tipo atual.</param>
        <summary>Determina se uma instância de um tipo especificado pode ser atribuída a uma instância do tipo atual.</summary>
        <returns><see langword="true" /> se qualquer uma das seguintes condições for verdadeira: 
-   <paramref name="c" /> e a instância atual representam o mesmo tipo.  
  
-   <paramref name="c" /> é derivado direta ou indiretamente da instância atual. <paramref name="c" /> será derivado diretamente da instância atual se herdar da instância atual; <paramref name="c" /> será derivado indiretamente da instância atual se herdar de uma sucessão de uma ou mais classes que herdam da instância atual.  
  
-   A instância atual é uma interface implementada por <paramref name="c" />.  
  
-   <paramref name="c" /> é um parâmetro de tipo genérico, e a instância atual representa uma das restrições de <paramref name="c" />.  
  
No exemplo a seguir, a instância atual é um objeto <see cref="T:System.Type" /> que representa a classe <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> é um tipo genérico cujo parâmetro de tipo genérico deve ser do tipo <see cref="T:System.IO.Stream" />. Passar o parâmetro de tipo genérico para o <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indica que uma instância do parâmetro de tipo genérico pode ser atribuída a um objeto <see cref="T:System.IO.Stream" />.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> representa um tipo de valor e a instância atual representa <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> no Visual Basic).  
  
 <see langword="false" /> se nenhuma dessas condições for verdadeira, ou se <paramref name="c" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsAssignableFrom%2A> método pode ser usado para determinar se uma instância de `c` pode ser atribuído a uma instância do tipo atual, o método é mais útil quando você estiver tratando objetos cujos tipos não são conhecidos em tempo de design e permite condicional atribuição, como o exemplo a seguir mostra.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Esse método, assim, garante que uma linha de código, como a seguir executará em tempo de execução sem gerar uma <xref:System.InvalidCastException> exceção ou uma exceção semelhante:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Este método pode ser substituído por uma classe derivada.  
  
> [!NOTE]
>  Uma definição de tipo genérico não é atribuível de um tipo construído fechado. Ou seja, você não é possível atribuir o tipo construído fechado `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) a uma variável do tipo `MyGenericList<T>`.  
  
 Se o `c` parâmetro é do tipo <xref:System.Reflection.Emit.TypeBuilder>, o resultado é baseado no tipo que deve ser criada. O exemplo de código a seguir demonstra isso usando um tipo interno chamado `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `IsAssignableFrom` usando o método definido em classes, matrizes de inteiros e genéricos.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são apresentados automaticamente pelo Common Language Runtime.</summary>
        <value><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valor de enumeração para o tipo, para permitir que o tempo de execução determinar a maneira apropriada para dispor a classe.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>.`  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do tipo e exibe o <xref:System.Type.IsAutoLayout%2A> propriedade.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadados e componentes autodescritivos</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aprovado por referência.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter o tipo real, desreferenciar o tipo que foi passado por referência e, em seguida, chamar <xref:System.Type.GetElementType%2A> nesse tipo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso do `IsByRef` propriedade para verificar se um tipo especificado é passado por referência. O exemplo define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método. Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsByRef" /> e determina se o <see cref="T:System.Type" /> é passado por referência.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é uma classe ou um delegado; ou seja, não um tipo de valor ou interface.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for uma classe; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna `true` para classes, bem como delegados. Ele retorna `false` para tipos de valor (para estruturas e enumerações), mesmo se eles são boxed.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `true`. Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna `true` se a definição de tipo genérico é uma definição de classe; ou seja, ele não define uma interface ou um tipo de valor.  
  
> [!NOTE]
>  Essa propriedade retornará `true` para `Type` instâncias que representam as <xref:System.Enum> e <xref:System.ValueType> classes. Essas duas classes são tipos de base para enumerações e tipos de valor, respectivamente, mas eles não são tipos de valor em si ou enumerações. Para obter mais informações, consulte o <xref:System.Type.IsValueType%2A> e <xref:System.Type.IsEnum%2A> propriedades.  
  
 O <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor de enumeração distingue uma declaração de tipo como classe ou interface. No entanto, as classes e tipos de valor são marcados com o <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atributo. Se você recuperar o valor da propriedade Attributes e uso de um tipo de <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor para determinar se um tipo é uma classe em vez de um tipo de valor, você também deve chamar o <xref:System.Type.IsValueType%2A> propriedade. O exemplo para o <xref:System.Reflection.TypeAttributes> enumeração contém informações adicionais, bem como anexample.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um tipo e indica se o tipo é uma classe.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um objeto COM.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna `false` para interfaces de COM, porque eles não são objetos. Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.  
  
 Você também pode carregar uma classe COM e obter um `Type` objeto dessa classe COM usando o [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int`> (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsCOMObject" /> e determina se o <see cref="T:System.Type" /> é um objeto COM.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna `false` para interfaces de COM, porque eles não são objetos. Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído. Você pode criar instâncias de um tipo genérico construído.</summary>
        <value><see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um tipo genérico construído teve tipos explícitos fornecidos para todos os seus parâmetros de tipo genérico. Ele também é chamado como um tipo genérico fechado.  
  
 Quando essa propriedade é `true`, você pode criar instâncias do tipo atual; quando ele for `false`, não é possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> puder ser hospedado em um contexto; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um contexto intercepta as chamadas para os membros da classe e impõe políticas que são aplicadas à classe, como sincronização. Para obter mais informações sobre os contextos de comunicação remota, consulte <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe. Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa a propriedade <see cref="P:System.Type.IsContextful" /> e determina se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> puder ser hospedado em um contexto; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Um contexto intercepta as chamadas para os membros da classe e impor políticas que são aplicadas à classe, como sincronização.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso do `IsContextfulImpl` método.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma enumeração.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> atual representar uma enumeração; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retornará `true` para uma enumeração, mas não para o <xref:System.Enum> próprio tipo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `IsEnum` propriedade.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser testado.</param>
        <summary>Retorna um valor que indica se o valor especificado existe no tipo de enumeração atual.</summary>
        <returns><see langword="true" /> se o valor especificado for um membro do tipo de enumeração atual; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> é de um tipo que não pode ser o tipo subjacente de uma enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">A equivalência do tipo de COM é testado em relação ao tipo atual.</param>
        <summary>Determina se dois tipos COM têm a mesma identidade e são elegíveis para equivalência de tipo.</summary>
        <returns><see langword="true" /> se os tipos COM forem equivalentes; caso contrário, <see langword="false" />. Esse método também retornará <see langword="false" />, se for um tipo for um assembly que é carregado para execução e o outro está em um assembly que é carregado no contexto de somente reflexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o common language runtime dá suporte à inserção de informações de tipo para tipos COM diretamente em assemblies gerenciados, em vez de exigir que os assemblies gerenciados obter informações de tipo para tipos COM de interoperabilidade assemblies. Como as informações de tipo inserido incluem somente os tipos e os membros que são realmente usados por um assembly gerenciado, dois assemblies gerenciados podem ter exibições muito diferentes do mesmo tipo COM. Cada assembly gerenciado tem um objeto <xref:System.Type> diferente para representar sua exibição do tipo COM. O Common Language Runtime dá suporte à equivalência de tipo entre essas exibições diferentes para interfaces, estruturas, enumerações e representantes.  
  
 Equivalência de tipo significa que um objeto COM que é passado de um assembly gerenciado para outro pode ser convertido no tipo gerenciado apropriado no assembly receptor. O <xref:System.Type.IsEquivalentTo%2A> método permite que um assembly determinar se um objeto COM obtido de outro assembly tem a mesma identidade COM um dos tipos de interoperabilidade do primeiro assembly próprio inserido e, portanto, pode ser convertido para esse tipo.  
  
 Para obter mais informações, consulte [equivalência de tipo e tipos de interoperabilidade inseridos](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são apresentados em deslocamentos explicitamente especificados.</summary>
        <value><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que os deslocamentos na qual iniciar os campos são especificados explicitamente.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um tipo e exibe o valor da sua <xref:System.Type.IsExplicitLayout%2A> propriedade. Ele usa o `MySystemTime` classe, que também está no código de exemplo para <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadados e componentes autodescritivos</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo na definição de um tipo ou método genérico.</summary>
        <value><see langword="true" /> se o objeto <see cref="T:System.Type" /> representar um parâmetro de tipo de uma definição de tipo genérico ou de método genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> objetos que representam os parâmetros de tipo genérico podem ser obtidos chamando o <xref:System.Type.GetGenericArguments%2A> método de um <xref:System.Type> objeto que representa uma definição de tipo genérico, ou o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método de um <xref:System.Reflection.MethodInfo> objeto que representa um método genérico definição.  
  
-   Para um tipo genérico ou definição de método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para cada elemento da matriz resultante.  
  
-   Para um tipo construído fechado ou método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `false` para cada elemento da matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método.  
  
-   Para um tipo construído aberto ou método, alguns elementos da matriz podem ser tipos específicos e outras podem ser parâmetros de tipo. <xref:System.Type.IsGenericParameter%2A> Retorna `false` para os tipos e `true` para os parâmetros de tipo. O exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade demonstra uma classe genérica com uma mistura de tipos e parâmetros de tipo.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.IsGenericParameter%2A> propriedade a ser testada para parâmetros de tipo genérico em um tipo genérico.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é um tipo genérico.</summary>
        <value><see langword="true" /> Se o tipo atual é um tipo genérico; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.IsGenericType%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo genérico. Use o <xref:System.Type.ContainsGenericParameters%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo construído aberto ou um tipo construído fechado.  
  
> [!NOTE]
>  O <xref:System.Type.IsGenericType%2A> propriedade retorna `false` se o tipo imediato não for genérico. Por exemplo, uma matriz cujos elementos são do tipo `A<int>` (`A(Of Integer)` no Visual Basic) é um tipo genérico, não em si.  
  
 A tabela a seguir resume as condições invariáveis para termos comuns usados na reflexão genérica.  
  
|Termo|Constante|  
|----------|---------------|  
|definição de tipo genérico|A propriedade <xref:System.Type.IsGenericTypeDefinition%2A> é `true`.<br /><br /> Define um tipo genérico. Um tipo construído é criado chamando o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> objeto que representa uma definição de tipo genérico e especificando uma matriz de argumentos de tipo.<br /><br /> <xref:System.Type.MakeGenericType%2A> pode ser chamado apenas em definições de tipo genérico.<br /><br /> Qualquer definição de tipo genérico é um tipo genérico (a <xref:System.Type.IsGenericType%2A> é de propriedade `true`), mas o inverso não é verdadeiro.|  
|tipo genérico|A propriedade <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> Pode ser uma definição de tipo genérico, um tipo construído aberto ou um tipo construído fechado.<br /><br /> Observe que uma matriz cujo tipo de elemento de tipo é genérico não é propriamente um tipo genérico. O mesmo é verdadeiro para um <xref:System.Type> objeto que representa um ponteiro para um tipo genérico.|  
|Abra o tipo construído|A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.<br /><br /> Os exemplos são um tipo genérico que tem não atribuídos a parâmetros de tipo, um tipo que está aninhado em uma definição de tipo genérico ou em um tipo construído aberto ou um tipo genérico que tem um argumento de tipo para o qual o <xref:System.Type.ContainsGenericParameters%2A> é de propriedade `true`.<br /><br /> Não é possível criar uma instância de um tipo construído aberto.<br /><br /> Observe que os tipos construídos abertos não todos são genéricos. Por exemplo, uma matriz cujo tipo de elemento é uma definição de tipo genérico não é genérica e um ponteiro para um tipo construído aberto não é genérico.|  
|tipo construído fechado|A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `false`.<br /><br /> Quando o examinado recursivamente, o tipo não tem nenhum parâmetro genérico não atribuído.|  
|parâmetro de tipo genérico|A propriedade <xref:System.Type.IsGenericParameter%2A> é `true`.<br /><br /> A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.<br /><br /> Em uma definição de tipo genérico, um espaço reservado para um tipo que será atribuído posteriormente.|  
|argumento de tipo genérico|Pode ser qualquer tipo, incluindo um parâmetro de tipo genérico.<br /><br /> Argumentos de tipo são especificados como uma matriz de <xref:System.Type> os objetos passados para o <xref:System.Type.MakeGenericType%2A> método durante a criação de um tipo genérico construído. Se as instâncias do tipo resultante devem ser criados, o <xref:System.Type.ContainsGenericParameters%2A> propriedade deve ser `false` para todos os argumentos de tipo.|  
  
 O exemplo de código e a tabela a seguir ilustram alguns desses termos e as invariáveis. O `Derived` classe é de particular interesse porque seu tipo base é um tipo construído que tem uma mistura de tipos e parâmetros de tipo na lista de argumentos de tipo.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 A tabela a seguir exemplos de mostra que usam e de compilação nas classes `Base`, `Derived`, e `G`. Quando o código C++ e c# é o mesmo, é mostrada apenas uma entrada.  
  
|Exemplo|Invariáveis|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Para o tipo de variável `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> está `false` porque `d` é uma matriz.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `false`.|  
|`T`, `U`, e `V` (em qualquer lugar que eles aparecem)|<xref:System.Type.IsGenericParameter%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> é `false` porque não há nenhuma maneira de restringir um parâmetro de tipo para tipos genéricos.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> está `true` porque `T`, `U`, e `V` são parâmetros de tipo genérico. Isso não significa nada sobre os argumentos de tipo que são atribuídos a eles mais tarde.|  
|O tipo de campo `F`|<xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> está `false` porque um tipo foi designado para o parâmetro de tipo `G`. Observe que isso é equivalente a ter chamado o <xref:System.Type.MakeGenericType%2A> método.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> está `true` porque o tipo de campo `F` tem um argumento de tipo que é um tipo construído aberto. O tipo construído é aberto porque seu argumento de tipo (ou seja, `Base`) é uma definição de tipo genérico. Isso ilustra a natureza recursiva do <xref:System.Type.IsGenericType%2A> propriedade.|  
|A classe aninhada `Nested`|<xref:System.Type.IsGenericType%2A> está `true`, mesmo que o `Nested` classe não tem nenhum parâmetro de tipo genérico de por conta própria, porque ela está aninhada em um tipo genérico.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `true`. Ou seja, você pode chamar o <xref:System.Type.MakeGenericType%2A> método e fornecer o parâmetro de tipo do tipo delimitador, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> está `true` porque o tipo de circunscrição, `Derived`, tem parâmetros de tipo genérico. Isso ilustra a natureza recursiva do <xref:System.Type.ContainsGenericParameters%2A> propriedade.|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor da <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, e <xref:System.Type.ContainsGenericParameters%2A> propriedades para os tipos descritos na seção comentários. Para obter explicações sobre os valores de propriedade, consulte a tabela que acompanha este artigo nos comentários.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</summary>
        <value><see langword="true" /> se o objeto <see cref="T:System.Type" /> representar uma definição de tipo genérico, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma definição de tipo genérico é um modelo do qual outros tipos podem ser construídos. Por exemplo, de definição de tipo genérico `G<T>` (expressa na sintaxe c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode construir e criar uma instância do tipo `G<int>` (`G(Of Integer)` no Visual Basic), chamando o <xref:System.Type.MakeGenericType%2A> método com uma lista de argumento genérico que contém o <xref:System.Int32> tipo. Considerando um <xref:System.Type> construída de objeto que representa esse tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método obtém a definição de tipo genérico volta novamente.  
  
 Use o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade para determinar se você pode criar novos tipos do tipo atual. Se o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade retorna `true`, você pode chamar o <xref:System.Type.MakeGenericType%2A> método para criar novos tipos genéricos.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir exibe informações sobre um tipo, incluindo se ele é uma definição de tipo genérico ou não. Informações são exibidas para um tipo construído, sua definição de tipo genérico e um tipo comum.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> tem um atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> aplicado, indicando que ele foi importado de uma biblioteca de tipos COM.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> tem uma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo `MyGenericType<T>.`  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto a ser comparado com o tipo atual.</param>
        <summary>Determina se o objeto especificado é uma instância do <see cref="T:System.Type" /> atual.</summary>
        <returns><see langword="true" /> se o <see langword="Type" /> atual estiver na hierarquia de herança do objeto representado pelo <paramref name="o" /> ou se o <see langword="Type" /> atual for uma interface implementada por <paramref name="o" />. <see langword="false" /> se nenhuma dessas condições for verdadeira, se <paramref name="o" /> for <see langword="null" /> ou se o <see langword="Type" /> atual for um tipo genérico aberto (ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
> [!NOTE]
>  Um tipo construído não é uma instância de sua definição de tipo genérico. Ou seja, `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) não é uma instância de `MyGenericList<T>` (`MyGenericList(Of T)` no Visual Basic).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do método `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é uma interface, ou seja, não é uma classe ou um tipo de valor.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> é uma interface; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue uma declaração de tipo como tipo de classe, interface ou valor.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma interface, verifica o tipo de interface e indica se uma classe tem o `IsInterface` conjunto de propriedades.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são apresentados em sequência, na ordem em que foram definidos ou emitidos para os metadados.</summary>
        <value><see langword="true" /> Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos na memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar a <xref:System.Runtime.InteropServices.StructLayoutAttribute> do atributo com o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que o layout é sequencial.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Para obter mais informações, consulte a seção 9.1.2 da especificação para a documentação do Common Language Infrastructure (CLI), "partição II: Definição de metadados e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de uma classe para o qual o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeração na <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe tiver sido definida, verifica o <xref:System.Type.IsLayoutSequential%2A> propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadados e componentes autodescritivos</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se é realizado marshal no <see cref="T:System.Type" /> por referência.</summary>
        <value><see langword="true" /> se for realizado marshal no <see cref="T:System.Type" /> por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe. Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa a propriedade <see cref="P:System.Type.IsMarshalByRef" /> e determina se é realizado marshal no <see cref="T:System.Type" /> por referência.</summary>
        <returns><see langword="true" /> se for realizado marshal no <see cref="T:System.Type" /> por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
   
  
## Examples  
 O exemplo a seguir determina se o tipo fornecido é empacotado por referência e exibe o resultado.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto atual <see cref="T:System.Type" /> representa um tipo cuja definição está aninhada dentro da definição de outro tipo.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> está aninhado dentro de outro tipo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsNested%2A> propriedade retorna `true` para todos os tipos, independentemente da visibilidade aninhados. Para testar o aninhamento e visibilidade ao mesmo tempo, use as propriedades relacionadas <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  O <xref:System.Reflection.TypeAttributes.VisibilityMask> membro de enumeração seleciona os atributos de visibilidade para um tipo.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visível somente dentro de seu próprio assembly.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visível somente dentro de seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visíveis somente para classes que pertencem à sua própria família e ao seu próprio assembly.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visíveis somente para classes que pertencem à sua própria família e seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
> [!NOTE]
>  As linguagens c# e Visual Basic não têm a semântica que permitem que você defina um tipo aninhado que é visível somente para tipos protegidos em seu próprio assembly. `protected internal` visibilidade em c# e `Protected Friend` visibilidade no Visual Basic define um tipo aninhado que é visível para tipos protegidos e a tipos no mesmo assembly.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos do mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visível somente dentro de sua própria família.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visível somente dentro de sua própria família; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos da exato mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e visíveis somente para classes que pertençam à sua própria família ou ao seu próprio assembly.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> aninhado e visíveis somente para classes que pertencem à sua própria família ou ao seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a visibilidade de um tipo é `protected internal` em c# ou `Protected Friend` no Visual Basic, o <xref:System.Type.IsNestedFamORAssem%2A> propriedade retorna `true`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos da exato mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhado e declarado privado.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> é aninhado e declarado privado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se uma classe é aninhada e declarada pública.</summary>
        <value><see langword="true" /> Se a classe aninhada e declarada pública; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Ele então recupera o valor de um número de relacionadas à visibilidade <xref:System.Type> propriedades para o tipo de pai e cada um dos seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> não está declarado como público.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> não está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use essa propriedade com os tipos aninhados; Use o <xref:System.Type.IsNestedPublic%2A> propriedade em vez disso.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `false`.  
  
   
  
## Examples  
 Este usa os de exemplo `IsNotPublic` propriedade para obter a visibilidade do tipo.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir demonstra por que não é possível usar `IsPublic` e `IsNotPublic` para classes aninhadas.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Para classes aninhadas, ignorar os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas aos resultados de `IsNestedPublic` e `IsNestedPrivate`. A saída de reflexão para este fragmento de código seria da seguinte maneira:  
  
|Classe|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|Um|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|FALSE|FALSE|TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um ponteiro.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso do `IsPointer` propriedade.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsPointer" /> e determina se o <see cref="T:System.Type" /> é um ponteiro.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um dos tipos primitivos.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 São os tipos primitivos <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades do <xref:System.Type> classe. Ele verifica se o tipo determinado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsPrimitive" /> e determina se o <see cref="T:System.Type" /> é um dos tipos primitivos.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 São os tipos primitivos <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
   
  
## Examples  
 O exemplo a seguir determina se o tipo fornecido é um tipo primitivo e exibe o resultado.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado como público.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use com tipos aninhados; Use <xref:System.Type.IsNestedPublic%2A> em vez disso.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do `MyTestClass`, verifica o `IsPublic` propriedade e exibe o resultado.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Para classes aninhadas, ignorar os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas aos resultados de <xref:System.Type.IsNestedPublic%2A> e <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado selado.</summary>
        <value><see langword="true" /> Se o <see cref="T:System.Type" /> é declarado selado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um `sealed` classe procura o `IsSealed` propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é crítico para segurança ou crítico para segurança e disponível no código transparente no nível de confiança atual e, portanto, pode realizar operações críticas.</summary>
        <value><see langword="true" /> Se o tipo atual é crítico para segurança ou segurança-seguro-crítica no nível de confiança atual; <see langword="false" /> se for transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações na segurança do .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo é crítico para segurança e disponível no código transparente no nível de confiança atual, ou seja, se ele pode realizar operações críticas e ser acessado por código transparente.</summary>
        <value><see langword="true" /> Se o tipo atual é segurança-seguro-crítica no nível de confiança atual; <see langword="false" /> se ele é crítico para segurança ou transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações na segurança do .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica que se o tipo atual é transparente no nível de confiança atual e, portanto, não pode realizar operações críticas.</summary>
        <value><see langword="true" /> Se o tipo é transparente de segurança no nível de confiança atual; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade retornará `true`, o <xref:System.Type.IsSecurityCritical%2A> e <xref:System.Type.IsSecuritySafeCritical%2A> retornam propriedades `false`.  
  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR). Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações na segurança do .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é serializável.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for serializável; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Tipos que são definidos no .NET Standard não são marcados com <xref:System.SerializableAttribute>. Em vez disso, cada implementação do .NET determina se um tipo é serializável. Em tempo de execução, você pode usar o <xref:System.Type.IsSerializable%2A> propriedade para determinar se essa implementação dá suporte à serialização de uma instância do tipo. Para obter mais informações e um exemplo, consulte [como determinar se um objeto .NET padrão é serializável](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do `MyTestClass` classe, define o atributo [Serializable] e verifica o `IsSerializable` propriedade `true` ou `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo tem um nome que exige tratamento especial.</summary>
        <value><see langword="true" /> se o tipo tiver um nome que exige tratamento especial; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes que começam com ou contenham um caractere de sublinhado (_), os acessadores de propriedade e métodos de sobrecarga de operador são exemplos de tipos que podem exigir tratamento especial por alguns compiladores.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">O tipo a ser comparado com o tipo atual.</param>
        <summary>Determina se o <see cref="T:System.Type" /> atual deriva do <see cref="T:System.Type" /> especificado.</summary>
        <returns><see langword="true" /> se o <see langword="Type" /> atual derivar de <paramref name="c" />; caso contrário, <see langword="false" />. Esse método também retorna <see langword="false" /> se <paramref name="c" /> e o <see langword="Type" /> atual forem iguais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode chamar o <xref:System.Type.IsSubclassOf%2A> método para determinar qualquer um dos seguintes:  
  
-   Se uma classe derivada de outra.  
  
-   Se um tipo derivado de <xref:System.ValueType>. No entanto, o <xref:System.Type.IsValueType%2A> é uma maneira mais eficiente para determinar se um tipo é um tipo de valor.  
  
-   Se um tipo derivado de <xref:System.Enum>. No entanto, o <xref:System.Type.IsEnum%2A> método é uma maneira mais eficiente para determinar se um tipo é uma enumeração.  
  
-   Se um tipo é um delegado, ou seja, se ele deriva de uma <xref:System.Delegate> ou <xref:System.MulticastDelegate>.  
  
 O <xref:System.Type.IsSubclassOf%2A> método não pode ser usado para determinar se uma interface deriva de outra interface ou se uma classe implementa uma interface. Use o <xref:System.Type.IsAssignableFrom%2A> método para essa finalidade, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, ela deriva de sua restrição de classe ou de <xref:System.Object?displayProperty=nameWithType> se ele tiver nenhuma restrição de classe.  
  
> [!NOTE]
>  Exceto quando usado com interfaces, <xref:System.Type.IsSubclassOf%2A> é o oposto de <xref:System.Type.IsAssignableFrom%2A>. Ou seja, se `t1.IsSubclassOf(t2)` está `true`, em seguida, `t2.IsAssignableFrom(t1)` também é `true`.  
  
 Este método pode ser substituído por uma classe derivada.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe chamada `Class1` e uma classe derivada chamada `DerivedC1`. Ele chama o <xref:System.Type.IsSubclassOf%2A> método para mostrar que `DerivedC1` é uma subclasse de `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> é usado para selecionar os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um tipo de valor.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de valor são tipos que são representados como sequências de bits; tipos de valor não são classes ou interfaces. Tipos de valor são chamados de "structs" em algumas linguagens de programação. Enumerações são um caso especial de tipos de valor.  
  
 Essa propriedade retornará `false` para o <xref:System.ValueType> classe, pois <xref:System.ValueType> não é um tipo de valor. É a classe base para todos os tipos de valor e, portanto, qualquer tipo de valor pode ser atribuído a ele. Isso não seria possível se <xref:System.ValueType> em si foi um tipo de valor. Tipos de valor são boxed quando eles forem atribuídos a um campo do tipo <xref:System.ValueType>.  
  
 Essa propriedade retornará `true` para enumerações, mas não para o <xref:System.Enum> próprio tipo. Para obter um exemplo que demonstra esse comportamento, consulte <xref:System.Type.IsEnum%2A>.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma variável do tipo `MyEnum`, verifica o `IsValueType` propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa a propriedade <see cref="P:System.Type.IsValueType" /> e determina se o <see cref="T:System.Type" /> é um tipo de valor, ou seja, não é uma classe nem uma interface.</summary>
        <returns><see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para habilitar a implementação de sistemas de tipo alternativo. Ele não é geralmente usado no código do aplicativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se <see cref="T:System.Type" /> pode ser acessado pelo código fora do assembly.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Type" /> atual é um tipo público ou um tipo público aninhado, de modo que todos os tipos de delimitadores são públicos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade para determinar se um tipo é parte da interface pública de um assembly do componente.  
  
   
  
## Examples  
 O exemplo de código a seguir testa as duas classes, apenas um deles é visível fora do assembly.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira para gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.  
  
 **Observação** o common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseados em zero) e matrizes multidimensionais. Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional que tem apenas uma dimensão. Essa sobrecarga de método só pode ser usada para criar tipos de vetor e é a única maneira de criar um tipo de vetor. Use o <xref:System.Type.MakeArrayType%28System.Int32%29> sobrecarga de método para criar tipos de matriz multidimensional.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
- ou - 
O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">O número de dimensões da matriz. Esse número deve ser menor ou igual a 32.</param>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</summary>
        <returns>Um objeto que representa uma matriz do tipo atual, com o número de dimensões especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira para gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.  
  
> [!NOTE]
>  O common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseados em zero) e matrizes multidimensionais. Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional que tem apenas uma dimensão. Você não pode usar essa sobrecarga de método para criar um tipo de vetor; Se `rank` for 1, essa sobrecarga de método retorna um tipo de matriz multidimensional que acaba tendo uma dimensão. Use o <xref:System.Type.MakeArrayType> sobrecarga de método para criar tipos de vetor.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> é inválido. Por exemplo, 0 ou negativo.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
- ou - 
O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.  
  
- ou - 
 <paramref name="rank" /> é maior que 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeByRefType%2A> método fornece uma maneira de gerar `ref` tipos (`ByRef` no Visual Basic) para o parâmetro de lista.  
  
 Usando a sintaxe da Microsoft intermediate language (MSIL), se o atual <xref:System.Type> objeto representa <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32&`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
- ou - 
O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Uma matriz de tipos a serem substituídos pelos parâmetros de tipo do tipo genérico atual.</param>
        <summary>Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna um objeto <see cref="T:System.Type" /> que representa o tipo construído resultante.</summary>
        <returns>Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeGenericType%2A> método permite que você escreva código que atribui tipos específicos para os parâmetros de tipo de uma definição de tipo genérico, criando assim um <xref:System.Type> objeto que representa um tipo construído específico. Você pode usar isso <xref:System.Type> objeto para criar instâncias de tempo de execução do tipo construído.  
  
 Tipos construídos com <xref:System.Type.MakeGenericType%2A> podem ser abertos, ou seja, alguns dos argumentos de tipo podem ser parâmetros de tipo de circunscrição tipos ou métodos genéricos. Você pode usar esses tipos construídos abertos quando você emite assemblies dinâmicos. Por exemplo, considere as classes `Base` e `Derived` no código a seguir.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Para gerar `Derived` em um assembly dinâmico, é necessário construir seu tipo base. Para fazer isso, chame o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> que representa a classe de objeto `Base`, usando os argumentos de tipo genérico <xref:System.Int32> e o parâmetro de tipo `V` de `Derived`. Como tipos e parâmetros de tipo genérico são representados por <xref:System.Type> objetos, uma matriz que contém ambos pode ser passada para o <xref:System.Type.MakeGenericType%2A> método.  
  
> [!NOTE]
>  Um tipo construído, como `Base<int, V>` é útil para emitir o código, mas você não pode chamar o <xref:System.Type.MakeGenericType%2A> método neste tipo porque ele não é uma definição de tipo genérico. Para criar um tipo construído fechado que pode ser instanciado, primeiro chame o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter uma <xref:System.Type> do objeto que representa a definição de tipo genérico e, em seguida, chamar <xref:System.Type.MakeGenericType%2A> com os argumentos de tipo desejado.  
  
 O <xref:System.Type> objeto retornado por <xref:System.Type.MakeGenericType%2A> é o mesmo que o <xref:System.Type> obtido chamando o <xref:System.Object.GetType%2A> método resultantes construído tipo, ou o <xref:System.Object.GetType%2A> construído de método de qualquer tipo que foi criado da mesma genérico usando os mesmos argumentos de tipo de definição de tipo.  
  
> [!NOTE]
>  Uma matriz de tipos genéricos não é propriamente um tipo genérico. Você não pode chamar <xref:System.Type.MakeGenericType%2A> em uma matriz de tipo como `C<T>[]` (`Dim ac() As C(Of T)` no Visual Basic). Para construir um tipo genérico fechado de `C<T>[]`, chame <xref:System.Type.GetElementType%2A> para obter a definição de tipo genérico `C<T>`; chamar <xref:System.Type.MakeGenericType%2A> na definição de tipo genérico para criar o tipo construído; e, finalmente, chame o <xref:System.Type.MakeArrayType%2A> método em o tipo construído para criar o tipo de matriz. O mesmo é verdadeiro de tipos de ponteiro e `ref` tipos (`ByRef` no Visual Basic).  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Tipos aninhados  
 Se um tipo genérico é definido usando c#, C++ ou Visual Basic, seus tipos aninhados são todos genéricos. Isso é verdadeiro mesmo se os tipos aninhados não tem nenhum parâmetro de tipo próprios, porque todos os três linguagens incluem os parâmetros de tipo de tipos de delimitadores nas listas de parâmetros de tipo de tipos aninhados. Considere as seguintes classes:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Lista de parâmetros de tipo da classe aninhada `Inner` tem dois parâmetros de tipo `T` e `U`, o primeiro deles é o parâmetro de tipo de sua classe delimitadora. Da mesma forma, a lista de parâmetros de tipo da classe aninhada `Innermost1` tem três parâmetros de tipo `T`, `U`, e `V`, com `T` e `U` provenientes de suas classes de delimitadores. A classe aninhada `Innermost2` tem dois parâmetros de tipo `T` e `U`, que vêm de suas classes de delimitadores.  
  
 Se a lista de parâmetros do tipo delimitador tem mais de um parâmetro de tipo, todos os parâmetros de tipo na ordem são incluídos na lista de parâmetros de tipo do tipo aninhado.  
  
 Para construir um tipo genérico com base na definição de tipo genérico para um tipo aninhado, chame o <xref:System.Type.MakeGenericType%2A> método com a matriz formado pela concatenação de matrizes de argumento de tipo de todos os tipos de delimitador, começando com o tipo genérico mais externo e terminando com o tipo de matriz de argumentos do tipo aninhado em si, se ele tem parâmetros de tipo próprios. Para criar uma instância do `Innermost1`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém três tipos, a ser atribuído ao T, U e V. Para criar uma instância do `Innermost2`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém dois tipos, a ser atribuído ao T e U.  
  
 Os idiomas propagam os parâmetros de tipo de tipos de delimitadores dessa maneira para que você pode usar os parâmetros de tipo de um tipo de delimitador para definir os campos de tipos aninhados. Caso contrário, os parâmetros de tipo não seria no escopo em que os corpos dos tipos aninhados. É possível definir tipos aninhados sem propagar os parâmetros de tipo de tipos de delimitadores, pela emissão do código em assemblies dinâmicos ou usando o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Considere o seguinte código para o assembler MSIL:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 Neste exemplo, não é possível definir um campo do tipo `T` ou `U` na classe `Innermost`, porque esses parâmetros de tipo não estão no escopo. O seguinte código de assembler define classes aninhadas que se comportam da forma que fariam se definida em C++, Visual Basic e c#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar as classes aninhadas definidas em linguagens de alto nível e observar esse esquema de nomenclatura.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.MakeGenericType%2A> método para criar um tipo construído da definição de tipo genérico para o <xref:System.Collections.Generic.Dictionary%602> tipo. Representa o tipo construído uma <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não representa uma definição de tipo genérica. Ou seja, <see cref="P:System.Type.IsGenericTypeDefinition" /> retorna <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> é <see langword="null" />.  
  
- ou - 
Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos em <paramref name="typeArguments" /> não é igual ao número de parâmetros de tipo na definição de tipo genérico atual.  
  
- ou - 
Nenhum elemento do <paramref name="typeArguments" /> satisfaz as restrições especificadas para o parâmetro de tipo correspondente do tipo genérico atual.  
  
- ou - 
 <paramref name="typeArguments" /> contém um elemento que é um tipo de ponteiro (<see cref="P:System.Type.IsPointer" /> retorna <see langword="true" />), um tipo by-ref (<see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />) ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflexão e tipos genéricos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Como examinar tipos genéricos e criar instâncias deles com a reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa um ponteiro para o tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakePointerType%2A> método fornece uma maneira para gerar tipos de ponteiro para listas de parâmetros.  
  
 Usando a sintaxe da Microsoft intermediate language (MSIL), se o atual <xref:System.Type> objeto representa <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32*`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
- ou - 
O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</summary>
        <value>Um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade substitui <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Portanto, quando você examinar um conjunto de <xref:System.Reflection.MemberInfo> objetos, por exemplo, a matriz retornada por <xref:System.Type.GetMembers%2A> - o <xref:System.Reflection.MemberInfo.MemberType%2A> propriedade retorna <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quando um determinado membro é um tipo aninhado.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra a `MemberType` campo como um parâmetro para o `GetMember` método:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa um valor ausente nas informações <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o `Missing` field para invocação por meio de reflexão para obter o valor padrão de um parâmetro. Se o `Missing` campo é passado para um valor de parâmetro e não há nenhum valor padrão para esse parâmetro, um <xref:System.ArgumentException> é gerada.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso do `Missing` campo para invocar um método com argumentos padrão.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Esse código gera a seguinte saída:  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 um = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo (a DLL) no qual o <see cref="T:System.Type" /> atual está definido.</summary>
        <value>O módulo no qual o <see cref="T:System.Type" /> atual está definido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna o módulo no qual a definição de tipo genérico foi definida. Por exemplo, se você criar uma instância do `MyGenericStack<int>`, o <xref:System.Type.Module%2A> propriedade para o tipo construído retorna o módulo no qual `MyGenericStack<T>` é definido.  
  
 Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e `Module` propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o nome do tipo atual.</summary>
        <value>O nome do tipo atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o namespace do <see cref="T:System.Type" />.</summary>
        <value>O namespace do <see cref="T:System.Type" />; <see langword="null" /> se a instância atual não tiver nenhum namespace ou representar um parâmetro genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um namespace é uma lógica de tempo de design nomenclatura conveniência, usada principalmente para definir o escopo em um aplicativo e organizar as classes e outros tipos em uma única estrutura hierárquica. Do ponto de vista do tempo de execução, não há nenhum namespace.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna o namespace que contém a definição de tipo genérico. Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o namespace que contém a definição de tipo genérico que define `T`.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do `Namespace` e <xref:System.Type.Module%2A> propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois objetos <see cref="T:System.Type" /> são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois objetos <see cref="T:System.Type" /> não são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto de classe que foi usado para obter esse membro.</summary>
        <value>O objeto <see langword="Type" /> por meio do qual este objeto <see cref="T:System.Type" /> foi obtido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Type> objetos, o valor dessa propriedade é sempre o mesmo que o valor da <xref:System.Type.DeclaringType%2A> propriedade.  
  
   
  
## Examples  
 Este exemplo exibe o tipo refletido de uma classe aninhada.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do <see cref="T:System.Type" /> a ser obtido.</param>
        <param name="throwIfNotFound"><see langword="true" /> para gerar uma <see cref="T:System.TypeLoadException" /> se não for possível encontrar o tipo, <see langword="false" /> para retornar <see langword="null" /> se não for possível encontrar o tipo. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase"><see langword="true" /> para executar uma pesquisa que não diferencia maiúsculas de minúsculas para <paramref name="typeName" />, <see langword="false" /> para realizar uma pesquisa que diferencia maiúsculas de minúsculas para <paramref name="typeName" />.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deverá realizar uma pesquisa que diferencia maiúsculas de minúsculas e se deverá gerar uma exceção se o tipo não for encontrado. O tipo é carregado para reflexão apenas, não para execução.</summary>
        <returns>O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwIfNotFound" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwIfNotFound" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o assembly que contém o tipo já não estiver carregado no contexto somente reflexão, usando o <xref:System.Type.ReflectionOnlyGetType%2A> método é equivalente ao primeiro carregar o assembly para reflexão apenas, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método e, em seguida, carregar o tipo chamando o um assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método. Para obter informações sobre nomes de assembly qualificado, consulte o <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriedade. Para obter mais detalhes sobre como especificar nomes de tipo, consulte o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método.  
  
 Se o assembly já foi carregado para execução, outra cópia é carregada no contexto somente reflexão.  
  
 O `throwIfNotFound` parâmetro especifica o que acontece quando o tipo não for encontrado e também suprime determinadas condições de exceção, conforme descrito na seção exceções. Algumas exceções são geradas, independentemente do valor de `throwIfNotFound`. Por exemplo, se o assembly não for válido, uma <xref:System.BadImageFormatException> é gerada, mesmo que `throwIfNotFound` é `false`.  
  
 Para obter mais informações sobre como usar o contexto de somente reflexão, consulte [como: carregar assemblies no contexto somente de reflexão](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
- ou - 
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida. 
- ou - 
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
- ou - 
 <paramref name="typeName" /> representa uma matriz de objetos <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> não inclui o nome do assembly.  
  
- ou - 
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida, por exemplo, "MyType[,*,]".  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
- ou - 
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
- ou - 
O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Especificando nomes de tipo totalmente qualificados</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Como carregar assemblies no contexto de somente reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve o layout do tipo atual.</summary>
        <value>Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve os recursos de layout bruto do tipo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> não é retornado pelo <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método. Em vez disso, use essa propriedade para obtê-lo.  
  
   
  
## Examples  
 O exemplo de código a seguir primeiro define uma classe, uma estrutura e uma estrutura com atributos de layout especial (as estruturas são aninhadas dentro da classe). O exemplo usa o <xref:System.Type.StructLayoutAttribute%2A> propriedade para obter um <xref:System.Runtime.InteropServices.StructLayoutAttribute> para cada tipo e exibe as propriedades dos atributos.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma <see langword="String" /> que representa o nome da <see langword="Type" /> atual.</summary>
        <returns>Uma <see cref="T:System.String" /> que representa o nome da <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna o nome para todos os tipos primitivos e totalmente qualificado namespace common language runtime. Por exemplo, a c# instrução, `(long)0.Type().ToString()` retorna "System.Int64" em vez de simplesmente "Int64".  
  
 Se o atual <xref:System.Type> representa um tipo genérico, o tipo e argumentos de tipo são qualificados por namespace e pelo tipo aninhado, mas não por assembly. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método retorna o nome não qualificado do parâmetro de tipo.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e <xref:System.Type.Module%2A> propriedades e o `ToString` método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pela <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador do <see cref="T:System.Type" /> atual.</summary>
        <value>O identificador do <see cref="T:System.Type" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` encapsula um ponteiro para uma estrutura de dados interna que representa o tipo. Esse identificador é exclusivo durante o tempo de vida do processo. O identificador é válido somente no domínio do aplicativo no qual ele foi obtido.  
  
   
  
## Examples  
 O exemplo a seguir retorna o identificador do tipo correspondente e transmite o identificador para um método que obtém o tipo do identificador e o exibe.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No momento, o .NET Compact Framework não dá suporte a essa propriedade.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o inicializador para o tipo.</summary>
        <value>Um objeto que contém o nome do construtor da classe para o <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicializadores de classe também estão disponíveis por meio de <xref:System.Type.FindMembers%2A> método, ou por meio de sobrecargas do <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, e <xref:System.Type.GetConstructors%2A> métodos que usam <xref:System.Reflection.BindingFlags> como um parâmetro.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade retornará `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o tipo fornecido pelo Common Language Runtime que representa esse tipo.</summary>
        <value>O tipo de sistema subjacente para o <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
