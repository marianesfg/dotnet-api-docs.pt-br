<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dcd9ac88a0a161873d835922b453f3bf3a1ce079" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55322417" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="45345-101">Representa um domínio de aplicativo, que é um ambiente isolado em que os aplicativos são executados.</span><span class="sxs-lookup"><span data-stu-id="45345-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="45345-102">Essa classe não pode ser herdada.</span><span class="sxs-lookup"><span data-stu-id="45345-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-103">Domínios de aplicativo, que são representados por <xref:System.AppDomain> objetos, ajudam a fornecer os limites de isolamento, descarregando e segurança para a execução de código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="45345-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="45345-104">Use domínios de aplicativo para isolar as tarefas que podem prejudicar a um processo.</span><span class="sxs-lookup"><span data-stu-id="45345-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="45345-105">Se o estado do <xref:System.AppDomain> que está executando uma tarefa torna-se instável, o <xref:System.AppDomain> pode ser descarregado sem afetar o processo.</span><span class="sxs-lookup"><span data-stu-id="45345-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="45345-106">Isso é importante quando um processo deve ser executado por longos períodos sem reiniciar.</span><span class="sxs-lookup"><span data-stu-id="45345-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="45345-107">Você também pode usar domínios de aplicativo para isolar as tarefas que não devem compartilhar dados.</span><span class="sxs-lookup"><span data-stu-id="45345-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="45345-108">Se um assembly é carregado no domínio de aplicativo padrão, ele não pode ser descarregado da memória enquanto o processo está em execução.</span><span class="sxs-lookup"><span data-stu-id="45345-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="45345-109">No entanto, se você abrir um segundo domínio de aplicativo para carregar e executar o assembly, o assembly é descarregado quando o domínio de aplicativo é descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="45345-110">Use essa técnica para minimizar o conjunto de trabalho de processos de longa execução que ocasionalmente usar DLLs grandes.</span><span class="sxs-lookup"><span data-stu-id="45345-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 > [!NOTE]
 >  <span data-ttu-id="45345-111">No .NET Core, o <xref:System.AppDomain> é limitada pelo design de implementação e não fornece limites de isolamento, descarregamento ou segurança.</span><span class="sxs-lookup"><span data-stu-id="45345-111">On .NET Core, the <xref:System.AppDomain> implementation is limited by design and does not provide isolation, unloading, or security boundaries.</span></span> <span data-ttu-id="45345-112">Para o .NET Core, há exatamente um <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="45345-112">For .NET Core, there is exactly one <xref:System.AppDomain>.</span></span> <span data-ttu-id="45345-113">Isolamento e descarregamento são fornecidos por meio de <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="45345-113">Isolation and unloading are provided through <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="45345-114">Limites de segurança devem ser fornecidos por limites de processo e as técnicas de comunicação remota apropriado.</span><span class="sxs-lookup"><span data-stu-id="45345-114">Security boundaries should be provided by process boundaries and appropriate remoting techniques.</span></span>
 
 <span data-ttu-id="45345-115">Vários domínios de aplicativo podem executar em um único processo; No entanto, não há uma correlação entre domínios de aplicativo e threads.</span><span class="sxs-lookup"><span data-stu-id="45345-115">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="45345-116">Vários threads podem pertencer a um único domínio de aplicativo e, enquanto um determinado thread não está limitado a um único domínio de aplicativo, a qualquer momento determinado, um thread é executado em um único domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-116">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="45345-117">Domínios de aplicativo são criados usando o <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-117">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="45345-118"><xref:System.AppDomain> instâncias são usadas para carregar e executar assemblies (<xref:System.Reflection.Assembly>).</span><span class="sxs-lookup"><span data-stu-id="45345-118"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="45345-119">Quando um <xref:System.AppDomain> é não mais em uso, ele pode ser descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-119">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="45345-120">O <xref:System.AppDomain> classe implementa um conjunto de eventos que permitem que os aplicativos responder quando um assembly é carregado, quando um domínio de aplicativo será descarregado, ou quando uma exceção não tratada é lançada.</span><span class="sxs-lookup"><span data-stu-id="45345-120">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="45345-121">Para obter mais informações sobre como usar domínios de aplicativo, consulte [domínios de aplicativo](~/docs/framework/app-domains/application-domains.md).</span><span class="sxs-lookup"><span data-stu-id="45345-121">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="45345-122">Essa classe implementa a <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory> interfaces.</span><span class="sxs-lookup"><span data-stu-id="45345-122">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="45345-123">Você nunca deve criar um wrapper que devem ser remotos para um <xref:System.AppDomain> objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-123">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="45345-124">Isso foi possível publicar uma referência remota para que <xref:System.AppDomain>, expondo métodos, como <xref:System.AppDomain.CreateInstance%2A> para acesso remoto e destruindo efetivamente a segurança de acesso do código para que <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="45345-124">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="45345-125">Os clientes mal-intencionados que conectam o remoto <xref:System.AppDomain> pôde obter acesso a qualquer recurso a <xref:System.AppDomain> em si tem acesso ao.</span><span class="sxs-lookup"><span data-stu-id="45345-125">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="45345-126">Não crie wrappers que devem ser remotos para qualquer tipo que estende <xref:System.MarshalByRefObject> e que implementa métodos que podem ser usados pelos clientes mal-intencionados para ignorar o sistema de segurança.</span><span class="sxs-lookup"><span data-stu-id="45345-126">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="45345-127">O valor padrão para o <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> é de propriedade `false`.</span><span class="sxs-lookup"><span data-stu-id="45345-127">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="45345-128">Essa configuração não é segura para os serviços.</span><span class="sxs-lookup"><span data-stu-id="45345-128">This setting is unsafe for services.</span></span> <span data-ttu-id="45345-129">Para impedir que serviços de download de código parcialmente confiável, defina essa propriedade como `true`.</span><span class="sxs-lookup"><span data-stu-id="45345-129">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-130">Este exemplo mostra como criar um novo <xref:System.AppDomain>, crie uma instância de um tipo em que novos <xref:System.AppDomain>e se comunicar com o objeto desse tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-130">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="45345-131">Além disso, este exemplo mostra como descarregar o <xref:System.AppDomain> fazendo com que o objeto a ser coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="45345-131">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="45345-132">Como: Configurar um domínio do aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-132">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="45345-133">Como: Criar um domínio do aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-133">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="45345-134">Como carregar assemblies em um domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-134">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="45345-135">Como descarregar um domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-135">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-136">Obtém o contexto de ativação para o domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-136">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="45345-137">Um objeto que representa o contexto de ativação para o domínio de aplicativo atual ou <see langword="null" />, se o domínio não tiver contexto de ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-137">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-138">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-138">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-139">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-139">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="45345-140">O nome do diretório a ser anexo ao caminho privado.</span><span class="sxs-lookup"><span data-stu-id="45345-140">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="45345-141">Anexa o nome do diretório especificado à lista de caminhos privado.</span><span class="sxs-lookup"><span data-stu-id="45345-141">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-142">O uso dessa propriedade não é recomendado, porque ela pode mudar o caminho de investigação para assemblies depois que já foram carregados.</span><span class="sxs-lookup"><span data-stu-id="45345-142">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="45345-143">Use a propriedade <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="45345-143">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="45345-144">O caminho privado ou o caminho de pesquisa relativo é o caminho relativo ao diretório base onde o resolvedor de assembly investigações assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-144">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-145">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-145">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-146">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-147">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-148">Obtém a identidade do aplicativo no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-148">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="45345-149">Um objeto que identifica o aplicativo no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-149">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-150">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-150">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-151">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-152">Obtém informações que descrevem as permissões concedidas a um aplicativo e se o aplicativo tem um nível de confiança que permite que ele seja executado.</span><span class="sxs-lookup"><span data-stu-id="45345-152">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="45345-153">Um objeto que encapsula informações de permissão e de relação de confiança do aplicativo no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-153">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-154">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-154">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-155">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-155">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-156">O nome de exibição do assembly no formato fornecido pela propriedade <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-156">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="45345-157">Retorna o nome de exibição do assembly depois de a política ser aplicada.</span><span class="sxs-lookup"><span data-stu-id="45345-157">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="45345-158">Uma cadeia de caracteres que contém o nome de exibição do assembly depois de a política ser aplicada.</span><span class="sxs-lookup"><span data-stu-id="45345-158">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-159">O <xref:System.AppDomain.ApplyPolicy%2A> usa o método assembly de nome de exibição e retorna o nome de exibição de pós política de.</span><span class="sxs-lookup"><span data-stu-id="45345-159">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="45345-160">Isso é útil se você precisar carregar um assembly usando a política, pois o contexto de somente reflexão não se aplica a política.</span><span class="sxs-lookup"><span data-stu-id="45345-160">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-161">Ocorre quando um assembly é carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-161">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-162">O <xref:System.AssemblyLoadEventHandler> delegado para esse evento indica que o assembly foi carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-162">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="45345-163">Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="45345-163">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="45345-164">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-164">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-165">O exemplo a seguir demonstra o <xref:System.AppDomain.AssemblyLoad> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-165">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="45345-166">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-166">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-167">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-167">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-168">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-168">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-169">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-170">Ocorre quando a resolução de um assembly falha.</span><span class="sxs-lookup"><span data-stu-id="45345-170">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-171">É responsabilidade do <xref:System.ResolveEventHandler> para este evento retornar o assembly especificado pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade, ou para retornar nulo se o assembly não é reconhecido.</span><span class="sxs-lookup"><span data-stu-id="45345-171">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="45345-172">O assembly deve ser carregado em um contexto de execução; Se ele for carregado no contexto somente reflexão, a carga que causou este evento a ser gerado falhará.</span><span class="sxs-lookup"><span data-stu-id="45345-172">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="45345-173">Para obter diretrizes sobre o uso desse evento, consulte [Resolvendo carregamentos de Assembly](~/docs/framework/app-domains/resolve-assembly-loads.md).</span><span class="sxs-lookup"><span data-stu-id="45345-173">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="45345-174">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade retorna o assembly que solicitou o carregamento do assembly que não pôde ser resolvido.</span><span class="sxs-lookup"><span data-stu-id="45345-174">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="45345-175">Por exemplo, o carregador pode ser não é possível carregar uma dependência do assembly solicitante porque o assembly solicitante e sua dependência não estão no caminho de investigação.</span><span class="sxs-lookup"><span data-stu-id="45345-175">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="45345-176">Saber a identidade do assembly solicitante pode ser útil localizar a dependência ou identificar a versão correta, se houver mais de uma versão da dependência.</span><span class="sxs-lookup"><span data-stu-id="45345-176">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="45345-177">Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-177">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-178">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o <xref:System.ResolveEventHandler> é gerado para todos os assemblies, incluindo assemblies de recursos.</span><span class="sxs-lookup"><span data-stu-id="45345-178">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="45345-179">Em versões anteriores, o evento não foi gerado para assemblies de recursos.</span><span class="sxs-lookup"><span data-stu-id="45345-179">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="45345-180">Se o sistema operacional está localizado, o manipulador pode ser chamado várias vezes: uma vez para cada cultura da cadeia de fallback.</span><span class="sxs-lookup"><span data-stu-id="45345-180">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="45345-181">Para este evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade retorna o nome do assembly antes de política é aplicada.</span><span class="sxs-lookup"><span data-stu-id="45345-181">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-182">Se mais de um manipulador de eventos é registrado para este evento, os manipuladores de eventos são chamados na ordem até que um manipulador de eventos retorna um valor que não seja `null`.</span><span class="sxs-lookup"><span data-stu-id="45345-182">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="45345-183">Manipuladores de eventos subsequentes serão ignorados.</span><span class="sxs-lookup"><span data-stu-id="45345-183">Subsequent event handlers are ignored.</span></span>
  
 <span data-ttu-id="45345-184">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-184">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-185">O exemplo a seguir demonstra o <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-185">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-186">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-186">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-187">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-187">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-188">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-189">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="45345-190">Resolvendo carregamentos de assembly</span><span class="sxs-lookup"><span data-stu-id="45345-190">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-191">Obtém o diretório base usado pelo resolvedor de assembly para investigar assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-191">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="45345-192">O diretório base usado pelo resolvedor de assembly para investigar assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-192">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-193">Essa propriedade corresponde à <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-193">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="45345-194">Ele também pode ser recuperado usando o <xref:System.AppDomain.GetData%2A> método com a cadeia de caracteres "APPBASE".</span><span class="sxs-lookup"><span data-stu-id="45345-194">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-195">O exemplo de código a seguir cria um novo domínio de aplicativo, especificando um diretório base para usar ao pesquisar assemblies para carregar no domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-195">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="45345-196">O exemplo usa o <xref:System.AppDomain.BaseDirectory%2A> propriedade para obter o caminho do diretório base para exibição no console.</span><span class="sxs-lookup"><span data-stu-id="45345-196">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-197">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-197">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-198">para acessar as informações no próprio caminho, incluindo se, o caminho está no formato "file://" ou \\\UNC\dir ou "c:\\".</span><span class="sxs-lookup"><span data-stu-id="45345-198">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span></span> <span data-ttu-id="45345-199">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-199">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-200">Redefine o caminho que especifica o local dos assemblies privados para a cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="45345-200">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-201">O caminho privado é um caminho relativo para o diretório base que o common language runtime pesquisa para localizar assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-201">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="45345-202">Para obter mais informações, consulte <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-202">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-203">O exemplo de código a seguir demonstra como usar o <xref:System.AppDomain.ClearPrivatePath%2A> método para remover todas as entradas da lista de caminhos privados para pesquisar quando os assemblies são carregados.</span><span class="sxs-lookup"><span data-stu-id="45345-203">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="45345-204">Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="45345-204">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-205">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-205">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-206">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-206">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-207">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-208">Redefine a lista de diretórios que contêm assemblies de cópia de sombra para a cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="45345-208">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-209">O caminho de cópia de sombra é uma lista de diretórios onde a sombra copiados assemblies são armazenados.</span><span class="sxs-lookup"><span data-stu-id="45345-209">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="45345-210">Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> e [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-210">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-211">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-211">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-212">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-212">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-213">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-213">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="45345-214">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="45345-214">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-215">Cria uma nova instância de um tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-215">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-216">O nome de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-216">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-217">O nome do módulo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-217">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="45345-218">Cria uma nova instância de um tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-218">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="45345-219">Parâmetros especificam o nome de um arquivo que contém um assembly com o tipo e o nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-219">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="45345-220">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-220">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-221">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-221">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-222">Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.</span><span class="sxs-lookup"><span data-stu-id="45345-222">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="45345-223">O valor de retorno deve para ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-223">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="45345-224">Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="45345-224">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-225">O exemplo a seguir demonstra</span><span class="sxs-lookup"><span data-stu-id="45345-225">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-226"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-226"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-227">O tipo não pode ser carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-227">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-228">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-228">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-229">Nenhum construtor público sem parâmetros foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-229">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-230"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-230"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="45345-231"><paramref name="typeName" /> é uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="45345-231"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="45345-232">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-232">-or-</span></span> 
<span data-ttu-id="45345-233">Este membro foi invocado com um mecanismo de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="45345-233">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-234">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-234">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-235"><paramref name="assemblyName" /> é uma cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="45345-235"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-236"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-236"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-237">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-237">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-238">O objeto COM que está sendo referenciado é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-238">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-239">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-239">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-240">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-240">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-241">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-241">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-242">O nome de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-242">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-243">O nome do módulo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-243">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="45345-244">Representa o valor do código hash computado.</span><span class="sxs-lookup"><span data-stu-id="45345-244">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="45345-245">Representa o algoritmo de hash usado pelo manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-245">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="45345-246">Cria uma nova instância de um tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-246">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="45345-247">Parâmetros especificam o nome de um arquivo que contém um assembly com o tipo e o nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-247">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="45345-248">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-248">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-249">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-249">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-250">Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.</span><span class="sxs-lookup"><span data-stu-id="45345-250">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="45345-251">O valor de retorno deve para ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-251">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="45345-252">Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="45345-252">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-253"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-253"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-254">O tipo não pode ser carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-254">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-255">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-255">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-256">Nenhum construtor público sem parâmetros foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-256">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-257"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-257"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="45345-258"><paramref name="typeName" /> é uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="45345-258"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="45345-259">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-259">-or-</span></span> 
<span data-ttu-id="45345-260">Este membro foi invocado com um mecanismo de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="45345-260">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-261">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-261">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-262"><paramref name="assemblyFile" /> é a cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="45345-262"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-263"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-263"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-264">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-264">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-265">O objeto COM que está sendo referenciado é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-265">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-266">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-266">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-267">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-268">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-268">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-269">Cria um novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-269">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-270">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-270">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="45345-271">Cria um novo domínio de aplicativo com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-271">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="45345-272">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-272">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-273">O `friendlyName` parâmetro destina-se para identificar o domínio de uma maneira que seja significativo para seres humanos.</span><span class="sxs-lookup"><span data-stu-id="45345-273">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="45345-274">Essa cadeia de caracteres deve ser adequada para exibição nas interfaces do usuário.</span><span class="sxs-lookup"><span data-stu-id="45345-274">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="45345-275">Essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-275">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-276">O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-276">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-277"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-277"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="45345-278">O método não é compatível com o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="45345-278">Method not supported on .NET Core.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-279">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-279">to provide evidence.</span></span> <span data-ttu-id="45345-280">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-281">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-281">The friendly name of the domain.</span></span> <span data-ttu-id="45345-282">Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-282">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="45345-283">Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-283">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="45345-284">Evidência que estabelece a identidade do código executado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-284">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="45345-285">Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-285">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="45345-286">Cria um novo domínio do aplicativo com o nome especificado usando a evidência fornecida.</span><span class="sxs-lookup"><span data-stu-id="45345-286">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="45345-287">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-287">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-288">Essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-288">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="45345-289">Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.</span><span class="sxs-lookup"><span data-stu-id="45345-289">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-290">Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-290">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="45345-291">Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-291">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="45345-292">Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-292">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-293">O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-293">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-294"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-294"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-295">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-295">to provide evidence.</span></span> <span data-ttu-id="45345-296">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-296">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-297">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-297">The friendly name of the domain.</span></span> <span data-ttu-id="45345-298">Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-298">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="45345-299">Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-299">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="45345-300">Evidência que estabelece a identidade do código executado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-300">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="45345-301">Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-301">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="45345-302">Um objeto que contém informações de inicialização do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-302">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="45345-303">Cria um novo domínio do aplicativo usando o nome, evidência e informações de instalação do domínio do aplicativo especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-303">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="45345-304">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-304">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-305">Se `info` não é fornecido, essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-305">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="45345-306">Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.</span><span class="sxs-lookup"><span data-stu-id="45345-306">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-307">Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-307">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="45345-308">Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-308">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="45345-309">Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-309">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-310">O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-310">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-311"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-311"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-312">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-312">to provide evidence.</span></span> <span data-ttu-id="45345-313">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-313">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-314">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-314">The friendly name of the domain.</span></span> <span data-ttu-id="45345-315">Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-315">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="45345-316">Para obter mais informações, consulte a descrição de <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-316">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="45345-317">Evidência que estabelece a identidade do código executado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-317">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="45345-318">Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-318">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="45345-319">Um objeto que contém informações de inicialização do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-319">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="45345-320">Um conjunto de permissões padrão concedido a todos os assemblies carregados no novo domínio do aplicativo que não tem concessões específicas.</span><span class="sxs-lookup"><span data-stu-id="45345-320">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="45345-321">Uma matriz de nomes fortes que representa os assemblies a serem considerados totalmente confiáveis no novo domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-321">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="45345-322">Cria um novo domínio do aplicativo usando o nome, evidência, informações de configuração do domínio do aplicativo, conjunto de permissões padrão e a matriz de assemblies totalmente confiáveis especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-322">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="45345-323">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-323">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-324">Você deve definir a <xref:System.AppDomainSetup.ApplicationBase%2A> propriedade do <xref:System.AppDomainSetup> objeto que você fornecer para `info`.</span><span class="sxs-lookup"><span data-stu-id="45345-324">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="45345-325">Caso contrário, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="45345-325">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45345-326">Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.</span><span class="sxs-lookup"><span data-stu-id="45345-326">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="45345-327">As informações fornecidas para `grantSet` e `fullTrustAssemblies` é usado para criar um <xref:System.Security.Policy.ApplicationTrust> objeto para o novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-327">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-328"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-328"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-329">O domínio do aplicativo é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-329">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-330">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-330">-or-</span></span> 
<span data-ttu-id="45345-331">A propriedade <see cref="P:System.AppDomainSetup.ApplicationBase" /> não está definida no objeto <see cref="T:System.AppDomainSetup" /> fornecido para <paramref name="info" />.</span><span class="sxs-lookup"><span data-stu-id="45345-331">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-332">para a capacidade de criar e manipular um domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-332">for the ability to create and manipulate an application domain.</span></span> <span data-ttu-id="45345-333">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="45345-333">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="45345-334">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-334">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-335">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-335">The friendly name of the domain.</span></span> <span data-ttu-id="45345-336">Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-336">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="45345-337">Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-337">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="45345-338">Evidência que estabelece a identidade do código executado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-338">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="45345-339">Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-339">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="45345-340">O diretório base usado pelo resolvedor de assembly para investigar assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-340">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="45345-341">Para obter mais informações, consulte <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="45345-341">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="45345-342">O caminho relativo ao diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-342">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="45345-343">Para obter mais informações, consulte <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="45345-343">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="45345-344">Se for <see langword="true" />, uma cópia de sombra de um assembly é carregada nesse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-344">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="45345-345">Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, o caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregada no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-345">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="45345-346">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-346">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-347">Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.</span><span class="sxs-lookup"><span data-stu-id="45345-347">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="45345-348">Para obter mais informações sobre a cópia de sombra, consulte <xref:System.AppDomain.ShadowCopyFiles%2A> e [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-348">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-349">Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-349">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="45345-350">Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-350">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="45345-351">Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-351">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-352">O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-352">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-353"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-353"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-354">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-354">to provide evidence.</span></span> <span data-ttu-id="45345-355">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-355">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="45345-356">O nome amigável do domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-356">The friendly name of the domain.</span></span> <span data-ttu-id="45345-357">Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-357">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="45345-358">Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-358">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="45345-359">Evidência que estabelece a identidade do código executado no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-359">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="45345-360">Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-360">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="45345-361">O diretório base usado pelo resolvedor de assembly para investigar assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-361">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="45345-362">Para obter mais informações, consulte <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="45345-362">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="45345-363">O caminho relativo ao diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-363">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="45345-364">Para obter mais informações, consulte <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="45345-364">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="45345-365"><see langword="true" /> para carregar uma cópia de sombra de um assembly no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-365"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="45345-366">Um delegado <see cref="T:System.AppDomainInitializer" /> que representa um método de retorno de chamada a ser invocado quando o novo objeto <see cref="T:System.AppDomain" /> for inicializado.</span><span class="sxs-lookup"><span data-stu-id="45345-366">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="45345-367">Uma matriz de argumentos de cadeia de caracteres a serem passados para o retorno de chamada representado por <paramref name="adInit" />, quando o novo objeto <see cref="T:System.AppDomain" /> é inicializado.</span><span class="sxs-lookup"><span data-stu-id="45345-367">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="45345-368">Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, o caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregada no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-368">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="45345-369">Especifica um método de retorno de chamada invocado quando o domínio de aplicativo é inicializado e uma matriz de argumentos de cadeia de caracteres para passar o método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-369">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="45345-370">O domínio de aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-370">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-371">O método representado pelo `adInit` é executado no contexto de domínio do aplicativo recém-criado.</span><span class="sxs-lookup"><span data-stu-id="45345-371">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="45345-372">Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.</span><span class="sxs-lookup"><span data-stu-id="45345-372">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="45345-373">Para obter mais informações sobre a cópia de sombra, consulte <xref:System.AppDomain.ShadowCopyFiles%2A> e [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-373">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-374">Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-374">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="45345-375">Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-375">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="45345-376">Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-376">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-377"><paramref name="friendlyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-377"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-378">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-378">to provide evidence.</span></span> <span data-ttu-id="45345-379">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-380">Cria uma nova instância de um tipo especificado definido no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-380">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-381">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-381">The display name of the assembly.</span></span> <span data-ttu-id="45345-382">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-382">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-383">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-383">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="45345-384">Cria uma nova instância do tipo especificado definido no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-384">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="45345-385">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-385">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-386">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-386">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-387">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-387">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-388">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-388">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="45345-389">Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-389">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="45345-390">Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-390">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="45345-391">O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-391">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-392">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-392">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-393"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-393"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-394"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-394"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-395">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-395">-or-</span></span> 
<span data-ttu-id="45345-396">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-396">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-397">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-397">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-398"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-398"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-399">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-399">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-400">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-400">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-401"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-401"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-402">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-402">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-403">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-404">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-405">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-405">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-406">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante.</span><span class="sxs-lookup"><span data-stu-id="45345-406">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="45345-407">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="45345-407">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-408">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-408">The display name of the assembly.</span></span> <span data-ttu-id="45345-409">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-409">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-410">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-410">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-411">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-411">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-412">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-412">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-413">Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-413">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-414">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-414">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-415">Cria uma nova instância do tipo especificado definido no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-415">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="45345-416">Um parâmetro especifica uma matriz de atributos de ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-416">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-417">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-417">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-418">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-418">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-419">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-419">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-420">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-420">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="45345-421">Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-421">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="45345-422">Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-422">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="45345-423">O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-423">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-424">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-424">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-425"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-425"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-426"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-426"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-427">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-427">-or-</span></span> 
<span data-ttu-id="45345-428">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-428">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-429">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-429">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-430"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-430"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-431">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-431">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-432">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-432">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-433">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-433">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-434"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-434"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-435">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-435">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-436">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-436">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-437">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-437">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-438">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-438">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-439">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante.</span><span class="sxs-lookup"><span data-stu-id="45345-439">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="45345-440">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="45345-440">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-441">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-441">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-442">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-443">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-443">The display name of the assembly.</span></span> <span data-ttu-id="45345-444">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-444">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-445">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-445">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-446">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-446">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-447">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-447">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-448">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-448">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-449">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-449">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="45345-450">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-450">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-451">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-451">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-452">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-452">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-453">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-453">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-454">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-454">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-455">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-455">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-456">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-456">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-457">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-457">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-458">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-458">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-459">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-459">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-460">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-460">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-461">Cria uma nova instância do tipo especificado definido no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-461">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="45345-462">Os parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, informações específicas da cultura usadas para interpretar argumentos e atributos de ativação opcionais.</span><span class="sxs-lookup"><span data-stu-id="45345-462">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-463">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-463">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-464">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-464">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-465">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-465">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="45345-466">Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-466">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="45345-467">Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-467">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="45345-468">O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-468">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-469">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-470"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-470"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-471"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-471"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-472">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-472">-or-</span></span> 
 <span data-ttu-id="45345-473"><paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-473"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-474">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-474">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-475"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-475"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-476">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-476">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-477">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-477">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-478">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-478">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-479"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-479"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-480">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-480">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-481">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-481">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-482">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-482">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-483">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-483">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-484">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante.</span><span class="sxs-lookup"><span data-stu-id="45345-484">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="45345-485">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="45345-485">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-486">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-486">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-487">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-487">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-488">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-488">The display name of the assembly.</span></span> <span data-ttu-id="45345-489">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-489">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-490">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-490">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-491">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-491">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-492">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-492">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-493">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-493">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-494">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-494">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="45345-495">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-495">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-496">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-496">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-497">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-497">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-498">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-498">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-499">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-499">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-500">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-500">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-501">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-501">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-502">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-502">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-503">Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-503">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-504">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-504">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="45345-505">Informações usadas para autorizar a criação de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-505">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="45345-506">Cria uma nova instância do tipo especificado definido no assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-506">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="45345-507">Os parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, informações específicas da cultura usadas para interpretar argumentos, atributos de ativação e autorização para criar o tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-507">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="45345-508">Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-508">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="45345-509">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-509">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-510">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-510">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="45345-511">Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-511">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="45345-512">Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-512">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="45345-513">O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-513">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-514">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-514">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-515"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-515"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-516"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-516"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-517">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-517">-or-</span></span> 
<span data-ttu-id="45345-518">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-518">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-519">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-519">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-520"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-520"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-521">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-521">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-522">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-522">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-523">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-523">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="45345-524">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-524">-or-</span></span> 
 <span data-ttu-id="45345-525"><paramref name="securityAttributes" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-525"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-526">Quando a política CAS herdada não está habilitada, <paramref name="securityAttributes" /> deve ser <see langword="null." /></span><span class="sxs-lookup"><span data-stu-id="45345-526">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-527"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-527"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-528">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-528">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-529">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-529">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-530">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-530">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-531">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-531">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-532">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-532">to provide evidence.</span></span> <span data-ttu-id="45345-533">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-533">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-534">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-534">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-535">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-535">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-536">Cria uma nova instância de um tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-536">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-537">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-537">The display name of the assembly.</span></span> <span data-ttu-id="45345-538">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-538">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-539">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-539">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="45345-540">Cria uma nova instância do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-540">Creates a new instance of the specified type.</span></span> <span data-ttu-id="45345-541">Parâmetros especificam o assembly no qual o tipo é definido e o nome do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-541">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="45345-542">Uma instância do objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-542">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-543">Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-543">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="45345-544">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-544">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-545">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-545">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="45345-546">Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-546">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-547">Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-547">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="45345-548">Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-548">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="45345-549">Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-549">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="45345-550">Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-550">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-551">O exemplo de código a seguir mostra a maneira mais simples para executar código em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-551">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="45345-552">O exemplo define uma classe chamada `Worker` que herda de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="45345-552">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="45345-553">O `Worker` classe define um método que exibe o nome do domínio do aplicativo no qual ele está em execução.</span><span class="sxs-lookup"><span data-stu-id="45345-553">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="45345-554">O exemplo cria instâncias de `Worker` no domínio de aplicativo padrão e em um novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-554">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-555">O assembly que contém `Worker` deve ser carregado em ambos os domínios de aplicativo, mas ele pode carregar outros assemblies que existem somente no novo domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-555">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-556"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-556"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-557">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-557">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-558"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-558"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-559"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-559"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-560">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-560">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-561">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-561">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-562"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-562"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-563">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-563">-or-</span></span> 
<span data-ttu-id="45345-564">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-564">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-565">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-565">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-566">a capacidade de ler o arquivo que contém o manifesto do assembly, ou se você estiver criando um tipo de um módulo diferente do arquivo de manifesto.</span><span class="sxs-lookup"><span data-stu-id="45345-566">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span></span> <span data-ttu-id="45345-567">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-567">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-568">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-568">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-569">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-569">The display name of the assembly.</span></span> <span data-ttu-id="45345-570">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-570">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-571">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-571">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-572">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-572">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-573">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-573">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-574">Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-574">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-575">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-575">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-576">Cria uma nova instância do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-576">Creates a new instance of the specified type.</span></span> <span data-ttu-id="45345-577">Parâmetros especificam o assembly no qual o tipo, o nome do tipo e uma matriz de atributos de ativação são definidos.</span><span class="sxs-lookup"><span data-stu-id="45345-577">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-578">Uma instância do objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-578">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-579">Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-579">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="45345-580">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-580">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-581">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-581">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="45345-582">Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-582">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-583">Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-583">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="45345-584">Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-584">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="45345-585">Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-585">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="45345-586">Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-586">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-587"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-587"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-588">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-588">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-589"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-589"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-590"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-590"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-591">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-591">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-592">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-592">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-593">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-593">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-594"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-594"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-595">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-595">-or-</span></span> 
<span data-ttu-id="45345-596">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-596">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-597">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-597">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-598">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-598">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-599">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-599">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-600">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-600">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-601">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante.</span><span class="sxs-lookup"><span data-stu-id="45345-601">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="45345-602">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="45345-602">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-603">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-603">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-604">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-604">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-605">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-605">The display name of the assembly.</span></span> <span data-ttu-id="45345-606">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-606">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-607">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-607">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-608">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-608">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-609">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-609">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-610">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-610">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-611">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-611">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="45345-612">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-612">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-613">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-613">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-614">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-614">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-615">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-615">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-616">Um objeto específico da cultura usado para controlar a coerção de tipos.</span><span class="sxs-lookup"><span data-stu-id="45345-616">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="45345-617">Caso <paramref name="culture" /> seja <see langword="null" />, <see langword="CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-617">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-618">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-618">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-619">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="45345-619">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="45345-620">que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-620">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-621">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-621">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-622">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-622">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-623">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-623">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-624">Cria uma nova instância do tipo indicado definido no assembly especificado, determinando se a diferenciação entre maiúsculas e minúsculas é ignorada no nome do tipo; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-624">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-625">Uma instância do objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-625">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-626">Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-626">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-627">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-627">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="45345-628">Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-628">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-629">Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-629">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="45345-630">Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-630">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="45345-631">Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-631">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="45345-632">Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-632">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-633">O exemplo a seguir demonstra o uso do `ignoreCase` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="45345-633">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-634"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-634"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-635">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-635">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-636"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-636"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-637"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-637"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-638">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-638">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-639">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-639">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-640">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-640">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-641"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-641"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-642">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-642">-or-</span></span> 
 <span data-ttu-id="45345-643"><paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-643"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-644">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-644">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-645">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-645">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-646">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-646">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-647">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-647">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-648">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante.</span><span class="sxs-lookup"><span data-stu-id="45345-648">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="45345-649">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="45345-649">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-650">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-650">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-651">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-651">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-652">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-652">The display name of the assembly.</span></span> <span data-ttu-id="45345-653">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-654">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-654">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-655">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-655">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-656">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-656">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-657">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-657">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-658">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-658">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="45345-659">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-659">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-660">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-660">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-661">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-661">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-662">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-662">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-663">Um objeto específico da cultura usado para controlar a coerção de tipos.</span><span class="sxs-lookup"><span data-stu-id="45345-663">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="45345-664">Caso <paramref name="culture" /> seja <see langword="null" />, <see langword="CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-664">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-665">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-665">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-666">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-666">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-667">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-667">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-668">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-668">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-669">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-669">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="45345-670">Informações usadas para autorizar a criação de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-670">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="45345-671">Cria uma nova instância do tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-671">Creates a new instance of the specified type.</span></span> <span data-ttu-id="45345-672">Os parâmetros especificam o nome do tipo e como ele é encontrado e criado.</span><span class="sxs-lookup"><span data-stu-id="45345-672">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="45345-673">Uma instância do objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-673">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-674">Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-674">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-675">Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="45345-675">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="45345-676">Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-676">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-677">Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-677">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="45345-678">Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-678">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="45345-679">Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-679">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="45345-680">Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.</span><span class="sxs-lookup"><span data-stu-id="45345-680">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-681">O exemplo a seguir demonstra o uso do `ignoreCase` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="45345-681">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-682"><paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-682"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-683">Nenhum construtor correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-683">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-684"><paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-684"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-685"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-685"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-686">O chamador não tem permissão para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-686">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-687">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-687">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-688">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-688">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-689"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-689"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-690">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-690">-or-</span></span> 
<span data-ttu-id="45345-691">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-691">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-692">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-692">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-693">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-693">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-694">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-694">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-695">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-695">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-696">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-696">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-697">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-697">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="45345-698">a capacidade de invocar operações em todos os membros do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-698">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="45345-699">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="45345-699">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-700">Cria uma nova instância de um tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-700">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-701">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-701">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="45345-702">O assembly é carregado usando o método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="45345-702">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-703">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-703">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="45345-704">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-704">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-705">Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-705">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="45345-706">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-706">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-707">O construtor padrão para `typeName` é invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-707">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="45345-708">Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-708">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="45345-709">Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-709">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="45345-710">No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-710">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="45345-711">Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos.</span><span class="sxs-lookup"><span data-stu-id="45345-711">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="45345-712">Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.</span><span class="sxs-lookup"><span data-stu-id="45345-712">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="45345-713">Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.</span><span class="sxs-lookup"><span data-stu-id="45345-713">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="45345-714">Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.</span><span class="sxs-lookup"><span data-stu-id="45345-714">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-715">O exemplo a seguir mostra como usar o <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga de método para criar uma instância de um objeto em um domínio de aplicativo de destino e chamar seus métodos.</span><span class="sxs-lookup"><span data-stu-id="45345-715">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="45345-716">O exemplo define o `MarshallableExample` classe, que pode ser empacotado entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-716">The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="45345-717">O exemplo cria um caminho para o assembly em execução no momento, cria um domínio de aplicativo de destino e usa o <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga do método para carregar o assembly de exemplo no domínio de aplicativo de destino e criar uma instância de `MarshallableExample`.</span><span class="sxs-lookup"><span data-stu-id="45345-717">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-718">O caminho é absoluto neste exemplo, mas um caminho relativo também funcionaria porque o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> método é usado para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-718">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="45345-719">Após o desencapsulamento o identificador de objeto, o exemplo demonstra três maneiras de usar um objeto em um domínio de aplicativo de destino:</span><span class="sxs-lookup"><span data-stu-id="45345-719">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="45345-720">Invocando um método com associação tardia, usando a reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-720">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="45345-721">Isso exige informações de tipo, que faz com que o assembly a ser carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="45345-721">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="45345-722">(Neste exemplo, ele já está carregado.)</span><span class="sxs-lookup"><span data-stu-id="45345-722">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="45345-723">Convertendo o objeto para uma interface conhecida para o chamador e o receptor.</span><span class="sxs-lookup"><span data-stu-id="45345-723">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="45345-724">Se a interface é definida no assembly de chamada ou em um terceiro assembly referenciado pelo chamador e o receptor, o assembly de chamada não é carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="45345-724">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="45345-725">Usando o objeto diretamente ao seu tipo é chamado para o chamador.</span><span class="sxs-lookup"><span data-stu-id="45345-725">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="45345-726">O assembly deve ser carregado no domínio de aplicativo do chamador.</span><span class="sxs-lookup"><span data-stu-id="45345-726">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="45345-727">Outra maneira de evitar carregar o assembly de chamada no domínio de aplicativo do chamador é para que o chamador derivar o <xref:System.MarshalByRefObject> classe e para definir um método que pode ser executado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-727">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="45345-728">Esse método pode usar reflexão para examinar um assembly de destino, porque o assembly de destino já está carregado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-728">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="45345-729">Consulte o exemplo para o <xref:System.AppDomain.DynamicDirectory%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-729">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-730"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-730"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-731">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-731">-or-</span></span> 
 <span data-ttu-id="45345-732"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-732"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-733"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-733"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-734"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="45345-734"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-735">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-735">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-736">Não foi encontrado nenhum construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="45345-736">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-737">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-737">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-738"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-738"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-739">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-739">-or-</span></span> 
<span data-ttu-id="45345-740">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-740">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-741">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-741">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-742">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-742">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-743">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-743">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-744">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-744">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-745">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-745">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-746">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-746">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="45345-747">O assembly é carregado usando o método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="45345-747">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-748">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-748">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-749">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-749">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-750">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-750">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-751">Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-751">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-752">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-752">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-753">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-753">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-754">Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-754">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="45345-755">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-755">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-756">O construtor padrão para `typeName` é invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-756">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="45345-757">Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-757">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="45345-758">Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-758">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="45345-759">No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-759">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="45345-760">Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos.</span><span class="sxs-lookup"><span data-stu-id="45345-760">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="45345-761">Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.</span><span class="sxs-lookup"><span data-stu-id="45345-761">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="45345-762">Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.</span><span class="sxs-lookup"><span data-stu-id="45345-762">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="45345-763">Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.</span><span class="sxs-lookup"><span data-stu-id="45345-763">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-764"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-764"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-765"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-765"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-766"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="45345-766"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-767">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-767">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-768">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-768">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-769">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-769">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-770">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-770">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-771"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-771"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-772">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-772">-or-</span></span> 
<span data-ttu-id="45345-773">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-773">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-774">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-774">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-775">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-775">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-776">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-776">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-777">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-777">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-778">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-778">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-779">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-779">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="45345-780">O assembly é carregado usando o método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="45345-780">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-781">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-781">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-782">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-782">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-783">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-783">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-784">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-784">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-785">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-785">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="45345-786">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-786">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-787">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-787">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-788">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-788">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-789">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-789">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-790">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-790">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-791">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-791">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-792">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-792">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-793">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-793">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-794">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-794">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-795">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-795">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-796">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-796">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-797">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-797">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-798">Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-798">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="45345-799">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-799">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-800">Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-800">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="45345-801">Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-801">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="45345-802">No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-802">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="45345-803">Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos.</span><span class="sxs-lookup"><span data-stu-id="45345-803">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="45345-804">Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.</span><span class="sxs-lookup"><span data-stu-id="45345-804">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="45345-805">Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.</span><span class="sxs-lookup"><span data-stu-id="45345-805">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="45345-806">Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.</span><span class="sxs-lookup"><span data-stu-id="45345-806">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-807"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-807"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-808">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-808">-or-</span></span> 
 <span data-ttu-id="45345-809"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-809"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-810">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-810">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-811">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-811">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-812"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-812"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-813"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="45345-813"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-814">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-814">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-815">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-815">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-816"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-816"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-817">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-817">-or-</span></span> 
 <span data-ttu-id="45345-818"><paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-818"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-819">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-819">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-820">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-820">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-821">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-821">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-822">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-822">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-823">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-823">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-824">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-824">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="45345-825">O assembly é carregado usando o método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="45345-825">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-826">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-826">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-827">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-827">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-828">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-828">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-829">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-829">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-830">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-830">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="45345-831">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-831">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-832">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-832">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-833">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-833">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-834">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-834">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-835">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-835">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-836">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-836">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-837">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-837">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-838">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-838">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-839">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-839">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-840">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-840">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-841">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-841">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="45345-842">Informações usadas para autorizar a criação de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-842">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="45345-843">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-843">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-844">Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-844">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="45345-845">O valor de retorno precisa ser desencapsulado para acessar o objeto real.</span><span class="sxs-lookup"><span data-stu-id="45345-845">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-846">Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-846">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="45345-847">Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="45345-847">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="45345-848">No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-848">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="45345-849">Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos.</span><span class="sxs-lookup"><span data-stu-id="45345-849">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="45345-850">Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.</span><span class="sxs-lookup"><span data-stu-id="45345-850">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="45345-851">Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.</span><span class="sxs-lookup"><span data-stu-id="45345-851">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="45345-852">Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.</span><span class="sxs-lookup"><span data-stu-id="45345-852">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-853"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-853"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-854">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-854">-or-</span></span> 
 <span data-ttu-id="45345-855"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-855"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-856">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-856">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="45345-857">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-857">-or-</span></span> 
 <span data-ttu-id="45345-858"><paramref name="securityAttributes" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-858"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-859">Quando a política CAS herdada não está habilitada, <paramref name="securityAttributes" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-859">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-860">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-860">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-861"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-861"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-862"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="45345-862"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-863">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-863">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-864">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-864">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-865"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-865"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-866">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-866">-or-</span></span> 
<span data-ttu-id="45345-867">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-867">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-868">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-868">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="45345-869">Esta instância é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-869">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-870">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-870">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-871">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-871">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-872">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-872">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-873">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-873">to provide evidence.</span></span> <span data-ttu-id="45345-874">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-874">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-875">Cria uma nova instância de um tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-875">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-876">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-876">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-877">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-877">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="45345-878">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-878">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-879">O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-879">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-880">Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-880">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="45345-881">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-881">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-882">Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-882">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-883"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-883"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-884">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-884">-or-</span></span> 
 <span data-ttu-id="45345-885"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-885"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-886">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-886">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-887"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-887"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-888"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-888"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-889">Não foi encontrado nenhum construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="45345-889">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-890">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-890">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-891"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-891"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-892">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-892">-or-</span></span> 
<span data-ttu-id="45345-893">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-894">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-894">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-895">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-895">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-896">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-896">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-897">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-897">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-898">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-898">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-899">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly (consulte a propriedade <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="45345-899">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-900">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-900">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-901">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-901">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-902">Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-902">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-903">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-903">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-904">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-904">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-905">O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-905">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-906">Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-906">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="45345-907">Este método chama o construtor padrão para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="45345-907">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="45345-908">Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-908">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-909"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-909"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-910">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-910">-or-</span></span> 
 <span data-ttu-id="45345-911"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-911"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-912">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-912">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-913">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-913">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-914"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-914"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-915"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-915"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-916">Não foi encontrado nenhum construtor público sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="45345-916">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-917">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-917">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-918"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-918"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-919">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-919">-or-</span></span> 
<span data-ttu-id="45345-920">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-920">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-921">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-921">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-922">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-922">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-923">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-923">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-924">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-924">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-925">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-925">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-926">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-926">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-927">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-927">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-928">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-928">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-929">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-929">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-930">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-930">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="45345-931">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-931">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-932">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-932">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-933">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-933">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-934">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-934">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-935">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-935">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-936">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-936">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-937">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-937">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-938">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-938">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-939">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-939">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-940">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-940">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-941">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-941">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="45345-942">Cria uma nova instância do tipo indicado definido no arquivo do assembly especificado, determinando se a diferenciação entre maiúsculas e minúsculas é ignorada no nome do tipo; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-942">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-943">O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-943">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-944">Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-944">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-945">Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-945">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-946"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-946"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-947">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-947">-or-</span></span> 
 <span data-ttu-id="45345-948"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-948"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-949">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-949">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-950">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-950">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-951"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-951"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-952"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-952"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-953">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-953">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-954">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-954">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-955"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-955"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-956">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-956">-or-</span></span> 
 <span data-ttu-id="45345-957"><paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-957"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-958">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-958">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-959">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-959">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-960">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-960">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-961">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-961">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-962">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-962">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="45345-963">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-963">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="45345-964">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</span><span class="sxs-lookup"><span data-stu-id="45345-964">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="45345-965">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-965">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-966">Caso <paramref name="bindingAttr" /> seja zero, uma pesquisa que diferencia maiúsculas de minúsculas para construtores públicos é realizada.</span><span class="sxs-lookup"><span data-stu-id="45345-966">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="45345-967">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-967">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="45345-968">Caso <paramref name="binder" /> seja nulo, o associador padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-968">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="45345-969">Os argumentos a serem passados para o construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-969">The arguments to pass to the constructor.</span></span> <span data-ttu-id="45345-970">Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="45345-970">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="45345-971">Caso o construtor padrão seja preferido, <paramref name="args" /> deve ser uma matriz vazia ou nula.</span><span class="sxs-lookup"><span data-stu-id="45345-971">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="45345-972">Informações específicas de cultura que controlam a coerção de <paramref name="args" /> para os tipos formais declarados do construtor <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-972">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="45345-973">Caso <paramref name="culture" /> seja <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> para o thread atual é usado.</span><span class="sxs-lookup"><span data-stu-id="45345-973">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="45345-974">Uma matriz de um ou mais atributos que podem participar da ativação.</span><span class="sxs-lookup"><span data-stu-id="45345-974">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="45345-975">Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="45345-975">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="45345-976">Esse parâmetro está relacionado a objetos ativados pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="45345-976">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="45345-977">A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="45345-977">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="45345-978">Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="45345-978">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="45345-979">Informações usadas para autorizar a criação de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-979">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="45345-980">Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-980">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="45345-981">O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-981">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-982">Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-982">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-983">Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-983">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-984"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-984"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-985">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-985">-or-</span></span> 
 <span data-ttu-id="45345-986"><paramref name="typeName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-986"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-987">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="45345-987">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-988">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-988">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-989"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-989"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="45345-990"><paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-990"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-991">Nenhum construtor público correspondente foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-991">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="45345-992">O chamador não tem permissão suficiente para chamar esse construtor.</span><span class="sxs-lookup"><span data-stu-id="45345-992">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-993"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-993"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-994">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-994">-or-</span></span> 
<span data-ttu-id="45345-995">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-995">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-996">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-996">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="45345-997">para a capacidade de ler o arquivo que contém o manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-997">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="45345-998">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="45345-998">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-999">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-999">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1000">Obtém o domínio de aplicativo atual do <see cref="T:System.Threading.Thread" /> atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1000">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="45345-1001">O domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1001">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45345-1002">O exemplo de código a seguir cria um novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1002">The following code example creates a new application domain.</span></span> <span data-ttu-id="45345-1003">O <xref:System.AppDomain.CurrentDomain%2A> propriedade é usada para obter um <xref:System.AppDomain> objeto que representa o domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1003">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="45345-1004">O <xref:System.AppDomain.FriendlyName%2A> propriedade fornece o nome do domínio do aplicativo atual, em seguida, é exibido na linha de comando.</span><span class="sxs-lookup"><span data-stu-id="45345-1004">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-1005">Define um assembly dinâmico no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1005">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1006">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1006">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1007">O modo de acesso para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1007">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1008">Define um assembly dinâmico com o nome e o modo de acesso especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1008">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="45345-1009">Um assembly dinâmico com o nome e o modo de acesso especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1009">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1010">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1010">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1011">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1011">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1012">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1012">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1013">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1013">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1014">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1014">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1015">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1015">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1016">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1016">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1017">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1017">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1018"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1018"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1019">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1019">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1020">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1020">-or-</span></span> 
<span data-ttu-id="45345-1021">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1021">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1022">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1022">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1023">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1023">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1024">O modo de acesso para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1024">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="45345-1025">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1025">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="45345-1026">Define um assembly dinâmico com o nome, o modo de acesso e os atributos personalizados especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1026">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-1027">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1027">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1028">Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1028">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="45345-1029">Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1029">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="45345-1030">Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1030">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1031">Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="45345-1031">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="45345-1032">Essa sobrecarga de método é apresentada na [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="45345-1032">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1033">O exemplo de código a seguir mostra como criar um assembly dinâmico que tem o <xref:System.Security.SecurityTransparentAttribute>.</span><span class="sxs-lookup"><span data-stu-id="45345-1033">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="45345-1034">O atributo deve ser especificado como um elemento de uma matriz de <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos.</span><span class="sxs-lookup"><span data-stu-id="45345-1034">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="45345-1035">A primeira etapa na criação de <xref:System.Reflection.Emit.CustomAttributeBuilder> é obter um construtor para o atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1035">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="45345-1036">O construtor não tem parâmetros, portanto, o <xref:System.Type.GetConstructor%2A> método for chamado com uma matriz vazia do <xref:System.Type> objetos para representar os tipos dos parâmetros.</span><span class="sxs-lookup"><span data-stu-id="45345-1036">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="45345-1037">A segunda etapa é passar resultante <xref:System.Reflection.ConstructorInfo> objeto para o construtor para o <xref:System.Reflection.Emit.CustomAttributeBuilder> classe, juntamente com uma matriz vazia do tipo <xref:System.Object> para representar os argumentos.</span><span class="sxs-lookup"><span data-stu-id="45345-1037">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="45345-1038">Resultante <xref:System.Reflection.Emit.CustomAttributeBuilder> é então passado para o <xref:System.AppDomain.DefineDynamicAssembly%2A> método como o único elemento de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="45345-1038">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="45345-1039">O exemplo de código define um módulo e um tipo no novo assembly dinâmico e, em seguida, exibe os atributos do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1039">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1040"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1040"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1041">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1041">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1042">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1042">-or-</span></span> 
<span data-ttu-id="45345-1043">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1043">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1044">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1044">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1045">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1045">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1046">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1046">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1047">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1047">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1048">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1048">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="45345-1049">Define um assembly dinâmico usando o nome, o modo de acesso e a evidência especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1049">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="45345-1050">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1050">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1051">Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1051">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1052">O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1052">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1053">Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo.</span><span class="sxs-lookup"><span data-stu-id="45345-1053">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="45345-1054">Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.</span><span class="sxs-lookup"><span data-stu-id="45345-1054">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1055">Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1055">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="45345-1056">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1056">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1057">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1057">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1058">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1058">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1059">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1059">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1060">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1060">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1061">O exemplo a seguir demonstra a <xref:System.AppDomain.DefineDynamicAssembly%2A> método e o <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-1061">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1062">Primeiro, o exemplo de código tenta criar uma instância de `MyDynamicType` chamando o <xref:System.AppDomain.CreateInstance%2A> método com um nome de assembly inválido e captura a exceção resultante.</span><span class="sxs-lookup"><span data-stu-id="45345-1062">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="45345-1063">O exemplo de código, em seguida, adiciona um manipulador de eventos para o <xref:System.AppDomain.AssemblyResolve> evento e novamente tenta criar uma instância de`MyDynamicType`.</span><span class="sxs-lookup"><span data-stu-id="45345-1063">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="45345-1064">Durante a chamada para <xref:System.AppDomain.CreateInstance%2A>, o <xref:System.AppDomain.AssemblyResolve> é gerado para o assembly inválido.</span><span class="sxs-lookup"><span data-stu-id="45345-1064">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="45345-1065">O manipulador de eventos cria um assembly dinâmico que contém um tipo chamado `MyDynamicType`, fornece o tipo de um construtor sem parâmetros e retorna o novo assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1065">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="45345-1066">A chamada para <xref:System.AppDomain.CreateInstance%2A> , em seguida, for concluída com êxito e o construtor para `MyDynamicType` exibe uma mensagem no console.</span><span class="sxs-lookup"><span data-stu-id="45345-1066">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1067"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1067"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1068">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1068">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1069">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1069">-or-</span></span> 
<span data-ttu-id="45345-1070">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1070">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1071">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1071">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1072">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1072">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1073">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1073">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1074">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1074">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1075">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1075">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1076">O nome do diretório onde o assembly será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1076">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="45345-1077">Caso <paramref name="dir" /> seja <see langword="null" />, o diretório usa como padrão o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1077">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="45345-1078">Define um assembly dinâmico usando o nome, o modo de acesso e o diretório de armazenamento especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1078">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="45345-1079">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1079">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1080">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1080">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1081">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1081">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1082">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1082">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1083">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1083">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1084">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1084">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1085">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1085">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1086">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1086">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1087">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1087">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1088"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1088"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1089">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1089">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1090">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1090">-or-</span></span> 
<span data-ttu-id="45345-1091">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1091">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1092">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1092">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1093">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1093">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1094">O modo de acesso para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1094">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="45345-1095">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1095">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="45345-1096">A origem do contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="45345-1096">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="45345-1097">Define um assembly dinâmico com o nome, o modo de acesso e os atributos personalizados especificados e usando a origem especificada para o seu contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="45345-1097">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="45345-1098">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1098">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1099">Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1099">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="45345-1100">Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1100">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="45345-1101">Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1101">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1102">Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="45345-1102">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1103"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1103"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1104">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1104">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1105">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1105">-or-</span></span> 
<span data-ttu-id="45345-1106">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1106">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1107">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1107">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="45345-1108">O valor de <paramref name="securityContextSource" /> não era um dos valores de enumeração.</span><span class="sxs-lookup"><span data-stu-id="45345-1108">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1109">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1109">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1110">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1110">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1111">O nome do diretório onde o assembly será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1111">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="45345-1112">Caso <paramref name="dir" /> seja <see langword="null" />, o diretório usa como padrão o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1112">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1113">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1113">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1114">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1114">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="45345-1115">Define um assembly dinâmico usando o nome, o modo de acesso, o diretório de armazenamento e a evidência especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1115">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="45345-1116">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1116">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1117">Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1117">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1118">O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1118">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1119">Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo.</span><span class="sxs-lookup"><span data-stu-id="45345-1119">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="45345-1120">Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.</span><span class="sxs-lookup"><span data-stu-id="45345-1120">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1121">Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1121">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="45345-1122">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1122">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1123">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1123">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1124">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1124">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1125">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1125">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1126">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1126">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1127">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1127">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1128">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1128">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1129">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1129">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1130"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1130"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1131">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1131">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1132">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1132">-or-</span></span> 
<span data-ttu-id="45345-1133">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1133">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1134">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1134">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1135">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1135">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1136">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1137">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1137">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1138">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1138">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1139">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1139">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1140">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1140">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1141">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1141">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="45345-1142">Define um assembly dinâmico usando o nome, o modo de acesso e as solicitações de permissão especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1142">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="45345-1143">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1143">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1144">As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1144">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="45345-1145">Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo no disco, use uma sobrecarga da <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence> objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-1145">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1146">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1146">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1147">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1147">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1148">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1148">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1149">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1149">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1150">Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="45345-1150">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1151">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1151">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1152">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1152">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1153">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1153">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1154"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1155">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1155">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1156">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1156">-or-</span></span> 
<span data-ttu-id="45345-1157">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1157">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1158">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1158">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1159">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1159">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1160">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1160">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1161">O nome do diretório no qual o assembly dinâmico será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1161">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="45345-1162">Se <paramref name="dir" /> for <see langword="null" />, o diretório atual será usado.</span><span class="sxs-lookup"><span data-stu-id="45345-1162">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="45345-1163"><see langword="true" /> para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1163"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="45345-1164">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1164">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="45345-1165">Define um assembly dinâmico usando o nome, o modo de acesso, o diretório de armazenamento e a opção de sincronização especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1165">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="45345-1166">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1166">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1167">Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1167">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="45345-1168">Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1168">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="45345-1169">Se `isSynchronized` está `true`, os seguintes métodos da resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1169">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="45345-1170">Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro seja concluído.</span><span class="sxs-lookup"><span data-stu-id="45345-1170">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1171"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1171"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1172">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1172">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1173">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1173">-or-</span></span> 
<span data-ttu-id="45345-1174">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1174">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1175">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1175">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1176">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1176">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1177">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1177">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1178">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1178">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1179">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1179">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1180">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1180">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1181">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1181">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1182">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1182">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="45345-1183">Define um assembly dinâmico usando o nome, o modo de acesso, a evidência e as solicitações de permissão especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1183">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="45345-1184">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1184">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1185">As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1185">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1186">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1186">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1187">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1187">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1188">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1188">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1189">Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1189">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1190">O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1190">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1191">Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo.</span><span class="sxs-lookup"><span data-stu-id="45345-1191">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="45345-1192">Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.</span><span class="sxs-lookup"><span data-stu-id="45345-1192">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1193">Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1193">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="45345-1194">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1194">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1195">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1195">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1196">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1196">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1197">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1197">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1198">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1198">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1199"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1199"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1200">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1200">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1201">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1201">-or-</span></span> 
<span data-ttu-id="45345-1202">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1202">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1203">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1203">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1204">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1204">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1205">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1205">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1206">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1206">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1207">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1207">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1208">O nome do diretório onde o assembly será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1208">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="45345-1209">Caso <paramref name="dir" /> seja <see langword="null" />, o diretório usa como padrão o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1209">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1210">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1210">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1211">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1211">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1212">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1212">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="45345-1213">Define um assembly dinâmico usando o nome, o modo de acesso, o diretório de armazenamento e as solicitações de permissão especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1213">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="45345-1214">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1214">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1215">As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1215">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="45345-1216">Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo no disco, use uma sobrecarga da <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence> objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-1216">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1217">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1217">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1218">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1218">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1219">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1219">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1220">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1220">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1221">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1221">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1222">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1222">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1223">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1223">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1224">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1224">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1225"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1225"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1226">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1226">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1227">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1227">-or-</span></span> 
<span data-ttu-id="45345-1228">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1228">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1229">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1229">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1230">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1230">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1231">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1231">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1232">O nome do diretório onde o assembly será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1232">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="45345-1233">Caso <paramref name="dir" /> seja <see langword="null" />, o diretório usa como padrão o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1233">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1234">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1234">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1235">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1235">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1236">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1236">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1237">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1237">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1238">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1238">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="45345-1239">Define um assembly dinâmico usando o nome, o modo de acesso, o diretório de armazenamento, a evidência e as solicitações de permissão especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1239">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="45345-1240">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1240">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1241">As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1241">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1242">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1242">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1243">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1243">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1244">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1244">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1245">Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1245">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1246">O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1246">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1247">Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo.</span><span class="sxs-lookup"><span data-stu-id="45345-1247">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="45345-1248">Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.</span><span class="sxs-lookup"><span data-stu-id="45345-1248">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1249">Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1249">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="45345-1250">Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1250">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="45345-1251">Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1251">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1252">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1252">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1253">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1253">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1254">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1254">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1255"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1255"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1256">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1256">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1257">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1257">-or-</span></span> 
<span data-ttu-id="45345-1258">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1258">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1259">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1259">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1260">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1260">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1261">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1262">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1262">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1263">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1263">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1264">O nome do diretório no qual o assembly dinâmico será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1264">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="45345-1265">Caso <paramref name="dir" /> seja <see langword="null" />, o diretório usa como padrão o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1265">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1266">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1266">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1267">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1267">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1268">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1268">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1269">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1269">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1270">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1270">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="45345-1271"><see langword="true" /> para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1271"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="45345-1272">Define um assembly dinâmico usando o nome, o modo de acesso, o diretório de armazenamento, a evidência, as solicitações de permissão e a opção de sincronização especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1272">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="45345-1273">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1273">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1274">As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1274">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1275">Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> em `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="45345-1275">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="45345-1276">A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1276">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="45345-1277">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1277">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1278">Somente os chamadores totalmente confiáveis podem fornecer a seu evidência ao definir um dinâmico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="45345-1278">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1279">O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1279">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1280">Parcialmente confiáveis os chamadores devem fornecer `null` para o `evidence` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="45345-1280">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="45345-1281">Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.</span><span class="sxs-lookup"><span data-stu-id="45345-1281">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1282">Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1282">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="45345-1283">Se `isSynchronized` está `true`, os seguintes métodos da resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1283">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="45345-1284">Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro seja concluído.</span><span class="sxs-lookup"><span data-stu-id="45345-1284">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1285">O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.</span><span class="sxs-lookup"><span data-stu-id="45345-1285">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="45345-1286">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1286">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1287">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1287">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1288"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1289">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1289">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1290">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1290">-or-</span></span> 
<span data-ttu-id="45345-1291">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1291">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1292">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1292">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1293">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1293">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1294">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1295">A identidade exclusiva do assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1295">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="45345-1296">O modo no qual o assembly dinâmico será acessado.</span><span class="sxs-lookup"><span data-stu-id="45345-1296">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="45345-1297">O nome do diretório no qual o assembly dinâmico será salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1297">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="45345-1298">Se <paramref name="dir" /> for <see langword="null" />, o diretório atual será usado.</span><span class="sxs-lookup"><span data-stu-id="45345-1298">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="45345-1299">A evidência fornecida para o assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="45345-1299">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="45345-1300">A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</span><span class="sxs-lookup"><span data-stu-id="45345-1300">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="45345-1301">A solicitação de permissões obrigatória.</span><span class="sxs-lookup"><span data-stu-id="45345-1301">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="45345-1302">A solicitação de permissões opcional.</span><span class="sxs-lookup"><span data-stu-id="45345-1302">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="45345-1303">A solicitação de permissões recusada.</span><span class="sxs-lookup"><span data-stu-id="45345-1303">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="45345-1304"><see langword="true" /> para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1304"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="45345-1305">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1305">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="45345-1306">Define um assembly dinâmico com o nome, o modo de acesso, o diretório de armazenamento, a evidência, as solicitações de permissão, a opção de sincronização e os atributos personalizados especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1306">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="45345-1307">Um assembly dinâmico com o nome e os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1307">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1308">Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1308">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="45345-1309">Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1309">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="45345-1310">As solicitações de permissão especificadas para o `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parâmetros são usados somente se o `evidence` também o parâmetro for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.</span><span class="sxs-lookup"><span data-stu-id="45345-1310">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1311">Ao desenvolver o código que emite assemblies dinâmicos, é recomendável que você inclua o <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> sinalizador no `refusedPermissions` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="45345-1311">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="45345-1312">A inclusão desse sinalizador garante que a Microsoft intermediate language (MSIL) será verificada.</span><span class="sxs-lookup"><span data-stu-id="45345-1312">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="45345-1313">Essa técnica irá detectar a geração não intencional de código não verificado, o que, normalmente, é muito difícil de detectar.</span><span class="sxs-lookup"><span data-stu-id="45345-1313">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="45345-1314">Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> seja gerada quando ele é usado com o código que exige confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1314">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="45345-1315">Somente os chamadores totalmente confiáveis podem fornecer a evidência ao definir um dinâmico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="45345-1315">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="45345-1316">O tempo de execução mapeia a <xref:System.Security.Policy.Evidence> por meio da política de segurança para determinar as permissões concedidas.</span><span class="sxs-lookup"><span data-stu-id="45345-1316">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="45345-1317">Parcialmente confiáveis os chamadores devem fornecer `null` para o `evidence` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="45345-1317">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="45345-1318">Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões (isto é, a concessão atual e negar conjuntos) do assembly do chamador para o assembly dinâmico que está sendo definido e marca a política como resolvido.</span><span class="sxs-lookup"><span data-stu-id="45345-1318">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="45345-1319">Se o assembly dinâmico é salvo em disco, subsequente cargas obterão concessões com base nas políticas que estão associadas com o local onde o assembly dinâmico foi salvo.</span><span class="sxs-lookup"><span data-stu-id="45345-1319">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="45345-1320">Se `isSynchronized` está `true`, os seguintes métodos da resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1320">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="45345-1321">Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro seja concluído.</span><span class="sxs-lookup"><span data-stu-id="45345-1321">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="45345-1322">Essa sobrecarga de método é apresentada na [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="45345-1322">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1323"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1323"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-1324">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1324">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="45345-1325">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1325">-or-</span></span> 
<span data-ttu-id="45345-1326">A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="45345-1326">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1327">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1327">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1328">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1328">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1329">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1329">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="45345-1330">Um delegado que especifica um método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="45345-1330">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="45345-1331">Executa o código em outro domínio de aplicativo que é identificado pelo delegado especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1331">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1332">`callBackDelegate` pode especificar um marshaling por valor, <xref:System.MarshalByRefObject>, ou <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="45345-1332">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1333">O exemplo a seguir demonstra o uso estático <xref:System.AppDomain.DoCallBack%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1333">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="45345-1334">O exemplo a seguir demonstra como usar o <xref:System.AppDomain.DoCallBack%2A> método por valor.</span><span class="sxs-lookup"><span data-stu-id="45345-1334">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="45345-1335">O exemplo a seguir demonstra como usar o <xref:System.AppDomain.DoCallBack%2A> método por referência.</span><span class="sxs-lookup"><span data-stu-id="45345-1335">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1336"><paramref name="callBackDelegate" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1336"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1337">Obtém o Gerenciador de domínio que foi fornecido pelo host quando o domínio do aplicativo foi inicializado.</span><span class="sxs-lookup"><span data-stu-id="45345-1337">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="45345-1338">Um objeto que representa o gerenciador de domínio fornecido pelo host quando o domínio do aplicativo foi inicializado ou <see langword="null" /> se nenhum gerenciador de domínio foi fornecido.</span><span class="sxs-lookup"><span data-stu-id="45345-1338">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1339">Um host não gerenciado do common language runtime (CLR) pode fornecer um Gerenciador de domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-1339">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="45345-1340">O Gerenciador de domínio pode participar ao inicializar o novo domínio de aplicativo e fornecer outros gerentes, como um <xref:System.Security.HostSecurityManager>, que participam em operações de domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1340">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-1341">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-1341">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-1342">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-1342">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1343">Ocorre quando um <see cref="T:System.AppDomain" /> está prestes a ser descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1343">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1344">O <xref:System.EventHandler> delegado para esse evento pode executar todas as atividades de encerramento antes que o domínio do aplicativo seja descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1344">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="45345-1345">Cada domínio de aplicativo que precisa executar o processamento quando ela for descarregada deve registrar um manipulador de eventos para este evento.</span><span class="sxs-lookup"><span data-stu-id="45345-1345">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="45345-1346">Um manipulador de eventos compartilhado não deve ser usado, pois o <xref:System.EventHandler> delegado não identifica o domínio que está sendo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1346">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1347">Esse evento nunca é gerado no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-1347">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="45345-1348">Não faça suposições sobre o evento é gerado no thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1348">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="45345-1349">O evento pode ser gerado em um thread diferente daquele que chamou o <xref:System.AppDomain.Unload%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1349">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1350">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1350">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1351">Obtém o diretório que usa o resolvedor de assembly para sondar assemblies criados dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-1351">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="45345-1352">O diretório que usa o resolvedor de assembly para sondar assemblies criados dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="45345-1352">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1353">Para definir o diretório dinâmico, atribua um caminho de diretório base para o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade do <xref:System.AppDomainSetup> objeto que será usado para criar o novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1353">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="45345-1354">O caminho do diretório base atribuir à propriedade é modificado pela adição de um subdiretório, cujo nome simple é o código hash da cadeia de caracteres que você atribuir à <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriedade, portanto, é o formato do diretório base *caminho original* \\ *o código hash*.</span><span class="sxs-lookup"><span data-stu-id="45345-1354">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="45345-1355">O diretório dinâmico é um subdiretório desse diretório base.</span><span class="sxs-lookup"><span data-stu-id="45345-1355">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="45345-1356">Seu nome simple é o valor da <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriedade, portanto, seu formato é *caminho original*\\*código hash*\\*nome do aplicativo*.</span><span class="sxs-lookup"><span data-stu-id="45345-1356">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1357">O exemplo a seguir cria um domínio de aplicativo com um diretório para assemblies dinâmicos, emite um assembly dinâmico e armazena-o no diretório dinâmico e, em seguida, carrega o assembly no novo domínio do aplicativo e usa-o.</span><span class="sxs-lookup"><span data-stu-id="45345-1357">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="45345-1358">O exemplo cria um <xref:System.AppDomainSetup> objeto e define seu <xref:System.AppDomainSetup.ApplicationName%2A> propriedade como "Exemplo" e seu <xref:System.AppDomainSetup.DynamicBase%2A> propriedade como "C:\DynamicAssemblyDir".</span><span class="sxs-lookup"><span data-stu-id="45345-1358">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="45345-1359">O exemplo, em seguida, exibe o <xref:System.AppDomainSetup.DynamicBase%2A> propriedade, para mostrar que o código hash do nome do aplicativo foi acrescentado como uma subpasta do caminho que foi originalmente atribuída.</span><span class="sxs-lookup"><span data-stu-id="45345-1359">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1360">O diretório base neste exemplo destina-se a ser fora do caminho de investigação para o aplicativo de exemplo.</span><span class="sxs-lookup"><span data-stu-id="45345-1360">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="45345-1361">Certifique-se de compilar o exemplo em um local diferente.</span><span class="sxs-lookup"><span data-stu-id="45345-1361">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="45345-1362">Exclua o diretório base e todos os seus subdiretórios cada vez que você executar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="45345-1362">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="45345-1363">O exemplo cria um novo domínio de aplicativo, usando o <xref:System.AppDomainSetup> objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-1363">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="45345-1364">O exemplo usa o <xref:System.AppDomain.DynamicDirectory%2A> propriedade para recuperar o nome do diretório, para que ele possa criar o diretório.</span><span class="sxs-lookup"><span data-stu-id="45345-1364">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="45345-1365">(O exemplo pode facilmente criar o diretório com antecedência concatenando o caminho original, o código hash do nome do aplicativo e o nome do aplicativo.)</span><span class="sxs-lookup"><span data-stu-id="45345-1365">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="45345-1366">O exemplo possui um `GenerateDynamicAssembly` método que emite um assembly denominado `DynamicHelloWorld.dll` e os armazena no diretório de dinâmico do novo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1366">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="45345-1367">O assembly dinâmico contém um tipo, `HelloWorld`, que tem um método estático (`Shared` método no Visual Basic) denominada `HelloFromAD`.</span><span class="sxs-lookup"><span data-stu-id="45345-1367">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="45345-1368">Chamar esse método exibe o nome do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1368">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="45345-1369">O `Example` classe deriva <xref:System.MarshalByRefObject>, portanto, o exemplo pode criar uma instância da classe na novo domínio de aplicativo e chame seu `Test` método.</span><span class="sxs-lookup"><span data-stu-id="45345-1369">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="45345-1370">O `Test` método carrega o assembly dinâmico por seu nome de exibição e chama estático `HelloFromAD` método.</span><span class="sxs-lookup"><span data-stu-id="45345-1370">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="45345-1371">Você pode mostrar que o diretório dinâmico é pesquisado após os caminhos de investigação normais, escrevendo código para um assembly denominado `DynamicHelloWorld.dll` e compilando-o no mesmo diretório que este exemplo.</span><span class="sxs-lookup"><span data-stu-id="45345-1371">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="45345-1372">O assembly deve ter uma classe chamada `HelloWorld` com um método estático denominado `HelloFromAD`.</span><span class="sxs-lookup"><span data-stu-id="45345-1372">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="45345-1373">Esse método não precisa ter a mesma funcionalidade que o exemplo; ele simplesmente pode exibir uma cadeia de caracteres para o console.</span><span class="sxs-lookup"><span data-stu-id="45345-1373">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="45345-1374">O assembly deve ter também um <xref:System.Reflection.AssemblyVersionAttribute> atributo que define sua versão para 1.0.0.0.</span><span class="sxs-lookup"><span data-stu-id="45345-1374">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="45345-1375">Quando você executar o exemplo, o assembly compilado no diretório atual é encontrado antes que o diretório dinâmico é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="45345-1375">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1376">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1376">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1377">para acesso às informações de caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1377">for access to the path information.</span></span> <span data-ttu-id="45345-1378">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1378">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1379">Obtém a <see cref="T:System.Security.Policy.Evidence" /> associada a esse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1379">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="45345-1380">A evidência associada a esse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1380">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1381">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1381">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1382">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1382">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1383">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1383">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="45345-1384">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1384">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-1385">Executa o assembly contido no arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1385">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1386">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1386">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="45345-1387">Executa o assembly contido no arquivo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1387">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="45345-1388">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1388">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1389">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1389">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1390">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1390">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1391">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1391">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1392">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1392">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1393">Para criar o <xref:System.AppDomain> para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1393">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1394">O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1394">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1395"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1395"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1396"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1396"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1397"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1397"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1398">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1398">-or-</span></span> 
<span data-ttu-id="45345-1399">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1399">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1400">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1400">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1401">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1401">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1402">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1402">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1403">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1404">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1405">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1405">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1406">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1406">to execute a console application.</span></span> <span data-ttu-id="45345-1407">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1407">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1408">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1408">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1409">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1409">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1410">Executa o assembly contido no arquivo especificado usando a evidência especificada.</span><span class="sxs-lookup"><span data-stu-id="45345-1410">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="45345-1411">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1411">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1412">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1412">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1413">O <xref:System.AppDomain.ExecuteAssembly%2A> método não cria um novo processo ou o domínio de aplicativo, e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1413">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1414">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1414">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1415">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1415">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1416">O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1416">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1417"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1417"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1418"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1418"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1419"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1419"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1420">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1420">-or-</span></span> 
<span data-ttu-id="45345-1421">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1421">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1422">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1422">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1423">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1423">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1424">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1424">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1425">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1425">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1426">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1427">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1427">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1428">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1428">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1429">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1429">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1430">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1430">to execute a console application.</span></span> <span data-ttu-id="45345-1431">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1431">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1432">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1432">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1433">Os argumentos para o ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1433">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1434">Executa o assembly contido no arquivo especificado usando argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1434">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1435">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1435">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1436">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1436">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1437">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1437">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1438">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1438">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1439">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1439">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1440">O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1440">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1441"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1441"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1442"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1442"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1443"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1443"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1444">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1444">-or-</span></span> 
 <span data-ttu-id="45345-1445"><paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-1445"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1446">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1446">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1447">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1447">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1448">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1448">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1449">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1449">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1450">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1450">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1451">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1451">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1452">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1452">to execute a console application.</span></span> <span data-ttu-id="45345-1453">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1453">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1454">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1454">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1455">A evidência fornecida para o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1455">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1456">Os argumentos para o ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1456">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1457">Executa o assembly contido no arquivo especificado, usando a evidência e os argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1457">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1458">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1458">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1459">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1459">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1460">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1460">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1461">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1461">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1462">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1462">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1463">O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1463">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1464"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1464"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1465"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1465"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1466"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1466"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1467">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1467">-or-</span></span> 
<span data-ttu-id="45345-1468">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1468">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1469">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1470">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1470">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-1471"><paramref name="assemblySecurity" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1471"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-1472">Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1472">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1473">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1473">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1474">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1474">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1475">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1475">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1476">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1476">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1477">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1477">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1478">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1478">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1479">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1479">to execute a console application.</span></span> <span data-ttu-id="45345-1480">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1480">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1481">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1481">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1482">Os argumentos para o ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1482">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="45345-1483">Representa o valor do código hash computado.</span><span class="sxs-lookup"><span data-stu-id="45345-1483">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="45345-1484">Representa o algoritmo de hash usado pelo manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1484">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="45345-1485">Executa o assembly contido no arquivo especificado usando os argumentos, o valor de hash e o algoritmo de hash especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1485">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="45345-1486">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1486">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1487">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1487">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1488">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1488">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1489">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1489">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1490">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1490">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1491">O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1491">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1492"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1492"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1493"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1493"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1494"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1494"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1495">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1495">-or-</span></span> 
 <span data-ttu-id="45345-1496"><paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-1496"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1497">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1497">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1498">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1498">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1499">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1499">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1500">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1500">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1501">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1501">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1502">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1502">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1503">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1503">to execute a console application.</span></span> <span data-ttu-id="45345-1504">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1504">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="45345-1505">O nome do arquivo que contém o assembly a ser executado.</span><span class="sxs-lookup"><span data-stu-id="45345-1505">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1506">A evidência fornecida para o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1506">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1507">Os argumentos para o ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1507">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="45345-1508">Representa o valor do código hash computado.</span><span class="sxs-lookup"><span data-stu-id="45345-1508">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="45345-1509">Representa o algoritmo de hash usado pelo manifesto do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1509">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="45345-1510">Executa o assembly contido no arquivo especificado usando a evidência, os argumentos, o valor de hash e o algoritmo de hash especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1510">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="45345-1511">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1511">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1512">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1512">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1513">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1513">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1514">Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1514">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="45345-1515">Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1515">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1516">Exemplo de asseguintes demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1516">Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1517"><paramref name="assemblyFile" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1517"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1518"><paramref name="assemblyFile" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1518"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1519"><paramref name="assemblyFile" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1519"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1520">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1520">-or-</span></span> 
<span data-ttu-id="45345-1521">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1521">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1522">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1522">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1523">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1523">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-1524"><paramref name="assemblySecurity" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1524"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-1525">Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1525">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1526">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1526">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1527">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1527">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1528">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1529">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1529">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1530">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1530">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1531">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1531">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1532">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1532">to execute a console application.</span></span> <span data-ttu-id="45345-1533">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1533">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-1534">Executa um assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1534">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1535">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1535">The display name of the assembly.</span></span> <span data-ttu-id="45345-1536">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1536">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="45345-1537">Executa um assembly dado seu nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="45345-1537">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="45345-1538">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1538">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1539">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1539">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1540">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1540">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1541">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1541">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1542">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1542">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="45345-1543">Para criar o <xref:System.AppDomain> para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1543">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1544"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1544"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1545">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1545">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1546">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1546">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1547">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1547">-or-</span></span> 
<span data-ttu-id="45345-1548">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1548">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1549">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1549">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1550">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1550">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1551">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1551">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1552">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1552">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1553">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1553">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1554">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1554">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1555">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1555">to execute a console application.</span></span> <span data-ttu-id="45345-1556">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1556">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1557">Um objeto <see cref="T:System.Reflection.AssemblyName" /> que representa o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1557">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1558">Argumentos de linha de comando a serem passados durante o início do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1558">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="45345-1559">Executa o assembly dado um <see cref="T:System.Reflection.AssemblyName" /> usando os argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1559">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1560">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1560">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1561">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1561">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1562">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1562">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1563">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1563">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1564">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1564">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1565">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1565">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1566">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1566">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1567">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1567">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1568">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1568">-or-</span></span> 
 <span data-ttu-id="45345-1569"><paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-1569"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1570">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1570">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1571">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1571">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1572">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1572">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1573">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1573">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1574">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1574">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1575">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1575">to execute a console application.</span></span> <span data-ttu-id="45345-1576">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1576">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1577">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1577">The display name of the assembly.</span></span> <span data-ttu-id="45345-1578">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1578">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1579">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1579">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1580">Executa um assembly dado seu nome de exibição usando a evidência especificada.</span><span class="sxs-lookup"><span data-stu-id="45345-1580">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="45345-1581">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1581">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1582">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1582">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1583">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1583">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1584">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1584">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1585">O <xref:System.AppDomain.ExecuteAssemblyByName%2A> método não cria um novo processo ou o domínio de aplicativo, e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1585">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1586">Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="45345-1586">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="45345-1587">Partes de evidências fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="45345-1587">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1588"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1588"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1589">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1589">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1590">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1590">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1591">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1591">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1592">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1592">-or-</span></span> 
<span data-ttu-id="45345-1593">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1593">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1594">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1594">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1595">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1595">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1596">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1596">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1597">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1597">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1598">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1598">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1599">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1599">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1600">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1600">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1601">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1601">to execute a console application.</span></span> <span data-ttu-id="45345-1602">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1602">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1603">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1603">The display name of the assembly.</span></span> <span data-ttu-id="45345-1604">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1604">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1605">Argumentos de linha de comando a serem passados durante o início do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1605">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="45345-1606">Executa o assembly dado seu nome de exibição usando os argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1606">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1607">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1607">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1608">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1608">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1609">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1609">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1610">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1610">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1611">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1611">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1612"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1612"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1613">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1613">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1614">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1614">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1615">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1615">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1616">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1616">-or-</span></span> 
 <span data-ttu-id="45345-1617"><paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</span><span class="sxs-lookup"><span data-stu-id="45345-1617"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1618">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1618">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1619">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1619">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1620">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1620">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1621">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1621">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1622">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1622">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1623">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1623">to execute a console application.</span></span> <span data-ttu-id="45345-1624">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1624">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1625">Um objeto <see cref="T:System.Reflection.AssemblyName" /> que representa o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1625">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1626">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1626">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1627">Argumentos de linha de comando a serem passados durante o início do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1627">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="45345-1628">Executa o assembly dado um <see cref="T:System.Reflection.AssemblyName" /> usando a evidência e os argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1628">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1629">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1629">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1630">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1630">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1631">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1631">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1632">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1632">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1633">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1633">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1634">Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="45345-1634">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="45345-1635">Partes de evidências fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="45345-1635">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1636">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1636">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1637">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1637">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1638">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1638">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1639">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1639">-or-</span></span> 
<span data-ttu-id="45345-1640">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1640">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1641">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1641">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-1642"><paramref name="assemblySecurity" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1642"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-1643">Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1643">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1644">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1644">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1645">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1645">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1646">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1646">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1647">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1647">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1648">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1648">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1649">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1649">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1650">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1650">to execute a console application.</span></span> <span data-ttu-id="45345-1651">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1651">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="45345-1652">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1652">The display name of the assembly.</span></span> <span data-ttu-id="45345-1653">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1654">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1654">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="45345-1655">Argumentos de linha de comando a serem passados durante o início do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1655">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="45345-1656">Executa o assembly dado seu nome de exibição usando a evidência e os argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="45345-1656">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="45345-1657">O valor retornado pelo ponto de entrada do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1657">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1658">O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo.</span><span class="sxs-lookup"><span data-stu-id="45345-1658">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="45345-1659">Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1659">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1660">O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1660">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="45345-1661">Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1661">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1662">Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetro, partes de evidências são mesclados.</span><span class="sxs-lookup"><span data-stu-id="45345-1662">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="45345-1663">Partes de evidências fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidências fornecida pelo carregador.</span><span class="sxs-lookup"><span data-stu-id="45345-1663">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1664"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1664"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1665">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1665">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1666">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-1666">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1667">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1667">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1668">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1668">-or-</span></span> 
<span data-ttu-id="45345-1669">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1669">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1670">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1670">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-1671"><paramref name="assemblySecurity" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1671"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-1672">Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1672">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="45345-1673">O assembly especificado não tem ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="45345-1673">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1674">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1674">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="45345-1675">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1675">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1676">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1676">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1677">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1677">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1678">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</span><span class="sxs-lookup"><span data-stu-id="45345-1678">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="45345-1679">para executar um aplicativo de console.</span><span class="sxs-lookup"><span data-stu-id="45345-1679">to execute a console application.</span></span> <span data-ttu-id="45345-1680">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1680">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1681">Ocorre quando uma exceção é lançada no código gerenciado, antes que o tempo de execução procure na pilha de chamadas um manipulador de exceção no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1681">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1682">Esse evento é apenas uma notificação.</span><span class="sxs-lookup"><span data-stu-id="45345-1682">This event is only a notification.</span></span> <span data-ttu-id="45345-1683">Manipular esse evento não tratar a exceção ou afetar de qualquer forma de tratamento de exceções subsequentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1683">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="45345-1684">Depois que o evento foi gerado e manipuladores de eventos são chamados, o common language runtime (CLR) começa a procurar por um manipulador para a exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-1684">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="45345-1685"><xref:System.AppDomain.FirstChanceException> fornece o domínio de aplicativo com a primeira oportunidade de examinar qualquer exceção gerenciada.</span><span class="sxs-lookup"><span data-stu-id="45345-1685"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="45345-1686">O evento pode ser tratado por domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1686">The event can be handled per application domain.</span></span> <span data-ttu-id="45345-1687">Se um thread passa por vários domínios de aplicativo durante a execução de uma chamada, o evento é gerado em cada domínio de aplicativo que foi registrado um manipulador de eventos, antes que o CLR começa a procurar por um manipulador de exceção correspondente no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1687">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="45345-1688">Depois que o evento foi tratado, uma pesquisa é feita para um manipulador de exceção correspondente no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1688">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="45345-1689">Se nenhum for encontrado, o evento é gerado no próximo domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1689">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="45345-1690">Você deve lidar com todas as exceções que ocorrem no evento de manipulador para o <xref:System.AppDomain.FirstChanceException> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-1690">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="45345-1691">Caso contrário, <xref:System.AppDomain.FirstChanceException> é acionado recursivamente.</span><span class="sxs-lookup"><span data-stu-id="45345-1691">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="45345-1692">Isso pode resultar em um estouro de pilha e o encerramento do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1692">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="45345-1693">É recomendável que você implemente manipuladores de eventos para esse evento como regiões de execução restrita CERs (), para evitar exceções relacionadas à infraestrutura, como memória insuficiente ou estouro da pilha que afetam a máquina virtual enquanto a notificação de exceção que está sendo processada.</span><span class="sxs-lookup"><span data-stu-id="45345-1693">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="45345-1694">Esse evento não é gerado para exceções que indicam corrupção de estado do processo, como violações de acesso, a menos que o manipulador de eventos é crítico para segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-1694">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="45345-1695">O common language runtime suspende anulações de thread enquanto este evento de notificação está sendo manipulado.</span><span class="sxs-lookup"><span data-stu-id="45345-1695">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1696">O exemplo a seguir cria uma série de domínios de aplicativo chamada `AD0` por meio `AD3`, com um `Worker` objeto em cada domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1696">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="45345-1697">Cada `Worker` objeto tem uma referência para o `Worker` do objeto no próximo domínio de aplicativo, exceto para o `Worker` no último domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1697">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="45345-1698">O <xref:System.AppDomain.FirstChanceException> evento é manipulado em todos os domínios de aplicativo, exceto `AD1`.</span><span class="sxs-lookup"><span data-stu-id="45345-1698">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1699">Além de neste exemplo, que demonstra as notificações de exceção de primeira chance em vários domínios de aplicativo, você pode encontrar casos de uso simples em [como: Receber notificações de exceções de primeira Chance](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1699">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="45345-1700">Quando os domínios de aplicativo tiveram sido criados, o domínio de aplicativo padrão chama o `TestException` método para o primeiro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1700">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="45345-1701">Cada `Worker` objeto chamadas a `TestException` método para o próximo domínio de aplicativo, até que o último `Worker` gera uma exceção que é tratada ou sem tratamento.</span><span class="sxs-lookup"><span data-stu-id="45345-1701">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="45345-1702">Portanto, o thread atual passa por meio de todos os domínios de aplicativo, e `TestException` é adicionado à pilha em cada domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1702">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="45345-1703">Quando a última `Worker` objeto manipula a exceção, o <xref:System.AppDomain.FirstChanceException> é gerado apenas no último domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1703">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="45345-1704">Os outros domínios de aplicativo nunca ter uma chance para tratar a exceção, portanto, o evento não será gerado.</span><span class="sxs-lookup"><span data-stu-id="45345-1704">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="45345-1705">Quando a última `Worker` objeto não trata a exceção, o <xref:System.AppDomain.FirstChanceException> é gerado em cada domínio de aplicativo que tem um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-1705">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="45345-1706">Após cada manipulador de eventos, a pilha continua até que a exceção é capturada pelo domínio do aplicativo padrão de desenrolamento.</span><span class="sxs-lookup"><span data-stu-id="45345-1706">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1707">Para ver como a exibição de pilha aumenta à medida que o evento é gerado mais próximo e mais próximo ao domínio do aplicativo padrão, altere `e.Exception.Message` à `e.Exception` no `FirstChanceHandler` manipuladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-1707">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="45345-1708">Observe que, quando `TestException` é chamado nos limites do domínio de aplicativo, ele aparece duas vezes: uma vez para o proxy e outra para o stub.</span><span class="sxs-lookup"><span data-stu-id="45345-1708">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-1709">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-1709">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-1710">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-1710">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="45345-1711">Como receber notificações de exceções de primeira tentativa</span><span class="sxs-lookup"><span data-stu-id="45345-1711">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1712">Obtém o nome amigável desse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1712">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="45345-1713">O nome amigável desse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1713">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1714">O nome amigável do domínio de aplicativo padrão é o nome do arquivo do processo executável.</span><span class="sxs-lookup"><span data-stu-id="45345-1714">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="45345-1715">Por exemplo, se o executável usado para iniciar o processo será `"c:\MyAppDirectory\MyAssembly.exe"`, o nome amigável do domínio do aplicativo padrão é `"MyAssembly.exe"`.</span><span class="sxs-lookup"><span data-stu-id="45345-1715">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1716">O seguinte exemplo de código usa o <xref:System.AppDomain.FriendlyName%2A> propriedade para obter o nome amigável do domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1716">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="45345-1717">Para o domínio de aplicativo padrão, o nome amigável é o nome do arquivo executável do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1717">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="45345-1718">O exemplo de código também exibe informações adicionais sobre o domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1718">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1719">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1719">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1720">Obtém os assemblies que foram carregados no contexto de execução desse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1720">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="45345-1721">Uma matriz de assemblies nesse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1721">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45345-1722">O seguinte exemplo de código usa o <xref:System.AppDomain.GetAssemblies%2A> método para obter uma lista de todos os assemblies que foram carregados no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1722">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="45345-1723">Os assemblies são exibidos no console.</span><span class="sxs-lookup"><span data-stu-id="45345-1723">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="45345-1724">Para executar este exemplo de código, você precisará criar um assembly denominado `CustomLibrary.dll`, ou alterar o nome do assembly que é passado para o <xref:System.AppDomain.GetAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1724">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1725">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1725">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1726">Obtém o identificador atual de thread.</span><span class="sxs-lookup"><span data-stu-id="45345-1726">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="45345-1727">Um inteiro com sinal de 32 bits que é o identificador do thread atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1727">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1728">Use o <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propriedade, que é estável, mesmo quando o .NET Framework é hospedado por um ambiente que dá suporte a fibras (ou seja, threads leves).</span><span class="sxs-lookup"><span data-stu-id="45345-1728">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1729">para chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="45345-1729">to call this method.</span></span> <span data-ttu-id="45345-1730">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1730">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="45345-1731">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1731">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-1732">O nome de uma propriedade de domínio de aplicativo predefinida ou o nome de uma propriedade de domínio de aplicativo que você definiu.</span><span class="sxs-lookup"><span data-stu-id="45345-1732">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="45345-1733">Obtém o valor armazenado no domínio atual do aplicativo para o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1733">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="45345-1734">O valor da propriedade <paramref name="name" /> ou <see langword="null" /> se a propriedade não existir.</span><span class="sxs-lookup"><span data-stu-id="45345-1734">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1735">Use esse método para recuperar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="45345-1735">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="45345-1736">Observe que a comparação de `name` com o nome de pares chave-valor diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="45345-1736">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="45345-1737">O cache automaticamente contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-1737">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="45345-1738">Você pode inspecionar seus valores com o <xref:System.AppDomain.GetData%2A> método, ou equivalente <xref:System.AppDomainSetup> propriedades.</span><span class="sxs-lookup"><span data-stu-id="45345-1738">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="45345-1739">Você pode inserir ou modificar seus próprios pares de nome dados definidos pelo usuário com o <xref:System.AppDomain.SetData%2A> método e inspecionar seus valores com o <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1739">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="45345-1740">A tabela a seguir descreve o `name` de cada entrada do sistema e correspondente predefinidos <xref:System.AppDomainSetup> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-1740">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="45345-1741">Valor de 'name'</span><span class="sxs-lookup"><span data-stu-id="45345-1741">Value of 'name'</span></span>|<span data-ttu-id="45345-1742">Propriedade</span><span class="sxs-lookup"><span data-stu-id="45345-1742">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="45345-1743">"APPBASE"</span><span class="sxs-lookup"><span data-stu-id="45345-1743">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1744">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="45345-1744">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1745">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="45345-1745">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="45345-1746">(nenhuma propriedade)</span><span class="sxs-lookup"><span data-stu-id="45345-1746">(no property)</span></span><br /><br /> <span data-ttu-id="45345-1747">"APP_LAUNCH_URL" representa a URL originalmente solicitada pelo usuário, antes de qualquer redirecionamento.</span><span class="sxs-lookup"><span data-stu-id="45345-1747">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="45345-1748">Ele está disponível somente quando o aplicativo foi iniciado com um navegador como o Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="45345-1748">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="45345-1749">Nem todos os navegadores fornecem esse valor.</span><span class="sxs-lookup"><span data-stu-id="45345-1749">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="45345-1750">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="45345-1750">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1751">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="45345-1751">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1752">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="45345-1752">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1753">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="45345-1753">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1754">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="45345-1754">"DEV_PATH"</span></span>|<span data-ttu-id="45345-1755">(nenhuma propriedade)</span><span class="sxs-lookup"><span data-stu-id="45345-1755">(no property)</span></span>|  
|<span data-ttu-id="45345-1756">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="45345-1756">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1757">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="45345-1757">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1758">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="45345-1758">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1759">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="45345-1759">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1760">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="45345-1760">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1761">"LICENSE_FILE" ou uma cadeia de caracteres específica do aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-1761">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1762">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="45345-1762">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1763">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="45345-1763">"LOCATION_URI"</span></span>|<span data-ttu-id="45345-1764">(nenhuma propriedade)</span><span class="sxs-lookup"><span data-stu-id="45345-1764">(no property)</span></span>|  
|<span data-ttu-id="45345-1765">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="45345-1765">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="45345-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="45345-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="45345-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" não é uma entrada de sistema e seu valor pode ser definido ao chamar o <xref:System.AppDomain.SetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="45345-1768">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="45345-1768">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="45345-1769">O exemplo a seguir cria um novo domínio de aplicativo, define um valor fornecido pelo sistema para o domínio e adiciona um novo par de valor para o domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-1769">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="45345-1770">O exemplo demonstra como usar o <xref:System.AppDomain.GetData%2A> método para recuperar os dados desses pares de valor e exibi-las no console.</span><span class="sxs-lookup"><span data-stu-id="45345-1770">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1771"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1771"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1772">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1772">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1773">para acesso às informações no caminho, se a propriedade se aplica a um caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1773">for access to the information in the path itself, if the property applies to a path.</span></span> <span data-ttu-id="45345-1774">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1774">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1775">Obtém o tipo da instância atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1775">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="45345-1776">O tipo da instância atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1776">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1777">Obtém um inteiro que identifica exclusivamente o domínio de aplicativo dentro do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1777">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="45345-1778">Um inteiro que identifica o domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1778">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45345-1779">O exemplo de código a seguir cria um segundo domínio de aplicativo e exibe informações sobre o domínio padrão e o novo domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-1779">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1780">Proporciona ao <see cref="T:System.AppDomain" /> um tempo de vida infinito impedindo que uma concessão seja criada.</span><span class="sxs-lookup"><span data-stu-id="45345-1780">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="45345-1781">Sempre <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1781">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1782">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1782">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-1783">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-1783">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-1784">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-1784">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="45345-1785">A opção de compatibilidade a testar.</span><span class="sxs-lookup"><span data-stu-id="45345-1785">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="45345-1786">Obtém um valor booliano anulável que indica se alguma a de compatibilidade está definida e, caso esteja, se a opção de compatibilidade especificada está definida.</span><span class="sxs-lookup"><span data-stu-id="45345-1786">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="45345-1787">Uma referência nula (<see langword="Nothing" /> no Visual Basic) se nenhuma opção de compatibilidade estiver definida; caso contrário, um valor booliano que indica se a opção de compatibilidade especificada por <paramref name="value" /> está definida.</span><span class="sxs-lookup"><span data-stu-id="45345-1787">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1788">Este método testa se a opção de compatibilidade especificado tiver sido definida para o domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1788">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="45345-1789">Opções de compatibilidade normalmente restaura um comportamento (como as cadeias de caracteres de forma são classificadas) que foi alterado entre as versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1789">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="45345-1790">Eles são definidos chamando a <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> método antes de criar um domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1790">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="45345-1791">A tabela a seguir fornece exemplos de opções de compatibilidade que podem ser definidas para restaurar o comportamento de versões anteriores do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45345-1791">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="45345-1792">Alternar</span><span class="sxs-lookup"><span data-stu-id="45345-1792">Switch</span></span>|<span data-ttu-id="45345-1793">Significado</span><span class="sxs-lookup"><span data-stu-id="45345-1793">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="45345-1794">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="45345-1794">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="45345-1795">Código de segurança de acesso (ACS) para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada neste domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1795">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="45345-1796">Ver [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1796">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="45345-1797">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="45345-1797">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="45345-1798">Cadeia de caracteres de classificação padrão para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] estão habilitadas neste domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1798">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="45345-1799">Seu sucesso requer um arquivo sort00001000.dll a serem instalados.</span><span class="sxs-lookup"><span data-stu-id="45345-1799">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="45345-1800">Ver [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1800">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="45345-1801">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="45345-1801">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="45345-1802">Cadeia de caracteres de classificação padrão para o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e Unicode 5.0 são habilitados neste domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1802">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="45345-1803">Seu sucesso requer sort00060101.dll a serem instalados.</span><span class="sxs-lookup"><span data-stu-id="45345-1803">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="45345-1804">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="45345-1804">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="45345-1805"><xref:System.TimeSpan> formatação de comportamento para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada neste domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1805"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="45345-1806">Ver [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) e a seção "Restaurando herdado TimeSpan formatando" o <xref:System.TimeSpan> tópico.</span><span class="sxs-lookup"><span data-stu-id="45345-1806">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="45345-1807">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="45345-1807">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="45345-1808">O tempo de execução calcula códigos hash para cadeias de caracteres em uma base de domínio de aplicativo em vez de usar um único algoritmo de hash que gera um código hash consistente entre domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1808">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="45345-1809">Ver [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1809">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1810">Retorna um valor que indica se o domínio de aplicativo é o domínio de aplicativo padrão para o processo.</span><span class="sxs-lookup"><span data-stu-id="45345-1810">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="45345-1811"><see langword="true" /> caso o objeto <see cref="T:System.AppDomain" /> atual represente o domínio de aplicativo padrão para o processo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1811"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1812">Cada processo gerenciado tem um domínio de aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-1812">Every managed process has a default application domain.</span></span> <span data-ttu-id="45345-1813">Execução começa no domínio padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-1813">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1814">O exemplo de código a seguir cria um segundo domínio de aplicativo e exibe informações sobre o domínio padrão e o novo domínio.</span><span class="sxs-lookup"><span data-stu-id="45345-1814">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-1815">Indica se esse domínio de aplicativo está descarregando e os objetos que ele contém estão sendo finalizados pelo Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="45345-1815">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="45345-1816"><see langword="true" /> se esse domínio de aplicativo estiver descarregando e o Common Language Runtime tiver começado a chamar finalizadores; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1816"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1817">O método de finalização para um objeto fornece uma oportunidade para executar qualquer operação de limpeza necessária antes que o objeto seja coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="45345-1817">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="45345-1818">Após a finalização, o objeto é acessível, mas em um estado inválido e, portanto, esta última inutilizável.</span><span class="sxs-lookup"><span data-stu-id="45345-1818">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="45345-1819">Eventualmente, a coleta de lixo é concluída e recupera o objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-1819">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="45345-1820">Método de finalização de um objeto é chamado em uma das seguintes situações: durante a coleta de lixo, quando o common language runtime está sendo desligado, ou quando o domínio do aplicativo que contém o objeto é descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1820">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="45345-1821">O <xref:System.AppDomain.IsFinalizingForUnload%2A> retorn `true` apenas no último caso; ele não retorna `true` se resultar de finalização de coleta de lixo de rotina ou de desligamento do CLR.</span><span class="sxs-lookup"><span data-stu-id="45345-1821">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1822">Para determinar se a finalização é devido ao desligamento do CLR, use o <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-1822">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="45345-1823">Ele retorna `true` se finalização é devido a um domínio do aplicativo que está sendo descarregado ou ao CLR que está sendo desligado.</span><span class="sxs-lookup"><span data-stu-id="45345-1823">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="45345-1824">Durante a execução em seu método de finalização durante o descarregamento de domínio, você talvez queira acessar outro objeto que é referenciado por um campo estático e tem um método de finalização.</span><span class="sxs-lookup"><span data-stu-id="45345-1824">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="45345-1825">No entanto, não é possível confiável porque o objeto acessado pode já ter sido finalizado.</span><span class="sxs-lookup"><span data-stu-id="45345-1825">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1826">Uma exceção a essa regra é o <xref:System.Console> classe, que contém campos estáticos que fazem referência a objetos de fluxo, mas é implementado, especialmente para que você sempre pode escrever no console do sistema, mesmo durante o desligamento do domínio do sistema ou descarregando.</span><span class="sxs-lookup"><span data-stu-id="45345-1826">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="45345-1827">Use esse método no método de finalização de um objeto para determinar se o domínio do aplicativo que contém o objeto está descarregando.</span><span class="sxs-lookup"><span data-stu-id="45345-1827">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="45345-1828">Se esse for o caso, você não pode acessar de forma confiável qualquer objeto que tem um método de finalização e é referenciado por um campo estático.</span><span class="sxs-lookup"><span data-stu-id="45345-1828">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1829">Obtém um valor que indica se os assemblies carregados no domínio de aplicativo atual são executados com confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1829">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="45345-1830"><see langword="true" /> se os assemblies carregados no domínio de aplicativo atual forem executados com confiança total; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1830"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1831">Esse método sempre retorna `true` para o domínio de aplicativo padrão de um aplicativo que é executado na área de trabalho.</span><span class="sxs-lookup"><span data-stu-id="45345-1831">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="45345-1832">Ele retorna `false` para um domínio de aplicativo em área restrita que foi criado usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga do método, a menos que as permissões que são concedidas ao domínio do aplicativo são equivalentes a confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1832">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1833">O exemplo a seguir demonstra a <xref:System.AppDomain.IsFullyTrusted%2A> propriedade e o <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> propriedade com domínios de aplicativo totalmente confiável quanto o parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-1833">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="45345-1834">O domínio de aplicativo totalmente confiável é o domínio de aplicativo padrão para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1834">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="45345-1835">O domínio de aplicativo parcialmente confiável é criado usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="45345-1835">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="45345-1836">O exemplo usa uma `Worker` classe que deriva de <xref:System.MarshalByRefObject>, portanto, ele pode ser empacotado entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1836">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="45345-1837">O exemplo cria um `Worker` objeto no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-1837">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="45345-1838">Em seguida, ele chama o `TestIsFullyTrusted` método para exibir o valor da propriedade para o domínio do aplicativo em dois assemblies que são carregados no domínio do aplicativo: mscorlib, que faz parte do .NET Framework e o assembly de exemplo.</span><span class="sxs-lookup"><span data-stu-id="45345-1838">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="45345-1839">O domínio de aplicativo é totalmente confiável, para que ambos os assemblies são totalmente confiáveis.</span><span class="sxs-lookup"><span data-stu-id="45345-1839">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="45345-1840">O exemplo cria outra `Worker` objeto em um domínio de aplicativo em área restrita e, novamente, chamadas a `TestIsFullyTrusted` método.</span><span class="sxs-lookup"><span data-stu-id="45345-1840">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="45345-1841">Mscorlib sempre é confiável, mesmo em um domínio de aplicativo parcialmente confiável, mas o assembly de exemplo é parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-1841">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-1842">Obtém um valor que indica se o domínio de aplicativo atual tem um conjunto de permissões concedido a todos os assemblies que são carregados no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1842">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="45345-1843"><see langword="true" /> se o domínio de aplicativo atual tiver um conjunto de permissões homogêneo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1843"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1844">Essa propriedade retornará `true` para domínios de aplicativo em área restrita que foram criados usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="45345-1844">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="45345-1845">Domínios de aplicativo em área restrita têm um conjunto homogêneo de permissões; ou seja, o mesmo conjunto de permissões é concedido a todos os assemblies parcialmente confiáveis que são carregados no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1845">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="45345-1846">Um domínio de aplicativo em área restrita, opcionalmente, tem uma lista de assemblies de nome forte que são isentos essa permissão definida e, em vez disso, é executado com confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-1846">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="45345-1847">Totalmente confiável para o código pode usar o <xref:System.AppDomain.PermissionSet%2A> propriedade para determinar o conjunto de concessões homogênea de um domínio de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-1847">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="45345-1848">Essa propriedade também retorna `true` para o domínio de aplicativo padrão de um aplicativo da área de trabalho, porque o domínio do aplicativo concede confiança total a todos os assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-1848">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-1849">Carrega um <see cref="T:System.Reflection.Assembly" /> para esse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1849">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="45345-1850">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1850">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1851">Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1851">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="45345-1852">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1852">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1853">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly que é carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1853">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="45345-1854">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1854">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1855">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1855">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1856">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1856">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1857">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1857">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1858">O exemplo a seguir demonstra o uso de carregamento de um assembly bruto.</span><span class="sxs-lookup"><span data-stu-id="45345-1858">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="45345-1859">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1859">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1860">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1860">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1861"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1861"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1862"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1862"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1863">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1863">-or-</span></span> 
<span data-ttu-id="45345-1864">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1864">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1865">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1865">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1866">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1866">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1867">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1867">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1868">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1868">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="45345-1869">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1869">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="45345-1870">Carrega um <see cref="T:System.Reflection.Assembly" /> dado seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1870">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="45345-1871">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1871">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1872">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1872">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1873">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1873">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1874">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1874">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1875">Se uma versão do assembly solicitado já está carregada, esse método retorna o assembly carregado, mesmo se uma versão diferente for solicitada.</span><span class="sxs-lookup"><span data-stu-id="45345-1875">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="45345-1876">Fornecendo um nome de assembly parcial para `assemblyRef` não é recomendado.</span><span class="sxs-lookup"><span data-stu-id="45345-1876">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="45345-1877">(Um nome parcial omite um ou mais dos cultura, versão ou token de chave pública.</span><span class="sxs-lookup"><span data-stu-id="45345-1877">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="45345-1878">Para sobrecargas que usam uma cadeia de caracteres em vez de um <xref:System.Reflection.AssemblyName> objeto, "MyAssembly, versão = 1.0.0.0" é um exemplo de um nome parcial e "MyAssembly, versão Version=1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" é um exemplo de um nome completo.) Usando nomes parciais tem um efeito negativo no desempenho.</span><span class="sxs-lookup"><span data-stu-id="45345-1878">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="45345-1879">Além disso, um nome de assembly parcial pode carregar um assembly do cache de assembly global somente se houver uma cópia exata do assembly no diretório base do aplicativo (<xref:System.AppDomain.BaseDirectory%2A> ou <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="45345-1879">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="45345-1880">Se o atual <xref:System.AppDomain> objeto representa o domínio de aplicativo `A`e o <xref:System.AppDomain.Load%2A> método é chamado de domínio do aplicativo `B`, o assembly é carregado em ambos os domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1880">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="45345-1881">Por exemplo, o código a seguir carrega `MyAssembly` no novo domínio de aplicativo `ChildDomain` e também no domínio de aplicativo em que o código é executado:</span><span class="sxs-lookup"><span data-stu-id="45345-1881">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="45345-1882">O assembly é carregado em ambos os domínios, porque <xref:System.Reflection.Assembly> não é derivado de <xref:System.MarshalByRefObject>e, portanto, o valor de retorno de <xref:System.AppDomain.Load%2A> método não pode ser empacotado.</span><span class="sxs-lookup"><span data-stu-id="45345-1882">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="45345-1883">Em vez disso, o common language runtime tenta carregar o assembly no domínio de aplicativo de chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-1883">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="45345-1884">Os assemblies que são carregados em dois domínios de aplicativo podem ser diferentes se as configurações de caminho para os dois domínios de aplicativo são diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1884">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-1885">Se ambos o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> estiverem definidas, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade).</span><span class="sxs-lookup"><span data-stu-id="45345-1885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="45345-1886">Se o arquivo não for encontrado, o <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade é usada para pesquisar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1886">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="45345-1887">Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="45345-1888">Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="45345-1888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1889"><paramref name="assemblyRef" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1889"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1890"><paramref name="assemblyRef" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1890"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1891"><paramref name="assemblyRef" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1891"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1892">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1892">-or-</span></span> 
<span data-ttu-id="45345-1893">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1894">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1894">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1895">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1895">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1896">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1896">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1897">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1897">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="45345-1898">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1898">The display name of the assembly.</span></span> <span data-ttu-id="45345-1899">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1899">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="45345-1900">Carrega um <see cref="T:System.Reflection.Assembly" /> de acordo com seu nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="45345-1900">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="45345-1901">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1901">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1902">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1902">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1903">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1903">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1904">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1904">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1905">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1905">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1906"><paramref name="assemblyString" /> é <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="45345-1906"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1907"><paramref name="assemblyString" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1907"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1908"><paramref name="assemblyString" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1908"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1909">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1909">-or-</span></span> 
<span data-ttu-id="45345-1910">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1910">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1911">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1911">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1912">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1912">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1913">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1913">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1914">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1914">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1915">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</span><span class="sxs-lookup"><span data-stu-id="45345-1915">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="45345-1916">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1916">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="45345-1917">Uma matriz do tipo <see langword="byte" /> contendo os bytes brutos que representam os símbolos para o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1917">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1918">Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1918">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="45345-1919">Os bytes brutos que representam os símbolos para o <see cref="T:System.Reflection.Assembly" /> também são carregados.</span><span class="sxs-lookup"><span data-stu-id="45345-1919">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="45345-1920">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1920">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1921">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly que é carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1921">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="45345-1922">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1922">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1923">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1923">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1924">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1924">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1925">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1925">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1926">O exemplo a seguir demonstra o uso de carregamento de um assembly bruto.</span><span class="sxs-lookup"><span data-stu-id="45345-1926">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="45345-1927">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1927">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1928">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1928">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1929"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1929"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1930"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1930"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1931">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1931">-or-</span></span> 
<span data-ttu-id="45345-1932">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1932">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1933">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1933">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1934">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1934">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1935">para ler um URI que não começa com "file://".</span><span class="sxs-lookup"><span data-stu-id="45345-1935">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1936">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1936">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1937">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1937">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="45345-1938">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1938">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1939">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1939">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1940">Carrega um <see cref="T:System.Reflection.Assembly" /> dado seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1940">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="45345-1941">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1941">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1942">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1942">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1943">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1943">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1944">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1944">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1945">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1945">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1946"><paramref name="assemblyRef" /> é <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="45345-1946"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1947"><paramref name="assemblyRef" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1947"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1948"><paramref name="assemblyRef" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1948"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1949">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1949">-or-</span></span> 
<span data-ttu-id="45345-1950">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1950">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1951">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1951">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1952">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1952">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1953">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1953">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1954">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1954">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1955">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1955">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1956">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1956">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1957">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</span><span class="sxs-lookup"><span data-stu-id="45345-1957">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="45345-1958">O nome para exibição do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1958">The display name of the assembly.</span></span> <span data-ttu-id="45345-1959">Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1959">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="45345-1960">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1960">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1961">Carrega um <see cref="T:System.Reflection.Assembly" /> de acordo com seu nome de exibição.</span><span class="sxs-lookup"><span data-stu-id="45345-1961">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="45345-1962">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1962">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1963">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1963">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1964">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1964">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1965">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1965">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1966">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1966">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1967"><paramref name="assemblyString" /> é <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="45345-1967"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="45345-1968"><paramref name="assemblyString" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-1968"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1969"><paramref name="assemblyString" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1969"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1970">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1970">-or-</span></span> 
<span data-ttu-id="45345-1971">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1972">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1972">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1973">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1973">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-1974">para carregar um assembly com evidências.</span><span class="sxs-lookup"><span data-stu-id="45345-1974">to load an assembly with evidence.</span></span> <span data-ttu-id="45345-1975">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1975">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-1976">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-1976">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-1977">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1977">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-1978">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</span><span class="sxs-lookup"><span data-stu-id="45345-1978">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="45345-1979">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1979">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="45345-1980">Uma matriz do tipo <see langword="byte" /> contendo os bytes brutos que representam os símbolos para o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1980">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="45345-1981">Evidência para carregar o assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-1981">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="45345-1982">Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="45345-1982">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="45345-1983">Os bytes brutos que representam os símbolos para o <see cref="T:System.Reflection.Assembly" /> também são carregados.</span><span class="sxs-lookup"><span data-stu-id="45345-1983">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="45345-1984">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1984">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-1985">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly que é carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-1985">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="45345-1986">Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-1986">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="45345-1987">Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-1987">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45345-1988">Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-1988">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="45345-1989">Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.</span><span class="sxs-lookup"><span data-stu-id="45345-1989">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-1990">O exemplo a seguir demonstra o uso de carregamento de um assembly bruto.</span><span class="sxs-lookup"><span data-stu-id="45345-1990">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="45345-1991">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-1991">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-1992">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-1992">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-1993"><paramref name="rawAssembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1993"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="45345-1994"><paramref name="rawAssembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="45345-1994"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="45345-1995">- ou -</span><span class="sxs-lookup"><span data-stu-id="45345-1995">-or-</span></span> 
<span data-ttu-id="45345-1996">A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-1996">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-1997">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-1997">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="45345-1998">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-1998">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="45345-1999"><paramref name="securityEvidence" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-1999"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="45345-2000">Quando a política CAS herdada não está habilitada, <paramref name="securityEvidence" /> deve ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2000">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-2001">para fornecer evidência.</span><span class="sxs-lookup"><span data-stu-id="45345-2001">to provide evidence.</span></span> <span data-ttu-id="45345-2002">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2002">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="45345-2003">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2003">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-2004">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-2004">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="45345-2005">Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2005">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="45345-2006">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</span><span class="sxs-lookup"><span data-stu-id="45345-2006">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2007">Obtém ou define um valor que indica se o monitoramento de CPU e memória de domínios de aplicativo está habilitado para o processo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-2007">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="45345-2008">Depois que o monitoramento é habilitado para um processo, ele não pode ser desabilitado.</span><span class="sxs-lookup"><span data-stu-id="45345-2008">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="45345-2009"><see langword="true" /> se o monitoramento está habilitado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2009"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2010">Isso `static` propriedade (`Shared` propriedade no Visual Basic) controla a CPU e memória de monitoramento de todos os domínios de aplicativo no processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2010">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="45345-2011">Se você tentar definir essa propriedade como `false`, um <xref:System.ArgumentException> exceção for lançada, mesmo se o valor atual da propriedade é `false`.</span><span class="sxs-lookup"><span data-stu-id="45345-2011">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="45345-2012">Depois que o monitoramento está habilitado, você pode usar o <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> propriedades para monitorar o uso de CPU e memória de domínios de aplicativo individuais da instância.</span><span class="sxs-lookup"><span data-stu-id="45345-2012">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="45345-2013">O processo atual tentou atribuir o valor <see langword="false" /> a esta propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2013">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2014">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2014">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2015">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2015">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="45345-2016">Monitoramento de recursos de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-2016">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="45345-2017">&lt;appdomainResourceMonitoring&gt; elemento</span><span class="sxs-lookup"><span data-stu-id="45345-2017">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2018">Obtém o número de bytes que sobreviveram à última coleta e que são conhecidos por serem referenciados pelo domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-2018">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="45345-2019">O número de bytes sobreviventes.</span><span class="sxs-lookup"><span data-stu-id="45345-2019">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2020">As estatísticas são atualizadas com cada coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="45345-2020">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="45345-2021">No entanto, eles são garantidos para ser preciso somente após uma completa de bloqueio de uma coleção. ou seja, uma coleção que inclui todas as gerações e que interrompe o aplicativo durante a coleta ocorre.</span><span class="sxs-lookup"><span data-stu-id="45345-2021">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="45345-2022">Por exemplo, o <xref:System.GC.Collect?displayProperty=nameWithType> sobrecarga do método executa uma completa de coleta de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="45345-2022">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="45345-2023">(Coleção simultânea ocorre em segundo plano e não bloqueia o aplicativo.)</span><span class="sxs-lookup"><span data-stu-id="45345-2023">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-2024">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2024">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2025">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2025">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2026">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2026">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="45345-2027">Monitoramento de recursos de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-2027">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2028">Obtém o total de bytes que sobreviveram da última coleção para todos os domínios de aplicativo no processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2028">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="45345-2029">O número total de bytes sobreviventes para o processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2029">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2030">Após uma coleta completa, bloqueio, esse número representa o número de bytes atualmente mantido ativo em heaps gerenciados.</span><span class="sxs-lookup"><span data-stu-id="45345-2030">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="45345-2031">Ele deve ser próximo ao número relatado pelo <xref:System.GC.GetTotalMemory%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-2031">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="45345-2032">Após uma coleta efêmera, esse número representa o número de bytes atualmente mantidos ativo em gerações efêmeras.</span><span class="sxs-lookup"><span data-stu-id="45345-2032">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-2033">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2033">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2034">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2034">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2035">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="45345-2036">Monitoramento de recursos de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-2036">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2037">Obtém o tamanho total, em bytes, de todas as alocações de memória que foram feitas pelo domínio do aplicativo desde que ele foi criado, sem subtrair a memória que foi coletada.</span><span class="sxs-lookup"><span data-stu-id="45345-2037">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="45345-2038">O tamanho total de todas as alocações de memória.</span><span class="sxs-lookup"><span data-stu-id="45345-2038">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-2039">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2039">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2040">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2040">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2041">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2041">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="45345-2042">Monitoramento de recursos de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-2042">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2043">Obtém o tempo total do processador usado por todos os threads durante a execução no domínio do aplicativo atual, desde o início do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2043">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="45345-2044">Tempo total do processador para o domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="45345-2044">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2045">O tempo total que é relatado para um domínio de aplicativo inclui o tempo gasto em cada thread no processo de execução nesse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2045">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="45345-2046">Um thread que chama código não gerenciado ainda está associado com um domínio de aplicativo e o tempo do processador gasto para executar que o código não gerenciado é relatado para o domínio do aplicativo em que a chamada foi feita.</span><span class="sxs-lookup"><span data-stu-id="45345-2046">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="45345-2047">Quando um thread estiver bloqueado ou em repouso, ela não consome tempo do processador.</span><span class="sxs-lookup"><span data-stu-id="45345-2047">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-2048">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2048">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2049">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2049">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2050">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="45345-2051">Monitoramento de recursos de domínio de aplicativo</span><span class="sxs-lookup"><span data-stu-id="45345-2051">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2052">Obtém o conjunto de permissões de um domínio de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-2052">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="45345-2053">O conjunto de permissões de um domínio de aplicativo em área restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-2053">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2054">Domínios de aplicativo em área restrita que foram criados usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga de método têm um conjunto de permissões de homogêneo; ou seja, o mesmo conjunto de permissões é concedido a todos os assemblies parcialmente confiáveis que são carregados no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2054">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="45345-2055">Um domínio de aplicativo em área restrita, opcionalmente, tem uma lista de assemblies de nome forte que são isentos essa permissão definida e, em vez disso, é executado com confiança total.</span><span class="sxs-lookup"><span data-stu-id="45345-2055">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2056">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2056">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2057">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2057">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2058">Ocorre quando o processo pai do domínio de aplicativo padrão é encerrado.</span><span class="sxs-lookup"><span data-stu-id="45345-2058">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2059">O <xref:System.EventHandler> para esse evento pode executar atividades de encerramento, como fechar arquivos, liberação de armazenamento e assim por diante, antes do término do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2059">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="45345-2060">Começando com o .NET Framework versão 2.0, esse evento é gerado em cada domínio de aplicativo que registra um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-2060">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-2061">No .NET Framework, o tempo de execução total de todos os <xref:System.AppDomain.ProcessExit> manipuladores de eventos é limitado, assim como o tempo de execução total de todos os finalizadores é limitado no desligamento do processo.</span><span class="sxs-lookup"><span data-stu-id="45345-2061">In .NET Framework, the total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="45345-2062">O padrão é dois segundos.</span><span class="sxs-lookup"><span data-stu-id="45345-2062">The default is two seconds.</span></span> <span data-ttu-id="45345-2063">Um host não gerenciado pode alterar esse tempo de execução chamando o [ICLRPolicyManager:: setTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) método com o [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valor de enumeração.</span><span class="sxs-lookup"><span data-stu-id="45345-2063">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span> <span data-ttu-id="45345-2064">Esse limite de tempo não existe no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="45345-2064">This time limit does not exist in .NET Core.</span></span>  
  
 <span data-ttu-id="45345-2065">Nas versões do .NET Framework 1.0 e 1.1, esse evento é gerado apenas no domínio de aplicativo padrão e somente se um manipulador de eventos é registrado no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-2065">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="45345-2066">Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="45345-2066">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="45345-2067">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2067">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2068">Ocorre quando a resolução de um assembly falha no contexto somente para reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-2068">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2069">No contexto somente reflexão, as dependências não são resolvidas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="45345-2069">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="45345-2070">Eles devem ser pré-carregado ou retornados pelo manipulador para este evento.</span><span class="sxs-lookup"><span data-stu-id="45345-2070">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="45345-2071">Esse evento é gerado quando um assembly tem uma dependência que já não foi carregada no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-2071">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="45345-2072">A dependência ausente é especificada pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2072">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="45345-2073">O <xref:System.ResolveEventHandler> para esse evento deve retornar um assembly que atende a dependência.</span><span class="sxs-lookup"><span data-stu-id="45345-2073">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="45345-2074">O assembly que é retornado deve ser carregado no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-2074">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-2075">Esse evento é gerado apenas para dependências ausentes do assembly que você está carregando no contexto somente reflexão (por exemplo, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> método).</span><span class="sxs-lookup"><span data-stu-id="45345-2075">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="45345-2076">Ele não será gerado se o assembly que você está carregando não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="45345-2076">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="45345-2077">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade retorna o assembly que solicitou o carregamento do assembly que não pôde ser resolvido.</span><span class="sxs-lookup"><span data-stu-id="45345-2077">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="45345-2078">Saber a identidade do assembly solicitante pode ser útil para identificar a versão correta da dependência, se mais de uma versão estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="45345-2078">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="45345-2079">Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-2079">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-2080">Para este evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade retorna o nome do assembly antes de política é aplicada.</span><span class="sxs-lookup"><span data-stu-id="45345-2080">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="45345-2081">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2081">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2082">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2082">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2083">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2083">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-2084">Retorna os assemblies que foram carregados no contexto somente de reflexão do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2084">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="45345-2085">Uma matriz de objetos <see cref="T:System.Reflection.Assembly" /> que representam os assemblies carregados no contexto de somente reflexão do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2085">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2086">Esse método retorna os assemblies que foram carregados no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-2086">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="45345-2087">Para obter os assemblies que foram carregados para a execução, use o <xref:System.AppDomain.GetAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-2087">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2088">O exemplo de código a seguir carrega o assembly System. dll no contexto de execução e, em seguida, no contexto somente reflexão.</span><span class="sxs-lookup"><span data-stu-id="45345-2088">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="45345-2089">O <xref:System.AppDomain.GetAssemblies%2A> e <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> métodos são usados para exibir os assemblies carregados no contexto de cada.</span><span class="sxs-lookup"><span data-stu-id="45345-2089">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2090">É feita uma tentativa de realizar uma operação em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2090">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2091">Obtém o caminho no diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-2091">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="45345-2092">O caminho no diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</span><span class="sxs-lookup"><span data-stu-id="45345-2092">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2093">Assemblies particulares são implantados na mesma estrutura de diretório do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2093">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="45345-2094">Se o caminho especificado o <xref:System.AppDomain.RelativeSearchPath%2A> propriedade não está sob <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, ele será ignorado.</span><span class="sxs-lookup"><span data-stu-id="45345-2094">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="45345-2095">Essa propriedade retorna o valor definido usando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-2095">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2096">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2096">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="45345-2097">para acesso às informações de caminho.</span><span class="sxs-lookup"><span data-stu-id="45345-2097">for access to the path information.</span></span> <span data-ttu-id="45345-2098">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2098">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2099">Ocorre quando a resolução de um recurso falha devido ao recurso não ser um recurso vinculado ou inserido válido no assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-2099">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2100">O <xref:System.ResolveEventHandler> para esse evento pode tentar localizar o assembly que contém o recurso e retorná-lo.</span><span class="sxs-lookup"><span data-stu-id="45345-2100">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="45345-2101">Esse evento não será gerado se a resolução falhar porque o arquivo não pode ser encontrado para um recurso vinculado válido.</span><span class="sxs-lookup"><span data-stu-id="45345-2101">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="45345-2102">Ele é gerado se um fluxo de recurso de manifesto não pode ser encontrado, mas ele não será gerado se uma chave de recurso individual não pode ser encontrada.</span><span class="sxs-lookup"><span data-stu-id="45345-2102">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="45345-2103">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade contém o assembly que o recurso solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-2103">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="45345-2104">Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-2104">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-2105">Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="45345-2105">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="45345-2106">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2106">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2107">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2108">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="45345-2109">O nível de política de segurança.</span><span class="sxs-lookup"><span data-stu-id="45345-2109">The security policy level.</span></span></param>
        <summary><span data-ttu-id="45345-2110">Estabelece o nível de política de segurança para esse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2110">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2111">Chame esse método antes de um assembly é carregado no <xref:System.AppDomain> em ordem para a política de segurança para ter efeito.</span><span class="sxs-lookup"><span data-stu-id="45345-2111">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2112">O exemplo a seguir demonstra como usar o <xref:System.AppDomain.SetAppDomainPolicy%2A> método para definir o nível de política de segurança de um domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2112">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-2113"><paramref name="domainPolicy" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2113"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="45345-2114">O nível de política de segurança já foi definido.</span><span class="sxs-lookup"><span data-stu-id="45345-2114">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2115">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2115">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2116">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2116">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2117">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2117">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="45345-2118">O caminho totalmente qualificado para o local da cópia de sombra.</span><span class="sxs-lookup"><span data-stu-id="45345-2118">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="45345-2119">Estabelece o caminho de diretório especificado como o local em que é feita cópia de sombra dos assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-2119">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2120">O caminho do cache será ignorado se o <xref:System.AppDomainSetup.ApplicationName%2A> não está definida.</span><span class="sxs-lookup"><span data-stu-id="45345-2120">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="45345-2121">Consulte a propriedade <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-2121">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="45345-2122">Para obter mais informações sobre cópias de sombra, consulte [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2122">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2123">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2123">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2124">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2124">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2125">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2125">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="45345-2126">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="45345-2126">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="45345-2127">Atribui um valor a uma propriedade de domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2127">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-2128">O nome de uma propriedade de domínio de aplicativo definida pelo usuário a ser criada ou alterada.</span><span class="sxs-lookup"><span data-stu-id="45345-2128">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="45345-2129">O valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2129">The value of the property.</span></span></param>
        <summary><span data-ttu-id="45345-2130">Atribui o valor especificado para a propriedade de domínio do aplicativo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-2130">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2131">Use esse método para inserir uma entrada ou modificar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="45345-2131">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="45345-2132">O cache automaticamente contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-2132">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="45345-2133">Não é possível inserir ou modificar as entradas do sistema com esse método.</span><span class="sxs-lookup"><span data-stu-id="45345-2133">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="45345-2134">Uma chamada de método que tenta modificar uma entrada do sistema não tem nenhum efeito; o método não gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2134">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="45345-2135">Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A> método, ou equivalente <xref:System.AppDomainSetup> propriedades descritas na <xref:System.AppDomain.GetData%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-2135">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="45345-2136">Você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar os padrões de expressão regular pela fonte "REGEX_DEFAULT_MATCH_TIMEOUT" como o valor da `name` argumento e uma <xref:System.TimeSpan> valor que representa o tempo limite como o valor do intervalo da `data` argumento.</span><span class="sxs-lookup"><span data-stu-id="45345-2136">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="45345-2137">Você também pode inserir ou modificar seus próprios pares de nome dados definidos pelo usuário com esse método e inspecionar seus valores com o <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-2137">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2138">O exemplo a seguir demonstra como usar o <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> método para criar um novo par de valor.</span><span class="sxs-lookup"><span data-stu-id="45345-2138">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="45345-2139">O exemplo usa o <xref:System.AppDomain.GetData%2A> método para recuperar o valor e o exibe no console.</span><span class="sxs-lookup"><span data-stu-id="45345-2139">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2140">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2140">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2141">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2141">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2142">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="45345-2143">O nome de uma propriedade de domínio de aplicativo definida pelo usuário a ser criada ou alterada.</span><span class="sxs-lookup"><span data-stu-id="45345-2143">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="45345-2144">O valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2144">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="45345-2145">A permissão para exigir do chamador quando a propriedade é recuperada.</span><span class="sxs-lookup"><span data-stu-id="45345-2145">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="45345-2146">Atribui o valor especificado à propriedade de domínio de aplicativo especificada, com uma permissão especificada para exigir do chamador quando a propriedade for recuperada.</span><span class="sxs-lookup"><span data-stu-id="45345-2146">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2147">Use esse método para inserir ou modificar suas próprias entradas definidas pelo usuário em um cache interno de pares de nome/dados que descrevem as propriedades do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2147">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="45345-2148">Quando você insere uma entrada, você pode especificar uma demanda de permissão para impor quando a entrada é recuperada. Além disso, você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar os padrões de expressão regular pela fonte "REGEX_DEFAULT_MATCH_TIMEOUT" como o valor da `name` argumento e uma <xref:System.TimeSpan> valor que representa o intervalo de tempo limite como o valor do `data` argumento.</span><span class="sxs-lookup"><span data-stu-id="45345-2148">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="45345-2149">Você não pode usar esse método para atribuir uma exigência de segurança a uma cadeia de caracteres de propriedade definida pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="45345-2149">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="45345-2150">O cache automaticamente contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado.</span><span class="sxs-lookup"><span data-stu-id="45345-2150">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="45345-2151">Não é possível inserir ou modificar as entradas do sistema com esse método.</span><span class="sxs-lookup"><span data-stu-id="45345-2151">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="45345-2152">Uma chamada de método que tenta modificar uma entrada do sistema não tem nenhum efeito; o método não gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2152">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="45345-2153">Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A> método ou o equivalente <xref:System.AppDomainSetup> as propriedades descritas na seção comentários para o <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-2153">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-2154"><paramref name="name" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="45345-2155"><paramref name="name" /> especifica uma cadeia de caracteres de propriedade definida pelo sistema e <paramref name="permission" /> não é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2155"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2156">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2156">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2157">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2157">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="45345-2158">O caminho totalmente qualificado que é o diretório base para subdiretórios em que assemblies dinâmicos são armazenados.</span><span class="sxs-lookup"><span data-stu-id="45345-2158">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="45345-2159">Estabelece o caminho de diretório especificado como o diretório base para subdiretórios em que os arquivos gerados dinamicamente são armazenados e acessados.</span><span class="sxs-lookup"><span data-stu-id="45345-2159">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2160">Esse método define o <xref:System.AppDomainSetup.DynamicBase%2A> propriedade de interno <xref:System.AppDomainSetup> associado a esta instância.</span><span class="sxs-lookup"><span data-stu-id="45345-2160">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2161">Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="45345-2161">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="45345-2162">O exemplo a seguir mostra como usar a alternativa não obsoleta, a <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2162">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="45345-2163">Para obter uma explicação desse exemplo, consulte o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade ou o <xref:System.AppDomain.DynamicDirectory%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2163">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2164">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2164">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2165">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2165">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2166">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2166">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="45345-2167">Um dos valores <see cref="T:System.Security.Principal.PrincipalPolicy" /> que especifica o tipo do objeto de entidade de segurança a ser anexado aos threads.</span><span class="sxs-lookup"><span data-stu-id="45345-2167">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="45345-2168">Especifica como objetos de identidade e de entidade de segurança devem ser anexados a um thread se a thread tenta se associar a uma entidade de segurança durante a execução nesse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2168">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2169">Definir esse valor só será eficaz se você defini-lo antes de usar o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="45345-2169">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="45345-2170">Por exemplo, se você definir <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para uma determinada entidade de segurança (por exemplo, uma entidade de segurança genérica) e, em seguida, use o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para definir o <xref:System.Security.Principal.PrincipalPolicy> para <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, a entidade atual permanecerá a entidade de segurança genérica.</span><span class="sxs-lookup"><span data-stu-id="45345-2170">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2171">O exemplo a seguir mostra o efeito em threads de como usar o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para alterar a política de entidade de segurança do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2171">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="45345-2172">Ele também mostra o efeito de usar o <xref:System.AppDomain.SetThreadPrincipal%2A> método para alterar a entidade que está disponível para anexar a threads no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2172">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2173">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2173">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-2174">para a capacidade de manipular o objeto principal.</span><span class="sxs-lookup"><span data-stu-id="45345-2174">for ability to manipulate the principal object.</span></span> <span data-ttu-id="45345-2175">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2175">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="45345-2176">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2176">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-2177">Ativa a cópia de sombra.</span><span class="sxs-lookup"><span data-stu-id="45345-2177">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2178">Para obter mais informações sobre cópias de sombra, consulte [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2178">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2179">Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="45345-2179">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2180">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2180">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2181">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2181">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2182">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2182">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="45345-2183">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="45345-2183">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="45345-2184">Uma lista de nomes de diretórios, em que cada nome é separado por ponto e vírgula.</span><span class="sxs-lookup"><span data-stu-id="45345-2184">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="45345-2185">Estabelece o caminho de diretório especificado como o lugar para o qual é feita cópia de sombra dos assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-2185">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2186">Por padrão, uma cópia de sombra inclui todos os assemblies localizados por meio de investigação.</span><span class="sxs-lookup"><span data-stu-id="45345-2186">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="45345-2187">O <xref:System.AppDomain.SetShadowCopyPath%2A> método restringe a cópia de sombra para os assemblies nos diretórios especificados pela `path`.</span><span class="sxs-lookup"><span data-stu-id="45345-2187">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="45345-2188">O <xref:System.AppDomain.SetShadowCopyPath%2A> método não especifica diretórios adicionais a ser pesquisado para assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-2188">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="45345-2189">Assemblies a serem copiados em sombra já devem estar localizados no caminho de pesquisa, por exemplo em <xref:System.AppDomain.BaseDirectory%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-2189">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="45345-2190">O <xref:System.AppDomain.SetShadowCopyPath%2A> método especifica quais caminhos de pesquisa são qualificados para ser copiado por sombra.</span><span class="sxs-lookup"><span data-stu-id="45345-2190">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="45345-2191">Esse método define o <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriedade de interno <xref:System.AppDomainSetup> associado a esta instância.</span><span class="sxs-lookup"><span data-stu-id="45345-2191">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="45345-2192">Para obter mais informações sobre cópias de sombra, consulte [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2192">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2193">Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="45345-2193">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2194">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2194">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2195">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2195">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2196">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2196">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="45345-2197">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="45345-2197">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="45345-2198">O objeto de entidade de segurança a ser anexado aos threads.</span><span class="sxs-lookup"><span data-stu-id="45345-2198">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="45345-2199">Define o objeto de entidade de segurança padrão a ser anexado aos threads se eles tentam se associar a uma entidade de segurança durante a execução nesse domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2199">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45345-2200">O exemplo a seguir mostra o efeito de usar o <xref:System.AppDomain.SetThreadPrincipal%2A> método para alterar a entidade que está disponível para anexar aos threads que estão em execução no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2200">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="45345-2201">Ele também mostra o efeito em threads de como usar o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para alterar a política de entidade de segurança do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2201">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-2202"><paramref name="principal" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2202"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="45345-2203">A entidade de segurança do thread já foi definida.</span><span class="sxs-lookup"><span data-stu-id="45345-2203">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2204">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2204">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-2205">para a capacidade de manipular o objeto principal.</span><span class="sxs-lookup"><span data-stu-id="45345-2205">for ability to manipulate the principal object.</span></span> <span data-ttu-id="45345-2206">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2206">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="45345-2207">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2207">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2208">Obtém as informações de configuração do domínio do aplicativo para essa instância.</span><span class="sxs-lookup"><span data-stu-id="45345-2208">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="45345-2209">As informações de inicialização do domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2209">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2210">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2210">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2211">Obtém uma indicação se o domínio do aplicativo é configurado para arquivos de cópia de sombra.</span><span class="sxs-lookup"><span data-stu-id="45345-2211">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="45345-2212"><see langword="true" /> se o domínio do aplicativo for configurado para arquivos de cópia de sombra; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2212"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2213">Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> e [cópias de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2213">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2214">A operação é tentada em um domínio de aplicativo descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2214">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="45345-2215">Criando cópias de sombra de assemblies</span><span class="sxs-lookup"><span data-stu-id="45345-2215">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="45345-2216">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="45345-2216">Reserved for future use.</span></span> <span data-ttu-id="45345-2217">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="45345-2217">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="45345-2218">Matriz passada de nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="45345-2218">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="45345-2219">Contagem dos nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="45345-2219">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="45345-2220">O contexto de localidade no qual interpretar os nomes.</span><span class="sxs-lookup"><span data-stu-id="45345-2220">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="45345-2221">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</span><span class="sxs-lookup"><span data-stu-id="45345-2221">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="45345-2222">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</span><span class="sxs-lookup"><span data-stu-id="45345-2222">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2223">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="45345-2223">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="45345-2224">Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="45345-2224">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="45345-2225">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="45345-2225">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="45345-2226">As informações de tipo a serem retornadas.</span><span class="sxs-lookup"><span data-stu-id="45345-2226">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="45345-2227">O identificador de localidade das informações do tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-2227">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="45345-2228">Recebe um ponteiro para o objeto de informações de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-2228">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="45345-2229">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</span><span class="sxs-lookup"><span data-stu-id="45345-2229">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2230">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="45345-2230">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="45345-2231">Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="45345-2231">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="45345-2232">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="45345-2232">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="45345-2233">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-2233">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="45345-2234">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</span><span class="sxs-lookup"><span data-stu-id="45345-2234">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2235">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="45345-2235">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="45345-2236">Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="45345-2236">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="45345-2237">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="45345-2237">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="45345-2238">Identifica o membro.</span><span class="sxs-lookup"><span data-stu-id="45345-2238">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="45345-2239">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="45345-2239">Reserved for future use.</span></span> <span data-ttu-id="45345-2240">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="45345-2240">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="45345-2241">O contexto de localidade no qual interpretar argumentos.</span><span class="sxs-lookup"><span data-stu-id="45345-2241">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="45345-2242">Sinalizadores que descrevem o contexto da chamada.</span><span class="sxs-lookup"><span data-stu-id="45345-2242">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="45345-2243">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</span><span class="sxs-lookup"><span data-stu-id="45345-2243">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="45345-2244">Ponteiro para o local onde o resultado deve ser armazenado.</span><span class="sxs-lookup"><span data-stu-id="45345-2244">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="45345-2245">Ponteiro para uma estrutura que contém informações de exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2245">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="45345-2246">O índice do primeiro argumento que tem um erro.</span><span class="sxs-lookup"><span data-stu-id="45345-2246">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="45345-2247">Fornece acesso a propriedades e métodos expostos por um objeto.</span><span class="sxs-lookup"><span data-stu-id="45345-2247">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2248">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="45345-2248">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="45345-2249">Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="45345-2249">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="45345-2250">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="45345-2250">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="45345-2251">Obtém uma representação de cadeia de caracteres que inclui o nome amigável do domínio do aplicativo e as políticas de contexto.</span><span class="sxs-lookup"><span data-stu-id="45345-2251">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="45345-2252">Uma cadeia de caracteres é formada pela concatenação da cadeia de caracteres literal “Nome:”, o nome amigável do domínio do aplicativo e as representações de cadeia de caracteres das políticas de contexto ou a cadeia de caracteres “Não há políticas sem contexto”.</span><span class="sxs-lookup"><span data-stu-id="45345-2252">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="45345-2253">O exemplo de código a seguir exibe o valor de retorno de <xref:System.AppDomain.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="45345-2253">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="45345-2254">O domínio de aplicativo representado pelo <see cref="T:System.AppDomain" /> atual foi descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2254">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2255">Ocorre quando a resolução de um tipo falha.</span><span class="sxs-lookup"><span data-stu-id="45345-2255">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2256">O <xref:System.AppDomain.TypeResolve> evento ocorre quando o common language runtime não é possível determinar o assembly que pode criar o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-2256">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="45345-2257">Isso pode ocorrer se o tipo é definido em um assembly dinâmico, ou o tipo não é definido em um assembly dinâmico, mas o tempo de execução não sabe qual assembly que o tipo é definido no.</span><span class="sxs-lookup"><span data-stu-id="45345-2257">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="45345-2258">Última situação pode ocorrer quando <xref:System.Type.GetType%2A?displayProperty=nameWithType> é chamado com um nome de tipo que não é qualificado com o nome do assembly.</span><span class="sxs-lookup"><span data-stu-id="45345-2258">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="45345-2259">O <xref:System.ResolveEventHandler> para esse evento pode tentar localizar e criar o tipo.</span><span class="sxs-lookup"><span data-stu-id="45345-2259">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="45345-2260">No entanto, o <xref:System.AppDomain.TypeResolve> evento não ocorre se o tempo de execução sabe que não é possível encontrar um tipo em determinados assemblies.</span><span class="sxs-lookup"><span data-stu-id="45345-2260">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="45345-2261">Por exemplo, esse evento não ocorrer se o tipo não for encontrado em um assembly estático, pois o tempo de execução sabe que tipos não podem ser adicionados dinamicamente para assemblies estáticos.</span><span class="sxs-lookup"><span data-stu-id="45345-2261">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="45345-2262">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade contém o assembly que o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="45345-2262">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="45345-2263">Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="45345-2263">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="45345-2264">Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="45345-2264">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="45345-2265">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2265">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2266">O exemplo a seguir demonstra o <xref:System.AppDomain.TypeResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-2266">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="45345-2267">Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="45345-2267">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="45345-2268">Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2268">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2269">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2269">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2270">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2270">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45345-2271">Ocorre quando uma exceção não é capturada.</span><span class="sxs-lookup"><span data-stu-id="45345-2271">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2272">Esse evento fornece notificação de exceções não identificadas.</span><span class="sxs-lookup"><span data-stu-id="45345-2272">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="45345-2273">Ele permite que o aplicativo registrar informações sobre a exceção antes do manipulador padrão do sistema relata a exceção para o usuário e encerra o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2273">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="45345-2274">Se informações suficientes sobre o estado do aplicativo são ações disponíveis, podem ser realizadas - como salvar dados do programa para recuperação posterior.</span><span class="sxs-lookup"><span data-stu-id="45345-2274">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="45345-2275">Tenha cuidado, porque os dados de programa podem se tornar corrompidos quando as exceções não são tratadas.</span><span class="sxs-lookup"><span data-stu-id="45345-2275">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-2276">Nas versões do .NET Framework 1.0 e 1.1, as opções de depuração e de término do aplicativo são relatados para o usuário antes desse evento é gerado, em vez de após.</span><span class="sxs-lookup"><span data-stu-id="45345-2276">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="45345-2277">Esse evento pode ser tratado em qualquer domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2277">This event can be handled in any application domain.</span></span> <span data-ttu-id="45345-2278">No entanto, o evento não é necessariamente gerado no domínio do aplicativo onde ocorreu a exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2278">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="45345-2279">Uma exceção é sem tratamento apenas se toda a pilha do thread foi organizada sem encontrar um manipulador de exceção aplicável, portanto, o primeiro lugar em que o evento pode ser gerado no domínio do aplicativo em que o thread foi originado.</span><span class="sxs-lookup"><span data-stu-id="45345-2279">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-2280">Nas versões do .NET Framework 1.0 e 1.1, esse evento ocorre somente para o domínio de aplicativo padrão que é criado pelo sistema quando um aplicativo é iniciado.</span><span class="sxs-lookup"><span data-stu-id="45345-2280">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="45345-2281">Se um aplicativo cria domínios de aplicativo adicionais, especificando um delegado para esse evento nos domínios de aplicativos não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="45345-2281">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="45345-2282">Se o <xref:System.AppDomain.UnhandledException> evento é manipulado no domínio do aplicativo padrão, ele será gerado lá para qualquer exceção sem tratamento em qualquer thread, independentemente de qual domínio de aplicativo o thread iniciada.</span><span class="sxs-lookup"><span data-stu-id="45345-2282">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="45345-2283">Se o thread foi iniciado em um domínio de aplicativo que tem um manipulador de eventos <xref:System.AppDomain.UnhandledException>, o evento é gerado nesse domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2283">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="45345-2284">Se esse domínio de aplicativo não é o domínio de aplicativo padrão e também há um manipulador de eventos no domínio de aplicativo padrão, o evento é gerado em ambos os domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2284">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="45345-2285">Por exemplo, suponha que um thread é iniciado domínio do aplicativo "IA1" chama um método no domínio do aplicativo "AD2" e a partir daí chama um método no domínio de aplicativo "AD3", onde ele gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2285">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="45345-2286">O primeiro domínio de aplicativo no qual o <xref:System.AppDomain.UnhandledException> evento pode ser gerado é "IA1".</span><span class="sxs-lookup"><span data-stu-id="45345-2286">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="45345-2287">Se o domínio de aplicativo não é o domínio de aplicativo padrão, o evento também pode ser gerado no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-2287">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-2288">O common language runtime suspende anulações de thread durante a manipuladores de eventos para o <xref:System.AppDomain.UnhandledException> eventos estão em execução.</span><span class="sxs-lookup"><span data-stu-id="45345-2288">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="45345-2289">Se o manipulador de eventos tem um <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo com os sinalizadores adequados, o manipulador de eventos é tratado como uma região de execução restrita.</span><span class="sxs-lookup"><span data-stu-id="45345-2289">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="45345-2290">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], esse evento não é gerado para exceções que corromper o estado do processo, como estouros de pilha ou violações, de acesso, a menos que o manipulador de eventos é crítico para segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="45345-2290">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="45345-2291">Nas versões do .NET Framework 1.0 e 1.1, uma exceção sem tratamento que ocorre em um thread diferente do thread principal do aplicativo é capturada pelo tempo de execução e, portanto, não causa o encerramento do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2291">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="45345-2292">Portanto, é possível que o <xref:System.AppDomain.UnhandledException> evento a ser gerado sem encerrar o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2292">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="45345-2293">Começando com o .NET Framework versão 2.0, essa barreira para exceções sem tratamento em threads filho tiver sido removida, pois o efeito cumulativo de tais falhas silenciosas incluído degradação de desempenho, dados corrompidos e travamentos, que eram difíceis depure.</span><span class="sxs-lookup"><span data-stu-id="45345-2293">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="45345-2294">Para obter mais informações, incluindo uma lista de casos em que não encerra o tempo de execução, consulte [exceções em Threads gerenciados](~/docs/standard/threading/exceptions-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2294">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="45345-2295">Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="45345-2295">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="45345-2296">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="45345-2296">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="45345-2297">Outros eventos para exceções não identificadas</span><span class="sxs-lookup"><span data-stu-id="45345-2297">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="45345-2298">Para determinados modelos de aplicativo, o <xref:System.AppDomain.UnhandledException> evento pode ser impedido por outros eventos, se a exceção sem tratamento ocorre no thread principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2298">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="45345-2299">Em aplicativos que usam o Windows Forms, exceções sem tratamento na causa do thread principal do aplicativo a <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> evento seja acionado.</span><span class="sxs-lookup"><span data-stu-id="45345-2299">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="45345-2300">Se esse evento é manipulado, o comportamento padrão é que a exceção sem tratamento não encerra o aplicativo, embora o aplicativo seja deixado em um estado desconhecido.</span><span class="sxs-lookup"><span data-stu-id="45345-2300">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="45345-2301">Nesse caso, o <xref:System.AppDomain.UnhandledException> não é gerado.</span><span class="sxs-lookup"><span data-stu-id="45345-2301">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="45345-2302">Esse comportamento pode ser alterado usando o arquivo de configuração de aplicativo, ou usando o <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> método para alterar o modo <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> antes do <xref:System.Windows.Forms.Application.ThreadException> manipulador de eventos é conectado.</span><span class="sxs-lookup"><span data-stu-id="45345-2302">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="45345-2303">Isso se aplica somente ao thread principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2303">This applies only to the main application thread.</span></span> <span data-ttu-id="45345-2304">O <xref:System.AppDomain.UnhandledException> é gerado para exceções sem tratamento lançadas em outros threads.</span><span class="sxs-lookup"><span data-stu-id="45345-2304">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="45345-2305">Começando com o Microsoft Visual Studio 2005, a estrutura de aplicativo do Visual Basic fornece outro evento para exceções sem tratamento no thread principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2305">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="45345-2306">Consulte o <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-2306">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="45345-2307">Esse evento possui um objeto de argumentos de evento com o mesmo nome que o objeto de argumentos de evento usado pelo <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, mas com propriedades diferentes.</span><span class="sxs-lookup"><span data-stu-id="45345-2307">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="45345-2308">Em particular, esse objeto de argumentos de evento tem um <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> propriedade que permite que o aplicativo continue em execução, ignorando a exceção sem tratamento (e deixar o aplicativo em um estado desconhecido).</span><span class="sxs-lookup"><span data-stu-id="45345-2308">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="45345-2309">Nesse caso, o <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> não é gerado.</span><span class="sxs-lookup"><span data-stu-id="45345-2309">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2310">O exemplo a seguir demonstra o <xref:System.AppDomain.UnhandledException> eventos.</span><span class="sxs-lookup"><span data-stu-id="45345-2310">The followingexample demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="45345-2311">Ele define um manipulador de eventos, `MyHandler`, que é invocado sempre que uma exceção não tratada é lançada no domínio do aplicativo padrão.</span><span class="sxs-lookup"><span data-stu-id="45345-2311">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="45345-2312">Em seguida, gera duas exceções.</span><span class="sxs-lookup"><span data-stu-id="45345-2312">It then throws two exceptions.</span></span> <span data-ttu-id="45345-2313">A primeira é tratada por um **try/catch** bloco.</span><span class="sxs-lookup"><span data-stu-id="45345-2313">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="45345-2314">A segunda é sem tratamento e invoca o `MyHandle` rotina antes que o aplicativo seja encerrado.</span><span class="sxs-lookup"><span data-stu-id="45345-2314">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="45345-2315">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="45345-2315">requires full trust for the immediate caller.</span></span> <span data-ttu-id="45345-2316">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="45345-2316">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="45345-2317">Um domínio de aplicativo a ser descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2317">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="45345-2318">Descarrega o domínio de aplicativo especificado.</span><span class="sxs-lookup"><span data-stu-id="45345-2318">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45345-2319">No .NET Framework versão 2.0 há um thread dedicado para o descarregamento de domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2319">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="45345-2320">Isso melhora a confiabilidade, especialmente quando o .NET Framework está hospedado.</span><span class="sxs-lookup"><span data-stu-id="45345-2320">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="45345-2321">Quando um thread chama <xref:System.AppDomain.Unload%2A>, o domínio de destino está marcado para descarregar.</span><span class="sxs-lookup"><span data-stu-id="45345-2321">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="45345-2322">O thread dedicado tenta descarregar o domínio e todos os threads no domínio são anulados.</span><span class="sxs-lookup"><span data-stu-id="45345-2322">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="45345-2323">Se um thread não anular, por exemplo porque ele está executando o código não gerenciado, ou porque ele está executando uma `finally` bloco, em seguida, após um período de tempo de um <xref:System.CannotUnloadAppDomainException> é gerada no thread que originalmente chamado <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-2323">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="45345-2324">Se o thread que não puderam ser anulado eventualmente for encerrada, o domínio de destino não é descarregado.</span><span class="sxs-lookup"><span data-stu-id="45345-2324">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="45345-2325">Assim, no .NET Framework versão 2.0 `domain` não é garantida para descarregar, porque ele pode não ser possível encerrar threads em execução.</span><span class="sxs-lookup"><span data-stu-id="45345-2325">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45345-2326">Em alguns casos, chamando <xref:System.AppDomain.Unload%2A> faz com que um imediata <xref:System.CannotUnloadAppDomainException>, por exemplo se ele for chamado em um finalizador.</span><span class="sxs-lookup"><span data-stu-id="45345-2326">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="45345-2327">Os threads no `domain` são encerradas usando o <xref:System.Threading.Thread.Abort%2A> método, que gera um <xref:System.Threading.ThreadAbortException> no thread.</span><span class="sxs-lookup"><span data-stu-id="45345-2327">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="45345-2328">Embora o thread deve terminar imediatamente, ele pode continuar a executar uma quantidade imprevisíveis de tempo em um `finally` cláusula.</span><span class="sxs-lookup"><span data-stu-id="45345-2328">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="45345-2329">Compatibilidade de versões</span><span class="sxs-lookup"><span data-stu-id="45345-2329">Version Compatibility</span></span>  
 <span data-ttu-id="45345-2330">No .NET Framework versão 1.0 e 1.1, se o thread que chama <xref:System.AppDomain.Unload%2A> está em execução no `domain`, outro thread é iniciado para realizar a operação de descarregamento.</span><span class="sxs-lookup"><span data-stu-id="45345-2330">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="45345-2331">Se `domain` não pode ser descarregado, uma <xref:System.CannotUnloadAppDomainException> é lançada nesse thread, não no thread original que chamou <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="45345-2331">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="45345-2332">No entanto, se o thread que chama <xref:System.AppDomain.Unload%2A> está em execução fora do `domain`, que o thread recebe a exceção.</span><span class="sxs-lookup"><span data-stu-id="45345-2332">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45345-2333">O exemplo de código a seguir mostra como descarregar um domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="45345-2333">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="45345-2334"><paramref name="domain" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2334"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="45345-2335">Não foi possível descarregar <paramref name="domain" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2335"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="45345-2336">Ocorreu um erro durante o processo de descarregamento.</span><span class="sxs-lookup"><span data-stu-id="45345-2336">An error occurred during the unload process.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="45345-2337">Para adicionar um manipulador de eventos para este evento.</span><span class="sxs-lookup"><span data-stu-id="45345-2337">to add an event handler for this event.</span></span> <span data-ttu-id="45345-2338">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="45345-2339">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="45345-2339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>