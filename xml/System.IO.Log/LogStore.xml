<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="37759107" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um armazenamento estruturado em log.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Log.LogRecordSequence> classe fornece uma implementação da interface de sequência de registro na parte superior de um log de sistema de arquivos de Log comum (CLFS). Ele funciona com o <xref:System.IO.Log.LogStore> classe, que fornece uma interface para diretamente manipular e gerenciando um CLFS arquivo de log. Um repositório de log fornece armazenamento somente de acréscimo em um conjunto de extensões de disco. O <xref:System.IO.Log.LogStore> classe representa esse armazenamento e fornece métodos para adicionar e remover os contêineres, configuração de política e criar arquivos mortos. Ele não fornece métodos para leitura e gravação para o armazenamento; Esses métodos são fornecidos pelo <xref:System.IO.Log.LogRecordSequence> classe.  
  
 A relação entre o <xref:System.IO.Log.LogStore> classe e o <xref:System.IO.Log.LogRecordSequence> classe é semelhante à relação entre um arquivo de disco e um <xref:System.IO.FileStream> objeto. O arquivo de disco fornece o armazenamento real e tem atributos, como comprimento e a hora do último acesso, enquanto o <xref:System.IO.FileStream> objeto fornece um modo de exibição no arquivo que pode ser usado para ler e gravar nele. Da mesma forma, o <xref:System.IO.Log.LogStore> classe tem atributos como uma diretiva e uma coleção de extensões do disco e o <xref:System.IO.Log.LogRecordSequence> classe fornece um mecanismo orientados a registros para ler e gravar dados.  
  
 Ao contrário de sequência de registro de arquivo representada pela <xref:System.IO.Log.FileRecordSequence> classe, uma <xref:System.IO.Log.LogStore> instância armazena seus dados em uma coleção de extensões do disco, representadas por <xref:System.IO.Log.LogExtent> instâncias. As extensões em um determinado <xref:System.IO.Log.LogStore> instância são todos do tamanho uniforme, e o espaço é adicionado ao e removido de um <xref:System.IO.Log.LogStore> instância em incrementos de extensão. Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A> e <xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos das <xref:System.IO.Log.LogExtentCollection> objeto, que pode ser retornado pelo <xref:System.IO.Log.LogStore.Extents%2A> propriedade.  
  
 Um <xref:System.IO.Log.LogStore> instância pode ter políticas associadas a ele. Esses são representados pelo <xref:System.IO.Log.LogPolicy> instâncias que podem ser retornadas pelo <xref:System.IO.Log.LogStore.Policy%2A> propriedade. Uma política impõe regras que o log tentará a seguir, como o número máximo de extensões e tamanho mínimo e instruções sobre aumentando ou reduzindo o <xref:System.IO.Log.LogStore> sob determinadas condições. Além disso, você pode especificar se um <xref:System.IO.Log.LogStore> instância pode ser arquivada. As políticas são definidas por log e são voláteis, o que significa que depois de cada identificador para o log é fechado, a política não existe mais.  
  
   
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> em um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo de log para o arquivo que o objeto <see cref="T:System.IO.Log.LogStore" /> atual encapsula.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" /> para o identificador especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Não foi possível vincular o identificador de log ao pool de threads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base do repositório de log a abrir.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" /> que determina como abrir ou criar o repositório.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" /> com o caminho e o modo especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor para abrir um repositório de log com o caminho especificado e o modo. O armazenamento é aberto com acesso de leitura/gravação e compartilha o acesso de leitura.  
  
 O `path` parâmetro deve usar a sintaxe a seguir:  
  
 `log:<physical log name>[::<log client name>]`  
  
 em que `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador de cliente exclusivo. Um repositório de log deve ser um repositório de log físico ou um repositório de log virtuais, mas não ambos. Quando um repositório de log tiver sido criado, física ou virtualmente, ele permanecerá isso o tempo de vida. Um repositório de log físico é criado especificando apenas o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome de log do cliente.  
  
 Clientes que compartilham o mesmo nome de log físico compartilham a mesma coleção de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
 <paramref name="path" /> contém somente espaços em branco.  
  
- ou - 
 <paramref name="path" /> contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao abrir o repositório de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> não pode ser usado porque o componente CLFS (Sistema de Arquivos de Log Comum) necessário não está instalado. Instale o componente CLFS se ele estiver disponível para sua plataforma ou use a classe <see cref="T:System.IO.Log.FileRecordSequence" /> em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base do repositório de log a abrir.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" /> que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma dos valores de <see cref="T:System.IO.FileAccess" /> que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" /> com o caminho, o modo e o acesso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor para abrir um novo repositório de log com o caminho especificado, o modo e o acesso. O armazenamento é aberto, compartilhando o acesso de leitura.  
  
 O `path` parâmetro deve usar a sintaxe a seguir:  
  
 `log:<physical log name>[::<log client name>]`  
  
 em que `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador de cliente exclusivo. Um repositório de log deve ser um repositório de log físico ou um repositório de log virtuais, mas não ambos. Quando um repositório de log tiver sido criado, física ou virtualmente, ele permanecerá isso o tempo de vida. Um repositório de log físico é criado especificando apenas o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome de log do cliente.  
  
 Clientes que compartilham o mesmo nome de log físico compartilham a mesma coleção de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
 <paramref name="path" /> contém somente espaços em branco.  
  
- ou - 
 <paramref name="path" /> contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.  
  
-ou 
 <paramref name="access" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao abrir o repositório de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> não pode ser usado porque o componente CLFS (Sistema de Arquivos de Log Comum) necessário não está instalado. Instale o componente CLFS se ele estiver disponível para sua plataforma ou use a classe <see cref="T:System.IO.Log.FileRecordSequence" /> em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base do repositório de log a abrir.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" /> que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma dos valores de <see cref="T:System.IO.FileAccess" /> que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Um dos valores <see cref="T:System.IO.FileShare" /> que determina como o repositório de log será compartilhado entre processos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um novo <xref:System.IO.Log.LogStore> objeto que ele seja aberto com o caminho especificado, modo e acesso. O armazenamento é aberto, compartilhando o acesso especificado.  
  
 O `path` parâmetro deve usar a sintaxe a seguir:  
  
 `log:<physical log name>[::<log client name>]`  
  
 em que `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador de cliente exclusivo. Um repositório de log deve ser um repositório de log físico ou um repositório de log virtuais, mas não ambos. Quando um repositório de log tiver sido criado, física ou virtualmente, ele permanecerá isso o tempo de vida. Um repositório de log físico é criado especificando apenas o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome de log do cliente.  
  
 Clientes que compartilham o mesmo nome de log físico compartilham a mesma coleção de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
 <paramref name="path" /> contém somente espaços em branco.  
  
- ou - 
 <paramref name="path" /> contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.  
  
-ou 
 <paramref name="access" /> contém um valor inválido.  
  
- ou - 
 <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao abrir o repositório de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> não pode ser usado porque o componente CLFS (Sistema de Arquivos de Log Comum) necessário não está instalado. Instale o componente CLFS se ele estiver disponível para sua plataforma ou use a classe <see cref="T:System.IO.Log.FileRecordSequence" /> em vez disso.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base do repositório de log a abrir.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" /> que determina como abrir ou criar o repositório.</param>
        <param name="access">Uma dos valores de <see cref="T:System.IO.FileAccess" /> que determina como o arquivo pode ser acessado pelo <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Um dos valores <see cref="T:System.IO.FileShare" /> que determina como o repositório de log será compartilhado entre processos.</param>
        <param name="fileSecurity">Um dos valores <see cref="T:System.Security.AccessControl.FileSecurity" /> que especifica a segurança a definir no repositório recém-criado, caso o repositório deva ser criado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um novo <xref:System.IO.Log.LogStore> objeto que ele seja aberto com o caminho especificado, modo e acesso. O armazenamento é aberto, compartilhando o acesso especificado. O `path` parâmetro deve seguir a sintaxe a seguir:  
  
 `log:<physical log name>[::<log client name>]`  
  
 em que `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador de cliente exclusivo. Um repositório de log deve ser um repositório de log físico ou um repositório de log virtuais, mas não ambos. Quando um repositório de log tiver sido criado, física ou virtualmente, ele permanecerá isso o tempo de vida. Um repositório de log físico é criado especificando apenas o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome de log do cliente.  
  
 Clientes que compartilham o mesmo nome de log físico compartilham a mesma coleção de extensões e a política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do arquivo de repositório de log especificado pelo <paramref name="path" /> não é válido.  
  
- ou - 
 <paramref name="Mode" /> é <see langword="CreateNew" />, que não pode ser usado sem acesso de gravação.  
  
- ou - 
 <paramref name="Mode" /> é <see langword="OpenOrCreate" />, que não pode ser usado sem acesso de gravação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.  
  
-ou 
 <paramref name="access" /> contém um valor inválido.  
  
- ou - 
 <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao abrir o repositório de log.  
  
O arquivo especificado por <paramref name="path" /> não pode ser acessado porque está em uso por outro processo.  
  
- ou - 
O arquivo especificado por <paramref name="path" /> não pode ser criado porque o arquivo ou diretório já existe.  
  
- ou - 
Não foi possível vincular o identificador de log ao pool de threads.  
  
- ou - 
A versão ou o formato de arquivo de log especificado é inválido.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> não pode ser usado porque o componente CLFS (Sistema de Arquivos de Log Comum) necessário não está instalado. Instale o componente CLFS se ele estiver disponível para sua plataforma ou use a classe <see cref="T:System.IO.Log.FileRecordSequence" /> em vez disso.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registros está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se esta instância <see cref="T:System.IO.Log.LogStore" /> pode ser arquivada.</summary>
        <value><see langword="true" /> Se este <see cref="T:System.IO.Log.LogStore" /> instância pode ser arquivado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um <xref:System.IO.Log.LogStore> não é pode ser arquivado, chamadas para o <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> e <xref:System.IO.Log.LogStore.SetArchiveTail%2A> métodos resultam em um <xref:System.NotSupportedException> que está sendo gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de sequência mais baixo que corresponde a um registro válido nesta instância <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>O número de sequência mais baixo que corresponde a um registro válido nesta <see cref="T:System.IO.Log.LogStore" /> instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Captura um instantâneo do estado do repositório de log necessário fazer um backup.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Captura um instantâneo do estado do repositório de log para fazer um backup.</summary>
        <returns>Um objeto <see cref="T:System.IO.Log.LogArchiveSnapshot" /> que contém o estado necessário para criar um arquivo morto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> em um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O repositório de log não pode ser arquivado.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao criar o instantâneo do arquivo.</exception>
        <exception cref="T:System.ArgumentException">Um argumento não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registros está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">O número de sequência inicial no intervalo para arquivar.</param>
        <param name="last">O número de sequência final no intervalo para arquivar.</param>
        <summary>Captura um instantâneo do estado do repositório de log entre os números de sequência especificado para fazer um backup.</summary>
        <returns>Um objeto <see cref="T:System.IO.Log.LogArchiveSnapshot" /> que contém o estado necessário para criar um arquivo morto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O instantâneo de arquivo retornado desse método abrange informações de número de sequência de base ou o número de sequência de arquivo morto, o que for menor, para o último número de sequência. Não é inclusivo para o último número de sequência, o que significa que o arquivo morto inclui somente os registros até, mas não incluindo a última. Além disso, ao usar esse método, o SequenceNumber de início deve ser igual ao BaseSequenceNumber para que o arquivo morto ser consistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="first" /> ou <paramref name="last" /> não está entre os números de base e de última sequência dessa sequência.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" /> é maior que <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao criar o instantâneo do arquivo.</exception>
        <exception cref="T:System.NotSupportedException">O repositório de log não pode ser arquivado.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registros está cheia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo de base de repositório de log a remover.</param>
        <summary>Remove o repositório de log.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
 <paramref name="path" /> contém somente espaços em branco.  
  
- ou - 
 <paramref name="path" /> contém um ou mais caracteres inválidos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao abrir o repositório de log.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.IO.Log.LogStore.Dispose%2A> quando você terminar de usar o <xref:System.IO.Log.LogStore>. O <xref:System.IO.Log.LogStore.Dispose%2A> método deixa o <xref:System.IO.Log.LogStore> em um estado inutilizável. Depois de chamar <xref:System.IO.Log.LogStore.Dispose%2A> , você deve liberar todas as referências para o <xref:System.IO.Log.LogStore> para que o coletor de lixo possa recuperar a memória que o <xref:System.IO.Log.LogStore> estava ocupando.  
  
> [!NOTE]
>  Sempre chamar <xref:System.IO.Log.LogStore.Dispose%2A> antes de liberar sua última referência para o <xref:System.IO.Log.LogStore>. Caso contrário, os recursos que ele está usando não serão liberados até que o coletor de lixo chame o <xref:System.IO.Log.LogStore> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de extensões de log que contêm os dados para este repositório de log.</summary>
        <value>Um <see cref="T:System.IO.Log.LogExtentCollection" /> instância que contém a coleção de extensões de log que encapsula dados para este repositório de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.IO.Log.LogStore> instância armazena seus dados em uma coleção de extensões do disco, representadas por <xref:System.IO.Log.LogExtent> instâncias. As extensões em um determinado <xref:System.IO.Log.LogStore> instância são todos do tamanho uniforme, e o espaço é adicionado ao e removido de um <xref:System.IO.Log.LogStore> instância em incrementos de extensão. Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A> e <xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos do <xref:System.IO.Log.LogExtentCollection> objeto, que é retornado por essa propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de bytes disponíveis no repositório de log.</summary>
        <value>O número de bytes disponíveis no repositório de log.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de arquivo do sistema operacional para o arquivo de log que a instância <see cref="T:System.IO.Log.LogStore" /> atual encapsula.</summary>
        <value>O identificador de arquivo do sistema operacional para o log de arquivo que atual <see cref="T:System.IO.Log.LogStore" /> instância encapsula.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o número de sequência do próximo registro a ser anexado ao repositório de log.</summary>
        <value>O número de sequência do próximo registro a ser acrescentado ao repositório de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho do repositório de log, em bytes.</summary>
        <value>O tamanho do armazenamento de log, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do repositório de log é a soma dos tamanhos das extensões do log.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a política associada a este repositório de log.</summary>
        <value>Um <see cref="T:System.IO.Log.LogPolicy" /> instância que representa a política associada a este repositório de log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.IO.Log.LogPolicy> instância retornada por essa propriedade para examinar e manipular a diretiva de log associada a este <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">O número de sequência do final do arquivo.</param>
        <summary>Define o número de sequência do final do arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O menor entre o número de sequência de base e o final do arquivo determina o final do log.  
  
   
  
## Examples  
 O exemplo a seguir mostra como arquivar um <xref:System.IO.Log.LogStore> em um documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> não está entre os números de base e de última sequência dessa sequência.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" /> não é válido para essa sequência.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi executada.</exception>
        <exception cref="T:System.IO.IOException">Ocorrerá um erro de E/S ao criar o instantâneo do arquivo.</exception>
        <exception cref="T:System.NotSupportedException">O repositório de log não pode ser arquivado.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para continuar a execução de um programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso ao repositório de log especificado é negado pelo sistema operacional.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de fluxos de log nesse repositório de log.</summary>
        <value>O número de fluxos de log nesse repositório de log.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>