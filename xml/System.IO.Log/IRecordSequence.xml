<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="55071e6e771f10cc96e2985b37bd85ac9623b58a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420620" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece uma interface genérica para uma sequência de registros.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Log.IRecordSequence> interface fornece uma interface abstrata para um fluxo orientados a registros. Um <xref:System.IO.Log.IRecordSequence> instância pode ser usada para ler e gravar registros de log.  
  
 O <xref:System.IO.Log.IRecordSequence> interface fornece os seguintes recursos,  
  
-   Acrescentar registros de log usando o <xref:System.IO.Log.IRecordSequence.Append%2A> métodos.  
  
-   Lê os registros acrescentados usando o <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> método.  
  
-   Gravar um registro de reinicialização especial usando o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> método.  
  
-   Leitura reiniciar registros do escritas recentemente registro reinicialização usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
-   Liberar os registros para o armazenamento durável usando o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
-   Reservar espaço para acrescentar registros.  
  
-   Espaço de log livre, aprimorando a base do log.  
  
-   Receber <xref:System.IO.Log.IRecordSequence.TailPinned> notificações de eventos para mover a base do log para liberar espaço.  
  
 Registros de log são anexados a um <xref:System.IO.Log.IRecordSequence> instância e cada registro de log tem um número de sequência exclusivo. Números de sequência são estritamente monotônica dentro de uma sequência de determinado registro. Um registro de log consiste em dados opacos, fornecidos para o <xref:System.IO.Log.IRecordSequence> instância em um <xref:System.Collections.IList> de ArraySegments de bytes.  
  
 O <xref:System.IO.Log.IRecordSequence> interface também expõe algumas propriedades básico que fornece informações sobre limites de log.  
  
-   O <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> propriedade contém o número de sequência do primeiro registro na sequência de registro válido.  
  
-   O <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> propriedade contém um número de sequência é garantido para ser maior do que o número de sequência do último registro de anexado.  
  
-   O <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> propriedade contém o número de sequência da última área reinicialização escrito.  
  
-   O <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> propriedade contém o tamanho do registro maior que pode ser anexado ao ou ler da sequência.  
  
-   O <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> propriedade contém o tamanho total de todas as reservas feitas nessa sequência de registro.  
  
-   Se o <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> está definida como `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A> operação falhará porque não há nenhum espaço na sequência, a sequência de registro tentará espaço livre e repita a operação de acréscimo.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">O novo número de sequência de base da sequência de registro.</param>
        <summary>Move o número de sequência de base para a parte inicial do log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa um <xref:System.IO.Log.LogRecordSequence> instância e tente para avançar o número de sequência para liberar espaço no log, o novo número de sequência de base deve residir em uma extensão de log diferente para a extensão anterior ser marcados como vazios. Não há suporte para a liberação de extensões parcialmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSequenceNumber" /> não está ativo no log.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao modificar a sequência.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registros está cheia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, grava um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, grava um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log no <see cref="T:System.IO.Log.IRecordSequence" />, usando espaço reservado anteriormente na sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log no <see cref="T:System.IO.Log.IRecordSequence" />, usando espaço reservado anteriormente na sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência do primeiro registro válido no <see cref="T:System.IO.Log.IRecordSequence" /> atual.</summary>
        <value>O número de sequência mais baixo que corresponde a um registro válido no <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 O valor dessa propriedade pode ser alterado, chamando o <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> ou <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousUndoRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">O número da sequência do registro mais recente que deve ser gravado. Se esse <see cref="T:System.IO.Log.SequenceNumber" /> for inválido, todos os registros deverão ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a operação de liberação for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de liberação assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de liberação assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de liberação assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado pelo método atual para o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método para garantir que a liberação é concluída e os recursos são liberados adequadamente. Se ocorrer um erro durante um movimento assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Chamar esse método garante que todos os registros que foram acrescentados ao <xref:System.IO.Log.IRecordSequence> são gravados de maneira durável.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação de liberação assíncrona, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa essa operação assíncrona, que poderia ainda estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa essa operação assíncrona, que poderia ainda estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de gravação de área de reinicialização assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a gravação da área de reinicialização for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação gravação de área de reinicialização assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de gravação da área de reinicialização assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante uma operação de gravação assíncrona reinicialização área, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 Se um <xref:System.IO.Log.ReservationCollection> for especificado, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode manter os dados e reserva será removida da coleção.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método é chamado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a gravação da área de reinicialização for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação gravação de área de reinicialização assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de gravação da área de reinicialização assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve transmitir o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados adequadamente. Se ocorreu um erro durante uma operação de gravação assíncrona reinicialização área, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 Se um <xref:System.IO.Log.ReservationCollection> for especificado, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode manter os dados e reserva será removida da coleção.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, cria um novo <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>O <see cref="T:System.IO.Log.ReservationCollection" /> recém-criado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de acréscimo assíncrona.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornarão visíveis quando <xref:System.IO.Log.IRecordSequence.EndAppend%2A> é chamado.  
  
 Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de liberação assíncrona.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de liberação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornarão visíveis quando <xref:System.IO.Log.IRecordSequence.EndFlush%2A> é chamado.  
  
 Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornarão visíveis quando <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> é chamado.  
  
 Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de gravação de área de reinicialização assíncrona.</summary>
        <returns>O número de sequência do registro de log gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornarão visíveis quando <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> é chamado.  
  
 Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, faz com que registros acrescentados sejam gravados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituída em uma classe derivada, garante que todos os registros acrescentados foram gravados.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método garante que todos os registros que foi acrescentada ao <xref:System.IO.Log.IRecordSequence> tiverem sido gravados de maneira durável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">O número da sequência do registro mais recente que deve ser gravado. Se esse <see cref="T:System.IO.Log.SequenceNumber" /> for inválido, todos os registros deverão ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, garante que todos os registros acrescentados até e incluindo o registro com o número de sequência especificado foram gravados de modo durável.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar que esse método garante que todos os registros com sequência de números até e incluindo o número de sequência especificado foram gravados muito tempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência que é maior que o último registro acrescentado.</summary>
        <value>Uma sequência numérica que é maior que o último registro anexado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade contém um número de sequência é garantido para ser maior do que o número de sequência do último registro de anexado. Números de sequência são maiores que ou igual a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Ao usar um <xref:System.IO.Log.LogRecordSequence> instância, o <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> valor pode se tornar desatualizado até que os registros são liberados para o log. Consulte <xref:System.IO.Log.IRecordSequence.Flush%2A> e <xref:System.IO.Log.RecordAppendOptions> para obter mais informações sobre os registros de liberação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o tamanho do registro maior que pode ser lido desta sequência ou acrescentado a ela, em bytes.</summary>
        <value>O tamanho do registro maior que pode ser anexado ao ou ler esta sequência, em bytes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">O número de sequência do primeiro registro em que a leitura começa.</param>
        <param name="logRecordEnum">Um valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica a maneira (ou seja, para frente ou para trás) como os registros devem ser lidos de um <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Quando substituída em uma classe derivada, retorna uma coleção enumerável de registros na sequência.</summary>
        <returns>Uma coleção enumerável de registros na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando substituída em uma classe derivada, retorna uma coleção enumerável de registros na sequência. A ordem dos registros de enumerada depende do valor da `logRecordEnum` parâmetro.  
  
   
  
## Examples  
 Este exemplo demonstra o uso de <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> método.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao ler o registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituída em uma classe derivada, retorna uma coleção enumerável de áreas de reinicialização na sequência.</summary>
        <returns>Uma coleção enumerável de áreas de reinicialização na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As áreas de reinicialização são enumeradas na ordem do número de sequência inversa, ou seja, do número de sequência mais alto para o menor número de sequência. Reiniciar somente áreas com números de sequência entre o último número de sequência e o número de sequência de base são enumeradas.  
  
> [!NOTE]
>  Se a extensão de log que contém o <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> torna-se corrompido, esse método pode acionar um <xref:System.IO.IOException> com a mensagem de erro "a solicitação não pôde ser executada devido a uma exceção de e/s inesperada. O seguinte código de erro foi retornado: '80070026' ".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao ler o registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a coleção na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número total de bytes que foram reservados.</summary>
        <value>O tamanho total de todas as reservas feitas nessa sequência de registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência da área de reinicialização mais recentemente gravada.</summary>
        <value>O número de sequência do mais recentemente escrito reinicialização área.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se há novas tentativas automáticas de acréscimo se o log está cheio.</summary>
        <value>
          <see langword="true" /> se anexa são repetidas automaticamente se o log está cheio; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor dessa propriedade é `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A> chamada falha porque não há espaço suficiente na sequência, a sequência de registro tentará espaço livre e tente novamente a acrescentar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a sequência de registro determina que a parte final deve ser movida para a frente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento quando a sequência de registro ficou sem espaço pode ser acionado. Quando esse evento é acionado, o final da sequência (ou seja, o número de sequência de base) é movido para frente para liberar espaço.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.  
  
 Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Os dados nos segmentos de matriz de bytes serão ser concatenados em uma matriz de byte único para acrescentar como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Os dados nos segmentos de matriz de bytes serão ser concatenados em uma matriz de byte único para acrescentar como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> e atualiza o número de sequência de base</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> e atualiza o número de sequência de base.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> usando uma reserva e atualiza o número de sequência de base</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e reserva será removida da coleção.  
  
 Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> usando uma reserva e atualiza o número de sequência de base.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando a recuperação for necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.  
  
 Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e reserva será removida da coleção.  
  
 Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.  
  
 Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
  </Members>
</Type>