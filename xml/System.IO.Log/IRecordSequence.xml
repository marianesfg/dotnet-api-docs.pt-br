<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6260e0146911a1dbb9e8df4620ffe2a357e6709f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37654486" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece uma interface genérica para uma sequência de registros.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Log.IRecordSequence> interface fornece uma interface abstrata para um fluxo orientados a registros. Um <xref:System.IO.Log.IRecordSequence> instância pode ser usada para ler e gravar registros de log.  
  
 O <xref:System.IO.Log.IRecordSequence> interface fornece os seguintes recursos,  
  
-   Acrescentar os registros de log usando o <xref:System.IO.Log.IRecordSequence.Append%2A> métodos.  
  
-   Ler os registros acrescentados usando o <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> método.  
  
-   Gravar um registro de reinicialização especial usando o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> método.  
  
-   Leitura reiniciar registros a partir do registro reinicialização gravada mais recentemente usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
-   Os registros de liberação para o armazenamento durável usando o <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
-   Reservar espaço para acrescentar registros.  
  
-   Espaço livre do log por Avançar a base do log.  
  
-   Receber <xref:System.IO.Log.IRecordSequence.TailPinned> notificações de eventos para mover a base do log para liberar espaço.  
  
 Registros de log são anexados a um <xref:System.IO.Log.IRecordSequence> instância e cada registro de log é fornecido com um número de sequência exclusivo. Números de sequência são estritamente de forma monotônica dentro de uma sequência de determinado registro. Consiste em um registro de log de dados opaco, fornecidos para o <xref:System.IO.Log.IRecordSequence> da instância em um <xref:System.Collections.IList> de ArraySegments de bytes.  
  
 O <xref:System.IO.Log.IRecordSequence> interface também expõe algumas propriedades básicas que fornece informações sobre os limites de log.  
  
-   O <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> propriedade contém o número de sequência do primeiro registro válido na sequência de registro.  
  
-   O <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> propriedade contém um número de sequência que é garantido que seja maior que o número de sequência do último registro de acrescentado.  
  
-   O <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> propriedade contém o número de sequência da última área de reinicialização escrito.  
  
-   O <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> propriedade contém o tamanho do registro maior que pode ser anexado para ou ler da sequência.  
  
-   O <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> propriedade contém o tamanho total de todas as reservas feitas nessa sequência de registro.  
  
-   Se o <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> estiver definida como `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A> Falha na operação porque não há nenhum espaço na sequência, a sequência de registro tentará liberar espaço e tente novamente a operação de acréscimo.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">O novo número de sequência de base da sequência de registro.</param>
        <summary>Move o número de sequência de base para a parte inicial do log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa um <xref:System.IO.Log.LogRecordSequence> instância e tente para avançar o número de sequência para liberar espaço no log, o novo número de sequência de base deve residir em uma extensão de log diferente para a extensão anterior seja marcado como vazio. Não há suporte para a liberação de extensões parcialmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> não está ativo no log.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao modificar a sequência.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registros está cheia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, grava um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, grava um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log para o <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log no <see cref="T:System.IO.Log.IRecordSequence" />, usando espaço reservado anteriormente na sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado irão consumir espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se o acréscimo for bem-sucedida, ele consumirá a menor área de reserva que pode conter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <summary>Quando substituída em uma classe derivada, acrescenta um registro de log no <see cref="T:System.IO.Log.IRecordSequence" />, usando espaço reservado anteriormente na sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado irão consumir espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se o acréscimo for bem-sucedida, ele consumirá a menor área de reserva que pode conter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência do primeiro registro válido no <see cref="T:System.IO.Log.IRecordSequence" /> atual.</summary>
        <value>O número de sequência mais baixo que corresponde a um registro válido no <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números de sequência são maiores que ou igual a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 O valor dessa propriedade pode ser alterado por meio da chamada a <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> ou <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado irão consumir espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se o acréscimo for bem-sucedida, ele consumirá a menor área de reserva que pode conter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousUndoRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservations">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para este registro.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de acréscimo assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa o acréscimo assíncrono, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 O registro acrescentado irão consumir espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se o acréscimo for bem-sucedida, ele consumirá a menor área de reserva que pode conter os dados e área de reserva será removida da coleção.  
  
 Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">O número da sequência do registro mais recente que deve ser gravado. Se esse <see cref="T:System.IO.Log.SequenceNumber" /> for inválido, todos os registros deverão ser gravados.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a operação de liberação for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de liberação assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de liberação assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de liberação assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado pelo método atual para o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método para garantir que a liberação é concluída e os recursos são liberados apropriadamente. Se ocorrer um erro durante uma liberação assíncrona, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Chamar esse método garante que todos os registros que tenha sido anexado ao <xref:System.IO.Log.IRecordSequence> são gravados de modo durável.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de liberação assíncrona, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndFlush%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa essa operação assíncrona, que poderia ainda estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas à reserva fornecida a coleção em uma operação atômica com um registro de operação de acréscimo. Se o acréscimo falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando o acréscimo for concluído.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de acréscimo assíncrono específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa essa operação assíncrona, que poderia ainda estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas à reserva fornecida a coleção em uma operação atômica com um registro de operação de acréscimo. Se o acréscimo falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, inicia uma operação de gravação de área de reinicialização assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a gravação da área de reinicialização for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação gravação de área de reinicialização assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de gravação da área de reinicialização assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método, para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante uma operação de gravação de área de reinicialização assíncrona, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 Se um <xref:System.IO.Log.ReservationCollection> for especificado, a área de reinicialização escrito irão consumir espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e que a reserva será removida da coleção.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método é chamado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a gravação da área de reinicialização for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma operação gravação de área de reinicialização assíncrona, usando o espaço reservado anteriormente na sequência.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de gravação da área de reinicialização assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve passar o <xref:System.IAsyncResult> retornado por esse método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados apropriadamente. Se ocorreu um erro durante uma operação de gravação de área de reinicialização assíncrona, uma exceção não é lançada até que o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método for chamado com o <xref:System.IAsyncResult> retornado por esse método.  
  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 Se um <xref:System.IO.Log.ReservationCollection> for especificado, a área de reinicialização escrito irão consumir espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e que a reserva será removida da coleção.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, cria um novo <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>O <see cref="T:System.IO.Log.ReservationCollection" /> recém-criado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de acréscimo assíncrona.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando <xref:System.IO.Log.IRecordSequence.EndAppend%2A> é chamado.  
  
 Esse método deve ser chamado exatamente uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de liberação assíncrona.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de liberação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando <xref:System.IO.Log.IRecordSequence.EndFlush%2A> é chamado.  
  
 Esse método deve ser chamado exatamente uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de reserva e acréscimo assíncrona.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> é chamado.  
  
 Esse método deve ser chamado exatamente uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Quando substituída em uma classe derivada, termina uma operação de gravação de área de reinicialização assíncrona.</summary>
        <returns>O número de sequência do registro de log gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> é chamado.  
  
 Esse método deve ser chamado exatamente uma vez em cada <xref:System.IAsyncResult> retornado pelo <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, faz com que registros acrescentados sejam gravados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituída em uma classe derivada, garante que todos os registros acrescentados foram gravados.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método garante que todos os registros que tenha sido anexado ao <xref:System.IO.Log.IRecordSequence> foram gravados por muito tempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">O número da sequência do registro mais recente que deve ser gravado. Se esse <see cref="T:System.IO.Log.SequenceNumber" /> for inválido, todos os registros deverão ser gravados.</param>
        <summary>Quando substituída em uma classe derivada, garante que todos os registros acrescentados até e incluindo o registro com o número de sequência especificado foram gravados de modo durável.</summary>
        <returns>O número de sequência do último registro gravado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar que esse método garante que todos os registros com sequência de números até e incluindo o número de sequência especificado foram gravados por muito tempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao liberar os dados.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência que é maior que o último registro acrescentado.</summary>
        <value>Uma sequência de número que é maior que o último registro acrescentado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade contém um número de sequência é garantido que seja maior que o número de sequência do último registro de acrescentado. Números de sequência são maiores que ou igual a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e menor que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Ao usar um <xref:System.IO.Log.LogRecordSequence> instância, o <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> valor pode ficar desatualizado até que os registros são liberados para o log. Ver <xref:System.IO.Log.IRecordSequence.Flush%2A> e <xref:System.IO.Log.RecordAppendOptions> para obter mais informações sobre registros de liberação...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o tamanho do registro maior que pode ser lido desta sequência ou acrescentado a ela, em bytes.</summary>
        <value>O tamanho do registro maior que pode ser anexado para ou ler esta sequência, em bytes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">O número de sequência do primeiro registro em que a leitura começa.</param>
        <param name="logRecordEnum">Um valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica a maneira (ou seja, para frente ou para trás) como os registros devem ser lidos de um <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Quando substituída em uma classe derivada, retorna uma coleção enumerável de registros na sequência.</summary>
        <returns>Uma coleção enumerável de registros na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando substituída em uma classe derivada, retorna uma coleção enumerável de registros na sequência. A ordem dos registros enumerados depende do valor da `logRecordEnum` parâmetro.  
  
   
  
## Examples  
 Este exemplo demonstra o uso do <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> método.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao ler o registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituída em uma classe derivada, retorna uma coleção enumerável de áreas de reinicialização na sequência.</summary>
        <returns>Uma coleção enumerável de áreas de reinicialização na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As áreas de reinicialização são enumeradas na ordem de número de sequência inversa, ou seja, do número de sequência mais alto ao mais baixo número de sequência. Apenas reinicie áreas com números de sequência entre o último número de sequência e o número de sequência de base são enumerados.  
  
> [!NOTE]
>  Se a extensão de log que contém o <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> torna-se corrompida, esse método pode lançar um <xref:System.IO.IOException> com a mensagem de erro "a solicitação não pôde ser executada devido a uma exceção de e/s inesperada. O seguinte código de erro foi retornado: '80070026' ".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao ler o registro.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a coleção na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas à reserva fornecida a coleção em uma operação atômica com um registro de operação de acréscimo. Se o acréscimo falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="nextUndoRecord">O número de sequência do próximo registro na ordem especificada pelo usuário.</param>
        <param name="previousRecord">O número de sequência do próximo registro na ordem Anterior.</param>
        <param name="recordAppendOptions">Um valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica como os dados devem ser gravados.</param>
        <param name="reservationCollection">A coleção de reservas na qual fazer reservas.</param>
        <param name="reservations">As reservas a fazer, em bytes.</param>
        <summary>Quando substituída em uma classe derivada, faz automaticamente uma única reserva e acrescenta um registro à sequência.</summary>
        <returns>O número de sequência do registro de log acrescentado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dados contidos no `data` parâmetro será concatenado em uma matriz de byte único para acréscimo como o registro. No entanto, nenhuma provisão é feita para dividir os dados novamente em segmentos de matriz quando o registro é lido.  
  
 As reservas especificadas são adicionadas à reserva fornecida a coleção em uma operação atômica com um registro de operação de acréscimo. Se o acréscimo falhar, nenhum espaço é reservado.  
  
 Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions.ForceFlush> sinalizador usando o `recordAppendOptions` parâmetro ou a chamada a <xref:System.IO.Log.IRecordSequence.Flush%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao acrescentar o registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter o novo registro ou para fazer a reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número total de bytes que foram reservados.</summary>
        <value>O tamanho total de todas as reservas feitas nessa sequência de registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituída em uma classe derivada, obtém o número de sequência da área de reinicialização mais recentemente gravada.</summary>
        <value>O número de sequência do gravado mais recentemente a área de reinicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se há novas tentativas automáticas de acréscimo se o log está cheio.</summary>
        <value><see langword="true" /> se anexa automaticamente são repetidas se o log estiver cheio; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor dessa propriedade é `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A> chamada falhará porque não há espaço suficiente na sequência, a sequência de registro tentará liberar espaço e tente novamente a acrescentar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A propriedade foi acessada depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a sequência de registro determina que a parte final deve ser movida para a frente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode disparar esse evento quando a sequência de registro ficou sem espaço. Quando esse evento é acionado, a parte final da sequência (ou seja, o número de sequência de base) é movida para frente para liberar espaço.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando uma recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação.  
  
 Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Os dados em segmentos de matriz de bytes serão concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Os dados em segmentos de matriz de bytes serão concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> e atualiza o número de sequência de base</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados em segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 Quando este método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> e atualiza o número de sequência de base.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados em segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 Quando este método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> usando uma reserva e atualiza o número de sequência de base</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados em segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e que a reserva será removida da coleção.  
  
 Quando este método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Uma lista de segmentos de matriz de bytes que serão concatenados e acrescentados como o registro.</param>
        <param name="newBaseSequenceNumber">O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual.</param>
        <param name="reservation">Um <see cref="T:System.IO.Log.ReservationCollection" /> que contém a reserva que deve ser usada para esta área de reinicialização.</param>
        <summary>Quando substituída em uma classe derivada, grava uma área de reinicialização no <see cref="T:System.IO.Log.IRecordSequence" /> usando uma reserva e atualiza o número de sequência de base.</summary>
        <returns>O número de sequência da área de reinicialização gravada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. Quando uma recuperação é necessária, você pode analisar a área de reinicialização para recuperar todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivo aberto para que possam ser usados no processo de recuperação. Uma área de reinicialização pode ser lido usando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> método.  
  
 Quando uma área de reinicialização é gravada, os dados em segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lido.  
  
 Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e que a reserva será removida da coleção.  
  
 Quando este método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência de menor que o novo número de sequência de base está inacessível.  
  
 Se uma sequência de registros foi descartada ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros que ocorreram durante uma solicitação de acréscimo assíncrono, por exemplo, uma falha de disco durante a solicitação de e/s, resultará em exceções sendo geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao gravar a área de reinicialização.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">A sequência de registro não pôde gerar espaço livre suficiente para conter a nova área de reinicialização.</exception>
        <exception cref="T:System.ObjectDisposedException">O método foi chamado depois que a sequência foi descartada.</exception>
      </Docs>
    </Member>
  </Members>
</Type>