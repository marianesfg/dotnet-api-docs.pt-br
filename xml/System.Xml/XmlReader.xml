<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a247d2896ea3528404d0f1bb04ecb2c3a4bb676" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37485433" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um leitor que fornece acesso rápido não armazenado em cache e somente de encaminhamento aos dados XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> fornece acesso de somente avanço, somente leitura aos dados XML em um documento ou fluxo. Essa classe está de acordo com o W3C [Extensible Markup Language (XML) 1.0 (quarta edição)](https://www.w3.org/TR/2006/REC-xml-20060816/) e o [Namespaces no XML 1.0 (terceira edição)](https://www.w3.org/TR/REC-xml-names/) recomendações.  
  
 <xref:System.Xml.XmlReader> métodos permitem que você percorrer os dados XML e ler o conteúdo de um nó. As propriedades da classe refletem o valor do nó atual, que é onde o leitor está posicionado. O <xref:System.Xml.XmlReader.ReadState%2A> valor da propriedade indica o estado atual do leitor de XML. Por exemplo, a propriedade é definida como <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> pela <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método e <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> pelo <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> método. <xref:System.Xml.XmlReader> também fornece verificações de conformidade de dados e a validação em um DTD ou esquema.  
  
 <xref:System.Xml.XmlReader> usa um modelo de pull para recuperar dados. Este modelo:  
  
-   Simplifica o gerenciamento de estado por um refinamento procedural natural, de cima para baixo.  
  
-   Dá suporte a vários fluxos de entrada e a disposição em camadas.  
  
-   Permite que o cliente dê ao analisador um buffer no qual a cadeia de caracteres é gravada diretamente e, portanto, evita a necessidade de uma cópia da cadeia de caracteres extras.  
  
-   Suporta processamento seletivo. O cliente pode ignorar itens e processar aqueles que são de interesse para o aplicativo. Você também pode definir propriedades de antemão para gerenciar como o fluxo XML é processado (por exemplo, normalização).  
  
 Nesta seção:  
  
 [Criando um leitor XML](#xmlreader_create)   
 [Validando dados XML](#xmlreader_validate)   
 [Compatibilidade de dados](#xmlreader_data)   
 [Navegar por nós](#xmlreader_nodes)   
 [Elementos XML de leitura](#xmlreader_elements)   
 [Atributos XML de leitura](#xmlreader_attributes)   
 [Conteúdo XML de leitura](#xmlreader_content)   
 [Convertendo em tipos CLR](#xmlreader_clr)   
 [Programação assíncrona](#xmlreader_async)   
 [Considerações sobre segurança](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Criando um leitor XML  
 Use o <xref:System.Xml.XmlReader.Create%2A> método para criar um <xref:System.Xml.XmlReader> instância.  
  
 Embora o .NET Framework fornece implementações concretas do <xref:System.Xml.XmlReader> classe, como o <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>e o <xref:System.Xml.XmlValidatingReader> classes, é recomendável que você use as classes especializadas apenas nesses cenários:  
  
-   Quando você deseja ler uma subárvore DOM XML de um <xref:System.Xml.XmlNode> do objeto, use o <xref:System.Xml.XmlNodeReader> classe. (No entanto, essa classe não dá suporte a validação de DTD ou esquema.)  
  
-   Se você deve expandir entidades mediante solicitação, você não quer seu texto conteúdo normalizados, ou você não deseja atributos retornados padrão, use o <xref:System.Xml.XmlTextReader> classe.  
  
 Para especificar o conjunto de recursos que você deseja habilitar o leitor de XML, passe uma <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> do objeto para o <xref:System.Xml.XmlReader.Create%2A> método. Você pode usar uma única <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> para criar vários leitores com a mesma funcionalidade do objeto ou modificar o <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> objeto para criar um novo leitor com um conjunto diferente de recursos. Também é fácil, você pode adicionar recursos a um leitor existente.  
  
 Se você não usar um <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> do objeto, as configurações padrão são usadas. Consulte o <xref:System.Xml.XmlReader.Create%2A> página de referência para obter detalhes.  
  
 <xref:System.Xml.XmlReader> gera um <xref:System.Xml.XmlException> erros de análise XML. Depois que uma exceção é lançada, o estado do leitor não é previsível. Por exemplo, o tipo de nó relatadas pode ser diferente do tipo de nó reais do nó atual. Use o <xref:System.Xml.XmlReader.ReadState%2A> propriedade para verificar se o leitor está no estado de erro.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validando dados XML  
 Para definir a estrutura de um documento XML e suas relações do elemento, tipos de dados e restrições de conteúdo, você pode usar um document type definition (DTD) ou o esquema de (XSD) de linguagem de definição de esquema XML. Um documento XML é considerado bem-formado se atender a todos os requisitos sintáticos definidos pela [recomendação do W3C XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/). Ele é considerado válido se ele está bem formado e que também está de acordo com as restrições definidas pela DTD ou esquema. (Consulte a [esquema W3C XML parte 1: estruturas](https://www.w3.org/TR/xmlschema-1/) e o [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/)recomendações.) Portanto, embora todos os documentos XML válidos sejam bem-formados, nem todos os documentos XML bem-formados são válidos.  
  
 Você pode validar os dados em um DTD, um esquema de XSD embutido ou um esquema XSD é armazenado em um <xref:System.Xml.Schema.XmlSchemaSet> objeto (um cache); esses cenários são descritos no <xref:System.Xml.XmlReader.Create%2A> página de referência. <xref:System.Xml.XmlReader> não dá suporte a validação de esquema XML-Data Reduced (XDR).  
  
 Use as seguintes configurações na <xref:System.Xml.XmlReaderSettings> classe para especificar o tipo de validação, se houver, o <xref:System.Xml.XmlReader> dá suporte a da instância.  
  
|Use esta <xref:System.Xml.XmlReaderSettings> membro|Para especificar|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|Propriedade <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|Se deseja permitir o processamento de DTD. O padrão é não permitir o processamento de DTD.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ValidationType%2A>|Se o leitor deve validar os dados e que tipo de validação a ser executado (DTD ou esquema). A opção não é possível validação de dados.|  
|Evento <xref:System.Xml.XmlReaderSettings.ValidationEventHandler>|Um manipulador de eventos para receber informações sobre eventos de validação. Se um manipulador de eventos não for fornecido, <xref:System.Xml.XmlException> será apresentada no primeiro erro de validação.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|Opções de validação adicional por meio de <xref:System.Xml.Schema.XmlSchemaValidationFlags> membros de enumeração:<br /><br /> -   `AllowXmlAttributes`-Permite atributos XML (`xml:*`) em documentos de instância, mesmo quando eles não estiverem definidos no esquema. Os atributos são validados com base no tipo de dados. Consulte o <xref:System.Xml.Schema.XmlSchemaValidationFlags> página de referência para a configuração a ser usada em cenários específicos. (Desabilitado por padrão).<br />-     - restrições de identidade de processo (`ProcessIdentityConstraints`, `xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`) encontrados durante a validação. (Habilitado por padrão).<br />-   `ProcessSchemaLocation` – Processar esquemas especificados pela `xsi:schemaLocation` ou `xsi:noNamespaceSchemaLocation` atributo. (Habilitado por padrão).<br />-   `ProcessInlineSchema`– Processe embutido esquemas XML durante a validação. (Desabilitado por padrão).<br />-   `ReportValidationWarnings`– Relatar eventos se ocorrer um aviso de validação. Um aviso é emitida normalmente quando não há nenhum DTD ou esquema XML para validar um elemento ou atributo específico contra. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> é usado para notificação. (Desabilitado por padrão).|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|O <xref:System.Xml.Schema.XmlSchemaSet> a ser usado para validação.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|O <xref:System.Xml.XmlResolver> para resolver e acessar recursos externos. Isso pode incluir entidades externas, como o DTD e esquemas e qualquer `xs:include` ou `xs:import` elementos contidos no esquema XML. Se você não especificar um <xref:System.Xml.XmlResolver>, o <xref:System.Xml.XmlReader> usa um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais do usuário.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Compatibilidade de dados  
 Os leitores XML que são criados pelo <xref:System.Xml.XmlReader.Create%2A> método cumprir os seguintes requisitos de conformidade por padrão:  
  
-   Novas linhas e o valor de atributo são normalizados de acordo com o W3C [recomendação XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Todas as entidades são expandidas automaticamente.  
  
-   Atributos padrões declarados na definição de tipo de documento sempre são adicionados, mesmo quando o leitor não valida.  
  
-   Declaração de prefixo XML mapeado para o URI de namespace XML correto é permitida.  
  
-   Os nomes de notação em uma única `NotationType` declaração de atributo e `NmTokens` em uma única `Enumeration` declaração de atributo são diferentes.  
  
 Use estas <xref:System.Xml.XmlReaderSettings> propriedades para especificar o tipo de conformidade verifica que você deseja habilitar:  
  
|Use esta <xref:System.Xml.XmlReaderSettings> propriedade|Para|Padrão|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|Propriedade <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|Habilitar ou desabilitar as verificações para o seguinte:<br /><br /> -Caracteres estão dentro do intervalo de caracteres XML legais, conforme definido pela [2.2 caracteres](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) seção recomendação W3C XML 1.0.<br />-Todos os nomes XML são válidos, conforme definido pela [2.3 comuns sintática constrói](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) seção recomendação W3C XML 1.0.<br /><br /> Quando essa propriedade é definida como `true` (padrão), um <xref:System.Xml.XmlException> exceção será lançada se o arquivo XML contém caracteres inválidos ou nomes XML inválidos (por exemplo, um nome de elemento inicia com um número).|Caractere e verificação de nome está habilitado.<br /><br /> A definição de <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> como `false` desativa a verificação de caracteres em referências de entidade de caracteres. Se o leitor está processando dados de texto, ele sempre verifica que os nomes XML são válidos, independentemente dessa configuração. **Observação:** a recomendação XML 1,0 requer compatibilidade de nível de documento quando um DTD presente. Portanto, se o leitor está configurado para suportar <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, mas os dados XML contêm um document type definition (DTD), um <xref:System.Xml.XmlException> é gerada.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|Escolha o nível de conformidade para impor a:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Está em conformidade com as regras para um [documento XML bem formado 1,0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Está em conformidade com as regras para um fragmento de documento bem formado que pode ser consumido como uma [externo analisado entidade](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. É compatível com o nível decidido pelo leitor.<br /><br /> Se os dados não estiverem em conformidade, um <xref:System.Xml.XmlException> exceção é lançada.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Navegar por nós  
 O nó atual é o nó XML no qual o leitor de XML é posicionado no momento. Todos os <xref:System.Xml.XmlReader> métodos executam operações em relação a esse nó e todos os <xref:System.Xml.XmlReader> propriedades refletem o valor do nó atual.  
  
 Os métodos a seguir tornam fácil navegar por nós e analisar dados.  
  
|Use esta <xref:System.Xml.XmlReaderSettings> método|Para|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Ler o primeiro nó e avance através do nó de um fluxo por vez. Essas chamadas são normalmente executadas dentro uma `while` loop.<br /><br /> Use o <xref:System.Xml.XmlReader.NodeType%2A> propriedade para obter o tipo (por exemplo, atributo, comentário, elemento e assim por diante) do nó atual.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Ignore os filhos do nó atual e mover para o próximo nó.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> e <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Ignorar nós não são de conteúdo e mover para o próximo nó de conteúdo ou para o final do arquivo.<br /><br /> Os nós de conteúdo não incluem <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, e <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Nós de conteúdo incluem texto não seja espaço em branco, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , e <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Ler um elemento e todos os seus filhos e retornar uma nova <xref:System.Xml.XmlReader> instância definida como <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Esse método é útil para a criação de limites em torno de elementos XML; Por exemplo, se você deseja passar dados para outro componente para processamento e você quiser limitar a quantidade de dados pode acessar o componente.|  
  
 Consulte o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> página de referência para obter um exemplo de navegar por meio de um nó de um de fluxo de texto por vez e exibir o tipo de cada nó.  
  
 As seções a seguir descrevem como você pode ler tipos específicos de dados, como elementos, atributos e dados de tipo.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Elementos XML de leitura  
 A tabela a seguir lista os métodos e propriedades que o <xref:System.Xml.XmlReader> classe fornece para processar elementos. Depois que <xref:System.Xml.XmlReader> é posicionada em um elemento, as propriedades de nó, como <xref:System.Xml.XmlReader.Name%2A>, refletem os valores do elemento. Além dos membros descritos a seguir, alguns dos métodos e das propriedades gerais da classe <xref:System.Xml.XmlReader> também podem ser usados para processar elementos. Por exemplo, é possível usar o método <xref:System.Xml.XmlReader.ReadInnerXml%2A> para ler o conteúdo de um elemento.  
  
> [!NOTE]
>  Consulte a seção 3.1 do [recomendação do W3C XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) para definições de marcas de início, término marcas e marcas de elemento vazio.  
  
|Use esta <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Método <xref:System.Xml.XmlReader.IsStartElement%2A>|Verifique se o nó atual é uma marca de início ou uma marca de elemento vazia.|  
|Método <xref:System.Xml.XmlReader.ReadStartElement%2A>|Verifique se o nó atual é um elemento e avança o leitor para o próximo nó (chamadas <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por <xref:System.Xml.XmlReader.Read%2A>).|  
|Método <xref:System.Xml.XmlReader.ReadEndElement%2A>|Verifique se o nó atual é uma marca de fim e avança o leitor para o próximo nó.|  
|Método <xref:System.Xml.XmlReader.ReadElementString%2A>|Ler um elemento somente texto.|  
|Método <xref:System.Xml.XmlReader.ReadToDescendant%2A>|Avança o leitor de XML para o próximo elemento descendente (filho) que tem o nome especificado.|  
|Método <xref:System.Xml.XmlReader.ReadToNextSibling%2A>|Avança o leitor de XML para o próximo elemento irmão com o nome especificado.|  
|Propriedade <xref:System.Xml.XmlReader.IsEmptyElement%2A>|Verifique se o elemento atual tem uma marca de elemento final. Por exemplo:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> é `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> é `false`, embora o conteúdo do elemento está vazio.)|  
  
 Para obter um exemplo de ler o conteúdo de texto dos elementos, consulte o <xref:System.Xml.XmlReader.ReadString%2A> método. O exemplo a seguir processa elementos usando um `while` loop.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Atributos XML de leitura  
 Atributos XML são mais comumente encontrados nos elementos, mas eles também têm permissão na declaração XML e nós de tipo de documento.  
  
 Quando posicionado em um nó de elemento, o <xref:System.Xml.XmlReader.MoveToAttribute%2A> método permite que você percorra a lista de atributos do elemento. Observe que, depois <xref:System.Xml.XmlReader.MoveToAttribute%2A> tiver sido chamado, as propriedades de nó, como <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> refletem as propriedades desse atributo, não as propriedades do elemento o atributo pertence.  
  
 O <xref:System.Xml.XmlReader> classe fornece os métodos e propriedades para ler e processar atributos em elementos.  
  
|Use esta <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriedade <xref:System.Xml.XmlReader.HasAttributes%2A>|Verifique se o nó atual tem todos os atributos.|  
|Propriedade <xref:System.Xml.XmlReader.AttributeCount%2A>|Obtenha o número de atributos no elemento atual.|  
|Método <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>|Mover para o primeiro atributo em um elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>|Mover para o próximo atributo em um elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToAttribute%2A>|Mover para um atributo especificado.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> método ou <xref:System.Xml.XmlReader.Item%2A> propriedade|Obter o valor de um atributo especificado.|  
|Propriedade <xref:System.Xml.XmlReader.IsDefault%2A>|Verifique se o nó atual é um atributo que foi gerado do valor padrão definido no DTD ou esquema.|  
|Método <xref:System.Xml.XmlReader.MoveToElement%2A>|Mover para o elemento que possui o atributo atual. Use esse método para retornar a um elemento depois de navegar por meio de seus atributos.|  
|Método <xref:System.Xml.XmlReader.ReadAttributeValue%2A>|Analisar o valor do atributo em um ou mais `Text`, `EntityReference`, ou `EndEntity` nós.|  
  
 Alguns dos métodos e propriedades gerais de <xref:System.Xml.XmlReader> também podem ser usados para processar atributos. Por exemplo, depois que <xref:System.Xml.XmlReader> é posicionado em um atributo, as propriedades <xref:System.Xml.XmlReader.Name%2A> e <xref:System.Xml.XmlReader.Value%2A> refletem os valores do atributo. Você também pode usar qualquer um dos métodos de conteúdo de `Read` para obter o valor do atributo.  
  
 Este exemplo usa o <xref:System.Xml.XmlReader.AttributeCount%2A> propriedade para navegar por todos os atributos em um elemento.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Este exemplo usa o <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> método em um `while` loop para navegar por meio dos atributos.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Lendo atributos em nós de declaração XML**  
  
 Quando o leitor de XML é posicionado em um nó de declaração XML, o <xref:System.Xml.XmlReader.Value%2A> propriedade retorna a versão, autônomas e informações de codifica como uma única cadeia de caracteres. <xref:System.Xml.XmlReader> objetos criados pela <xref:System.Xml.XmlReader.Create%2A> método, o <xref:System.Xml.XmlTextReader> classe e o <xref:System.Xml.XmlValidatingReader> classe expõe a versão, autônomas e itens de codificação como atributos.  
  
 **Lendo atributos em nós de tipo de documento**  
  
 Quando o leitor de XML é posicionado em um nó de tipo de documento, o <xref:System.Xml.XmlReader.GetAttribute%2A> método e <xref:System.Xml.XmlReader.Item%2A> propriedade pode ser usada para retornar os valores para os literais SYSTEM e PUBLIC. Por exemplo, a chamada de `reader.GetAttribute("PUBLIC")` retorna o valor PUBLIC.  
  
 **Lendo atributos em nós de instrução de processamento**  
  
 Quando o <xref:System.Xml.XmlReader> é posicionado em um nó de instrução de processamento, a propriedade <xref:System.Xml.XmlReader.Value%2A> retorna todo o conteúdo de texto. Itens no nó de instrução de processamento não são tratados como atributos. Eles não podem ser lidos com o <xref:System.Xml.XmlReader.GetAttribute%2A> ou <xref:System.Xml.XmlReader.MoveToAttribute%2A> método.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Conteúdo XML de leitura  
 A classe XMLReader inclui os seguintes membros que leiam o conteúdo de um arquivo XML e retornam o conteúdo como valores de cadeia de caracteres. (Para retornar tipos CLR, consulte a [próxima seção](#xmlreader_clr).)  
  
|Use esta <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriedade <xref:System.Xml.XmlReader.Value%2A>|Obter o conteúdo de texto do nó atual. O valor retornado depende do tipo de nó; Consulte o <xref:System.Xml.XmlReader.Value%2A> página de referência para obter detalhes.|  
|Método <xref:System.Xml.XmlReader.ReadString%2A>|Obter o conteúdo de um elemento ou nó de texto como uma cadeia de caracteres. Esse método para em instruções de processamento e comentários.<br /><br /> Para obter detalhes sobre como esse método lida com tipos de nó específico, consulte o <xref:System.Xml.XmlReader.ReadString%2A> página de referência.|  
|Métodos <xref:System.Xml.XmlReader.ReadInnerXml%2A> e <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Obtenha todo o conteúdo do nó atual, inclusive a marcação, mas excluindo marcas de início e término. Por exemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Retorna:<br /><br /> `this<child id="123"/>`|  
|Métodos <xref:System.Xml.XmlReader.ReadOuterXml%2A> e <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Obtenha todo o conteúdo do nó atual e seus filhos, incluindo as marcas de marcação e início/término. Por exemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Retorna:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Convertendo em tipos CLR  
 Você pode usar os membros do <xref:System.Xml.XmlReader> classe (listado na tabela a seguir) para ler dados XML e retornar valores como o common language runtime (CLR) tipos em vez de cadeias de caracteres. Esses membros permitem que você obter valores na representação que é mais apropriada para sua tarefa de codificação sem a necessidade de analisar ou converter valores de cadeia de caracteres manualmente.  
  
-   O **ReadElementContentAs** métodos só podem ser chamados em tipos de nó de elemento. Esses métodos não podem ser usados em elementos que contêm os elementos filho ou o conteúdo misturado. Quando chamado, o objeto de <xref:System.Xml.XmlReader> ler a tag de início, lê o conteúdo do elemento, e então move após a marca do elemento de extremidade. Instruções de processamento e comentários são ignorados e as entidades são expandidas.  
  
-   O **{1&gt;readcontentas&lt;1** métodos ler o conteúdo de texto na posição do leitor atual e se os dados XML não tem qualquer esquema ou os dados associadas a ele, de informações de tipo converter o conteúdo de texto para o tipo de retorno solicitado. Texto, o espaço em branco, o espaço em branco significativo e seções CDATA são concatenados. Comentários e instruções de processamento são ignoradas e referências a entidades são resolvidas automaticamente.  
  
 O <xref:System.Xml.XmlReader> classe usa as regras definidas pela [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/)recomendação.  
  
|Use esta <xref:System.Xml.XmlReader> método|Para retornar esse tipo CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> e <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|O tipo especificado com o `returnType` parâmetro|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|O tipo mais apropriado, conforme especificado pelo <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> propriedade. Ver [suporte a tipo nas Classes System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) para informações de mapeamento.|  
  
 Se um elemento não pode ser facilmente convertido em um tipo CLR devido a seu formato, você pode usar um mapeamento de esquema para garantir uma conversão bem-sucedida. O exemplo a seguir usa um arquivo. xsd para converter o `hire-date` elemento para o `xs:date` tipo e, em seguida, usa o <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para retornar o elemento como um <xref:System.DateTime> objeto.  
  
 **Entrada (XML):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schema (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Código:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Saída:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programação assíncrona  
 A maioria do <xref:System.Xml.XmlReader> métodos têm contrapartes assíncronos com "Async" ao final de seus nomes de método. Por exemplo, o equivalente assíncrono do <xref:System.Xml.XmlReader.ReadContentAsObject%2A> é <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Os métodos a seguir podem ser usados com chamadas de método assíncrono:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 As seções a seguir descrevem o uso assíncrono para métodos que não têm equivalentes assíncronos.  
  
 **Método ReadStartElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **Método ReadEndElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **Método ReadToNextSibling**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **Método ReadToFollowing**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **Método ReadToDescendant**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Considerações sobre segurança  
 Considere o seguinte ao trabalhar com o <xref:System.Xml.XmlReader> classe:  
  
-   As exceções geradas do <xref:System.Xml.XmlReader> pode divulgar informações de caminho que não podem ser transferidos até seu aplicativo. Seu aplicativo deve capturar exceções e processá-las adequadamente.  
  
-   Não habilite o processamento de DTD se você estiver preocupado com a negação de problemas de serviço ou se você estiver lidando com fontes não confiáveis. Processamento de DTD é desativado por padrão para <xref:System.Xml.XmlReader> objetos criados pelo <xref:System.Xml.XmlReader.Create%2A> método.  
  
     Se você tiver o processamento de DTD ativado, você pode usar <xref:System.Xml.XmlSecureResolver> para restringir os recursos que <xref:System.Xml.XmlReader> pode acessar. Você também pode criar seu aplicativo para que o processamento de XML é memória e hora restritos. Por exemplo, você pode configurar limites de tempo limite em seu aplicativo ASP.NET.  
  
-   Os dados XML podem incluir referências a recursos externos como um arquivo de esquema. Por padrão, os recursos externos são resolvidos usando um <xref:System.Xml.XmlUrlResolver> objeto sem credenciais do usuário. Você pode proteger este adicional seguindo um destes procedimentos:  
  
    -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
  
    -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> a `null`.  
  
-   O <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> e <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> sinalizadores de validação de um <xref:System.Xml.XmlReaderSettings> objeto não são definidas por padrão. Isso ajuda a proteger contra ataques <xref:System.Xml.XmlReader> baseados esquema- quando está processando dados de uma fonte não confiável. Quando esses sinalizadores são definidos, <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do objeto de <xref:System.Xml.XmlReaderSettings> é usado para resolver os locais de esquema encontrados no documento de instância em <xref:System.Xml.XmlReader>. Se o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> estiver definida como `null`, locais de esquema não são resolvidos mesmo se o <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> e <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> sinalizadores de validação são definidos.  
  
     Os esquemas adicionados durante a validação adicionar novos tipos e podem alterar o resultado de validação de documento que está sendo validada. Como resultado, os esquemas externos só devem ser resolvidos de fontes confiáveis.  
  
     É recomendável desabilitar a <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> sinalizar quando a validação não confiáveis, grandes documentos XML em cenários de alta disponibilidade em um esquema que tem restrições de identidade sobre uma grande parte do documento. Esse sinalizador é habilitado por padrão.  
  
-   Os dados XML podem conter um grande número de declarações de atributos, namespace, elementos aninhados e assim por diante que exigem um montante considerável de tempo de processamento. Para limitar o tamanho da entrada que é enviado para o <xref:System.Xml.XmlReader>, você pode:  
  
    -   Limitar o tamanho do documento, definindo o <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> propriedade.  
  
    -   Limitar o número de caracteres resultantes de expanda entidades definindo a <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> propriedade.  
  
    -   Criar um personalizado `IStream` implementação para o <xref:System.Xml.XmlReader>.  
  
-   O <xref:System.Xml.XmlReader.ReadValueChunk%2A> método pode ser usado para lidar com grandes fluxos de dados. Este método lê um pequeno número de caracteres de cada vez em vez de atribuir uma única cadeia de caracteres para o valor inteiro.  
  
-   Ao ler um documento XML com um grande número de prefixos, namespaces ou nomes exclusivos de locais, pode ocorrer um problema. Se você estiver usando uma classe que deriva de <xref:System.Xml.XmlReader>, e você chamar o <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, ou <xref:System.Xml.XmlReader.NamespaceURI%2A> propriedade para cada item, a cadeia de caracteres retornada é adicionada a um <xref:System.Xml.NameTable>. A coleção mantida pelo <xref:System.Xml.NameTable> nunca diminui de tamanho, a criação de um vazamento de memória virtual das alças de cadeia de caracteres. Uma mitigação para isso é derivar o <xref:System.Xml.NameTable> de classe e impor uma cota de tamanho máximo. (Não há nenhuma maneira de evitar o uso de um <xref:System.Xml.NameTable>, ou alternar o <xref:System.Xml.NameTable> quando estiver cheio). Outra mitigação é evitar usar as propriedades mencionadas e usar em vez disso, o <xref:System.Xml.XmlReader.MoveToAttribute%2A> método com o <xref:System.Xml.XmlReader.IsStartElement%2A> método sempre que possível; esses métodos não retornar cadeias de caracteres e, portanto, evitar o problema de sobrecarga do <xref:System.Xml.NameTable> coleção.  
  
-   os objetos de<xref:System.Xml.XmlReaderSettings> podem conter informações sigilosas como credenciais do usuário. Um componente não confiável pode usar o objeto de <xref:System.Xml.XmlReaderSettings> e suas credenciais de usuário para criar objetos de <xref:System.Xml.XmlReader> para ler dados. Tenha cuidado ao armazenar em cache <xref:System.Xml.XmlReaderSettings> objetos, ou ao passar o <xref:System.Xml.XmlReaderSettings> objeto de um componente para outro.  
  
-   Aceitar componentes de suporte, como <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, e objetos de <xref:System.Xml.XmlResolver> , de uma fonte não confiável.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar a API assíncrona para analisar o XML.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see langword="XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse construtor é chamado por construtores de classe derivada para inicializar o estado nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o número de atributos no nó atual.</summary>
        <value>O número de atributos no nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é relevante para `Element`, `DocumentType` e `XmlDeclaration` somente nós. (Outros tipos de nó não tem atributos.)  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o URI base do nó atual.</summary>
        <value>O URI base do nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um documento XML em rede é composto por blocos de dados agregados usando vários mecanismos de inclusão padrão W3C e, portanto, contém nós que vêm de diferentes locais. Entidades de DTD são um exemplo disso, mas isso não é limitado para DTDs. A base de URI informa onde vieram esses nós. O `String.Empty` propriedade não pode ser definida após a ocorrência de uma operação de leitura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Xml.XmlReader" /> implementa os métodos de leitura de conteúdo binário.</summary>
        <value>
          <see langword="true" /> Se os métodos de leitura de conteúdo binários são implementados; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conteúdo binário ler métodos incluem a <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, e <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> métodos. Se essa propriedade retornará `false` um <xref:System.NotSupportedException> é retornado quando qualquer um dos binário ler métodos é chamado.  
  
 Todas as implementações do Microsoft .NET Framework do <xref:System.Xml.XmlReader> retorno de classe `true` para essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Xml.XmlReader" /> implementa o método <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>
          <see langword="true" /> Se o <see langword="true" /> é usado para construir um <see cref="T:System.Xml.XmlReader" />, para normalizar os valores de atributo <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> deve ser definida como <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Análise de texto <xref:System.Xml.XmlReader> objetos que foram criados com base estático <xref:System.Xml.XmlReader.Create%2A> método sempre retornam `true`. Todas as outras implementações do Microsoft .NET Framework a <xref:System.Xml.XmlReader> classe, incluindo o <xref:System.Xml.XmlTextReader> classe, retornar `false`.  
  
 Se essa propriedade retornará `false` uma <xref:System.NotSupportedException> é retornado quando o <xref:System.Xml.XmlReader.ReadValueChunk%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este leitor pode analisar e resolver entidades.</summary>
        <value>
          <see langword="true" /> Se o leitor pode analisar e resolver entidades; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna `false` para implementações de <xref:System.Xml.XmlReader> que não dão suporte a informações de DTD. Nesse caso, chamando <xref:System.Xml.XmlReader.ResolveEntity%2A> gera uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, altera o <see cref="P:System.Xml.XmlReader.ReadState" /> para <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método também libera os recursos mantidos durante a leitura. Se <xref:System.Xml.XmlReader.Close%2A> já foi chamado, nenhuma ação é executada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria dos <xref:System.Xml.XmlReader.Create%2A> sobrecargas incluem um `settings` parâmetro que aceita um <xref:System.Xml.XmlReaderSettings> objeto. Você pode usar esse objeto para:  
  
-   Especifique quais recursos deseja dar suporte no <xref:System.Xml.XmlReader> objeto.  
  
-   Reutilizar o <xref:System.Xml.XmlReaderSettings> objeto para criar vários leitores. Você pode usar as mesmas configurações para criar vários leitores com a mesma funcionalidade. Ou, você pode modificar as configurações em um <xref:System.Xml.XmlReaderSettings> da instância e criar um novo leitor com um conjunto diferente de recursos.  
  
-   Adicione recursos a um leitor de XML existente. O método <xref:System.Xml.XmlReader.Create%2A> pode aceitar outro objeto <xref:System.Xml.XmlReader>. Subjacente <xref:System.Xml.XmlReader> objeto pode ser um leitor definido pelo usuário, uma <xref:System.Xml.XmlTextReader> objeto ou outro <xref:System.Xml.XmlReader> instância que você deseja adicionar recursos adicionais.  
  
-   Pode aproveitar recursos como melhores verificação de compatibilidade e conformidade com o [XML 1.0 (quarta edição)](https://www.w3.org/TR/2006/REC-xml-20060816/)recomendação que estão disponíveis apenas nas <xref:System.Xml.XmlReader> objetos criados pelo estático <xref:System.Xml.XmlReader.Create%2A> método.  
  
> [!NOTE]
>  Embora o .NET Framework inclua implementações concretas do <xref:System.Xml.XmlReader> classe, como o <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>e o <xref:System.Xml.XmlValidatingReader> classes, é recomendável que você crie <xref:System.Xml.XmlReader> instâncias usando o <xref:System.Xml.XmlReader.Create%2A> método.  
  
## <a name="default-settings"></a>Configurações padrão  
 Se você usar um <xref:System.Xml.XmlReader.Create%2A> sobrecarga que não aceita um <xref:System.Xml.XmlReaderSettings> do objeto, as seguintes configurações de leitor padrão são usadas:  
  
|Configuração|Padrão|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Um objeto <xref:System.Xml.Schema.XmlSchemaSet> vazio|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> habilitado|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Um novo objeto <xref:System.Xml.XmlUrlResolver>.  Começando com o .NET Framework 4.5.2, essa configuração tem um valor padrão de `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Configurações para cenários comuns  
 Aqui estão as <xref:System.Xml.XmlReaderSettings> propriedades deve ser definida para alguns dos cenários típicos de leitor XML.  
  
|Requisito|Set|  
|-----------------|---------|  
|Dados devem ser um documento XML bem formado.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> para <xref:System.Xml.ConformanceLevel.Document>.|  
|Dados devem ser uma entidade analisada XML bem formada.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> para <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Dados devem ser validados em um DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> para <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> para <xref:System.Xml.ValidationType.DTD>.|  
|Dados devem ser validados em relação a um esquema XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> para <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> para o <xref:System.Xml.Schema.XmlSchemaSet> a ser usado para validação. Observe que <xref:System.Xml.XmlReader> não dá suporte a validação de esquema XML-Data Reduced (XDR).|  
|Dados devem ser validados em relação a um esquema XML embutido.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> para <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> para <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Suporte de tipo.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> para <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> para o <xref:System.Xml.Schema.XmlSchemaSet> usar.|  
  
 <xref:System.Xml.XmlReader> não dá suporte a validação de esquema XML-Data Reduced (XDR).  
  
## <a name="asynchronous-programming"></a>Programação assíncrona  
 No modo síncrono, o <xref:System.Xml.XmlReader.Create%2A> método lê a primeira parte de dados do buffer do leitor de texto, fluxo ou arquivo. Isso pode gerar uma exceção se uma operação de e/s falhar. No modo assíncrono, a primeira operação de e/s ocorre com uma operação de leitura, portanto, as exceções surgidas serão geradas quando ocorre a operação de leitura.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Por padrão, o <xref:System.Xml.XmlReader> usa um <xref:System.Xml.XmlUrlResolver> objeto sem credenciais de usuário para abrir os recursos. Isso significa que, por padrão, o leitor de XML pode acessar qualquer local que não requer credenciais. Use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para controlar o acesso aos recursos:  
  
-   Definir <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> para um <xref:System.Xml.XmlSecureResolver> objeto para restringir os recursos que o leitor de XML pode acessar.  
  
 - ou -  
  
-   Definir <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> para `null` para impedir que o leitor de XML abra todos os recursos externos.  
  
   
  
## Examples  
 Este exemplo cria um leitor de XML que retira o espaço em branco insignificante, retira comentários e executa a verificação de compatibilidade de fragmento-nível.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 O exemplo a seguir usa um <xref:System.Xml.XmlUrlResolver> com credenciais padrão para acessar um arquivo.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 O código a seguir encapsula uma instância do leitor dentro de outro leitor.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 Este exemplo encadeia leitores para adicionar validação de esquema DTD e XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo buscando uma marca de ordem de byte ou outro sinal de codificação. Quando a codificação é determinada, ela é usada para continuar a ler o fluxo e o processamento continuará analisando a entrada como um fluxo de caracteres (Unicode).</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o fluxo especificado com as configurações padrão.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> objeto como um de seus argumentos e passe um <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Xml.XmlReader> objeto que lê de um <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode, por isso a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <summary>Cria uma nova instância de <see cref="T:System.Xml.XmlReader" /> usando o leitor de texto especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> objeto como um de seus argumentos e passe um <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.StringReader> classe para ler uma cadeia de caracteres XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI para o arquivo que contém os dados XML. A classe <see cref="T:System.Xml.XmlUrlResolver" /> é usada para converter o caminho em uma representação de dados canônica.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> com o URI especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> objeto como um de seus argumentos e passe um <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que lê o arquivo de dados XML especificado pelo URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo identificado pelo URI não existe.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> No [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.  </para>
          </block> O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo buscando uma marca de ordem de byte ou outro sinal de codificação. Quando a codificação é determinada, ela é usada para continuar a ler o fluxo e o processamento continuará analisando a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> com as configurações e o fluxo especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode, por isso a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância do <see cref="T:System.Xml.XmlReader" /> usando as configurações e o leitor de texto especificados.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI do arquivo que contém os dados XML. O objeto <see cref="T:System.Xml.XmlResolver" /> no objeto <see cref="T:System.Xml.XmlReaderSettings" /> é usado para converter o caminho em uma representação de dados canônica. Se <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> for <see langword="null" />, um novo objeto <see cref="T:System.Xml.XmlUrlResolver" /> será usado.</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o URI e as configurações especificados.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Isso significa que o <xref:System.Xml.XmlReader> pode acessar todos os locais que não requer autenticação. Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode restringir os recursos que o <xref:System.Xml.XmlReader> pode acessar definindo o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para um <xref:System.Xml.XmlSecureResolver> objeto.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que dá suporte à validação de DTD (definição) de tipo de documento.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível encontrar o arquivo especificado pelo URI.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> No [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.  </para>
          </block> O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">O objeto que você deseja usar como o leitor XML subjacente.</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />.  O nível de conformidade do objeto <see cref="T:System.Xml.XmlReaderSettings" /> deve corresponder ao nível de conformidade do leitor subjacente ou deve ser definido como <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as configurações e o leitor XML especificados.</summary>
        <returns>Um objeto encapsulado em torno do objeto <see cref="T:System.Xml.XmlReader" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que você adicione recursos adicionais para uma subjacente <xref:System.Xml.XmlReader> objeto. Subjacente <xref:System.Xml.XmlReader> objeto pode ser outro <xref:System.Xml.XmlReader> objeto criado pelo <xref:System.Xml.XmlReader.Create%2A> método, ou uma <xref:System.Xml.XmlReader> objeto criado usando um dos concretas <xref:System.Xml.XmlReader> implementações.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um esquema.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um Validando <xref:System.Xml.XmlReader> objeto que é encapsulado em torno de um <xref:System.Xml.XmlNodeReader> objeto.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="reader" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se o objeto <see cref="T:System.Xml.XmlReaderSettings" /> especificar um nível de conformidade que não é consistente com o nível de conformidade do leitor subjacente.  -ou- O <see cref="T:System.Xml.XmlReader" /> subjacente está em um estado <see cref="F:System.Xml.ReadState.Error" /> ou <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo buscando uma marca de ordem de byte ou outro sinal de codificação. Quando a codificação é determinada, ela é usada para continuar a ler o fluxo e o processamento continuará analisando a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <param name="baseUri">O URI base para a entidade ou o documento que está sendo lido. Este valor pode ser <see langword="null" />.  **Observação de segurança** O URI base é usado para resolver o URI relativo do documento XML. Não use um URI base de uma fonte não confiável.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o fluxo, o URI base e as configurações especificadas.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo buscando uma marca de ordem de byte ou outro sinal de codificação. Quando a codificação é determinada, ela é usada para continuar a ler o fluxo e o processamento continuará analisando a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> a ser usado, a codificação, o escopo de namespace, o escopo de <c>xml:lang</c> e <c>xml:space</c> atual, o URI base e a definição de tipo de documento.  Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de fluxo, configurações e contexto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode, por isso a codificação especificada na declaração XML não é usada pelo <see cref="T:System.Xml.XmlReader" /> para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <param name="baseUri">O URI base para a entidade ou o documento que está sendo lido. Este valor pode ser <see langword="null" />.  **Observação de segurança** O URI base é usado para resolver o URI relativo do documento XML. Não use um URI base de uma fonte não confiável.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o leitor de texto especificado, as configurações e o URI base.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode, por isso a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> a ser usado, a codificação, o escopo de namespace, o escopo de <c>xml:lang</c> e <c>xml:space</c> atual, o URI base e a definição de tipo de documento.  Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de contexto, de configurações e do leitor de texto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  - ou -  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que lê um fragmento XML.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ambas as propriedades <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> e <see cref="P:System.Xml.XmlParserContext.NameTable" /> contêm valores. (Somente uma dessas propriedades <see langword="NameTable" /> podem ser definidas e usadas).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI do arquivo que contém os dados XML. O objeto <see cref="T:System.Xml.XmlResolver" /> no objeto <see cref="T:System.Xml.XmlReaderSettings" /> é usado para converter o caminho em uma representação de dados canônica. Se <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> for <see langword="null" />, um novo objeto <see cref="T:System.Xml.XmlUrlResolver" /> será usado.</param>
        <param name="settings">As configurações para a nova instância <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> a ser usado, a codificação, o escopo de namespace, o escopo de <c>xml:lang</c> e <c>xml:space</c> atual, o URI base e a definição de tipo de documento.  Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de URI, de configurações e de contexto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos, como um document type definition (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Isso significa que o <xref:System.Xml.XmlReader> pode acessar todos os locais que não requer autenticação. Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode restringir os recursos que o <xref:System.Xml.XmlReader> pode acessar definindo o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para um <xref:System.Xml.XmlSecureResolver> objeto.  
  
 Criado <xref:System.Xml.XmlReader> objeto expande as referências a entidades e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <see langword="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
        <exception cref="T:System.ArgumentException">Ambas as propriedades <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> e <see cref="P:System.Xml.XmlParserContext.NameTable" /> contêm valores. (Somente uma dessas propriedades <see langword="NameTable" /> podem ser definidas e usadas).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível encontrar o arquivo especificado pelo URI.</exception>
        <exception cref="T:System.UriFormatException">O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém a profundidade do nó atual no documento XML.</summary>
        <value>A profundidade do nó atual no documento XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ver <xref:System.Xml.XmlTextReader.Depth%2A> (no `XmlTextReader` classe) para obter um exemplo de uso dessa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Libera os recursos usados pela classe <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Xml.XmlReader" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o leitor está posicionado no final do fluxo.</summary>
        <value>
          <see langword="true" /> Se o leitor estiver posicionado no final do fluxo; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Quando substituído em uma classe derivada, obtém o valor de um atributo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo. O índice é baseado em zero. (O primeiro atributo tem índice 0.)</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o índice especificado.</summary>
        <returns>O valor do atributo especificado. Esse método não move o leitor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir obtém o valor do atributo terceiro.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> está fora do intervalo. Ele deve ser não negativo e menor que o tamanho da coleção de atributos.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <returns>O valor do atributo especificado. Se o atributo não foi encontrado ou o valor é <see langword="String.Empty" />, <see langword="null" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não move o leitor.  
  
 Se o leitor estiver posicionado em um `DocumentType` nó, esse método pode ser usado para obter os literais PUBLIC e sistema, por exemplo, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 O exemplo a seguir obtém o valor do atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="namespaceURI">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.LocalName" /> e o <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificados.</summary>
        <returns>O valor do atributo especificado. Se o atributo não foi encontrado ou o valor é <see langword="String.Empty" />, <see langword="null" /> será retornado. Esse método não move o leitor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O XML a seguir contém um atributo em um namespace específico:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Você pode pesquisar o `dt:type` de atributo usando um argumento (prefixo e o nome local) ou dois argumentos (nome local e URI de namespace):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 A pesquisa a `xmlns:dt` de atributo, use um dos seguintes argumentos:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Você também pode obter essas informações usando o <xref:System.Xml.XmlReader.Prefix%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o valor do nó atual de forma assíncrona.</summary>
        <returns>O valor do nó atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o nó atual tem atributos.</summary>
        <value>
          <see langword="true" /> Se o nó atual tiver atributos; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual pode ter um <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>
          <see langword="true" /> se o nó em que o leitor está posicionado no momento puder ter um <see langword="Value" />, caso contrário, <see langword="false" />. Se <see langword="false" />, o nó tem um valor de <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista os tipos de nós que têm um valor a ser retornado.  
  
|Tipo de nó|Valor|  
|---------------|-----------|  
|`Attribute`|O valor do atributo.|  
|`CDATA`|O conteúdo da seção CDATA.|  
|`Comment`|O conteúdo do comentário.|  
|`DocumentType`|O subconjunto interno.|  
|`ProcessingInstruction`|Todo o conteúdo, exceto o destino.|  
|`SignificantWhitespace`|O espaço em branco entre a marcação em um modelo de conteúdo misto.|  
|`Text`|O conteúdo do nó de texto.|  
|`Whitespace`|Espaço em branco entre a marcação.|  
|`XmlDeclaration`|O conteúdo da declaração.|  
  
   
  
## Examples  
 Ver <xref:System.Xml.XmlTextReader.HasValue%2A> (no `XmlTextReader` classe) para obter um exemplo usando esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual é um atributo que foi gerado com base no valor padrão definido no DTD ou no esquema.</summary>
        <value>
          <see langword="true" /> Se o nó atual é um atributo cujo valor foi gerado a partir o valor padrão definido no DTD ou esquema; <see langword="false" /> se o valor do atributo foi definido explicitamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` sempre retorna `false` para implementações de `XmlReader` que não dão suporte a informações de DTD ou esquema. Essa propriedade só se aplica a um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no elemento raiz.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 O exemplo usa os seguintes arquivos como entrada.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual é um elemento vazio (por exemplo, <c>&lt;MyElement/&gt;</c>).</summary>
        <value>
          <see langword="true" /> Se o nó atual é um elemento (<see cref="P:System.Xml.XmlReader.NodeType" /> é igual a <see langword="XmlNodeType.Element" />) que terminará com <c> / &gt; </c>; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite determinar a diferença entre o seguinte:  
  
 `<item num="123"/>` (`IsEmptyElement` é `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` é `false`, embora o conteúdo do elemento está vazio).  
  
 Um correspondente `EndElement` nó não é gerado para elementos vazios.  
  
 Se o conteúdo padrão foi adicionado a um elemento devido à validação de esquema `IsEmptyElement` ainda retorna `true`. Ele não tem nenhuma relevância em ou não o elemento tem um valor padrão. Em outras palavras, `IsEmptyElement` simplesmente informa se o elemento no documento de origem tinha uma marca de elemento final.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 O exemplo usa o arquivo `elems.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O nome a ser validado.</param>
        <summary>Retorna um valor que indica se o argumento de cadeia de caracteres é um nome XML válido.</summary>
        <returns>
          <see langword="true" /> se o nome for válido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recomendação do W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar se o nome é válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O token de nome a ser validado.</param>
        <summary>Retorna um valor que indica se o argumento de cadeia de caracteres é um token de nome XML válido.</summary>
        <returns>
          <see langword="true" /> se for um token de nome válido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recomendação do W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar se o token de nome é válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Testa se o nó de conteúdo atual é uma marca de início.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chama <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual é uma marca de início ou uma marca de elemento vazia.</summary>
        <returns>
          <see langword="true" /> se <see cref="M:System.Xml.XmlReader.MoveToContent" /> encontrar uma marca de início ou uma marca de elemento vazia; <see langword="false" /> se um tipo de nó diferente de <see langword="XmlNodeType.Element" /> for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método, em seguida, testa se o nó atual é um elemento.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 O exemplo usa o arquivo `elems.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado XML incorreto no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres é comparada com a propriedade <see langword="Name" /> do elemento encontrado.</param>
        <summary>Chama <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual é uma marca de início ou uma marca de elemento vazio e se a propriedade <see cref="P:System.Xml.XmlReader.Name" /> que o elemento encontrou corresponde ao argumento fornecido.</summary>
        <returns>
          <see langword="true" /> se o nó resultante é um elemento e a propriedade <see langword="Name" /> corresponde à cadeia de caracteres especificada. <see langword="false" /> se um tipo de nó diferente de <see langword="XmlNodeType.Element" /> foi encontrado ou se a propriedade <see langword="Name" /> do elemento não corresponde à cadeia de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método, em seguida, testa se o nó atual é um elemento.  
  
   
  
## Examples  
 O exemplo a seguir exibe cada elemento de preço.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado XML incorreto no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">A cadeia de caracteres de correspondência com a propriedade <see langword="LocalName" /> do elemento encontrado.</param>
        <param name="ns">A cadeia de caracteres de correspondência com a propriedade <see langword="NamespaceURI" /> do elemento encontrado.</param>
        <summary>Chama <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual é uma marca de início ou uma marca de elemento vazio e, se as propriedades <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> do elemento encontrado correspondem às cadeias de caracteres fornecidas.</summary>
        <returns>
          <see langword="true" /> se o nó resultante é um elemento. <see langword="false" /> se um tipo de nó diferente de <see langword="XmlNodeType.Element" /> foi encontrado ou se as propriedades <see langword="LocalName" /> e <see langword="NamespaceURI" /> do elemento não correspondem às cadeias de caracteres especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método, em seguida, testa se o nó atual é um elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado XML incorreto no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o índice especificado.</summary>
        <value>O valor do atributo especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não move o leitor.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <value>O valor do atributo especificado. Se o atributo não for encontrado, <see langword="null" /> será retornado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não move o leitor.  
  
 Se o leitor estiver posicionado em um `DocumentType` nó, esse método pode ser usado para obter os literais PUBLIC e sistema, por exemplo, `reader["PUBLIC"]`  
  
   
  
## Examples  
 O exemplo a seguir obtém o valor do atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="namespaceURI">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.LocalName" /> e o <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificados.</summary>
        <value>O valor do atributo especificado. Se o atributo não for encontrado, <see langword="null" /> será retornado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não move o leitor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o nome local do nó atual.</summary>
        <value>O nome do nó atual com o prefixo removido. Por exemplo, <see langword="LocalName" /> está <see langword="book" /> para o elemento <c> &lt;BK: Book&gt;</c>.  Para tipos de nós que não têm um nome (como <see langword="Text" />, <see langword="Comment" /> e assim por diante), essa propriedade retornará <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existirem, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">O prefixo cujo URI de namespace você deseja resolver. Para corresponder ao namespace padrão, transmita uma cadeia de caracteres vazia.</param>
        <summary>Quando substituído em uma classe derivada, resolve um prefixo de namespace no escopo do elemento atual.</summary>
        <returns>O URI de namespace para o qual o prefixo será mapeado ou <see langword="null" /> se nenhum prefixo correspondente for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na seguinte cadeia XML, se o leitor estiver posicionado na `href` do atributo, o prefixo `a` é resolvida chamando `reader.LookupNamespace("a")`. A cadeia de caracteres retornada é `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Quando substituído em uma classe derivada, passa para o atributo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo.</param>
        <summary>Quando substituído em uma classe derivada, é movido para o atributo com o índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro tem um valor negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, é movido para o atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <returns>
          <see langword="true" /> se o atributo for encontrado; caso contrário, <see langword="false" />. Se <see langword="false" />, a posição do leitor não será alterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de chamar `MoveToAttribute`, o <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> propriedades refletem as propriedades desse atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="ns">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, passa para o atributo com os <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificados.</summary>
        <returns>
          <see langword="true" /> se o atributo for encontrado; caso contrário, <see langword="false" />. Se <see langword="false" />, a posição do leitor não será alterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de chamar `MoveToAttribute`, o <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> propriedades refletem as propriedades desse atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó atual é um nó de conteúdo (texto sem espaço em branco, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />). Se o nó não for um nó de conteúdo, o leitor avançará para o próximo nó de conteúdo ou para o final do arquivo. Pula nós de tipo seguir: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" />, ou <see langword="SignificantWhitespace" />.</summary>
        <returns>O <see cref="P:System.Xml.XmlReader.NodeType" /> do nó atual encontrado pelo método ou <see langword="XmlNodeType.None" /> se o leitor atingiu o fim do fluxo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o nó atual é um nó de atributo, este método Move o leitor para o elemento que possui o atributo.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Isso é útil quando você deseja escrever um código que pode ignorar aleatória marcação XML sem interromper. Por exemplo, suponha que você tenha o seguinte código:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Esse código pode lidar com as entradas a seguir sem interromper:  
  
```xml  
<price>123.4</price>  
```  
  
 e  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 e  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 e  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorreto encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;MoveToContentAsync&gt;c__async5))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica de forma assíncrona se o nó atual é um nó de conteúdo. Se o nó não for um nó de conteúdo, o leitor avançará para o próximo nó de conteúdo ou para o final do arquivo.</summary>
        <returns>O <see cref="P:System.Xml.XmlReader.NodeType" /> do nó atual encontrado pelo método ou <see langword="XmlNodeType.None" /> se o leitor atingiu o fim do fluxo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.MoveToContent%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, move para o elemento que contém o nó de atributo atual.</summary>
        <returns>
          <see langword="true" /> se o leitor estiver posicionado em um atributo (o leitor se move para o elemento que possui o atributo); <see langword="false" /> se o leitor não estiver posicionado em um atributo (a posição do leitor não é alterada).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para retornar a um elemento depois de navegar por meio de seus atributos. Esse método Move o leitor a um dos seguintes tipos de nó: `Element`, `DocumentType`, ou `XmlDeclaration`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, move o primeiro atributo.</summary>
        <returns>
          <see langword="true" /> se um atributo existir (o leitor é movido para o primeiro atributo); caso contrário, <see langword="false" /> (a posição do leitor não é alterada).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir obtém o valor do primeiro atributo.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, vai para o atributo seguinte.</summary>
        <returns>
          <see langword="true" /> se houver um atributo seguinte; <see langword="false" /> se não houver mais nenhum atributo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o nó atual é um nó de elemento, esse método é equivalente a <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Se `MoveToNextAttribute` retorna `true`, o leitor se move para o próximo atributo; caso contrário, a posição do leitor não é alterada.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no nó atual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o nome qualificado do nó atual.</summary>
        <value>O nome qualificado do nó atual. Por exemplo, <see langword="Name" /> está <see langword="bk:book" /> para o elemento <c> &lt;BK: Book&gt;</c>.  O nome retornado depende do <see cref="P:System.Xml.XmlReader.NodeType" /> do nó. Os seguintes tipos de nó retornam os valores listados. Todos os outros tipos de nó retornam uma cadeia de caracteres vazia.  
  
 <list type="table"><listheader><term> Tipo de nó </term><description> nome </description></listheader><item><term><see langword="Attribute" /></term><description> o nome do atributo.  </description></item><item><term><see langword="DocumentType" /></term><description> O nome do tipo de documento.  </description></item><item><term><see langword="Element" /></term><description> O nome da marca.  </description></item><item><term><see langword="EntityReference" /></term><description> O nome da entidade referenciada.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> O destino da instrução de processamento.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> A cadeia de caracteres literal <see langword="xml" />.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o URI do namespace (conforme definido na especificação de Namespace do W3C) do nó no qual o leitor está posicionado.</summary>
        <value>O URI do namespace do nó atual; caso contrário, uma cadeia de caracteres vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é relevante para `Element` e `Attribute` somente nós.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existirem, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o <see cref="T:System.Xml.XmlNameTable" /> associado a essa implementação.</summary>
        <value>O <see langword="XmlNameTable" /> que permite obter a versão atomizada de uma cadeia de caracteres no nó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os nomes de nó e o atributo retornado de <xref:System.Xml.XmlReader> são objetos usando o `NameTable`. Quando o mesmo nome é retornado várias vezes (por exemplo, `Customer`), em seguida, o mesmo `String` objeto será retornado para esse nome. Isso torna possível para você escrever código eficiente que o objeto comparações nessas cadeias de caracteres em vez de comparações de cadeia de caracteres caro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o tipo do nó atual.</summary>
        <value>Um dos valores de enumeração que especificam o tipo do nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o prefixo de namespace associado com o nó atual.</summary>
        <value>O prefixo de namespace associado com o nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existirem, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o caractere de aspas usado para circunscrever o valor de um nó de atributo.</summary>
        <value>O caractere de aspas ("ou") usado para Circunscrever o valor de um nó de atributo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade só se aplica a um nó de atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o próximo nó do fluxo.</summary>
        <returns>
          <see langword="true" /> se o próximo nó foi lido com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Xml.XmlReader> é primeiro criado e inicializado, não há nenhuma informação disponível. Você deve chamar <xref:System.Xml.XmlReader.Read%2A> para ler o primeiro nó. O <xref:System.Xml.XmlReader.Read%2A> método define o estado do leitor de XML para iniciar <xref:System.Xml.ReadState> e se movimentam pelo arquivo XML sequencialmente até atingir o final do arquivo, no ponto em que o método retorna um valor de `false`.  
  
 Esse método requer pelo menos quatro bytes do fluxo de dados para começar a analisar. Se menos de quatro bytes são retornados e não houver mais nenhum dado no fluxo, o método retorna `false`. Se houver mais dados no fluxo, o método irá bloquear a análise até o recebimento do quarto byte.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Saída:**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê assincronamente o próximo nó do fluxo.</summary>
        <returns>
          <see langword="true" /> se o próximo nó for lido com êxito; <see langword="false" /> se não houver mais nenhum nó para ler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.Read%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, analisa o valor do atributo em um ou mais nós <see langword="Text" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />.</summary>
        <returns>
          <see langword="true" /> se houver nós para retornar.  
  
 <see langword="false" /> se o leitor não estiver posicionado em um nó de atributo quando a chamada inicial for feita ou se todos os valores de atributo tiverem sido lidos.  Um atributo vazio, como <c>misc=""</c>, retorna <see langword="true" /> com um único nó com um valor de <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método depois de chamar <xref:System.Xml.XmlReader.MoveToAttribute%2A> para ler os nós de referência de texto ou uma entidade que compõem o valor do atributo. O <xref:System.Xml.XmlReader.Depth%2A> de nós de valor do atributo é um mais a profundidade do nó de atributo; ele incrementa e decrementa por um quando a etapa dentro e fora de referências a entidades geral.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  **Observação** Com a versão do .NET Framework 3.5, o valor do parâmetro <c>returnType</c> agora pode ser do tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo. Por exemplo, ele pode ser usado ao converter um objeto <see cref="T:System.Xml.XmlQualifiedName" /> em um <c>xs:string</c>.  Este valor pode ser <see langword="null" />.</param>
        <summary>Lê o conteúdo como um objeto do tipo especificado.</summary>
        <returns>O valor de atributo ou conteúdo de texto concatenado convertido para o tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo de texto na posição atual do leitor e converte-o para o tipo de retorno solicitado. Texto, o espaço em branco, o espaço em branco significativo e seções CDATA são concatenados. Comentários e instruções de processamento são ignorados e referências a entidades são resolvidas automaticamente.  
  
 Esse método é usado para ler, converter se necessário e retornar os itens de valor atômico do nó atual conteúdo. Se o tipo de entrada é um mapeamentos válido para o tipo do nó atual, em seguida, uma instância do tipo de destino que contém o valor do nó atual será retornado. Consulte a seção comentários a <xref:System.Xml.XmlReader> referencepage para obter uma lista dos mapeamentos padrão.  
  
 Por exemplo, se você tivesse o seguinte texto XML:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Se os dados são digitados e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> chamada de método e, em seguida, os valores inteiros são convertidos de cadeias de caracteres de acordo com a lista de mapeamentos de tipo CLR válidos.  
  
 Se os dados não são digitados e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> chamada de método, em seguida, o conteúdo é analisado em cadeias de caracteres separadas. Uma matriz que contém duas cadeias de caracteres é retornada com os valores "123" e "456". Os espaços não são preservados do conteúdo.  
  
 O conteúdo em geral, ao ler dados não tipados é analisado de acordo com o tipo fornecido. Por exemplo, se uma matriz de inteiros é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> chamada de método e em seguida, a cadeia de caracteres é analisada em uma matriz de inteiros {123,456}.  
  
 No exemplo a seguir o texto XML não é separado por espaços  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Se o conteúdo é não tipado e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> chamada de método, em seguida, uma matriz que contém uma cadeia de caracteres concatenada é retornada com o valor "123456789".  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadContentAs%2A> método para retornar o conteúdo do elemento de cores em uma matriz de objetos de cadeia de caracteres.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 O exemplo usa o arquivo `dataFile_2.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O conteúdo não está no formato correto para o tipo de destino.</exception>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="returnType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsAsync&gt;c__async1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê de forma assíncrona o conteúdo como um objeto do tipo especificado.</summary>
        <returns>O valor de atributo ou conteúdo de texto concatenado convertido para o tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadContentAs%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo e retorna os bytes binários decodificados de Base64.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método transmite o conteúdo, decodifica as `Base64` de conteúdo e retorna os bytes binários decodificados (por exemplo, um embutido `Base64` codificados de imagem GIF) no buffer. Esse método pode ser chamado sucessivamente para ler grandes fluxos de texto inserido. Para obter mais informações, consulte RFC 1521, "parte MIME (Multipurpose Internet Mail Extensions) uma: mecanismos para especificar e que descreve o formato dos corpos de mensagens da Internet". Você pode obter RFCs do [para o site da Web de comentários de solicitação](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Você não deve acessar qualquer uma das propriedades leitor entre as chamadas para o <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método até que o método retorna o valor `0`.  
  
 Esse método tem o seguinte comportamento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Retorna o valor `0` quando ele alcançou o final do fluxo de bytes operava sobre. O leitor está posicionado no primeiro nó não são de conteúdo.  
  
-   Se você pedir para menos, ou o número exato de bytes que são deixados no fluxo o leitor permaneça na posição atual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Não há suporte para os seguintes tipos de nós XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê de forma assíncrona o conteúdo e retorna que os bytes binários decodificados de Base64.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo e retorna os bytes binários decodificados <see langword="BinHex" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método transmite o conteúdo, decodifica as `BinHex` de conteúdo e retorna os bytes binários decodificados (por exemplo, um embutido `BinHex` codificados de imagem GIF) no buffer. Esse método pode ser chamado sucessivamente para ler grandes fluxos de texto inserido.  
  
> [!NOTE]
>  Você não deve acessar qualquer uma das propriedades leitor entre as chamadas para o <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método até que o método retorna o valor `0`.  
  
 Esse método tem o seguinte comportamento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Retorna o valor `0` quando ele alcançou o final do fluxo de bytes operava sobre. O leitor está posicionado no primeiro nó não são de conteúdo.  
  
-   Se você solicitar menos ou o número exato, de bytes que são deixados no fluxo, o leitor permaneça na posição atual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Não há suporte para os seguintes tipos de nós XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê de forma assíncrona o conteúdo e retorna os bytes binários decodificados <see langword="BinHex" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um <see langword="Boolean" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não é tipado `xsd:boolean`, o leitor tentará convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> método para ler o atributo como um B`oolean` valor.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 O exemplo usa o arquivo `dataFile_2.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não é tipado `xsd:dateTime`, o leitor tentará convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader> sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor como 1904 nesse caso.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O conteúdo do texto na posição atual como um objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:decimal`, o leitor retorna um não demarcado <xref:System.Decimal> objeto. Se o conteúdo não é tipado `xsd:decimal`, o leitor tentará convertê-lo para um <xref:System.Decimal> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo de texto como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não é tipado `xsd:double`, o leitor tentará convertê-lo em um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo de texto na posição atual como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:float`, o leitor retorna um não demarcado um número de ponto flutuante de precisão simples. Se o conteúdo não é tipado `xsd:float`, o leitor tentará convertê-lo em um número de ponto flutuante de precisão simples acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um inteiro com sinal de 32 bits.</summary>
        <returns>O conteúdo de texto como um inteiro com sinal de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:integer`, o leitor retorna um inteiro com sinal de 32 bits não Demarcado. Se o conteúdo não é tipado `xsd:integer`, o leitor tentará convertê-lo em um inteiro com sinal de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um inteiro com sinal de 64 bits.</summary>
        <returns>O conteúdo de texto como um inteiro com sinal de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo está digitado `xsd:long`, o leitor retorna um inteiro com sinal de 64 bits não Demarcado. Se o conteúdo não é tipado `xsd:long`, o leitor tentará convertê-lo em um inteiro com sinal de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve este método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que `XmlConvert.ToXxx` no valor do atributo.|O leitor permaneça na posição atual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo do texto na posição atual como um <see cref="T:System.Object" />.</summary>
        <returns>O conteúdo do texto como o objeto CLR (Common Language Runtime) mais apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado, o leitor retorna CLR disponível comercialmente do tipo mais apropriado, especificado pelo <xref:System.Xml.XmlReader.ValueType%2A> propriedade. Se o conteúdo for um tipo de lista, o leitor retorna uma matriz de objetos demarcados do tipo apropriado.  
  
> [!NOTE]
>  Se ocorrer um erro de validação ao analisar o conteúdo e o leitor é uma <xref:System.Xml.XmlReader> objeto criado pelo <xref:System.Xml.XmlReader.Create%2A> método, o leitor retorna o conteúdo como uma cadeia de caracteres. Em outras palavras quando um erro de validação ou aviso ocorre, o conteúdo é considerado sem tipo.  
  
 Se o conteúdo é não tipado, o leitor retorna o conteúdo como uma cadeia de caracteres.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permaneça na posição atual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|O valor do elemento se o leitor é um esquema de validação de leitor (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> é definido como <xref:System.Xml.ValidationType.Schema>); caso contrário, uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsObjectAsync&gt;c__async0))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o conteúdo do texto na posição atual como um <see cref="T:System.Object" />.</summary>
        <returns>O conteúdo do texto como o objeto CLR (Common Language Runtime) mais apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.String" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, espaço em branco, espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Esse método pode ser usado converter valores digitados em uma cadeia de caracteres, ou para ler o conteúdo de texto ao ignorar comentários e instruções de processamento.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato da cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o conteúdo do texto na posição atual como um objeto <see cref="T:System.String" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadContentAsString%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto do tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  **Observação** Com a versão do .NET Framework 3.5, o valor do parâmetro <c>returnType</c> agora pode ser do tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê o conteúdo do elemento como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAs%2A> método para ler o conteúdo do `date` nó.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  **Observação** Com a versão do .NET Framework 3.5, o valor do parâmetro <c>returnType</c> agora pode ser do tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual e, em seguida, lê o conteúdo do elemento atual como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsAsync&gt;c__async4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê de forma assíncrona o conteúdo do elemento como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento e decodifica o conteúdo de <see langword="Base64" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo do elemento, decodifica usando `Base64` de codificação e retorna os bytes binários decodificados (por exemplo, um embutido `Base64`-codificados de imagem GIF) no buffer. Para obter mais informações, consulte RFC 1521, "parte MIME (Multipurpose Internet Mail Extensions) uma: mecanismos para especificar e que descreve o formato dos corpos de mensagens da Internet". Você pode obter RFCs do [para o site da Web de comentários de solicitação](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> só pode ler os elementos de conteúdo simples. O elemento pode conter texto, espaço em branco, espaço em branco significativo, seções CDATA, comentários e instruções de processamento. Ele também pode conter referências de entidade, que são automaticamente expandidas. O elemento não pode ter elementos filho.  
  
 Esse método é muito semelhante ao <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método, exceto que ele só pode ser chamado em tipos de nó de elemento.  
  
 Se o `count` valor é maior do que o número de bytes no documento, ou se for igual ao número de bytes no documento, o <xref:System.Xml.XmlReader> lê todos os bytes restantes no documento e retorna o número de bytes lidos. A próxima <xref:System.Xml.XmlReader> chamada de método retorna um zero e move o leitor para o nó após o `EndElement`.  
  
 Se você chamar <xref:System.Xml.XmlReader.Read%2A> antes de todo o conteúdo do elemento é consumido, o leitor pode se comportar como se o conteúdo foi consumido e, em seguida, o <xref:System.Xml.XmlReader.Read%2A> método foi chamado. Isso significa que o leitor lerá todo o texto até que o elemento final seja encontrado. Ele, em seguida, ler o nó de marca de fim, ler o próximo nó e, em seguida, se posicionar no próximo nó subsequente.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um embutido `Base64` imagem codificada. O `Base64` os dados são inseridos dentro de `<image>` elemento. Um <xref:System.IO.BinaryWriter> é usado para criar um novo arquivo de dados binários.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento contém conteúdo misto.</exception>
        <exception cref="T:System.FormatException">Não é possível converter conteúdo no tipo solicitado.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê de forma assíncrona o elemento e decodifica o conteúdo <see langword="Base64" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento e decodifica o conteúdo de <see langword="BinHex" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo do elemento, decodifica usando `BinHex` de codificação e retorna os bytes binários decodificados (por exemplo, um embutido `BinHex`-codificados de imagem GIF) no buffer.  
  
 Esse método só pode ler os elementos de conteúdo simples. O elemento pode conter texto, espaço em branco, espaço em branco significativo, seções CDATA, comentários e instruções de processamento. Ele também pode conter referências de entidade, que são automaticamente expandidas. O elemento não pode ter elementos filho.  
  
 Esse método é muito semelhante ao <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método, exceto que ele só pode ser chamado em tipos de nó de elemento.  
  
 Se o `count` valor é maior do que o número de bytes no documento, ou se for igual ao número de bytes no documento, o <xref:System.Xml.XmlReader> lê todos os bytes restantes no documento e retorna o número de bytes lidos. A próxima <xref:System.Xml.XmlReader> chamada de método retorna um zero e move o leitor para o nó após o `EndElement`.  
  
 Se você chamar <xref:System.Xml.XmlReader.Read%2A> antes de todo o conteúdo do elemento é consumido, o leitor pode se comportar como se o conteúdo foi consumido e, em seguida, o <xref:System.Xml.XmlReader.Read%2A> método foi chamado. Isso significa que o leitor lerá todo o texto até que o elemento final seja encontrado. Ele, em seguida, ler o nó de marca de fim, ler o próximo nó e, em seguida, se posicionar no próximo nó subsequente.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um embutido `BinHex` imagem codificada. O `BinHex` os dados são inseridos dentro de `<image>` elemento. Um <xref:System.IO.BinaryWriter> é usado para criar um novo arquivo de dados binários.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento contém conteúdo misto.</exception>
        <exception cref="T:System.FormatException">Não é possível converter conteúdo no tipo solicitado.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer no qual o resultado começará a ser copiado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê de forma assíncrona o elemento e decodifica o conteúdo <see langword="BinHex" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o valor do elemento atual como um objeto <see cref="T:System.Boolean" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Boolean" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo do elemento é digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não é tipado `xsd:boolean`, o leitor tentará convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um objeto <see cref="T:System.Boolean" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Boolean" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não é tipado `xsd:boolean`, o leitor tentará convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.DateTime" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não é tipado `xsd:dateTime`, o leitor tentará convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader> sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor como 1904 nesse caso.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para ler o conteúdo do `date` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um objeto <see cref="T:System.DateTime" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O conteúdo do elemento como um objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não é tipado `xsd:dateTime`, o leitor tentará convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader> sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor como 1904 nesse caso.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o valor do elemento atual como um objeto <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tentará converter o elemento de conteúdo para um <xref:System.Decimal> objeto de acordo com as regras definidas pela [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tentará converter o elemento de conteúdo para um <xref:System.Decimal> objeto de acordo com as regras definidas pela [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão dupla.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não é tipado `xsd:double`, o leitor tentará convertê-lo em um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o método para retornar o conteúdo do elemento como um número de ponto flutuante de precisão dupla.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um número de ponto flutuante de precisão dupla.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual, lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não é tipado `xsd:double`, o leitor tentará convertê-lo em um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o valor do elemento atual como um número de ponto flutuante de precisão simples.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tentará converter o conteúdo do elemento em um número de ponto flutuante de precisão simples acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um número de ponto flutuante de precisão simples.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual, lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tentará converter o conteúdo do elemento em um número de ponto flutuante de precisão simples acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um número de ponto flutuante de precisão simples.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 32 bits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 32 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro com sinal de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:integer`, o leitor retorna um inteiro com sinal de 32 bits não Demarcado. Se o conteúdo não é tipado `xsd:integer`, o leitor tentará convertê-lo em um inteiro com sinal de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um inteiro com sinal de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual, lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 32 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro com sinal de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:integer`, o leitor retorna um inteiro com sinal de 32 bits não Demarcado. Se o conteúdo não é tipado `xsd:integer`, o leitor tentará convertê-lo em um inteiro com sinal de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um inteiro com sinal de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 64 bits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 64 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro com sinal de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:long`, o leitor retorna um inteiro com sinal de 64 bits não Demarcado. Se o conteúdo não é tipado `xsd:long`, o leitor tentará convertê-lo em um inteiro com sinal de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> método para ler o conteúdo do `longValue` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um inteiro com sinal de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual, lê o elemento atual e retorna o conteúdo como um inteiro com sinal de 64 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro com sinal de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo está digitado `xsd:long`, o leitor retorna um inteiro com sinal de 64 bits não Demarcado. Se o conteúdo não é tipado `xsd:long`, o leitor tentará convertê-lo em um inteiro com sinal de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um inteiro com sinal de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna os conteúdos como um <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna os conteúdos como um <see cref="T:System.Object" />.</summary>
        <returns>Um objeto CLR (Common Language Runtime) demarcado do tipo mais apropriado. A propriedade <see cref="P:System.Xml.XmlReader.ValueType" /> determina o tipo CLR apropriado. Se o conteúdo for tipado como tipo de lista, esse método retornará uma matriz de objetos demarcados do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o método para ler o conteúdo do `price` nó. O leitor usa as informações do esquema para mapear o conteúdo para o tipo de dados correto.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 O exemplo usa dois arquivos a seguir como entrada.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome local e o URI de namespace especificados são iguais aos do elemento atual, lê o elemento atual e retorna o conteúdo como um <see cref="T:System.Object" />.</summary>
        <returns>Um objeto CLR (Common Language Runtime) demarcado do tipo mais apropriado. A propriedade <see cref="P:System.Xml.XmlReader.ValueType" /> determina o tipo CLR apropriado. Se o conteúdo for tipado como tipo de lista, esse método retornará uma matriz de objetos demarcados do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido no tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsObjectAsync&gt;c__async2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o elemento atual e retorna o conteúdo como um <see cref="T:System.Object" />.</summary>
        <returns>Um objeto CLR (Common Language Runtime) demarcado do tipo mais apropriado. A propriedade <see cref="P:System.Xml.XmlReader.ValueType" /> determina o tipo CLR apropriado. Se o conteúdo for tipado como tipo de lista, esse método retornará uma matriz de objetos demarcados do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê o `stringValue` elemento e retorna o conteúdo de texto (ignorando o comentário e instrução de processamento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um objeto <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignorará comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção de comentários do <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
   
  
## Examples  
 O exemplo a seguir lê o `stringValue` elemento e retorna o conteúdo de texto (ignorando o comentário e instrução de processamento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  -ou- O conteúdo do elemento não pode ser convertido em um objeto <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsStringAsync&gt;c__async3))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê somente os elementos de texto simples. No entanto, é recomendável que você use o método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método para ler um elemento de texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um elemento somente texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento estiver vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString> método para ler um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O próximo nó de conteúdo não é uma marca de início ou o elemento encontrado não contém um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome para verificar.</param>
        <summary>Verifica se a propriedade <see cref="P:System.Xml.XmlReader.Name" /> do elemento encontrado corresponde à cadeia de caracteres fornecida antes de ler um elemento somente texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento estiver vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString> método para ler um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se o próximo nó de conteúdo não for uma marca de início; se o elemento <see langword="Name" /> não corresponde ao argumento fornecido; ou se o elemento encontrado não contiver um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">O nome local a ser verificado.</param>
        <param name="ns">O URI de namespace a ser verificado.</param>
        <summary>Verifica se as propriedades <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> do elemento encontrado correspondem às cadeias de caracteres fornecidas antes de ler um elemento somente de texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento estiver vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> método para ler um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se o próximo nó de conteúdo não for uma marca de início; se o elemento <see langword="LocalName" /> ou <see langword="NamespaceURI" /> não corresponder aos argumentos fornecidos; ou se o elemento encontrado não contiver um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó de conteúdo atual é uma marca de fim e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o conteúdo de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 O exemplo usa o `book3.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O nó atual não é uma marca de fim ou XML incorreto foi encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê todo o conteúdo, incluindo a marcação, como uma cadeia de caracteres.</summary>
        <returns>Todo o conteúdo XML, incluindo a marcação, no nó atual. Se o nó atual não tiver nenhum filho, uma cadeia de caracteres vazia será retornada.  Se o nó atual não for um elemento nem um atributo, uma cadeia de caracteres vazia será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna todo o conteúdo do nó atual, incluindo a marcação. O nó atual (marca de início) e o nó de fim correspondente (marca de fim) não são retornados. Por exemplo, se você tivesse o seguinte:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` retorna `this <child id="123"/>`  
  
 Esse método lida conosco de elemento e atributo da seguinte maneira:  
  
|Tipo de nó|Posição antes da chamada|Fragmento XML|Valor retornado|Posição após a chamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na tag de início de `item1`.|\<item1>text1\</item1>\<item2>text2\</item2>|text1|Na tag de início de `item2`.|  
|`Attribute`|No nó de atributo `attr1`.|\<item attr1 = attr2 "val1" = "val2" > texto \< /item >|val1|Permanece no nó de atributo `attr1`.|  
  
 Se o leitor estiver posicionado em um nó folha, chamar `ReadInnerXml` será o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>. O método retorna `String.Empty` (exceto para nós de atributo, caso em que o valor do atributo será retornado).  
  
 Esse método verifica XML bem formado. Se `ReadInnerXml` é chamado de um <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo retornado.  
  
 Conforme implementado de <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> e `XmlValidatingReader` classes o `ReadOuterXml` método está ciente do namespace.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir compara os `ReadInnerXml` e <xref:System.Xml.XmlReader.ReadOuterXml%2A> métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 O exemplo usa `2books.xml` de arquivo como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O XML está malformado ou ocorreu um erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadInnerXmlAsync&gt;c__async6))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona todo o conteúdo, inclusive a marcação, como uma cadeia de caracteres.</summary>
        <returns>Todo o conteúdo XML, incluindo a marcação, no nó atual. Se o nó atual não tiver nenhum filho, uma cadeia de caracteres vazia será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadInnerXml%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o conteúdo, inclusive a marcação, que representa esse nó e todos os seus filhos.</summary>
        <returns>Se o leitor estiver posicionado em um elemento ou em um nó de atributo, esse método retornará todo o conteúdo XML, inclusive a marcação do nó atual e todos os seus filhos; caso contrário, ele retornará uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é semelhante ao <xref:System.Xml.XmlReader.ReadInnerXml%2A> , exceto que ele também retorna as marcas de início e término.  
  
 Esse método lida conosco de elemento e atributo da seguinte maneira:  
  
|Tipo de nó|Posição antes da chamada|Fragmento XML|Valor retornado|Posição após a chamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na tag de início de `item1`.|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|Na tag de início de `item2`.|  
|`Attribute`|No nó de atributo `attr1`.|\<item attr1 = attr2 "val1" = "val2" > texto \< /item >|attr1="val1"|Permanece no nó de atributo `attr1`.|  
  
 Se o leitor estiver posicionado em um nó folha, chamar `ReadOuterXml` será o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>. O método retorna `String.Empty` (exceto para nós de atributo, caso em que a marcação do atributo será retornada).  
  
 Esse método verifica XML bem formado. Se `ReadOuterXml` é chamado de um <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo retornado  
  
 Conforme implementado de <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> e `XmlValidatingReader` classes o `ReadOuterXml` método está ciente do namespace. Considerando o seguinte texto XML `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, se o leitor foram posicionado em de `S:B` marca, de início `ReadOuterXml` retorna `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir compara os `ReadInnerXml` e `ReadOuterXml` métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 O exemplo usa `2books.xml` de arquivo como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O XML está malformado ou ocorreu um erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadOuterXmlAsync&gt;c__async8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o conteúdo, inclusive a marcação, representando este nó e todos os seus filhos.</summary>
        <returns>Se o leitor estiver posicionado em um elemento ou em um nó de atributo, esse método retornará todo o conteúdo XML, inclusive a marcação do nó atual e todos os seus filhos; caso contrário, ele retornará uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadOuterXml%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Verifica se o nó atual é um elemento e avança o leitor para o próximo nó.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó atual é um elemento e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por <xref:System.Xml.XmlReader.Read%2A> para posicioná-lo no conteúdo do elemento encontrado no fluxo de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento.</param>
        <summary>Verifica se o nó de conteúdo atual é um elemento com o <see cref="P:System.Xml.XmlReader.Name" /> fornecido e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para esse método corresponde a uma chamada para <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por uma chamada para <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 O exemplo usa o `book3.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.  -ou- O <see cref="P:System.Xml.XmlReader.Name" /> do elemento não corresponde ao <paramref name="name" /> fornecido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">O nome local do elemento.</param>
        <param name="ns">O URI do namespace do elemento.</param>
        <summary>Verifica se o nó de conteúdo atual é um elemento com o <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> fornecidos e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para esse método corresponde a uma chamada para <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por uma chamada para <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.  -ou- As propriedades <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> do elemento encontrado não correspondem aos argumentos fornecidos.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o estado do leitor.</summary>
        <value>Um dos valores de enumeração que especifica o estado do leitor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.XmlReader.ReadState%2A> propriedade tem um dos seguintes valores:  
  
-   <xref:System.Xml.ReadState.Initial>, quando o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método é chamado.  
  
-   <xref:System.Xml.ReadState.Interactive>, quando o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método foi chamado e métodos adicionais podem ser chamados no leitor.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, quando o fim do documento XML foi alcançado com êxito.  
  
-   <xref:System.Xml.ReadState.Closed>, quando o <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> método é chamado.  
  
-   <xref:System.Xml.ReadState.Error>, quando um erro está impedindo a operação de leitura de continuar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o conteúdo de um nó de elemento ou texto como uma cadeia de caracteres. No entanto, é recomendável que você use o método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O conteúdo do elemento ou uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método para ler o conteúdo de um nó de elemento ou texto como uma cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma nova instância <see langword="XmlReader" /> que pode ser usada para ler o nó atual e todos os seus descendentes.</summary>
        <returns>Uma nova instância de leitor XML definida como <see cref="F:System.Xml.ReadState.Initial" />. Uma chamada ao método <see cref="M:System.Xml.XmlReader.Read" /> posiciona o novo leitor no nó que era atual antes da chamada ao método <see cref="M:System.Xml.XmlReader.ReadSubtree" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> pode ser chamado somente em nós de elemento. Quando a subárvore inteira foi lido, chamadas para o <xref:System.Xml.XmlReader.Read%2A> retorno do método `false`. Quando o novo leitor XML foi fechado, o original readeris posicionado no `EndElement` nós da subárvore. Portanto, se você chamou o <xref:System.Xml.XmlReader.ReadSubtree%2A> método na marca de início do elemento de livro, após a subárvore de leitura e o novo leitor XML foi fechado, o leitor XML original é posicionado na marca de fim do elemento de livro.  
  
 Você não deve executar qualquer operações no leitor original até que o novo leitor seja fechado. Esta ação não é suportada e pode levar ao comportamento imprevisível.  
  
> [!NOTE]
>  O <xref:System.Xml.XmlReader.ReadSubtree%2A> método não é destinado ao creatingcopies dos dados XML que você pode trabalhar independentemente. Desenvolvido é criar um limite em torno de um elemento XML. Isso é útil se você deseja passar dados para outro componente para processamento e desejar limitar quantos de seus dados, o componente pode acessar. Quando você passa um leitor de XML retornado pelo <xref:System.Xml.XmlReader.ReadSubtree%2A> método para outro aplicativo, o aplicativo pode acessar somente esse elemento XML, e não todo o documento XML.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o método <xref:System.Xml.XmlReader.ReadSubtree%2A>.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Use os seguintes dados XML para executar os exemplos neste tópico:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Avança o <see cref="T:System.Xml.XmlReader" /> para o próximo elemento descendente correspondente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento para o qual você deseja mover.</param>
        <summary>Avança o <see cref="T:System.Xml.XmlReader" /> para o próximo elemento descendente com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" /> se um elemento descendente correspondente for encontrado; caso contrário, <see langword="false" />. Se um elemento filho correspondente não for encontrado, o <see cref="T:System.Xml.XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento.  Se o <see cref="T:System.Xml.XmlReader" /> não estiver posicionado em um elemento quando <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> foi chamado, esse método retornará <see langword="false" /> e a posição do <see cref="T:System.Xml.XmlReader" /> não será alterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir analisa o segundo nó de livro.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 O exemplo usa o arquivo `2books.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento para o qual você deseja mover.</param>
        <param name="namespaceURI">O URI do namespace do elemento para o qual você deseja mover.</param>
        <summary>Avança o <see cref="T:System.Xml.XmlReader" /> para o próximo elemento descendente com o nome local e URI do namespace especificados.</summary>
        <returns>
          <see langword="true" /> se um elemento descendente correspondente for encontrado; caso contrário, <see langword="false" />. Se um elemento filho correspondente não for encontrado, o <see cref="T:System.Xml.XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento.  Se o <see cref="T:System.Xml.XmlReader" /> não estiver posicionado em um elemento quando <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> foi chamado, esse método retornará <see langword="false" /> e a posição do <see cref="T:System.Xml.XmlReader" /> não será alterada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Lê até que o elemento nomeado seja encontrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento.</param>
        <summary>Lê até que seja encontrado um elemento com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" /> se um elemento correspondente for encontrado; caso contrário, <see langword="false" /> e o <see cref="T:System.Xml.XmlReader" /> estará em um estado de fim do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é funcionalmente equivalente a executar o `following::name` expressão XPath do nó atual. Ele fornece uma maneira rápida de localizar um elemento nomeado no documento XML. Ele avança o leitor para o próximo elemento abaixo que corresponde ao nome especificado e retorna `true` se um elemento correspondente for encontrado. Usando o exemplo a seguir, o leitor leria para a primeira instância do elemento especificado durante a leitura para frente.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Esse método pode ser chamado em todos os tipos de nó.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Lê até que seja encontrado um elemento com o nome do local e o URI do namespace especificados.</summary>
        <returns>
          <see langword="true" /> se um elemento correspondente for encontrado; caso contrário, <see langword="false" /> e o <see cref="T:System.Xml.XmlReader" /> estará em um estado de fim do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é funcionalmente equivalente a executar o `following::name` expressão XPath do nó atual. Ele fornece uma maneira rápida de localizar um elemento nomeado no documento XML. Ele avança o leitor para o próximo elemento abaixo que corresponde ao nome especificado e retorna `true` se um elemento correspondente for encontrado.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Esse método pode ser chamado em todos os tipos de nó.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <summary>Avança o <see langword="XmlReader" /> para o próximo elemento irmão correspondente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento irmão para o qual você deseja realizar a movimentação.</param>
        <summary>Avança o <see langword="XmlReader" /> para o próximo elemento irmão com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" /> se um elemento irmão correspondente for encontrado; caso contrário, <see langword="false" />. Se um elemento irmão correspondente não for encontrado, o <see langword="XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento pai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não chame <xref:System.Xml.XmlReader.ReadToNextSibling%2A> quando o `XmlReader` é um estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> é <xref:System.Xml.ReadState.Initial>). Você pode chamar <xref:System.Xml.XmlReader.Read%2A> para avançar o `XmlReader` e, em seguida, chamar o <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir lê o atributo ISBN em cada nó de livro.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento irmão para o qual você deseja.</param>
        <param name="namespaceURI">O URI do namespace do elemento irmão para o qual você deseja mover.</param>
        <summary>Avança o <see langword="XmlReader" /> para o próximo elemento irmão com o nome local e o URI de namespace especificados.</summary>
        <returns>
          <see langword="true" /> se um elemento irmão correspondente for encontrado; caso contrário, <see langword="false" />. Se um elemento irmão correspondente não for encontrado, o <see langword="XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento pai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não chame <xref:System.Xml.XmlReader.ReadToNextSibling%2A> quando o `XmlReader` é um estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> é <xref:System.Xml.ReadState.Initial>). Você pode chamar <xref:System.Xml.XmlReader.Read%2A> para avançar o `XmlReader` e, em seguida, chamar o <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A matriz de caracteres que serve como o buffer no qual os conteúdos de texto são gravados. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento dentro do buffer em que o <see cref="T:System.Xml.XmlReader" /> pode começar a copiar os resultados.</param>
        <param name="count">O número máximo de caracteres a ser copiado para o buffer. O número real de caracteres copiado é retornado deste método.</param>
        <summary>Lê grandes fluxos de texto inseridos em um documento XML.</summary>
        <returns>O número de caracteres lidos no buffer. O valor zero é retornado quando não há mais nenhum conteúdo de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite a leitura dos fluxos muito grandes de texto inserido em um documento XML de uma forma de streaming, ou seja, um pequeno número de caracteres de cada vez em vez de alocar uma única cadeia de caracteres para o valor inteiro. Esse método pode ser chamado em qualquer nó que tem um valor (<xref:System.Xml.XmlReader.HasValue%2A> é `true`), no entanto, o fluxo real do valor do nó ocorre apenas quando chamado em um texto, espaço em branco e nós de espaço em branco significativo. Outros valores de tipo de nó são armazenados em cache, incluindo atributos e nós CDATA.  
  
 Esse método retorna apenas o conteúdo da <xref:System.Xml.XmlReader.Value%2A> propriedade e não move o <xref:System.Xml.XmlReader>.  
  
 Esse método lê o número especificado de caracteres (`count`) do valor do nó em um buffer de caracteres (`buffer`) em um deslocamento especificado (`index`) e retorna o número de caracteres gravados no buffer. Ele retorna o `0` quando ele alcançou o final do valor. Ele não pode ser reiniciado para ler por meio do valor novamente.  
  
 Entre chamadas para <xref:System.Xml.XmlReader.ReadValueChunk%2A> as <xref:System.Xml.XmlReader> propriedades não fazem nenhuma alteração, exceto para o <xref:System.Xml.XmlReader.Value%2A> propriedade. Quando o <xref:System.Xml.XmlReader.Value%2A> propriedade é acessada ou pode retornar um valor parcial (com caracteres ainda não foi retornados pelo <xref:System.Xml.XmlReader.ReadValueChunk%2A>) ou um valor completo, dependendo da implementação. Todos os as <xref:System.Xml.XmlReader> implementações na <xref:System.Xml> namespace retornar um valor parcial para o <xref:System.Xml.XmlReader.Value%2A> implementação da propriedade.  
  
 Qualquer leitura método pode ser chamado entre chamadas para <xref:System.Xml.XmlReader.ReadValueChunk%2A>. Se isso ocorrer, o <xref:System.Xml.XmlReader> move para a próxima <xref:System.Xml.XmlNodeType> no fluxo e quaisquer caracteres ainda não foram retornadas são ignoradas.  
  
 Pode haver um caso de quando <xref:System.Xml.XmlReader.ReadValueChunk%2A> retornará menor que o número de caracteres solicitado. Por exemplo, se você tivesse um valor longo de 200 caracteres com um par substituto em posições 127 e 128 e você chamou <xref:System.Xml.XmlReader.ReadValueChunk%2A> com um buffer de 128 caracteres, a chamada de método retornaria 127 caracteres, em vez de 128 solicitada. O par substituto, em seguida, seria retornado nas próximas <xref:System.Xml.XmlReader.ReadValueChunk%2A> chamar. Nesse caso, <xref:System.Xml.XmlReader.ReadValueChunk%2A> não retornou os 128 caracteres solicitados porque fazer então teria resultado em um par substituto incompleta no final do buffer.  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <exception cref="T:System.ArgumentNullException">O valor <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice do buffer ou a contagem de índices + é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">Os dados XML não estão bem formados.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A matriz de caracteres que serve como o buffer no qual os conteúdos de texto são gravados. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento dentro do buffer em que o <see cref="T:System.Xml.XmlReader" /> pode começar a copiar os resultados.</param>
        <param name="count">O número máximo de caracteres a ser copiado para o buffer. O número real de caracteres copiado é retornado deste método.</param>
        <summary>Lê de forma assíncrona grandes fluxos de texto inserido em um documento XML.</summary>
        <returns>O número de caracteres lidos no buffer. O valor zero é retornado quando não há mais nenhum conteúdo de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.ReadValueChunk%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, resolve a referência da entidade para nós <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o leitor estiver posicionado em um `EntityReference` nó (`XmlNodeType.EntityReference`), se <xref:System.Xml.XmlReader.Read%2A> for chamado após chamar esse método, o texto de substituição de entidade é analisado. Quando o texto de substituição de entidade é concluído, um `EndEntity` nó será retornado para fechar o escopo de referência de entidade.  
  
> [!NOTE]
>  Depois de chamar esse método, se a entidade fizer parte de um valor de atributo, você deve chamar <xref:System.Xml.XmlReader.ReadAttributeValue%2A> para a etapa para a entidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as informações de esquema que foram atribuídas ao nó atual como resultado da validação de esquema.</summary>
        <value>Um objeto <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> que contém as informações de esquema para o nó atual. Informações de esquema podem ser definidas em elementos, atributos ou nós de texto com um não-nulo <see cref="P:System.Xml.XmlReader.ValueType" /> (valores digitados).  Se o nó atual não é um dos tipos de nó acima ou se o <see langword="XmlReader" /> instância não relata informações de esquema, essa propriedade retornará <see langword="null" />.  Se essa propriedade é chamada de um <see cref="T:System.Xml.XmlTextReader" /> ou um <see cref="T:System.Xml.XmlValidatingReader" /> do objeto, essa propriedade sempre retorna <see langword="null" />. Eles <see langword="XmlReader" /> implementações não expõem informações de esquema por meio de <see langword="SchemaInfo" /> propriedade.  
  
 <block subset="none" type="note"><para> Se você tiver que obter o conjunto de informações de post-schema-validation (PSVI) de um elemento, posicione o leitor na marca de fim do elemento, em vez de na marca de início. Obtenha o PSVI por meio de <see langword="SchemaInfo" /> propriedade de um leitor. O leitor Validando criado por meio <see cref="Overload:System.Xml.XmlReader.Create" /> com o <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> propriedade definida como <see cref="F:System.Xml.ValidationType.Schema" /> tem a PSVI completa para um elemento somente quando o leitor está posicionado na marca de fim de um elemento.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.Schema.IXmlSchemaInfo> interface expõe um subconjunto da postagem de esquema validação Infoset (PSVI) associado a um nó XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Xml.XmlReaderSettings" /> usado para criar essa instância <see cref="T:System.Xml.XmlReader" />.</summary>
        <value>O objeto <see cref="T:System.Xml.XmlReaderSettings" /> usado para criar essa instância do leitor. Se esse leitor não foi criado usando o <see cref="Overload:System.Xml.XmlReader.Create" /> método, essa propriedade retornará <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O <xref:System.Xml.XmlReaderSettings> objeto pode conter informações sigilosas como credenciais do usuário. Aplicativos devem ter cuidado ao armazenamento em cache esse objeto ou passá-la para outro componente.  
  
 O <xref:System.Xml.XmlReaderSettings> classe é usada para especificar o conjunto de recursos para dar suporte na instância do leitor criado. O <xref:System.Xml.XmlReaderSettings> objeto retornado por essa propriedade não pode ser modificado. Qualquer tentativa alterar as configurações individuais resulta em uma exceção sendo lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignora os filhos do nó atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No seguinte XML de entrada se o leitor está posicionado sobre o `<a>` nó ou qualquer um dos seus atributos, chamando `Skip` posiciona o leitor para o `<b>` nó.  
  
 Se o leitor está posicionado em um nó folha já (como o `<x>` nó ou o nó de texto `abc`), chamar `Skip` é o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Esse método verifica XML bem formado.  
  
 Se o leitor estiver um <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo foi ignorado.  
  
 O `XmlReader` determina de implementação ou não o `Skip` método expandirá as entidades externas. A tabela a seguir descreve se a entidades externas são expandidas para vários tipos de `XmlReader` objetos.  
  
|Tipo de XmlReader|Expande as entidades externas|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nº|  
|<xref:System.Xml.XmlReader> instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método que está lendo dados de texto.|Nº|  
|<xref:System.Xml.XmlReader> instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método que está lendo dados binários.|Não aplicável.|  
|Um esquema Validando <xref:System.Xml.XmlReader> instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método.|Sim.|  
|<xref:System.Xml.XmlValidatingReader>|Sim.|  
|<xref:System.Xml.XmlReader> instância retornada por uma <xref:System.Xml.XPath.XPathNavigator> objeto.|Não aplicável.|  
|<xref:System.Xml.XmlNodeReader>|Nº|  
|<xref:System.Xml.XmlReader> instância encapsulada em torno de outro <xref:System.Xml.XmlReader> instância.|Depende da implementação de subjacente <xref:System.Xml.XmlReader>. (O `Skip` método no subjacente <xref:System.Xml.XmlReader> é chamado).|  
  
 Para obter a versão assíncrona deste método, consulte <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir analisa um arquivo XML iniciando no segundo nó de livro.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 O exemplo usa o arquivo `2books.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignora de forma assíncrona os filhos do nó atual.</summary>
        <returns>O nó atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona de <xref:System.Xml.XmlReader.Skip%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir a <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Neste caso, <see cref="T:System.InvalidOperationException" /> é gerado com a mensagem: “Defina XmlReaderSettings.Async como verdadeiro se desejar usar Métodos Assíncronos”.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o valor do texto do nó atual.</summary>
        <value>O valor retornado depende do <see cref="P:System.Xml.XmlReader.NodeType" /> do nó. A tabela a seguir lista os tipos de nós que têm um valor a ser retornado. Todos os outros tipos de nó retornam <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Tipo de nó </term><description> valor </description></listheader><item><term><see langword="Attribute" /></term><description> o valor do atributo.  </description></item><item><term><see langword="CDATA" /></term><description> O conteúdo da seção CDATA.  </description></item><item><term><see langword="Comment" /></term><description> O conteúdo do comentário.  </description></item><item><term><see langword="DocumentType" /></term><description> O subconjunto interno.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Todo o conteúdo, exceto o destino.  </description></item><item><term><see langword="SignificantWhitespace" /></term><description> O espaço em branco entre a marcação em um modelo de conteúdo misto.  </description></item><item><term><see langword="Text" /></term><description> O conteúdo do nó de texto.  </description></item><item><term><see langword="Whitespace" /></term><description> O espaço em branco entre a marcação.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> O conteúdo da declaração.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter a versão assíncrona dessa propriedade, consulte o <xref:System.Xml.XmlReader.GetValueAsync%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo CLR (Common Language Runtime) para o nó atual.</summary>
        <value>O tipo CLR que corresponde ao valor digitado do nó. O padrão é <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ver [suporte a tipo nas Classes System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) para obter uma lista dos mapeamentos padrão.  
  
 Um elemento do tipo `xs:int` tem uma `ValueType` de `System.Int32` por padrão. No entanto, o `ValueType` poderia ser um dos tipos válidos que podem ser mapeados para `xs:int`, como `System.Int16` ou `System.Double`.  
  
 Se um nó é não tipado, ou se o nó for um elemento que contém conteúdo misto, o valor do nó é mapeado para o `System.String` tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <block subset="none" type="overrides">
          <para>Os implementadores devem fornecer um <see langword="ValueType" /> para cada nó, mesmo que ele seja somente o <see langword="System.String" /> tipo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o escopo <see langword="xml:lang" /> atual.</summary>
        <value>Atual <see langword="xml:lang" /> escopo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade representa o `xml:lang` definir o escopo no qual reside o nó atual. Por exemplo, aqui está um fragmento XML com `xml:lang` definido como inglês dos EUA no elemento raiz:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Quando o leitor está posicionado sobre o `name` elemento, você pode usar essa propriedade para localizar o que ele está no escopo de um inglês dos EUA `xml:lang` atributo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> para obter um exemplo de como usar essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o escopo <see langword="xml:space" /> atual.</summary>
        <value>Um dos valores de <see cref="T:System.Xml.XmlSpace" />. Se nenhum <see langword="xml:space" /> escopo existir, essa propriedade padroniza como <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ver <xref:System.Xml.XmlTextReader.XmlSpace%2A> (no `XmlTextReader` classe) para obter um exemplo de uso dessa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será gerado com a mensagem “Uma operação assíncrona já está em andamento”.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>