<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="010b867d0c50e186006fea90cdbc67fefd8cfd61" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410670" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa uma série de linhas e curvas conectadas. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicativos usam caminhos para desenhar os contornos das formas, preencher os interiores das formas e criar regiões de recorte. O mecanismo de gráficos mantém as coordenadas de formas geométricas um caminho no espaço de coordenadas do mundo.  
  
 Um caminho pode ser composto de qualquer número de valores (subcaminhos). Cada figura ou é composta de uma sequência de linhas conectadas e curvas ou uma primitivo de forma geométrica. O ponto de partida de uma figura é o primeiro ponto na sequência de linhas e curvas conectadas. O ponto final é o último ponto na sequência. Os pontos iniciais e final de uma forma geométrica primitivo são definidos pela especificação de primitivos.  
  
 Uma figura que consiste em uma sequência de linhas conectadas e curvas (cujos pontos inicial e final podem ser coincidentes) é uma figura aberta, a menos que ela está fechada explicitamente. Uma figura pode ser fechada explicitamente, usando o <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> método, que fecha a figura atual por uma linha de conexão do ponto final para o ponto de partida. Uma figura que consiste em um primitivo de forma geométrica é uma figura fechada.  
  
 Para fins de preenchimento e recorte (por exemplo, se um caminho é renderizado usando <xref:System.Drawing.Graphics.FillPath%2A>), todos os valores são fechados, adicionando uma linha do primeiro ponto da figura no último ponto.  
  
 Uma nova figura é iniciada implicitamente quando um caminho é criado ou quando uma figura está fechada. Uma nova figura explicitamente é criada quando o <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> método é chamado.  
  
 Quando uma forma geométrica primitivo é adicionada a um caminho, adicione uma figura que contém a forma geométrica e também implicitamente inicia uma nova figura. Consequentemente, sempre há uma figura atual em um caminho. Quando linhas e curvas são adicionadas a um caminho, uma linha implícita é adicionada, conforme necessário para conectar o ponto final da figura atual para o ponto de partida das novas linhas e curvas para formar uma sequência de linhas conectadas e curvas.  
  
 Uma figura tem uma direção que descreve como segmentos de linha e curva são rastreados entre o ponto de partida e o ponto final. A direção é definida na ordem em que as linhas e curvas são adicionados a uma figura, ou é definido pela forma geométrica primitivo. A direção é usada para determinar os interiores de caminho de recorte e preenchimento.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com uma enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> de <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com um valor <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> de <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">A enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como o interior desse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> é preenchido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com a enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que define as coordenadas dos pontos que compõem este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Uma matriz de elementos de enumeração <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica o tipo de cada ponto correspondente na matriz <c>pts</c>.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com as matrizes <see cref="T:System.Drawing.Drawing2D.PathPointType" /> e <see cref="T:System.Drawing.Point" /> especificadas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que define as coordenadas dos pontos que compõem este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Uma matriz de elementos de enumeração <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica o tipo de cada ponto correspondente na matriz <c>pts</c>.</param>
        <summary>Inicializa uma nova instância da matriz <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com as matrizes <see cref="T:System.Drawing.Drawing2D.PathPointType" /> e <see cref="T:System.Drawing.PointF" /> especificadas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que define as coordenadas dos pontos que compõem este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Uma matriz de elementos de enumeração <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica o tipo de cada ponto correspondente na matriz <c>pts</c>.</param>
        <param name="fillMode">Uma enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica como os interiores das formas neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> são preenchidos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com as matrizes <see cref="T:System.Drawing.Drawing2D.PathPointType" /> e <see cref="T:System.Drawing.Point" /> especificadas e com o elemento de enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que define as coordenadas dos pontos que compõem este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Uma matriz de elementos de enumeração <see cref="T:System.Drawing.Drawing2D.PathPointType" /> que especifica o tipo de cada ponto correspondente na matriz <c>pts</c>.</param>
        <param name="fillMode">Uma enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica como os interiores das formas neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> são preenchidos.</param>
        <summary>Inicializa uma nova instância da matriz <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> com as matrizes <see cref="T:System.Drawing.Drawing2D.PathPointType" /> e <see cref="T:System.Drawing.PointF" /> especificadas e com o elemento de enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta um arco elíptico à figura atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.Rectangle" /> que representa os limites retangulares da elipse da qual o arco é retirado.</param>
        <param name="startAngle">O ângulo inicial do arco, medido em graus no sentido horário do eixo x.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final do arco.</param>
        <summary>Acrescenta um arco elíptico à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior ao início do arco.  
  
 O arco é rastreado ao longo do perímetro da elipse delimitada pelo retângulo especificado. O ponto de partida do arco é determinado pelo avaliar no sentido horário do eixo x da elipse (com o ângulo de graus de 0), o número de graus no ângulo inicial. Da mesma forma, o ponto de extremidade está localizado medindo no sentido horário do ponto de partida pelo número de graus em ângulo de flecha. Se o ângulo de flecha é maior que 360 graus ou menor que-360 graus, o arco é varridas para exatamente 360 graus ou-360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um retângulo, do qual o arco é definido.  
  
-   Cria um caminho, `myPath`.  
  
-   Define um arco elíptico de 180 graus que varre de 0 graus a 180 graus e anexa a um caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.RectangleF" /> que representa os limites retangulares da elipse da qual o arco é retirado.</param>
        <param name="startAngle">O ângulo inicial do arco, medido em graus no sentido horário do eixo x.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final do arco.</param>
        <summary>Acrescenta um arco elíptico à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior ao início do arco.  
  
 O arco é rastreado ao longo do perímetro da elipse delimitada pelo retângulo especificado. O ponto de partida do arco é determinado pelo avaliar no sentido horário do eixo x da elipse (com o ângulo de graus de 0), o número de graus no ângulo inicial. Da mesma forma, o ponto de extremidade está localizado medindo no sentido horário do ponto de partida pelo número de graus em ângulo de flecha. Se o ângulo de flecha é maior que 360 graus ou menor que-360 graus, o arco é varridas para exatamente 360 graus ou-360 graus, respectivamente.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="y">A coordenada y do canto superior esquerdo da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="width">A largura da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="height">A altura da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="startAngle">O ângulo inicial do arco, medido em graus no sentido horário do eixo x.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final do arco.</param>
        <summary>Acrescenta um arco elíptico à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior ao início do arco.  
  
 O arco é rastreado ao longo do perímetro da elipse delimitada pelo retângulo especificado. O ponto de partida do arco é determinado pelo avaliar no sentido horário do eixo x da elipse (com o ângulo de graus de 0), o número de graus no ângulo inicial. Da mesma forma, o ponto de extremidade está localizado medindo no sentido horário do ponto de partida pelo número de graus em ângulo de flecha. Se o ângulo de flecha é maior que 360 graus ou menor que-360 graus, o arco é varridas para exatamente 360 graus ou-360 graus, respectivamente.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="y">A coordenada y do canto superior esquerdo da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="width">A largura da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="height">A altura da região retangular que define a elipse da qual o arco é retirado.</param>
        <param name="startAngle">O ângulo inicial do arco, medido em graus no sentido horário do eixo x.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final do arco.</param>
        <summary>Acrescenta um arco elíptico à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior ao início do arco.  
  
 O arco é rastreado ao longo do perímetro da elipse delimitada pelo retângulo especificado. O ponto de partida do arco é determinado pelo avaliar no sentido horário do eixo x da elipse (com o ângulo de graus de 0), o número de graus no ângulo inicial. Da mesma forma, o ponto de extremidade está localizado medindo no sentido horário do ponto de partida pelo número de graus em ângulo de flecha. Se o ângulo de flecha é maior que 360 graus ou menor que-360 graus, o arco é varridas para exatamente 360 graus ou-360 graus, respectivamente.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma curva de Bézier cúbica à figura atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Uma <see cref="T:System.Drawing.Point" /> que representa o ponto inicial da curva.</param>
        <param name="pt2">Uma <see cref="T:System.Drawing.Point" /> que representa o primeiro ponto de controle da curva.</param>
        <param name="pt3">Uma <see cref="T:System.Drawing.Point" /> que representa o segundo ponto de controle da curva.</param>
        <param name="pt4">Um <see cref="T:System.Drawing.Point" /> que representa o ponto de extremidade da curva.</param>
        <summary>Adiciona uma curva de Bézier cúbica à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A curva cúbica é construída do primeiro ponto até o quarto ponto usando os pontos de segundo e terceiro como pontos de controle.  
  
 Se houver uma linha anterior ou um segmento de curva na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Uma <see cref="T:System.Drawing.PointF" /> que representa o ponto inicial da curva.</param>
        <param name="pt2">Uma <see cref="T:System.Drawing.PointF" /> que representa o primeiro ponto de controle da curva.</param>
        <param name="pt3">Uma <see cref="T:System.Drawing.PointF" /> que representa o segundo ponto de controle da curva.</param>
        <param name="pt4">Um <see cref="T:System.Drawing.PointF" /> que representa o ponto de extremidade da curva.</param>
        <summary>Adiciona uma curva de Bézier cúbica à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A curva cúbica é construída do primeiro ponto até o quarto ponto usando os pontos de segundo e terceiro como pontos de controle.  
  
 Se houver uma linha anterior ou um segmento de curva na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">A coordenada X do ponto de partida da curva.</param>
        <param name="y1">A coordenada Y do ponto de partida da curva.</param>
        <param name="x2">A coordenada X do primeiro ponto de controle da curva.</param>
        <param name="y2">A coordenada Y do primeiro ponto de controle da curva.</param>
        <param name="x3">A coordenada X do segundo ponto de controle da curva.</param>
        <param name="y3">A coordenada Y do segundo ponto de controle da curva.</param>
        <param name="x4">A coordenada X do ponto de extremidade da curva.</param>
        <param name="y4">A coordenada Y do ponto de extremidade da curva.</param>
        <summary>Adiciona uma curva de Bézier cúbica à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A curva cúbica é construída do primeiro ponto até o quarto ponto usando os pontos de segundo e terceiro como pontos de controle.  
  
 Se houver uma linha anterior ou um segmento de curva na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona uma curva de Bézier cúbica definida por pontos (50, 50), (70, 0), (100, 120) e (150, 50) para o caminho.  
  
-   Fecha a curva.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">A coordenada X do ponto de partida da curva.</param>
        <param name="y1">A coordenada Y do ponto de partida da curva.</param>
        <param name="x2">A coordenada X do primeiro ponto de controle da curva.</param>
        <param name="y2">A coordenada Y do primeiro ponto de controle da curva.</param>
        <param name="x3">A coordenada X do segundo ponto de controle da curva.</param>
        <param name="y3">A coordenada Y do segundo ponto de controle da curva.</param>
        <param name="x4">A coordenada X do ponto de extremidade da curva.</param>
        <param name="y4">A coordenada Y do ponto de extremidade da curva.</param>
        <summary>Adiciona uma curva de Bézier cúbica à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A curva cúbica é construída do primeiro ponto até o quarto ponto usando os pontos de segundo e terceiro como pontos de controle.  
  
 Se houver uma linha anterior ou um segmento de curva na figura, uma linha é adicionada ao conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona à figura atual uma sequência de curvas de Bézier cúbicas conectadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem as curvas.</param>
        <summary>Adiciona à figura atual uma sequência de curvas de Bézier cúbicas conectadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `points` parâmetro especifica uma matriz de pontos de extremidade e pontos de controle das curvas conectadas. A primeira curva é construída do primeiro ponto até o quarto ponto na `points` matriz usando os pontos de segundo e terceiro como pontos de controle. Além de ponto de extremidade da curva anterior, cada curva subsequente na sequência deverá exatamente três pontos mais: os dois pontos na sequência são pontos de controle e a terceira é o ponto de extremidade para a curva adicionado.  
  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada para conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica primeiro na sequência.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria uma matriz de sete pontos (representando duas curvas de Bézier conectadas).  
  
-   Cria um caminho e adiciona a série de pontos de curva de Bézier no caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem as curvas.</param>
        <summary>Adiciona à figura atual uma sequência de curvas de Bézier cúbicas conectadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `points` parâmetro especifica uma matriz de pontos de extremidade e pontos de controle das curvas conectadas. A primeira curva é construída do primeiro ponto até o quarto ponto na `points` matriz usando os pontos de segundo e terceiro como pontos de controle. Além de ponto de extremidade da curva anterior, cada curva subsequente na sequência deverá exatamente três pontos mais: os dois pontos na sequência são pontos de controle e a terceira é o ponto de extremidade para a curva adicionado.  
  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada para conectar o ponto de extremidade do segmento anterior para o ponto de partida da curva cúbica primeiro na sequência.  
  
   
  
## Examples  
 Para ver um exemplo:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma curva fechada a esse caminho. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem a curva.</param>
        <summary>Adiciona uma curva fechada a esse caminho. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais. Se o primeiro ponto e o último ponto na `points` matriz não são o mesmo ponto, a curva é fechada por conectar-se esses dois pontos. O valor de tensão não pode ser definido para esse método e o padrão é um valor equivalente a 0,5.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem a curva.</param>
        <summary>Adiciona uma curva fechada a esse caminho. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais. Se o primeiro ponto e o último ponto na `points` matriz não são o mesmo ponto, a curva é fechada por conectar-se esses dois pontos. O valor de tensão não pode ser definido para esse método e o padrão é um valor equivalente a 0,5.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem a curva.</param>
        <param name="tension">Um valor entre 0 e 1, que especifica o quanto a curva se dobra entre pontos, com 0 sendo a curva menor (com canto mais agudo) e 1 sendo a curva mais suave.</param>
        <summary>Adiciona uma curva fechada a esse caminho. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais. Se o primeiro ponto e o último ponto na `points` matriz não são o mesmo ponto, a curva é fechada por conectar-se esses dois pontos.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria uma matriz de seis pontos (representando um spline cardeal).  
  
-   Cria um caminho e adiciona as curvas spline cardeal fechada ao caminho (fechado do ponto de extremidade para o ponto de partida).  
  
-   Desenha o caminho para a tela.  
  
 Observe que uma tensão de 0,5 é usada.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem a curva.</param>
        <param name="tension">Um valor entre 0 e 1, que especifica o quanto a curva se dobra entre pontos, com 0 sendo a curva menor (com canto mais agudo) e 1 sendo a curva mais suave.</param>
        <summary>Adiciona uma curva fechada a esse caminho. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais. Se o primeiro ponto e o último ponto na `points` matriz não são o mesmo ponto, a curva é fechada por conectar-se esses dois pontos.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma curva de spline à figura atual. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem a curva.</param>
        <summary>Adiciona uma curva de spline à figura atual. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem a curva.</param>
        <summary>Adiciona uma curva de spline à figura atual. Uma curva de spline cardinal é usada porque a curva percorre cada um dos pontos da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem a curva.</param>
        <param name="tension">Um valor que especifica quanto a curva se dobra entre os pontos de controle. Valores maiores que 1 produzem resultados imprevisíveis.</param>
        <summary>Adiciona uma curva de spline à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem a curva.</param>
        <param name="tension">Um valor que especifica quanto a curva se dobra entre os pontos de controle. Valores maiores que 1 produzem resultados imprevisíveis.</param>
        <summary>Adiciona uma curva de spline à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem a curva.</param>
        <param name="offset">O índice do elemento na matriz <c>points</c> que é usada como o primeiro ponto da curva.</param>
        <param name="numberOfSegments">Um valor que especifica quanto a curva se dobra entre os pontos de controle. Valores maiores que 1 produzem resultados imprevisíveis.</param>
        <param name="tension">Um valor que especifica quanto a curva se dobra entre os pontos de controle. Valores maiores que 1 produzem resultados imprevisíveis.</param>
        <summary>Adiciona uma curva de spline à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
 A curva começa no ponto na matriz especificada pelo `offset` parâmetro e inclui o número de pontos (segmentos) especificado por `numberOfSegments`.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria uma matriz de quatro pontos (representando um spline cardeal).  
  
-   Cria um caminho e usando a matriz de pontos, adiciona a curva ao caminho.  
  
-   Desenha o caminho para a tela.  
  
 Observe que enquanto a matriz contém quatro pontos, há apenas três segmentos, que é o número especificado no terceiro argumento da chamada para <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem a curva.</param>
        <param name="offset">O índice do elemento na matriz <c>points</c> que é usada como o primeiro ponto da curva.</param>
        <param name="numberOfSegments">O número de segmentos usados para desenhar a curva. Um segmento pode ser pensado como uma linha conectando dois pontos.</param>
        <param name="tension">Um valor que especifica quanto a curva se dobra entre os pontos de controle. Valores maiores que 1 produzem resultados imprevisíveis.</param>
        <summary>Adiciona uma curva de spline à figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
 A curva começa no ponto na matriz especificada por `offset`e inclui o número de pontos (segmentos) especificado por `numberOfSegments`.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma elipse ao caminho atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo delimitador que define a elipse.</param>
        <summary>Adiciona uma elipse ao caminho atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
 Cria um retângulo que define uma elipse.  
  
 Cria um caminho e adiciona a elipse ao caminho.  
  
 Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo delimitador que define a elipse.</param>
        <summary>Adiciona uma elipse ao caminho atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse.</param>
        <summary>Adiciona uma elipse ao caminho atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse.</param>
        <summary>Adiciona uma elipse ao caminho atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta um segmento de linha para esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Um <see cref="T:System.Drawing.Point" /> que representa a posição inicial da linha.</param>
        <param name="pt2">Um <see cref="T:System.Drawing.Point" /> que representa o ponto de extremidade da linha.</param>
        <summary>Acrescenta um segmento de linha para esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método adiciona o segmento de linha definido por pontos especificados ao final deste <xref:System.Drawing.Drawing2D.GraphicsPath>. Se houver linhas anteriores ou curvas no <xref:System.Drawing.Drawing2D.GraphicsPath>, um segmento de linha é desenhado para conectar-se o último ponto no caminho até o primeiro ponto em que o novo segmento de linha.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Um <see cref="T:System.Drawing.PointF" /> que representa a posição inicial da linha.</param>
        <param name="pt2">Um <see cref="T:System.Drawing.PointF" /> que representa o ponto de extremidade da linha.</param>
        <summary>Acrescenta um segmento de linha para esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método adiciona o segmento de linha definido por pontos especificados ao final deste <xref:System.Drawing.Drawing2D.GraphicsPath>. Se houver linhas anteriores ou curvas no <xref:System.Drawing.Drawing2D.GraphicsPath>, um segmento de linha é desenhado para conectar-se o último ponto no caminho até o primeiro ponto em que o novo segmento de linha.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">A coordenada X do ponto de partida da linha.</param>
        <param name="y1">A coordenada y do ponto de partida da linha.</param>
        <param name="x2">A coordenada X do ponto de extremidade da linha.</param>
        <param name="y2">A coordenada y do ponto de extremidade da linha.</param>
        <summary>Acrescenta um segmento de linha para a figura atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método adiciona o segmento de linha definido por pontos especificados ao final da figura atual. Se houver linhas anteriores ou curvas no <xref:System.Drawing.Drawing2D.GraphicsPath>, um segmento de linha é desenhado para conectar-se o último ponto no caminho até o primeiro ponto em que o novo segmento de linha.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código cria um caminho, adiciona três linhas que formam um triângulo e, em seguida, desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">A coordenada X do ponto de partida da linha.</param>
        <param name="y1">A coordenada y do ponto de partida da linha.</param>
        <param name="x2">A coordenada X do ponto de extremidade da linha.</param>
        <param name="y2">A coordenada y do ponto de extremidade da linha.</param>
        <summary>Acrescenta um segmento de linha para esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método adiciona o segmento de linha definido por pontos especificados ao final deste <xref:System.Drawing.Drawing2D.GraphicsPath>. Se houver linhas anteriores ou curvas no <xref:System.Drawing.Drawing2D.GraphicsPath>, um segmento de linha é desenhado para conectar-se o último ponto no caminho até o primeiro ponto em que o novo segmento de linha.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta uma série de segmentos de linha conectados ao final deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que definem os segmentos de linha a serem adicionados.</param>
        <summary>Acrescenta uma série de segmentos de linha conectados ao final deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada para conectar o ponto de extremidade do segmento o ponto de partida da linha anterior. O `points` parâmetro especifica uma matriz de pontos de extremidade. Os dois primeiros especificam a primeira linha. Cada ponto adicional que especifica o ponto de extremidade de um segmento de linha cujo ponto de partida é o ponto de extremidade da linha anterior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria uma matriz de quatro pontos que descrevem um triângulo.  
  
-   Cria um caminho e adiciona o conjunto de linhas.  
  
-   Desenha o caminho para a tela.  
  
 Observe que cada linha após o primeiro ponto usa o ponto anterior como o ponto de partida e o novo ponto como o ponto de extremidade.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que definem os segmentos de linha a serem adicionados.</param>
        <summary>Acrescenta uma série de segmentos de linha conectados ao final deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver linhas anteriores ou curvas na figura, uma linha é adicionada para conectar o ponto de extremidade do segmento o ponto de partida da linha anterior. O `points` parâmetro especifica uma matriz de pontos de extremidade. Os dois primeiros especificam a primeira linha. Cada ponto adicional que especifica o ponto de extremidade de um segmento de linha cujo ponto de partida é o ponto de extremidade da linha anterior.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">O <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> a ser adicionado.</param>
        <param name="connect">Um valor booliano que especifica se a primeira figura no caminho adicionado faz parte da figura último nesse caminho. Um valor de <see langword="true" /> que especifica (se possível) que a primeira figura no caminho adicionado faz parte da última figura nesse caminho. Um valor de <see langword="false" /> que especifica que a primeira figura no caminho adicionado é separada da última figura nesse caminho.</param>
        <summary>Acrescenta o <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um de dois caminhos um triângulo direito lado-o e o outro um triângulo para baixo ao lado de backup.  
  
-   Adiciona o segundo caminho para o primeiro.  
  
-   Desenha o caminho resultante para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona a estrutura de tópicos de uma forma de pizza a esse caminho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="startAngle">O ângulo inicial da fatia da pizza, medido em graus no sentido horário do eixo X.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final da fatia da pizza, medido em graus no sentido horário de <c>startAngle</c>.</param>
        <summary>Adiciona a estrutura de tópicos de uma forma de pizza a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A forma de pizza é definida por uma descrição parcial de uma elipse e as duas linhas radiais que cruzam os pontos de extremidade da estrutura de tópicos parcial. A estrutura de tópicos parcial começa em `startAngle` (medido no sentido horário do eixo x) e termina no `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="startAngle">O ângulo inicial da fatia da pizza, medido em graus no sentido horário do eixo X.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final da fatia da pizza, medido em graus no sentido horário de <c>startAngle</c>.</param>
        <summary>Adiciona a estrutura de tópicos de uma forma de pizza a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A forma de pizza é definida por uma descrição parcial de uma elipse e as duas linhas radiais que cruzam os pontos de extremidade da estrutura de tópicos parcial. A estrutura de tópicos parcial começa em `startAngle` (medido no sentido horário do eixo x) e termina no `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código cria um caminho de gráficos, adiciona a forma de pizza e, em seguida, desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse com base na qual a pizza é desenhada.</param>
        <param name="startAngle">O ângulo inicial da fatia da pizza, medido em graus no sentido horário do eixo X.</param>
        <param name="sweepAngle">O ângulo entre <c>startAngle</c> e o final da fatia da pizza, medido em graus no sentido horário de <c>startAngle</c>.</param>
        <summary>Adiciona a estrutura de tópicos de uma forma de pizza a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A forma de pizza é definida por uma descrição parcial de uma elipse e as duas linhas radiais que cruzam os pontos de extremidade da estrutura de tópicos parcial. A estrutura de tópicos parcial começa em `startAngle` (medido no sentido horário do eixo x) e termina no `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um polígono a esse caminho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.Point" /> que define o polígono a ser adicionado.</param>
        <summary>Adiciona um polígono a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os pontos de `points` matriz especifique os vértices de um polígono. Se o primeiro ponto na matriz não é o mesmo que o último ponto, os dois pontos são conectados para fechar o polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria uma matriz de pontos que define um polígono.  
  
-   Cria um caminho e adiciona o polígono ao caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que define o polígono a ser adicionado.</param>
        <summary>Adiciona um polígono a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os pontos de `points` matriz especifique os vértices de um polígono. Se o primeiro ponto na matriz não é o mesmo que o último ponto, os dois pontos são conectados para fechar o polígono.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um retângulo a esse caminho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo a ser adicionado.</param>
        <summary>Adiciona um retângulo a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Cria um retângulo e adiciona o retângulo para o caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo a ser adicionado.</param>
        <summary>Adiciona um retângulo a esse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma série de retângulos a este caminho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.Rectangle" /> que representa os retângulos a serem adicionados.</param>
        <summary>Adiciona uma série de retângulos a este caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Cria uma matriz de retângulos e adiciona os retângulos ao caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.RectangleF" /> que representa os retângulos a serem adicionados.</param>
        <summary>Adiciona uma série de retângulos a este caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona uma cadeia de texto nesse caminho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> a ser adicionado.</param>
        <param name="family">Uma <see cref="T:System.Drawing.FontFamily" /> que representa o nome da fonte com a qual o teste é desenhado.</param>
        <param name="style">Um enumeração <see cref="T:System.Drawing.FontStyle" /> que representa as informações de estilo sobre o texto (negrito, itálico e assim por diante). Isso deve ser transmitido como um inteiro (consulte o código de exemplo mais à frente nesta seção).</param>
        <param name="emSize">A altura da caixa quadrada em que delimita o caractere.</param>
        <param name="origin">Um <see cref="T:System.Drawing.Point" /> que representa o ponto em que o texto começa.</param>
        <param name="format">Um <see cref="T:System.Drawing.StringFormat" /> que especifica as informações de formatação de texto, como o espaçamento entre linhas e o alinhamento.</param>
        <summary>Adiciona uma cadeia de texto nesse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Define os argumentos de cadeia de caracteres e fonte.  
  
-   Adiciona a cadeia de caracteres para o caminho.  
  
-   Desenha a cadeia de caracteres para a tela.  
  
 Há dois aspectos importantes a ser indicadas. Primeiro, observe que o `fontStyle` argumento é convertido como um inteiro. O <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> método requer isso assim que dois ou mais <xref:System.Drawing.FontStyle> membros podem ser combinados para criar o estilo de fonte desejado (nesse caso, <xref:System.Drawing.FontStyle.Italic> e <xref:System.Drawing.FontStyle.Underline>). Em segundo lugar, observe que o <xref:System.Drawing.Graphics.FillPath%2A> método é usado em vez de <xref:System.Drawing.Graphics.DrawPath%2A> método. Se <xref:System.Drawing.Graphics.FillPath%2A> for usado, sólido texto é renderizado, enquanto se <xref:System.Drawing.Graphics.DrawPath%2A> for usado, o texto será um estilo de estrutura de tópicos.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> a ser adicionado.</param>
        <param name="family">Uma <see cref="T:System.Drawing.FontFamily" /> que representa o nome da fonte com a qual o teste é desenhado.</param>
        <param name="style">Um enumeração <see cref="T:System.Drawing.FontStyle" /> que representa as informações de estilo sobre o texto (negrito, itálico e assim por diante). Isso deve ser transmitido como um inteiro (consulte o código de exemplo mais à frente nesta seção).</param>
        <param name="emSize">A altura da caixa quadrada em que delimita o caractere.</param>
        <param name="origin">Um <see cref="T:System.Drawing.PointF" /> que representa o ponto em que o texto começa.</param>
        <param name="format">Um <see cref="T:System.Drawing.StringFormat" /> que especifica as informações de formatação de texto, como o espaçamento entre linhas e o alinhamento.</param>
        <summary>Adiciona uma cadeia de texto nesse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> a ser adicionado.</param>
        <param name="family">Uma <see cref="T:System.Drawing.FontFamily" /> que representa o nome da fonte com a qual o teste é desenhado.</param>
        <param name="style">Um enumeração <see cref="T:System.Drawing.FontStyle" /> que representa as informações de estilo sobre o texto (negrito, itálico e assim por diante). Isso deve ser transmitido como um inteiro (consulte o código de exemplo mais à frente nesta seção).</param>
        <param name="emSize">A altura da caixa quadrada em que delimita o caractere.</param>
        <param name="layoutRect">Um <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo que limita o texto.</param>
        <param name="format">Um <see cref="T:System.Drawing.StringFormat" /> que especifica as informações de formatação de texto, como o espaçamento entre linhas e o alinhamento.</param>
        <summary>Adiciona uma cadeia de texto nesse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> a ser adicionado.</param>
        <param name="family">Uma <see cref="T:System.Drawing.FontFamily" /> que representa o nome da fonte com a qual o teste é desenhado.</param>
        <param name="style">Um enumeração <see cref="T:System.Drawing.FontStyle" /> que representa as informações de estilo sobre o texto (negrito, itálico e assim por diante). Isso deve ser transmitido como um inteiro (consulte o código de exemplo mais à frente nesta seção).</param>
        <param name="emSize">A altura da caixa quadrada em que delimita o caractere.</param>
        <param name="layoutRect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo que limita o texto.</param>
        <param name="format">Um <see cref="T:System.Drawing.StringFormat" /> que especifica as informações de formatação de texto, como o espaçamento entre linhas e o alinhamento.</param>
        <summary>Adiciona uma cadeia de texto nesse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa todos os marcadores desse caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> método para criar um marcador no local atual em um <xref:System.Drawing.Drawing2D.GraphicsPath>. Use o <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> método para iterar os marcadores existentes em um caminho.  
  
 Marcadores são usados para separar grupos de subcaminhos. Um ou mais subcaminhos podem estar contidos entre dois marcadores.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona vários objetos ao caminho.  
  
-   Adiciona marcadores para o caminho.  
  
-   Limpa todos os marcadores do caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia exata desse caminho.</summary>
        <returns>O <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que esse método cria, convertido como um objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona vários valores para o caminho.  
  
-   Desenha o caminho para a tela.  
  
-   Clona uma cópia desse caminho.  
  
-   Desenha o novo caminho para a tela.  
  
 Observe que a chamada a <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> método deve ser convertido como um <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha todos os valores nesse caminho e inicia uma nova figura. Ele fecha cada figura aberta conectando uma linha de seu ponto de extremidade a seu ponto inicial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona várias figuras abertas para o caminho.  
  
-   Fecha todos os números no caminho.  
  
-   Desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha a figura atual e inicia uma nova figura. Se a figura atual contiver uma sequência de linhas e curvas conectadas, o método fechará o loop conectando uma linha do ponto de extremidade ao ponto de partida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código cria um triângulo, criando um novo caminho, iniciando uma figura, adicionando linhas de interseção de dois a figura e fechando a figura para formar um triângulo. Em seguida, o caminho é desenhado na tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados por este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> permite que os recursos usados por este <xref:System.Drawing.Drawing2D.GraphicsPath> sejam realocadas para outras finalidades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como os interiores das formas neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> são preenchidos.</summary>
        <value>Uma enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que especifica como os interiores das formas neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> são preenchidos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que um objeto tente liberar recursos e executar outras operações de limpeza antes de ser recuperado pela coleta de lixo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte cada curva neste caminho em uma sequência de segmentos de linha conectados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte cada curva neste caminho em uma sequência de segmentos de linha conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> pelo qual transformar esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> antes de mesclar.</param>
        <summary>Aplica a transformação especificada e então converte cada curva neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> em uma sequência de segmentos de linha conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> pelo qual transformar esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> antes de mesclar.</param>
        <param name="flatness">Especifica o erro máximo permitido entre a curva e sua aproximação plana. Um valor de 0,25 é o padrão. Reduzir o valor de planeza aumentará o número de segmentos de linha na aproximação.</param>
        <summary>Converte cada curva neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> em uma sequência de segmentos de linha conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho de gráfico e uma matriz de tradução.  
  
-   Adiciona uma curva para o caminho usando quatro pontos.  
  
-   Desenha o caminho (curva) para a tela, usando uma caneta preta.  
  
-   Desloca a curva para 10 pixels e mescla a ele.  
  
-   Desenha a curva à tela usando uma caneta vermelha.  
  
 Observe que a curva vermelha tem nivelados linhas que conectam os pontos.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um retângulo que circunda esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um retângulo que circunda esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Um <see cref="T:System.Drawing.RectangleF" /> que representa um retângulo que circunda esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do retângulo delimitador retornado é influenciado pelo tipo de delimitada, a largura de caneta e o limite de esquadria caneta e, portanto, gera um "ajuste flexível" para o caminho associado. A fórmula aproximada é: o retângulo delimitador inicial é inflado pela largura de caneta e esse resultado é multiplicado pelo limite de esquadria, além de algumas margem adicional para permitir tampas.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho de gráficos.  
  
-   Adiciona uma elipse (círculo) a ele e desenha na tela.  
  
-   Recupera o retângulo delimitador para o círculo com uma chamada para <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> e desenha um retângulo para a tela.  
  
-   Cria um segundo caminho de gráficos.  
  
-   Adiciona um círculo e amplia o caminho para uma largura de 10.  
  
-   Desenha o caminho para a tela.  
  
-   Recupera o retângulo delimitador para o segundo círculo.  
  
-   Desenha o retângulo delimitador para a tela.  
  
-   Exibe o tamanho do retângulo em uma caixa de diálogo.  
  
 Observe que o retângulo delimitador à direita (para a conta para a extra largura da linha).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">O <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação a ser aplicada a esse caminho antes do retângulo delimitador ser calculado. Esse caminho não é transformado permanentemente; a transformação é usada somente durante o processo de cálculo do retângulo delimitador.</param>
        <summary>Retorna um retângulo que delimita este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando este caminho é transformado pelo <see cref="T:System.Drawing.Drawing2D.Matrix" /> especificado.</summary>
        <returns>Um <see cref="T:System.Drawing.RectangleF" /> que representa um retângulo que circunda esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do retângulo delimitador retornado é influenciado pelo tipo de delimitada, a largura de caneta e o limite de esquadria caneta e, portanto, gera um "ajuste flexível" para o caminho associado. A fórmula aproximada é: o retângulo delimitador inicial é inflado pela largura de caneta e esse resultado é multiplicado pelo limite de esquadria, além de algumas margem adicional para permitir tampas.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">O <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação a ser aplicada a esse caminho antes do retângulo delimitador ser calculado. Esse caminho não é transformado permanentemente; a transformação é usada somente durante o processo de cálculo do retângulo delimitador.</param>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> com a qual desenhar o <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Retorna um retângulo que delimita este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando o caminho atual é transformado pelo <see cref="T:System.Drawing.Drawing2D.Matrix" /> especificado e desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
        <returns>Um <see cref="T:System.Drawing.RectangleF" /> que representa um retângulo que circunda esse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do retângulo delimitador retornado é influenciado pelo tipo de delimitada, a largura de caneta e o limite de esquadria caneta e, portanto, gera um "ajuste flexível" para o caminho associado. A fórmula aproximada é: o retângulo delimitador inicial é inflado pela largura de caneta e esse resultado é multiplicado pelo limite de esquadria, além de algumas margem adicional para permitir tampas.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o último ponto na matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Um <see cref="T:System.Drawing.PointF" /> que representa o último ponto neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código cria um caminho, adiciona uma linha para o caminho e, em seguida, obtém o último ponto no caminho.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Um <see cref="T:System.Drawing.Point" /> que especifica o local a testar.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Um <see cref="T:System.Drawing.PointF" /> que especifica o local a testar.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Um <see cref="T:System.Drawing.Point" /> que especifica o local a testar.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada e usando o <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado. As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação de `graphics` temporariamente é aplicada antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Um <see cref="T:System.Drawing.PointF" /> que especifica o local a testar.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada e usando o <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido em (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado. As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação de `graphics` temporariamente é aplicada antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada e usando o <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido no contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado. As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação de `graphics` temporariamente é aplicada antes de testar para visibilidade.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, um <xref:System.Windows.Forms.Form.OnPaint%2A> eventos. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona um retângulo ao caminho.  
  
-   Cria uma caneta ampla e amplia o caminho com esse caneta (para tornar o exemplo mais claro),  
  
-   Testes de um ponto (100, 50) para ver se ela está dentro de (em) um das bordas do retângulo chamando <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 O resultado é mostrado na caixa de mensagem (nesse caso, true). Em outras palavras, a borda é renderizada através desse ponto.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="pen">O <see cref="T:System.Drawing.Pen" /> a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido dentro de (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada e usando o <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Este método retorna <see langword="true" /> se o ponto especificado está contido em (sob) o contorno deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> quando desenhado com a <see cref="T:System.Drawing.Pen" /> especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método verifica se a estrutura de tópicos de um determinado caminho será renderizada visível no ponto especificado. As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação do `graphics` parâmetro temporariamente é aplicado antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Um <see cref="T:System.Drawing.Point" /> que representa o ponto a testar.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">Um <see cref="T:System.Drawing.PointF" /> que representa o ponto a testar.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Um <see cref="T:System.Drawing.Point" /> que representa o ponto a testar.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação do `graphics` parâmetro temporariamente é aplicado antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Um <see cref="T:System.Drawing.PointF" /> que representa o ponto a testar.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido nisso; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação do `graphics` parâmetro temporariamente é aplicado antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, usando o <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação de `graphics` temporariamente é aplicada antes de testar para visibilidade.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho e adiciona uma elipse ao caminho.  
  
-   Testa se o ponto especificado está contido dentro do caminho.  
  
-   Exibe o resultado em uma caixa de diálogo.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado.</param>
        <param name="y">A coordenada Y do ponto a ser testado.</param>
        <param name="graphics">O <see cref="T:System.Drawing.Graphics" /> do qual a visibilidade será testada.</param>
        <summary>Indica se o ponto especificado está contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, na região de recorte visível do <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <returns>Esse método retornará <see langword="true" /> se o ponto especificado estiver contido neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As coordenadas do ponto a ser testada são fornecidas nas coordenadas do mundo. A matriz de transformação do `graphics` parâmetro temporariamente é aplicado antes de testar para visibilidade.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Drawing.Drawing2D.PathData" /> que encapsula matrizes de pontos (<paramref name="points" />) e tipos (<paramref name="types" />) para este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>Um <see cref="T:System.Drawing.Drawing2D.PathData" /> que encapsula matrizes para os pontos e os tipos deste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os pontos no caminho.</summary>
        <value>Uma matriz de objetos <see cref="T:System.Drawing.PointF" /> que representam o caminho.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os tipos dos pontos correspondentes na matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />.</summary>
        <value>Uma matriz de bytes que especifica os tipos dos pontos correspondentes no caminho.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz de bytes retornado pelo <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> propriedade especifica sinalizadores para os pontos de dados e tipos de pontos em um caminho. Para cada ponto, bits de 0 a 2 indicam o tipo de um ponto e bits de 3 a 7 manter um conjunto de sinalizadores que especificam os atributos de um ponto. A tabela a seguir mostra os valores possíveis e seus significados.  
  
|Valor|Significado|  
|-----------|-------------|  
|0|Indica que o ponto de início de uma figura.|  
|1|Indica que o ponto é um dos dois pontos de extremidade de uma linha.|  
|3|Indica que o ponto é um ponto de extremidade ou ponto de controle de uma spline de Bézier cúbica.|  
|0x7|Máscaras de todos os bits, exceto os três bits de ordem inferior que indicam o tipo de ponto.|  
|0x20|Especifica que o ponto de um marcador.|  
|0x80|Especifica que o ponto é o último ponto em um subcaminho fechado (Figura).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos na <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> ou na matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />.</summary>
        <value>Um inteiro que especifica o número de elementos no <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> ou <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> matriz.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esvazia as matrizes <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> e <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> e define o <see cref="T:System.Drawing.Drawing2D.FillMode" /> como <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona várias primitivos a ele.  
  
-   Desenha a matriz de pontos do caminho para a tela.  
  
-   Redefine o caminho para um estado vazio.  
  
-   Adquire novamente a matriz de pontos (se houver).  
  
-   Desenha a matriz para a tela.  
  
 Observe que ele encontrar nenhuma matriz após a chamada de redefinição.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverte a ordem dos pontos na matriz <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> desse <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho e adiciona várias primitivos para o caminho.  
  
-   Desenha a matriz de pontos do caminho para a tela.  
  
-   Desenha a matriz de pontos revertida para a tela.  
  
 Observe que a segunda listagem de pontos na ordem inversa da primeira.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define um marcador neste <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um marcador no caminho que pode ser usado para separar seções do caminho. Você pode usar o <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> métodos para iterar os marcadores no caminho.  
  
 Marcadores são usados para separar grupos de subcaminhos. Subcaminhos de um ou mais podem estar contidos entre dois marcadores no caminho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código cria um caminho e adiciona várias primitivos para o caminho separado por marcadores e desenha o caminho para a tela.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia uma nova figura sem fechar a figura atual. Todos os pontos subsequentes adicionados ao caminho são adicionados a essa nova figura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve manter os pontos originais se forem necessários. Os pontos originais são convertidos em pontos de controle de Bézier cúbicos internamente, portanto, não há nenhum mecanismo para retornar os pontos originais.  
  
 Esse método inicia um subcaminho de novo no caminho. Subcaminhos permitem que você separar um caminho em seções e usar o <xref:System.Drawing.Drawing2D.GraphicsPathIterator> classe para iterar por meio de subcaminhos.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho.  
  
-   Adiciona dois conjuntos de valores. O primeiro conjunto de figuras combina quatro primitivas em duas figuras. O segundo conjunto de figuras combina as mesmas primitivas de quatro (exceto que eles são deslocados no eixo y) em três números.  
  
-   Desenha todos os valores para a tela.  
  
 Observe a diferença de aparência entre os dois conjuntos de valores.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que representa a transformação a ser aplicada.</param>
        <summary>Aplica a uma matriz de transformação a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A transformação pode dimensionar, traduzir, girar ou inclinar o <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho e adiciona uma elipse ao caminho.  
  
-   Desenha o caminho para a tela.  
  
-   Cria uma matriz de transformação para converter as 100 unidades de caminho na direção do eixo x.  
  
-   Desenha o caminho transformado na tela.  
  
 Observe que a elipse original é desenhada em preto e transformado elipse é desenhada em vermelho.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica uma transformação de distorção, definida por um retângulo e um paralelogramo, a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo no qual o retângulo definido por <c>srcRect</c> é transformado. A matriz pode conter três ou quatro elementos. Se a matriz contiver três elementos, o canto inferior direito do paralelogramo será inferido pelos três primeiros pontos.</param>
        <param name="srcRect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo que é transformado no paralelogramo definido por <c>destPoints</c>.</param>
        <summary>Aplica uma transformação de distorção, definida por um retângulo e um paralelogramo, a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo no qual o retângulo definido por <c>srcRect</c> é transformado. A matriz pode conter três ou quatro elementos. Se a matriz contiver três elementos, o canto inferior direito do paralelogramo será inferido pelos três primeiros pontos.</param>
        <param name="srcRect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo que é transformado no paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação geométrica a ser aplicada ao caminho.</param>
        <summary>Aplica uma transformação de distorção, definida por um retângulo e um paralelogramo, a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que define um paralelogramo no qual o retângulo definido por <c>srcRect</c> é transformado. A matriz pode conter três ou quatro elementos. Se a matriz contiver três elementos, o canto inferior direito do paralelogramo será inferido pelos três primeiros pontos.</param>
        <param name="srcRect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo que é transformado no paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação geométrica a ser aplicada ao caminho.</param>
        <param name="warpMode">Uma enumeração <see cref="T:System.Drawing.Drawing2D.WarpMode" /> que especifica se essa operação de distorção usa o modo bilinear ou de perspectiva.</param>
        <summary>Aplica uma transformação de distorção, definida por um retângulo e um paralelogramo, a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo no qual o retângulo definido por <c>srcRect</c> é transformado. A matriz pode conter três ou quatro elementos. Se a matriz contiver três elementos, o canto inferior direito do paralelogramo será inferido pelos três primeiros pontos.</param>
        <param name="srcRect">Um <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo que é transformado no paralelogramo definido por <c>destPoints</c>.</param>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação geométrica a ser aplicada ao caminho.</param>
        <param name="warpMode">Uma enumeração <see cref="T:System.Drawing.Drawing2D.WarpMode" /> que especifica se essa operação de distorção usa o modo bilinear ou de perspectiva.</param>
        <param name="flatness">Um valor de 0 a 1 que especifica a planeza do caminho resultante. Para obter mais informações, consulte os métodos <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />.</param>
        <summary>Aplica uma transformação de distorção, definida por um retângulo e um paralelogramo, a este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho e adiciona um retângulo ao caminho.  
  
-   Desenha um retângulo para a tela em preto.  
  
-   Deforma o caminho com uma distorção de perspectiva.  
  
-   Desenha o retângulo distorcido (caminho) para a tela em vermelho.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Substitui este caminho por curvas que circunscrevem a área preenchida quando esse caminho é desenhado pela caneta especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">Um <see cref="T:System.Drawing.Pen" /> que especifica a largura entre a estrutura de tópicos original do caminho e a nova estrutura de tópicos criada por esse método.</param>
        <summary>Adiciona um contorno adicional ao caminho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma estrutura de tópicos em torno de linhas original na <xref:System.Drawing.Drawing2D.GraphicsPath>, com uma distância entre as linhas existentes e os novos tópicos igual a que a largura do <xref:System.Drawing.Pen> usado na chamada para <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Se você deseja preencher o espaço entre as linhas que você deve usar o <xref:System.Drawing.Graphics.FillPath%2A> em vez de <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">Um <see cref="T:System.Drawing.Pen" /> que especifica a largura entre a estrutura de tópicos original do caminho e a nova estrutura de tópicos criada por esse método.</param>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação a ser aplicada ao caminho antes da ampliação.</param>
        <summary>Adiciona um contorno adicional ao <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma estrutura de tópicos em torno de linhas original na <xref:System.Drawing.Drawing2D.GraphicsPath>, com uma distância entre as linhas existentes e os novos tópicos igual a que a largura do <xref:System.Drawing.Pen> usado na chamada para <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Se você deseja preencher o espaço entre as linhas que você deve usar o <xref:System.Drawing.Graphics.FillPath%2A> em vez de <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Para ver um exemplo, consulte <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Um <see cref="T:System.Drawing.Pen" /> que especifica a largura entre a estrutura de tópicos original do caminho e a nova estrutura de tópicos criada por esse método.</param>
        <param name="matrix">Um <see cref="T:System.Drawing.Drawing2D.Matrix" /> que especifica uma transformação a ser aplicada ao caminho antes da ampliação.</param>
        <param name="flatness">Um valor que especifica a planeza das curvas.</param>
        <summary>Substitui este <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> por curvas que circunscrevem a área preenchida quando esse caminho é desenhado pela caneta especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma estrutura de tópicos em torno de linhas original na <xref:System.Drawing.Drawing2D.GraphicsPath>, com uma distância entre as linhas existentes e os novos tópicos igual a que a largura do <xref:System.Drawing.Pen> usado na chamada para <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Se você deseja preencher o espaço entre as linhas que você deve usar o <xref:System.Drawing.Graphics.FillPath%2A> em vez de <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, uma <xref:System.Windows.Forms.Form.OnPaint%2A> objeto de evento. O código executa as seguintes ações:  
  
-   Cria um caminho e adiciona duas elipses no caminho.  
  
-   Desenha o caminho em preto.  
  
-   Amplia o caminho.  
  
-   Desenha o caminho em vermelho.  
  
 Observe que o processamento de segundo usa <xref:System.Drawing.Graphics.FillPath%2A> em vez de <xref:System.Drawing.Graphics.DrawPath%2A>, e, portanto, a Figura renderizada tem a estrutura de tópicos preenchida.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>