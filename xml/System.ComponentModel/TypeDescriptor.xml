<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="402b90676782f23b4720487e8f9cc3febcd32c4e" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038093" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptor sealed" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece informações sobre as características de um componente, como atributos, propriedades e eventos. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework fornece duas maneiras de acessar os metadados em um tipo: a reflexão API fornecida a <xref:System.Reflection?displayProperty=nameWithType> namespace e o <xref:System.ComponentModel.TypeDescriptor> classe. Reflexão é um mecanismo geral disponível a todos os tipos porque sua base é estabelecida a <xref:System.Object.GetType%2A> método da raiz <xref:System.Object> classe. As informações que ele retorna para um tipo não são extensíveis, em que ele não pode ser modificado após a compilação do tipo de destino. Para obter mais informações, consulte os tópicos [reflexão](~/docs/framework/reflection-and-codedom/reflection.md).  
  
 Por outro lado, <xref:System.ComponentModel.TypeDescriptor> é um mecanismo de inspeção extensível para componentes: as classes que implementam o <xref:System.ComponentModel.IComponent> interface. Ao contrário de reflexão, ele não inspeciona para métodos. <xref:System.ComponentModel.TypeDescriptor> pode ser estendido dinamicamente por vários serviços disponíveis por meio do componente de destino <xref:System.ComponentModel.Component.Site%2A>. A tabela a seguir mostra esses serviços.  
  
|Nome do serviço|Descrição|  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|Permite que a outra classe, como <xref:System.Windows.Forms.ToolTip>, para fornecer propriedades adicionais para um componente.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Permite que outro objeto para modificar os metadados padrão que é exposto por um componente.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|Permite que uma classe completamente e dinamicamente especificar seus próprios metadados, substituindo o mecanismo de inspeção de padrão de <xref:System.ComponentModel.TypeDescriptor>.|  
  
 A extensibilidade fornecida pelo <xref:System.ComponentModel.TypeDescriptor> permite a representação de tempo de design de um componente seja diferente da sua representação de tempo de execução real, o que torna <xref:System.ComponentModel.TypeDescriptor> úteis para a criação da infraestrutura de tempo de design.  
  
 Todos os métodos no <xref:System.ComponentModel.TypeDescriptor> são `static`. Não é possível criar uma instância dessa classe, e essa classe não pode ser herdada.  
  
 Você pode definir a propriedade e evento valores de duas maneiras diferentes: especificá-los na classe de componente ou alterá-los em tempo de design. Porque você pode definir esses valores de duas maneiras, os métodos sobrecarregados de <xref:System.ComponentModel.TypeDescriptor> levar dois tipos diferentes de parâmetros: um tipo de classe ou uma instância do objeto.  
  
 Quando você deseja acessar <xref:System.ComponentModel.TypeDescriptor> informações e você tiver uma instância do objeto, use o método que chama um componente. Use o método que chama para o tipo de classe somente quando você não tem uma instância do objeto.  
  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se esse for o caso, o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método deve ser chamado para atualizar o cache.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.EventDescriptor" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.ComponentModel.IComponent" />
    <altmember cref="T:System.ComponentModel.ISite" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona atributos de nível de classe ao componente de destino.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAttributes (instance As Object, ParamArray attributes As Attribute()) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(System::Object ^ instance, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <param name="attributes">Uma matriz de objetos <see cref="T:System.Attribute" /> a serem adicionados à classe do componente.</param>
        <summary>Adiciona os atributos de nível de classe à instância de componente de destino.</summary>
        <returns>O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recém-criado que foi usado para adicionar os atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29> método adiciona os atributos de nível de classe para a instância especificada de um componente. Como esse é um requisito comum de aplicativos usando a Visual Studio Windows Forms Designer e a janela Propriedades, esse método fornece um atalho, criando um provedor de descrição de tipo que mescla os atributos fornecidos com os atributos que já existe na classe. O valor de retorno é o provedor de descrição de tipo que foi usado para adicionar os atributos. Este provedor posteriormente pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método quando os atributos adicionados não são mais necessários.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz de objetos <see cref="T:System.Attribute" /> a serem adicionados à classe do componente.</param>
        <summary>Adiciona atributos de nível de classe ao tipo de componente de destino.</summary>
        <returns>O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recém-criado que foi usado para adicionar os atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29> método adiciona os atributos de nível de classe para o tipo de um componente especificado. Como esse é um requisito comum de aplicativos usando a Visual Studio Windows Forms Designer e a janela Propriedades, esse método fornece um atalho, criando um provedor de descrição de tipo que mescla os atributos fornecidos com os atributos que já existe na classe. O valor de retorno é o provedor de descrição de tipo que foi usado para adicionar os atributos. Este provedor posteriormente pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método quando os atributos adicionados não são mais necessários.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddEditorTable (editorBaseType As Type, table As Hashtable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddEditorTable(Type ^ editorBaseType, System::Collections::Hashtable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">O tipo base do editor para o qual adicionar a tabela de editor. Se já existe uma tabela para este tipo, esse método não fará nada.</param>
        <param name="table">O <see cref="T:System.Collections.Hashtable" /> a ser adicionado.</param>
        <summary>Adiciona uma tabela de editor para o tipo base do editor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A> método adiciona uma tabela de editor para o tipo base do editor especificado. Normalmente, os editores são especificados como metadados em um componente. No entanto, se nenhum metadado editor solicitado base de tipo pode ser encontrado no componente, associado <xref:System.ComponentModel.TypeDescriptor> irá procurar uma tabela de editor para o tipo de editor, se pode ser encontrado. Após a adição de uma tabela de editor para um descritor de tipo, ele não pode ser removido e pertence ao descritor de tipo. O descritor de tipo livremente pode fazer modificações nesta tabela.  
  
 O formato de uma tabela de editor usa tipos de dados como chaves e editores como valores. A parte do valor de uma entrada na tabela representa uma instância do editor. Ele pode ter um dos três valores. Se ele contém uma cadeia de caracteres, o descritor de tipo assumirá que este é um nome totalmente qualificado de um tipo e, em seguida, carregar o tipo do objeto. Se ele contém um tipo, uma instância desse tipo será criada para obter um editor. Por fim, a parte de valor pode conter uma instância do editor real. Se o descritor de tipo resolve um editor para uma instância, ele armazena a instância de volta na tabela para uso futuro.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um provedor de descrição de tipo à lista de provedores deste descritor de tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo para uma única instância de um componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método adiciona um provedor de descrição de tipo que fornece informações de tipo para uma única instância de um componente. Se um provedor é adicionado por esse método, o provedor <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método não será chamado porque a instância já existe.  
  
 Esse método não mantém uma referência de disco rígida para o componente, para que ela não impede que o componente finalizando.  
  
 É possível adicionar vários provedores de descrição de tipo para o mesmo tipo ou objeto. Se isso ocorrer, o primeiro tipo descrição provedor encontrado que fornece informações de tipo será usado exclusivamente. Como provedores de informações de tipo são armazenadas em uma pilha, o último provedor adicionado será o primeiro deles consultada. Esse comportamento permite que o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> e <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> provedor de descrição de tipos de métodos a serem usados para enviar por push e pop conforme necessário para cenários específicos.  
  
 Se for bem-sucedida, este método chama o <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29> método sobre o `instance` parâmetro.  
  
> [!NOTE]
>  As duas versões do método produzem resultados com escopos diferentes. O <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que utiliza um <xref:System.Object> parâmetro afeta somente uma instância única do componente especificado. Por outro lado, a outra sobrecarga, que usa um <xref:System.Type> parâmetro afeta todas as instâncias do componente descrita por tipo.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma classe de componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método adiciona um provedor de descrição de tipo que fornece informações de tipo para a classe especificada, as classes derivadas e todas as instâncias desses tipos.  
  
> [!NOTE]
>  O `type` parâmetro pode ser qualquer tipo, incluindo uma interface. Por exemplo, para fornecer informações de instância para todos os componentes e tipo personalizado, você especificaria `typeof(IComponent)`. Passando `typeof(object)` chamará o provedor para fornecer informações de tipo para todos os tipos.  
  
 Esse método não manter uma referência de disco rígida para qualquer objeto, para que ela não impede que objetos finalizando.  
  
 É possível adicionar vários provedores de descrição de tipo para o mesmo tipo ou objeto. Se isso ocorrer, o primeiro tipo descrição provedor encontrado que fornece informações de tipo será usado exclusivamente. Como provedores de informações de tipo são armazenadas em uma pilha, o último provedor adicionado será o primeiro deles consultada. Esse comportamento permite que o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> e <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> provedor de descrição de tipos de métodos a serem usados para enviar por push e pop conforme necessário para cenários específicos.  
  
 Se for bem-sucedida, este método chama o <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29> método sobre o `type` parâmetro.  
  
> [!NOTE]
>  As duas versões do método produzem resultados com escopos diferentes. O <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que utiliza um <xref:System.Object> parâmetro afeta somente uma instância única do componente especificado. Por outro lado, a outra sobrecarga, que usa um <xref:System.Type> parâmetro afeta todas as instâncias do componente descrita por tipo.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um provedor de descrição de tipo à lista de provedores deste descritor de tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo para uma única instância de um componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para a instância especificada se seu tipo também é parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define o <paramref name="instance" /> tipo do parâmetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser adicionado.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Adiciona um provedor de descrição de tipo de uma classe de componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para o tipo especificado se também for parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ComNativeDescriptorHandler As IComNativeDescriptorHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ComponentModel::IComNativeDescriptorHandler ^ ComNativeDescriptorHandler { System::ComponentModel::IComNativeDescriptorHandler ^ get(); void set(System::ComponentModel::IComNativeDescriptorHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o provedor para as informações de tipo do COM (Component Object Model) do componente de destino.</summary>
        <value>Um <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> que representa o provedor de informações COM tipo de instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A> propriedade e o <xref:System.ComponentModel.IComNativeDescriptorHandler> interface está obsoleta. Para obter mais informações, consulte a propriedade <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComObjectType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ ComObjectType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do objeto COM (Component Object Model) representado pelo componente de destino.</summary>
        <value>O <see cref="T:System.Type" /> do objeto COM representado por esse componente, ou <see langword="null" /> para objetos COM não.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriedade retorna um tipo que pode ser passado para o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método para definir um provedor de descrição de tipo para tipos COM.  
  
 O <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propriedade e outros membros dessa classe substituem a funcionalidade de obsoleto <xref:System.ComponentModel.IComNativeDescriptorHandler> interface. Para implementar uma camada de mapeamento entre um objeto COM e <xref:System.ComponentModel.TypeDescriptor>, adicione um <xref:System.ComponentModel.TypeDescriptionProvider> para lidar com tipo <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O <see cref="T:System.Object" /> primário.</param>
        <param name="secondary">O <see cref="T:System.Object" /> secundário.</param>
        <summary>Cria uma associação primária-secundária entre dois objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método cria uma associação entre um principal e um objeto secundário. Quando uma associação é criada, um designer ou outro mecanismo de filtragem pode adicionar propriedades roteiam para qualquer objeto no conjunto de propriedades do objeto principal. Quando é feita uma chamada de propriedade do objeto principal, o <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> método será chamado para resolver a instância do objeto real que está relacionada ao seu parâmetro de tipo.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não impede que qualquer objeto que está sendo finalizado e recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> é igual a <paramref name="secondary" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDesigner (component As IComponent, designerBaseType As Type) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, Type ^ designerBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">Um <see cref="T:System.ComponentModel.IComponent" /> que especifica o componente a ser associado com o designer.</param>
        <param name="designerBaseType">Um <see cref="T:System.Type" /> que representa o tipo de designer a ser criado.</param>
        <summary>Cria uma instância do designer associada ao componente especificado e do tipo de designer especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.Design.IDesigner" /> que é uma instância do designer para o componente ou <see langword="null" /> se nenhum designer puder ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método não é possível localizar um válido <xref:System.ComponentModel.DesignerAttribute>, ele procura a hierarquia de classe para um designer. Se ele não é possível localizar um designer na hierarquia de classe, ele retorna `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo descritor de evento que é idêntico a um descritor de eventos existente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvent (componentType As Type, oldEventDescriptor As EventDescriptor, ParamArray attributes As Attribute()) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::ComponentModel::EventDescriptor ^ oldEventDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O tipo do componente para o qual criar o novo evento.</param>
        <param name="oldEventDescriptor">As informações de evento existentes.</param>
        <param name="attributes">Os novos atributos.</param>
        <summary>Cria um novo descritor de evento que é idêntico a um descritor de eventos existente, ao passar pelo <see cref="T:System.ComponentModel.EventDescriptor" /> existente.</summary>
        <returns>Um novo <see cref="T:System.ComponentModel.EventDescriptor" /> que mesclou os atributos de metadados especificados com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O tipo do componente no qual o evento reside.</param>
        <param name="name">O nome do evento.</param>
        <param name="type">O tipo do delegado que manipula o evento.</param>
        <param name="attributes">Os atributos desse evento.</param>
        <summary>Cria um novo descritor de evento que é idêntico a um descritor de evento existente através da geração dinâmica de informações de descritor de um evento específico em um tipo.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> que está associado a um tipo.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">O provedor de serviços que fornece um serviço <see cref="T:System.ComponentModel.TypeDescriptionProvider" />. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="objectType">O <see cref="T:System.Type" /> do objeto a ser criado.</param>
        <param name="argTypes">Uma matriz opcional de tipos de parâmetro a serem passados para o construtor do objeto. Esse parâmetro pode ser <see langword="null" /> ou uma matriz de tamanho zero.</param>
        <param name="args">Uma matriz opcional de valores de parâmetro a serem passados para o construtor do objeto. Se não for <see langword="null" />, o número de elementos deverá ser o mesmo que <c>argTypes</c>.</param>
        <summary>Cria um objeto que pode ser substituído em outro tipo de dados.</summary>
        <returns>Uma instância do tipo de dados substituto se um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método irá procurar uma <xref:System.ComponentModel.TypeDescriptionProvider> associado especificado `objectType` tipo de dados. Esse método primeiro tenta obter um provedor de descrição de tipo do `provider` parâmetro. Se isso falhar, ele procura suas próprias tabelas internas por um provedor (essas entradas foram criadas por meio de chamadas anteriores para <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>). Se ele encontrar um provedor, esse método delegará a chamada de criação para o objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> é <see langword="null" /> ou <paramref name="args" /> é <see langword="null" /> quando <paramref name="argTypes" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> e <paramref name="args" /> têm quantidades diferentes de elementos.</exception>
        <block subset="none" type="overrides">
          <para>Se a classe derivada não fornecer uma instância de substituição, esse método deve chamar a implementação base.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo descritor de propriedade para uma propriedade existente de um componente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProperty (componentType As Type, oldPropertyDescriptor As PropertyDescriptor, ParamArray attributes As Attribute()) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::ComponentModel::PropertyDescriptor ^ oldPropertyDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente do qual a propriedade é um membro.</param>
        <param name="oldPropertyDescriptor">O descritor de propriedade existente.</param>
        <param name="attributes">Os novos atributos desta propriedade.</param>
        <summary>Cria um novo descritor de propriedade com base em um descritor de propriedade existente, usando o <see cref="T:System.ComponentModel.PropertyDescriptor" /> existente especificado e matriz de atributos.</summary>
        <returns>Um novo <see cref="T:System.ComponentModel.PropertyDescriptor" /> que tem os atributos de metadados especificados mesclados com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente do qual a propriedade é um membro.</param>
        <param name="name">O nome da propriedade.</param>
        <param name="type">O <see cref="T:System.Type" /> da propriedade.</param>
        <param name="attributes">Os novos atributos desta propriedade.</param>
        <summary>Cria e associa dinamicamente um descritor de propriedade a um tipo, usando o nome, o tipo e a matriz de atributos da propriedade especificada.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> que está associado ao tipo especificado e que tem os atributos de metadados especificados mesclados com os atributos de metadados existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Necessário para inspecionar os membros não-públicos do componente. Vincular o acesso de demanda necessários para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAssociation(Type ^ type, System::Object ^ primary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="primary">O objeto primário da associação.</param>
        <summary>Retorna uma instância do tipo associado com objeto primário especificado.</summary>
        <returns>Uma instância do tipo secundário que foi associado com o objeto primário, se existir uma associação; caso contrário, <paramref name="primary" /> se não existir nenhuma associação especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma associação anterior foi feita o `type` parâmetro usando o <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método, então o <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> método retorna o objeto correto secundário chamar para o tipo solicitado. Caso contrário, <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> procura um designer compatível para `type` e retorna o designer, caso seja encontrado. Esse método nunca retorna `null`.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não impede que o objeto primário ou secundário que está sendo finalizado e recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.IDesignerHost.GetDesigner(System.ComponentModel.IComponent)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a coleção de atributos de um componente ou um tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual você deseja obter atributos.</param>
        <summary>Retorna a coleção de atributos para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> que contém os atributos do componente. Se <paramref name="component" /> for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos retornados pelo <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método pode ser modificado dinamicamente de fonte do componente original listando por provedores de extensor (<xref:System.ComponentModel.IExtenderProvider>), serviços de filtro (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) e filtros de atributo.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 Para obter um exemplo desse método, consulte o <xref:System.ComponentModel.AttributeCollection.Matches%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (componentType As Type) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna uma coleção de atributos para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> com os atributos do tipo de componente. Se o componente for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Para atributos com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, a coleção de atributos remove instâncias duplicadas. Essas são as instâncias em que o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade retorna valores iguais.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object, noCustomTypeDesc As Boolean) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual você deseja obter atributos.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para usar um conjunto de linha de base de atributos do descritor de tipo personalizado se o <c>componente</c> for do tipo <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />; caso contrário, <see langword="false" />.</param>
        <summary>Retorna uma coleção de atributos para o componente especificado e um valor booliano que indica que um descritor de tipo personalizado foi criado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.AttributeCollection" /> com os atributos para o componente. Se o componente for <see langword="null" />, esse método retornará uma coleção vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos retornados pelo <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método pode ser modificado dinamicamente do original componentes listando por provedores de extensor (<xref:System.ComponentModel.IExtenderProvider>), serviços de filtro (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) e filtros de atributo.  
  
 Quando você define um atributo personalizado com <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> definida como `true`, você deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade para torná-lo exclusivo. Se todas as instâncias do seu atributo forem exclusivas, substituir <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para retornar a identidade do objeto do seu atributo. Se apenas algumas instâncias do seu atributo são exclusivas, retornar um valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que retornaria igualdade nesses casos. Por exemplo, alguns atributos tem um parâmetro de construtor que atua como uma chave exclusiva. Para esses atributos, retornar o valor do parâmetro de construtor do <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  A implementação padrão de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> retorna a identidade de tipo independentemente do valor de <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propriedade. Para retornar várias instâncias de um <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> de atributo do <xref:System.ComponentModel.AttributeCollection>, o atributo deve substituir o <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClassName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o nome da classe para o componente especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <summary>Retorna o nome da classe para o componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome da classe para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o total <xref:System.Type> nome para o `component` tipo de parâmetro. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se `component` implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, ele pode retornar um nome alternativo.  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (componentType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o nome da classe para o tipo especificado.</summary>
        <returns>Uma <see cref="T:System.String" /> que contém o nome da classe para o tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o descritor de tipo personalizado em cache para o tipo especificado para descobrir o nome da classe associada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o nome da classe para o componente especificado usando um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome da classe para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o total <xref:System.Type> nome para o `component` tipo de parâmetro. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se o `component` parâmetro implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, ele pode retornar um nome alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComponentName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o nome do componente especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <summary>Retorna o nome do componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o nome do componente especificado ou <see langword="null" /> se não houver nenhum nome de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método retorna o nome para o site do componente, se houver. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button".  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 Esse método é usado em tempo de design para recuperar o nome de uma instância de um componente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.Object" /> para o qual você deseja o nome de classe.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o nome do componente especificado usando um descritor de tipo personalizado.</summary>
        <returns>O nome da classe para o componente especificado ou <see langword="null" /> se não houver nenhum nome de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado em tempo de design para recuperar o nome de uma instância de um componente. Normalmente, esse método retorna o nome para o site do componente, se houver. Por exemplo, o nome da classe para um botão é "System.Windows.Forms.Button". Se o componente implementa o <xref:System.ComponentModel.ICustomTypeDescriptor> interface, ele pode retornar um nome alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConverter">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um conversor de tipo para um componente ou um tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter o conversor.</param>
        <summary>Retorna um conversor de tipo para o tipo do componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método localiza um conversor de tipo apropriado, procurando um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetConverter%2A> método com um segundo parâmetro do `false`.  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse método, consulte o <xref:System.ComponentModel.TypeConverter> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna um conversor de tipo para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Esse método procura o conversor de tipo apropriado, procurando um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object, noCustomTypeDesc As Boolean) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter o conversor.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna um conversor de tipo para o tipo do componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeConverter" /> para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método procura o conversor de tipo apropriado ao tentar localizar um <xref:System.ComponentModel.TypeConverterAttribute>. Se ele não encontrar um <xref:System.ComponentModel.TypeConverterAttribute>, ele percorre a hierarquia de classe base da classe até encontrar um tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o evento padrão de um componente ou tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter o evento.</param>
        <summary>Retorna o evento padrão para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão ou <see langword="null" /> se não houver eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a sobrecarregados <xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29> método com um segundo parâmetro do `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (componentType As Type) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o evento padrão para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão ou <see langword="null" /> se não houver eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object, noCustomTypeDesc As Boolean) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter o evento.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna o evento padrão para um componente com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptor" /> com o evento padrão ou <see langword="null" /> se não houver eventos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a propriedade padrão de um componente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter a propriedade padrão.</param>
        <summary>Retorna a propriedade padrão para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão ou <see langword="null" /> se não houver propriedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `component` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (componentType As Type) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Um <see cref="T:System.Type" /> que representa a classe para a qual obter a propriedade.</param>
        <summary>Retorna a propriedade padrão para o tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão ou <see langword="null" /> se não houver propriedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter a propriedade padrão.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a propriedade padrão para o componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptor" /> com a propriedade padrão ou <see langword="null" /> se não houver propriedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `component` parâmetro é `null`, esse método retornará `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEditor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um editor com o tipo base especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter o editor.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você deseja localizar.</param>
        <summary>Obtém um editor com o tipo base especificado para o componente especificado.</summary>
        <returns>Uma instância do editor que pode ser transmitida para o tipo de editor especificado ou <see langword="null" /> se nenhum editor do tipo solicitado for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo, <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores para uma propriedade. Você pode usar esse método para selecionar o editor que você deseja usar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(Type ^ type, Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você está tentando localizar.</param>
        <summary>Retorna um editor com o tipo base especificado para o tipo especificado.</summary>
        <returns>Uma instância do objeto de editor que pode ser convertida para o tipo base especificado ou <see langword="null" /> se nenhum editor do tipo solicitado puder ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores de um tipo. Você pode usar esse método para selecionar o que você deseja usar.  
  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type, noCustomTypeDesc As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">O componente para o qual obter o editor.</param>
        <param name="editorBaseType">Um <see cref="T:System.Type" /> que representa o tipo base do editor que você deseja localizar.</param>
        <param name="noCustomTypeDesc">Um sinalizador que indica se as informações de descrição do tipo personalizado devem ser consideradas.</param>
        <summary>Retorna um editor com o tipo base especificado e com um descritor de tipo personalizado para o componente especificado.</summary>
        <returns>Uma instância do editor que pode ser transmitida para o tipo de editor especificado ou <see langword="null" /> se nenhum editor do tipo solicitado for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo de `editorBaseType` é geralmente <xref:System.Drawing.Design.UITypeEditor>, mas você também pode usar outros tipos (por exemplo <xref:System.ComponentModel.ComponentEditor> e <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Você pode definir vários editores para uma propriedade. Você pode usar esse método para selecionar o editor que você deseja usar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> ou <paramref name="editorBaseType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a coleção de eventos de um componente ou tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter os eventos.</param>
        <summary>Retorna a coleção de eventos para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupera uma coleção de eventos que o determinado `component` parâmetro instância fornece. Essa coleção pode ser diferente do conjunto de eventos que fornece a classe. Se o `component` parâmetro é localizado, o site pode adicionar ou remover eventos adicionais.  
  
 Se `component` é `null`, em seguida, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 Para obter um exemplo desse método, consulte o <xref:System.ComponentModel.EventDescriptorCollection.Count%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna a coleção de eventos para um tipo de componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter os eventos.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> que você pode usar como um filtro.</param>
        <summary>Retorna a coleção de eventos para um componente especificado usando uma matriz especificada de atributos como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para esse componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os eventos para o `component` parâmetro pode ser diferente dos eventos de uma classe, porque o site pode adicionar ou remover eventos, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter os eventos.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de eventos para um componente especificado com um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna uma coleção de eventos que o determinado `component` parâmetro instância fornece. Isso pode ser diferente do conjunto de eventos que fornece a classe. Se o `component` parâmetro é localizado, o site pode adicionar ou remover eventos adicionais.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> que você pode usar como um filtro.</param>
        <summary>Retorna a coleção de eventos para um tipo de componente especificado usando uma matriz especificada de atributos como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para esse componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 O `attributes` matriz de parâmetro pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual obter os eventos.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de eventos para um componente especificado usando uma matriz especificada de atributos como um filtro e usando um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.EventDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para esse componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os eventos para o `component` parâmetro pode ser diferente dos eventos de uma classe, porque o site pode adicionar ou remover eventos, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz de parâmetro pode ter uma mistura de <xref:System.Type> e <xref:System.Attribute> objetos. A filtragem é definida pelas seguintes regras:  
  
-   Um <xref:System.Type> é tratado como um curinga; ele corresponde a qualquer evento que tem o <xref:System.Type> em seu conjunto de atributos.  
  
-   Se um evento não tem um <xref:System.Attribute> da mesma classe, o evento não está incluído na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, o evento deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é o evento padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> no evento.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.ComponentModel.Component" /> para o qual localizar o nome.</param>
        <summary>Retorna o nome totalmente qualificado do componente.</summary>
        <returns>O nome totalmente qualificado do componente especificado ou <see langword="null" /> se o componente não tem nome.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em muitos casos, o <xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A> método retornará o mesmo valor que o <xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A> método. No entanto, se o componente reside em um contêiner aninhado ou se tiver outras semânticas aninhadas, poderá retornar um nome totalmente qualificado diferente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a coleção de propriedades em um componente ou tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado.</summary>
        <returns>Uma <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades do componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades de um componente podem ser diferente das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o componente está localizado.  
  
 Se o `component` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para acessar as propriedades de um controle. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.Design.ComponentDesigner> classe.  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Um <see cref="T:System.Type" /> que representa o componente para o qual obter as propriedades.</param>
        <summary>Retorna a coleção de propriedades de um tipo de componente especificado.</summary>
        <returns>Uma <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades de um tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <summary>Retorna a coleção de propriedades de um componente especificado usando uma matriz de atributos especificada como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades que correspondem aos atributos especificados para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades para o `component` parâmetro pode ser diferentes das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` parâmetro é localizado.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como implementar o <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para não considerar as informações de descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de propriedades para um componente especificado usando o descritor de tipo padrão.</summary>
        <returns>Uma <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades para um componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades para o `component` parâmetro pode ser diferentes das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` parâmetro é localizado.  
  
 Se `component` é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">O <see cref="T:System.Type" /> do componente de destino.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <summary>Retorna a coleção de propriedades de um tipo de componente especificado usando uma matriz especificada de atributos como um filtro.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com as propriedades que correspondem aos atributos especificados para esse tipo de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se o `componentType` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como implementar o <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Windows.Forms.Design.PropertyTab> classe.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Um componente cujas propriedades serão obtidas.</param>
        <param name="attributes">Uma matriz do tipo <see cref="T:System.Attribute" /> a ser usada como um filtro.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para considerar as informações da descrição de tipo personalizado; caso contrário, <see langword="false" />.</param>
        <summary>Retorna a coleção de propriedades para um componente especificado usando uma matriz especificada de atributos como um filtro e usando um descritor de tipo personalizado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> com os eventos que correspondem aos atributos especificados para o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades de um `component` podem diferir das propriedades de uma classe, porque o site pode adicionar ou remover propriedades, se o `component` está localizado.  
  
 O `attributes` matriz de parâmetros é usada para filtrar a matriz. A filtragem é definida pelas seguintes regras:  
  
-   Se uma propriedade não tem um <xref:System.Attribute> da mesma classe, a propriedade não está incluída na matriz retornada.  
  
-   Se o atributo for uma instância do <xref:System.Attribute> classe, a propriedade deve ser uma correspondência exata ou ele não está incluído na matriz retornada.  
  
-   Se um <xref:System.Attribute> instância for especificada e é a propriedade padrão, ele está incluído na matriz retornada mesmo se não houver nenhuma instância do <xref:System.Attribute> na propriedade.  
  
-   Se `attributes` tem um atributo padrão, o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método corresponde o caso quando a propriedade não tem o atributo aplicado.  
  
 Se o `component` parâmetro é `null`, uma coleção vazia será retornada.  
  
 A ordem da coleção retornada não é garantida para ser idêntico entre as chamadas, portanto, sempre solicitá-lo antes do uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> é um objeto remoto entre processos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o provedor de descrição de tipo para o componente ou tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProvider (instance As Object) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Retorna o provedor de descrição de tipo para o componente especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado com o componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método sempre retornará um provedor de descrição de tipo. Até mesmo o padrão <xref:System.ComponentModel.TypeDescriptor> implementação é criada em um <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna o provedor de descrição de tipo para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> associado ao tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método sempre retornará um provedor de descrição de tipo. Até mesmo o padrão <xref:System.ComponentModel.TypeDescriptor> implementação é criada em um <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> que pode ser usado para executar a reflexão.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Retorna um <see cref="T:System.Type" /> que pode ser usado para executar a reflexão, considerando um objeto.</summary>
        <returns>Um <see cref="T:System.Type" /> para o objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método é uma versão de nível baixo do <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> normalmente é usado para executar a reflexão padrão em um objeto quando nenhum descritor de tipo personalizado pode ser localizado para ele.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> é <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Retorna um <see cref="T:System.Type" /> que pode ser usado para executar a reflexão, considerando um tipo de classe.</summary>
        <returns>Um <see cref="T:System.Type" /> da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método é uma versão de nível baixo do <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> normalmente é usado para executar reflexão padrão em uma classe quando nenhum descritor de tipo personalizado pode ser localizado para ele.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InterfaceType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ InterfaceType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um tipo que representa um provedor de descrição de tipo para todos os tipos de interface.</summary>
        <value>Um <see cref="T:System.Type" /> que representa um provedor de descrição de tipo personalizado para todos os tipos de interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A> propriedade obtém um <xref:System.Type> objeto que você pode passar para o <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> métodos para definir um provedor de descrição de tipo para tipos de interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Limpa as propriedades e eventos do cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Um componente para o qual as propriedades ou os eventos foram alterados.</param>
        <summary>Limpa do cache as propriedades e eventos do componente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles devem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente no tempo de design. Ele não é usado durante o tempo de execução.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ao alteram as propriedades ou eventos de um componente. Esse evento é gerado apenas se não houver uma chamada anterior para o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que as informações armazenadas em cache.  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse método, consulte o <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">O <see cref="T:System.Reflection.Assembly" /> que representa o assembly a ser atualizado. Cada <see cref="T:System.Type" /> neste assembly será atualizado.</param>
        <summary>Limpa do cache as propriedades e eventos do assembly especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente no tempo de design. Ele não é usado durante o tempo de execução.  
  
 Antes de fazer uma chamada para o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para limpar o cache, você precisa chamar o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para o assembly específico para armazenar em cache as informações primeiro.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas as classes que deseja ser notificado quando a propriedade de conjunto de alterações de um componente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Assembly" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Module ^ module);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">O <see cref="T:System.Reflection.Module" /> que representa o módulo a ser atualizado. Cada <see cref="T:System.Type" /> neste módulo será atualizado.</param>
        <summary>Limpa do cache as propriedades e eventos do módulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente no tempo de design. Ele não é usado durante o tempo de execução.  
  
 Antes de fazer uma chamada para o <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para limpar o cache, você precisa chamar o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para o módulo específico ao armazenar em cache as informações primeiro.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas as classes que deseja ser notificado quando a propriedade de conjunto de alterações de um componente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Limpa do cache as propriedades e eventos do tipo de componente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esta versão deste método somente quando você não tem uma instância do objeto.  
  
 Propriedades e eventos são armazenados em cache por <xref:System.ComponentModel.TypeDescriptor> para maior velocidade. Normalmente, eles são constantes para o tempo de vida de um objeto. No entanto, os designers e provedores de extensor podem alterar o conjunto de propriedades em um objeto. Se isso ocorrer, eles podem chamar este método para limpar os descritores de evento e propriedade do objeto. Esse método é usado somente no tempo de design. Ele não é usado durante o tempo de execução.  
  
 Esse método também gera um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ao alteram as propriedades ou eventos de um componente. Esse evento é gerado apenas se não houver uma chamada anterior para o <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> ou <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que as informações armazenadas em cache.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Refreshed As RefreshEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::ComponentModel::RefreshEventHandler ^ Refreshed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o cache de um componente é limpo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Para obter um exemplo de como usar esse evento, consulte o <xref:System.ComponentModel.RefreshEventHandler> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O <see cref="T:System.Object" /> primário.</param>
        <param name="secondary">O <see cref="T:System.Object" /> secundário.</param>
        <summary>Remove uma associação entre dois objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A> método Remove uma associação entre dois objetos formado pelo <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não influencia quando o objeto é finalizado ou recuperado pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociations (primary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociations(System::Object ^ primary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">O <see cref="T:System.Object" /> primário em uma associação.</param>
        <summary>Remove todas as associações de um objeto primário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A> método Remove todas as associações entre um objeto principal e todos os seus objetos secundários, criados por chamadas para o <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Um <xref:System.WeakReference> é usado para manter a associação entre o objeto principal e secundário; portanto, esse método não influencia quando primário dos objetos secundários são finalizadas ou recuperada pela coleta de lixo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente, que esteja associado com o objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o objeto associado.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente, que esteja associado com o tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o tipo associado.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você precisar chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obter acesso completo aos recursos do sistema. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estados associados:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="instance">Uma instância do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente, que esteja associado com o objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o objeto associado.  
  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode registrar um provedor para a instância especificada se seu tipo também é parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define o <paramref name="instance" /> tipo do parâmetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">O <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> a ser removido.</param>
        <param name="type">O <see cref="T:System.Type" /> do componente de destino.</param>
        <summary>Remove um provedor de descrição de tipo adicionado anteriormente, que esteja associado com o tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método Remove um provedor de descrição de tipo adicionado anteriormente com o <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Remoção de um provedor faz com que um <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento ser gerado para o tipo associado.  
  
 Esse método pode ser chamado de código parcialmente confiável. Se <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> for definido, o chamador pode cancelar o registro de um provedor para o tipo especificado se também for parcialmente confiável.  
  
 Use o <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método se você não precisa chamar a partir de código parcialmente confiável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Um ou ambos os parâmetros são <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acesso ao registro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo associado: O <see cref="T:System.Security.PermissionSet" /> que é necessário para o assembly que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortDescriptorArray (infos As IList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SortDescriptorArray(System::Collections::IList ^ infos);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">Um <see cref="T:System.Collections.IList" /> que contém os descritores a serem classificados.</param>
        <summary>Classifica os descritores usando o nome do descritor.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
  </Members>
</Type>