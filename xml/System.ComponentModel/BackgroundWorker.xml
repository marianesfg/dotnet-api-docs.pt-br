<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39f7c80e09eb1e4015b00c77fb7fae56e118bba5" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48631319" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Executa uma operação em outro thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker> classe permite que você execute uma operação em um thread separado e dedicado. Operações demoradas, como downloads e transações de banco de dados podem fazer com que sua interface do usuário (UI) para parecer que ele tiver parado de responder enquanto eles estão em execução. Se você quer uma interface de usuário responsiva e está enfrentando longos atrasos associados a essas operações, o <xref:System.ComponentModel.BackgroundWorker> classe fornece uma solução conveniente.  
  
 Para executar uma operação demorada em segundo plano, criar um <xref:System.ComponentModel.BackgroundWorker> e escutar eventos que relatam o andamento da operação e sinalizam quando a operação é concluída. Você pode criar o <xref:System.ComponentModel.BackgroundWorker> por meio de programação ou você pode arrastá-lo para seu formulário do **componentes** guia dos **caixa de ferramentas**. Se você criar o <xref:System.ComponentModel.BackgroundWorker> no Designer de formulários do Windows, ele será exibido na bandeja de componentes e suas propriedades serão exibidas na janela Propriedades.  
  
 Para configurar para uma operação em segundo plano, adicione um manipulador de eventos para o <xref:System.ComponentModel.BackgroundWorker.DoWork> eventos. Chame sua operação demorada neste manipulador de eventos. Para iniciar a operação, chame <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Para receber notificações de atualizações de andamento, manipule o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. Para receber uma notificação quando a operação for concluída, manipule o <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos.  
  
> [!NOTE]
>  Você deve ter cuidado para não manipular quaisquer objetos de interface do usuário no seu <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos. Em vez disso, se comunicar com a interface do usuário por meio de <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> e <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> eventos não são empacotados em <xref:System.AppDomain> limites. Não use uma <xref:System.ComponentModel.BackgroundWorker> para executar operações de vários threads em mais de um componente de <xref:System.AppDomain>.  
  
 Se a operação em segundo plano requer um parâmetro, chame <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> com seu parâmetro. Dentro de <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos, você pode extrair o parâmetro do <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> propriedade.  
  
 Para saber mais sobre <xref:System.ComponentModel.BackgroundWorker>, consulte [Como executar uma operação em segundo plano](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra as Noções básicas do <xref:System.ComponentModel.BackgroundWorker> classe para executar uma operação demorada de forma assíncrona. A ilustração a seguir mostra um exemplo da saída.  
  
 ![Exemplo simples de BackgroundWorker](~/add/media/backgroundworker-simple.png "exemplo simples de BackgroundWorker")  
  
 Para testar esse código, crie um aplicativo do Windows Forms. Adicionar um <xref:System.Windows.Forms.Label> controle chamado `resultLabel` e adicione dois <xref:System.Windows.Forms.Button> controles denominados `startAsyncButton` e `cancelAsyncButton`. Criar <xref:System.Windows.Forms.Control.Click> manipuladores de eventos para os dois botões. Dos **componentes** guia da caixa de ferramentas, adicione um <xref:System.ComponentModel.BackgroundWorker> componente denominado `backgroundWorker1`. Crie <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, e <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipuladores de eventos para o <xref:System.ComponentModel.BackgroundWorker>. No código para o formulário, substitua o código existente pelo código a seguir.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 O exemplo de código a seguir demonstra o uso da <xref:System.ComponentModel.BackgroundWorker> classe para executar uma operação demorada de forma assíncrona. A ilustração a seguir mostra um exemplo da saída.  
  
 ![Exemplo de BackgroundWorker Fibonacci](~/add/media/backgroundworker-fibonacci.png "exemplo de BackgroundWorker Fibonacci")  
  
 A operação calcula o número de Fibonacci selecionado, relata atualizações de progresso como o cálculo continua e permite que um cálculo pendente a ser cancelada.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
    <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Práticas recomendadas de threading gerenciado</related>
    <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ComponentModel.BackgroundWorker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita o cancelamento de uma operação pendente em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> envia uma solicitação para encerrar a operação pendente em segundo plano e define o <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade para `true`.  
  
 Quando você chama <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, seu método de trabalho tem uma oportunidade de interromper sua execução e sair. O código de trabalho deve verificar periodicamente as <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade para ver se ele foi definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que seu código na <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e seu loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> que está sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> do sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é uma preocupação comum na programação multi-threaded. Para obter mais informações sobre o design de multithreading problemas, consulte [práticas recomendadas de Threading gerenciado](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método Cancelar uma operação assíncrona ("em segundo plano"). Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> é <see langword="false" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o aplicativo solicitou o cancelamento de uma operação em segundo plano.</summary>
        <value>
          <see langword="true" /> se o aplicativo tiver solicitado o cancelamento de uma operação em segundo plano; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> está `true`, em seguida, a <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método foi chamado no <xref:System.ComponentModel.BackgroundWorker>.  
  
 Esta propriedade destina-se para uso pelo thread de trabalho, deve verificar periodicamente <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> e anule a operação em segundo plano quando ele é definido como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade para consultar um <xref:System.ComponentModel.BackgroundWorker> sobre seu estado de cancelamento. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> é chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando você chama o <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método. Isso é onde você inicia a operação que executa o trabalho potencialmente demorado.  
  
 Seu código na <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos deve verificar periodicamente as <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> valor da propriedade e anular a operação se ele for `true`. Quando isso ocorrer, você pode definir as <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> do sinalizador de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> para `true`e o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> do sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos será definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que seu código na <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e seu loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> que está sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> do sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é uma preocupação comum na programação multi-threaded. Para obter mais informações sobre o design de multithreading problemas, consulte [práticas recomendadas de Threading gerenciado](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Se a operação produz um resultado, você pode atribuir o resultado para o <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> propriedade. Isso estará disponível para o <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos no <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade.  
  
 Se a operação gera uma exceção que seu código não processa, o <xref:System.ComponentModel.BackgroundWorker> captura a exceção e passa-o na <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos, onde ele é exposto como o <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriedade do <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Se você estiver executando sob o depurador do Visual Studio, o depurador interromperá no ponto de <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos onde a exceção sem tratamento foi gerada. Se você tiver mais de uma <xref:System.ComponentModel.BackgroundWorker>, você não deve referenciar qualquer um deles diretamente, pois isso seria acoplar seus <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos a uma instância específica do <xref:System.ComponentModel.BackgroundWorker>. Em vez disso, você deve acessar sua <xref:System.ComponentModel.BackgroundWorker> convertendo o `sender` parâmetro em seu <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos.  
  
 Você deve ter cuidado para não manipular quaisquer objetos de interface do usuário no seu <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos. Em vez disso, se comunicar com a interface do usuário por meio de <xref:System.ComponentModel.BackgroundWorker> eventos.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.DoWork> evento para iniciar uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Práticas recomendadas de threading gerenciado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> está executando uma operação assíncrona.</summary>
        <value>
          <see langword="true" />, se o <see cref="T:System.ComponentModel.BackgroundWorker" /> estiver executando uma operação assíncrona; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker> inicia uma operação assíncrona ao chamar <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> propriedade para aguardar a conclusão de um <xref:System.ComponentModel.BackgroundWorker> operação. Este exemplo de código é parte de um exemplo maior, descrito em [como: baixar um arquivo em segundo plano](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> método também permite que classes derivadas manipular o evento sem anexar um delegado. Essa é a técnica preferencial para manipular o evento em uma classe derivada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> método para relatar o progresso de uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.AsyncOperationManager> classe.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> , de modo que delegados registrados recebam o evento.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A> método também permite que classes derivadas manipular o evento sem anexar um delegado. Essa é a técnica preferencial para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> , de modo que delegados registrados recebam o evento.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> é chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando você chama o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">O percentual, de 0 a 100, da operação em segundo plano concluída.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar que a operação em segundo plano para relatar o progresso, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. O <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> o valor da propriedade deve ser `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lançará um <xref:System.InvalidOperationException>.  
  
 Cabe a você implementar uma maneira significativa de medir o progresso da operação de seu plano de fundo como um percentual do total da tarefa concluída.  
  
 A chamada para o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método é assíncrono e retorna imediatamente. O <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> manipulador de eventos executa no thread que criou o <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> é definida como <see langword="false" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">O percentual, de 0 a 100, da operação em segundo plano concluída.</param>
        <param name="userState">O objeto de estado passado para <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar que a operação em segundo plano para relatar o progresso, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. O <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> valor de propriedade deve ser `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lançará um <xref:System.InvalidOperationException>.  
  
 Cabe a você implementar uma maneira significativa de medir o progresso da operação de seu plano de fundo como um percentual do total da tarefa concluída.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Windows.Forms.ToolStripProgressBar> classe.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> é definida como <see langword="false" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia a execução de uma operação em segundo plano.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia a execução de uma operação em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envia uma solicitação para iniciar a operação de execução de forma assíncrona. Quando a solicitação é atendida, o <xref:System.ComponentModel.BackgroundWorker.DoWork> é gerado, que por sua vez inicia a execução de sua operação em segundo plano.  
  
 Se a operação em segundo plano já está em execução, chamando <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> novamente irá gerar um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar uma operação assíncrona. Ele faz parte de um exemplo maior, descrito em [como: baixar um arquivo em segundo plano](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> é <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Práticas recomendadas de threading gerenciado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Um parâmetro para uso pela operação em segundo plano a ser executado no manipulador de eventos <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</param>
        <summary>Inicia a execução de uma operação em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envia uma solicitação para iniciar a operação de execução de forma assíncrona. Quando a solicitação é atendida, o <xref:System.ComponentModel.BackgroundWorker.DoWork> é gerado, que por sua vez inicia a execução de sua operação em segundo plano.  
  
 Se a operação exige um parâmetro, você pode fornecê-la como o `argument` parâmetro para <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Se a operação em segundo plano já está em execução, chamando <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> novamente irá gerar um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> é <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Práticas recomendadas de threading gerenciado</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a operação em segundo plano foi concluída, cancelada ou gerou uma exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando o <xref:System.ComponentModel.BackgroundWorker.DoWork> retorna do manipulador de eventos.  
  
 Se a operação for concluída com êxito e seu resultado é atribuído a <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos, você pode acessar o resultado por meio de <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade.  
  
 O <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriedade de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica que uma exceção foi gerada pela operação.  
  
 O <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propriedade <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica se uma solicitação de cancelamento foi processada pela operação em segundo plano. Se seu código na <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos detecta uma solicitação de cancelamento, verificando a <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> sinalizador e configuração o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> do sinalizador de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> para `true`, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> do sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> também será definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que seu código na <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e seu loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> que está sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> do sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é uma preocupação comum na programação multi-threaded. Para obter mais informações sobre o design de multithreading problemas, consulte [práticas recomendadas de Threading gerenciado](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Sua <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos sempre deve verificar o <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> e <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> propriedades antes de acessar o <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade. Se uma exceção foi gerada ou se a operação foi cancelada, acessando o <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade gera uma exceção.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos para manipular o resultado de uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> pode relatar atualizações de progresso.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.ComponentModel.BackgroundWorker" /> der suporte a atualizações de progresso; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina a <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> propriedade para `true` se você quiser que o <xref:System.ComponentModel.BackgroundWorker> para dar suporte a atualizações de andamento. Quando essa propriedade é `true`, o código do usuário pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> dá suporte ao cancelamento assíncrono.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.ComponentModel.BackgroundWorker" /> der suporte ao cancelamento; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina a <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> propriedade para `true` se você quiser que o <xref:System.ComponentModel.BackgroundWorker> para dar suporte ao cancelamento. Quando essa propriedade é `true`, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método para interromper uma operação em segundo plano.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Como executar uma operação na tela de fundo</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Como baixar um arquivo no segundo plano</related>
      </Docs>
    </Member>
  </Members>
</Type>