<Type Name="ArrayPool&lt;T&gt;" FullName="System.Buffers.ArrayPool&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0cd4416c419b70f301ca33ef17107cf4f059b502" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58722635" /></Metadata><TypeSignature Language="C#" Value="public abstract class ArrayPool&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ArrayPool`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.ArrayPool`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ArrayPool(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ArrayPool abstract" />
  <TypeSignature Language="F#" Value="type ArrayPool&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Buffers</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="T">O tipo dos objetos que estão no pool de recursos.</typeparam>
    <summary>Fornece um pool de recursos que permite a reutilização de instâncias do tipo <see cref="T:T[]" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Usando o <xref:System.Buffers.ArrayPool%601> classe alugar e retornar buffers (usando o <xref:System.Buffers.ArrayPool%601.Rent%2A> e <xref:System.Buffers.ArrayPool%601.Return%2A> métodos) pode melhorar o desempenho em situações em que as matrizes são criadas e destruídas com frequência, resultando na pressão de memória significativa no lixo coletor.
  
 ]]></format>
    </remarks>
    <threadsafe>Essa classe é thread-safe. Todos os membros podem ser usados por vários threads simultaneamente.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ArrayPool ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ArrayPool();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Observe que esse construtor é protegido; ele só pode ser chamado por classes derivadas do <xref:System.Buffers.ArrayPool%601> classe. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma nova instância da classe <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <returns>Uma nova instância da classe <see cref="T:System.Buffers.ArrayPool`1" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create (int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create(int32 maxArrayLength, int32 maxArraysPerBucket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (maxArrayLength As Integer, maxArraysPerBucket As Integer) As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create(int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="F#" Value="static member Create : int * int -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create (maxArrayLength, maxArraysPerBucket)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxArrayLength" Type="System.Int32" />
        <Parameter Name="maxArraysPerBucket" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxArrayLength">O comprimento máximo de uma instância de matriz que pode ser armazenada no pool.</param>
        <param name="maxArraysPerBucket">O número máximo de instâncias de matriz que podem ser armazenadas em cada bucket no pool. O pool agrupa matrizes de comprimentos semelhantes em buckets para um acesso mais rápido.</param>
        <summary>Cria uma nova instância da classe <see cref="T:System.Buffers.ArrayPool`1" /> usando a configuração especificada.</summary>
        <returns>Uma nova instância da classe <see cref="T:System.Buffers.ArrayPool`1" /> com a configuração especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
A instância das <xref:System.Buffers.ArrayPool%601> classe criada por esse método agrupará matrizes em buckets, sem nenhum mais de `maxArraysPerBucket` em cada bucket e com as matrizes não excedendo `maxArrayLength` de comprimento.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rent">
      <MemberSignature Language="C#" Value="public abstract T[] Rent (int minimumLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] Rent(int32 minimumLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Rent (minimumLength As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;T&gt; ^ Rent(int minimumLength);" />
      <MemberSignature Language="F#" Value="abstract member Rent : int -&gt; 'T[]" Usage="arrayPool.Rent minimumLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minimumLength">O comprimento mínimo da matriz.</param>
        <summary>Recupera um buffer que tenha, pelo menos, o comprimento solicitado.</summary>
        <returns>Uma matriz do tipo <see cref="T:T[]" /> que seja, pelo menos, de comprimento <paramref name="minimumLength" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Esse buffer está emprestado ao chamador e deve ser retornado para o mesmo pool usando o <xref:System.Buffers.ArrayPool%601.Return%2A> método, para que ele possa ser reutilizado em chamadas subsequentes para o <xref:System.Buffers.ArrayPool%601.Rent%2A> método. Falha ao retornar um buffer alugado não é um erro fatal. No entanto, ele pode levar a desempenho reduzido do aplicativo, como o pool pode precisar criar um novo buffer para substituir o perdido.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public abstract void Return (T[] array, bool clearArray = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Return(!T[] array, bool clearArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Return (array As T(), Optional clearArray As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member Return : 'T[] * bool -&gt; unit" Usage="arrayPool.Return (array, clearArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="clearArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="array">Um buffer para retornar para o pool que foi obtido anteriormente usando o método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />.</param>
        <param name="clearArray">Indica se o conteúdo do buffer deve ser apagado antes da reutilização. Se <paramref name="clearArray" /> for definido como <see langword="true" /> e se o pool for armazenar o buffer para permitir a reutilização subsequente, o método <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" /> limpará o conteúdo do <paramref name="array" /> para que um chamador subsequente usando o método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> não veja o conteúdo do chamador anterior. Se <paramref name="clearArray" /> for definido como <see langword="false" /> ou se o pool for liberar o buffer, o conteúdo da matriz permanecerá inalterado.</param>
        <summary>Retorna uma matriz para o pool que foi obtido anteriormente usando o método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> na mesma instância <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Depois que um buffer foi retornado ao pool, o chamador desiste todas as propriedade do buffer e não deve usá-lo. A referência retornada de uma determinada chamada para o <xref:System.Buffers.ArrayPool%601.Rent%2A> método só deve ser retornado usando o <xref:System.Buffers.ArrayPool%601.Return%2A> método uma vez. O padrão <xref:System.Buffers.ArrayPool%601> pode manter o buffer retornado para alugá-la novamente, ou ele pode liberar o buffer retornado se for determinado que o pool já tem buffers suficientes armazenados.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shared">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Shared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Buffers.ArrayPool`1&lt;!T&gt; Shared" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.ArrayPool`1.Shared" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Shared As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Buffers::ArrayPool&lt;T&gt; ^ Shared { System::Buffers::ArrayPool&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Shared : System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Shared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma instância <see cref="T:System.Buffers.ArrayPool`1" /> compartilhada.</summary>
        <value>Compartilhado <see cref="T:System.Buffers.ArrayPool`1" /> instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

O pool compartilhado fornece uma implementação padrão da <xref:System.Buffers.ArrayPool%601> classe que é destinado a aplicabilidade geral. Uma classe compartilhada mantém as matrizes de vários tamanhos e pode devolver uma matriz maior que, na verdade, foi solicitado, mas ele será nunca devolver uma matriz menor do que foi solicitado. Alugar um buffer de uma classe compartilhada usando o <xref:System.Buffers.ArrayPool%601.Rent%2A> método resultará em um buffer existente que está sendo tirado do pool, se um buffer adequado está disponível ou em um novo buffer que está sendo alocado se um não está disponível.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>