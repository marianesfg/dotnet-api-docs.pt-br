<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UnicodeEncoding.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac537bb8ffd133cbb1ddd3c3fdd2f593086d39584aa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Represents a UTF-16 encoding of Unicode characters.</source>
          <target state="translated">Representa uma codificação de caracteres Unicode UTF-16.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">Decodificação de é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <bpt id="p1">[</bpt>Unicode Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> assigns a code point (a number) to each character in every supported script.</source>
          <target state="translated">O <bpt id="p1">[</bpt>padrão Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> atribui um ponto de código (um número) para cada caractere em todos os scripts com suporte.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>A Unicode Transformation Format (UTF) is a way to encode that code point.</source>
          <target state="translated">Um formato de transformação Unicode (UTF) é uma forma de codificar esse ponto de código.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <bpt id="p1">[</bpt>Unicode Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> uses the following UTFs:</source>
          <target state="translated">O <bpt id="p1">[</bpt>padrão Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> usa UTFs os seguintes:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-8, which represents each code point as a sequence of one to four bytes.</source>
          <target state="translated">UTF-8, que representa cada ponto de código como uma sequência de um a quatro bytes.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-16, which represents each code point as a sequence of one to two 16-bit integers.</source>
          <target state="translated">UTF-16, que representa cada ponto de código como uma sequência de inteiros de 16 bits de um ou dois.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-32, which represents each code point as a 32-bit integer.</source>
          <target state="translated">UTF-32, o que representa cada ponto de código como um inteiro de 32 bits.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For more information about the UTFs and other encodings supported by <ph id="ph1">&lt;xref:System.Text&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre os UTFs e outras codificações com suporte <ph id="ph1">&lt;xref:System.Text&gt;</ph>, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class represents a UTF-16 encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> classe representa uma codificação UTF-16.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The encoder can use either big endian byte order (most significant byte first) or little endian byte order (least significant byte first).</source>
          <target state="translated">O codificador pode usar qualquer ordem de byte big endian (byte mais significativo primeiro) ou a ordem de byte endian pouca (byte menos significativo primeiro).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):</source>
          <target state="translated">Por exemplo, a letra maiuscula latina um (ponto de código U + 0041) é serializado como segue (em hexadecimal):</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Big endian byte order: 00 00 00 41</source>
          <target state="translated">Ordem de byte big endian: 00 00 00 41</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little endian byte order: 41 00 00 00</source>
          <target state="translated">Ordem de bytes endian pouco: 41 00 00 00</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>It is generally more efficient to store Unicode characters using the native byte order of a particular platform.</source>
          <target state="translated">É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo de uma plataforma específica.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</source>
          <target state="translated">Por exemplo, é melhor usar a ordem de bytes endian pouco em plataformas endian pequeno, como computadores Intel.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class corresponds to the Windows code pages 1200 (little endian byte order) and 1201 (big endian byte order).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> classe corresponde à páginas de código Windows 1200 (ordem de byte endian pouco) e 1201 (ordem de byte big endian).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>You can determine the "endianness" of a particular architecture by calling the <ph id="ph1">&lt;xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode determinar o "endian" de uma arquitetura específica chamando o <ph id="ph1">&lt;xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">Opcionalmente, o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto fornece uma marca de ordem de byte (BOM), que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Se o preâmbulo contiver uma marca de ordem de byte (BOM), ele ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>If the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance is configured to provide a BOM, you can retrieve it by calling the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instância está configurada para fornecer um BOM, você poderá recuperá-lo ao chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método; caso contrário, o método retorna uma matriz vazia.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Note that, even if a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class do not do this automatically.</source>
          <target state="translated">Observe que, mesmo se um <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto é configurado para dar suporte a BOM, você deve incluir a BOM no início do fluxo de bytes codificados como apropriado; os métodos de codificação do <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> classe não faça isso automaticamente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>To enable error detection and to make the class instance more secure, you should instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph3">`throwOnInvalidBytes`</ph> argument to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Para habilitar a detecção de erro e tornar a instância da classe mais seguro, você deve criar uma instância de um <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto chamando o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> construtor e a configuração de seu <ph id="ph3">`throwOnInvalidBytes`</ph> argumento <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>With error detection, a method that detects an invalid sequence of characters or bytes throws a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Com a detecção de erro, um método que detecta uma sequência inválida de caracteres ou bytes lança um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</source>
          <target state="translated">Sem detecção de erro, nenhuma exceção é lançada e a sequência inválida geralmente é ignorada.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto de várias maneiras, dependendo se você deseja-lo para fornecer uma marca de ordem de byte (BOM), se desejar que a codificação big-endian ou little endian e se você deseja habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following table lists the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> constructors and the <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> properties that return a <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">A seguinte tabela lista o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> construtores e <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> propriedades que retornam uma <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Member</source>
          <target state="translated">Membro</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Endianness</source>
          <target state="translated">Endianness</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>BOM</source>
          <target state="translated">BOM</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Error detection</source>
          <target state="translated">Detecção de erro</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Big-endian</source>
          <target state="translated">Big-endian.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Sim</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little-endian</source>
          <target state="translated">Little endian</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Sim</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little-endian</source>
          <target state="translated">Little endian</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Sim</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Likewise, the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> methods perform the actual decoding.</source>
          <target state="translated">Da mesma forma, o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> os métodos executam a decodificação real.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> properties, respectively.</source>
          <target state="translated">Para um codificador ou decodificador é capaz de salvar informações de estado quando a codificação ou decodificação de dados que abrange vários blocos (como cadeia de caracteres de 1 milhão de caracteres codificada em segmentos de caractere de 100.000), use o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> propriedades, respectivamente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following example demonstrates how to encode a string of Unicode characters into a byte array by using a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir demonstra como codificar uma cadeia de caracteres Unicode em uma matriz de bytes usando um <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The byte array is decoded into a string to demonstrate that there is no loss of data.</source>
          <target state="translated">A matriz de bytes é decodificada em uma cadeia de caracteres para demonstrar que não há nenhuma perda de dados.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</source>
          <target state="translated">O exemplo a seguir usa a mesma cadeia de caracteres que o anterior, exceto que ele grava os bytes codificados em um arquivo e prefixos de fluxo de bytes com uma marca de ordem de byte (BOM).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>It then reads the file in two different ways: as a text file by using a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object; and as a binary file.</source>
          <target state="translated">Ele lê o arquivo de duas maneiras diferentes: como um arquivo de texto usando um <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> objeto; e como um arquivo binário.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>As you would expect, in neither case is the BOM included in the newly read string.</source>
          <target state="translated">Como se esperaria em nenhum caso é BOM incluído na cadeia de caracteres leitura recentemente.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este construtor cria uma instância que usa a ordem de bytes endian pouco, fornece uma marca de ordem de byte Unicode e não gerará uma exceção quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>For security reasons, you should enable error detection by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph2">`throwOnInvalidBytes`</ph> argument to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, você deve ativar a detecção de erro chamando o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> construtor e a configuração de seu <ph id="ph2">`throwOnInvalidBytes`</ph> argumento <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance and display the name of the encoding.</source>
          <target state="translated">O exemplo a seguir demonstra como criar um novo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instância e exiba o nome da codificação.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to use the big endian byte order (most significant byte first), or <ph id="ph2">&lt;see langword="false" /&gt;</ph> to use the little endian byte order (least significant byte first).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para usar a ordem de byte big endian (byte mais significativo primeiro) ou <ph id="ph2">&lt;see langword="false" /&gt;</ph> para usar a ordem de byte little endian (byte menos significativo primeiro).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que o método <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> retorna uma marca de ordem de byte Unicode, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>Parameters specify whether to use the big endian byte order and whether the <ph id="ph1">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark.</source>
          <target state="translated">Os parâmetros especificam se é necessário usar a ordem de byte big endian e se o método <ph id="ph1">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> retorna uma marca de ordem de byte Unicode.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este construtor cria uma instância que não lança uma exceção quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>For security reasons, you should enable error detection by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph2">`throwOnInvalidBytes`</ph> argument to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, você deve ativar a detecção de erro chamando o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> construtor e a configuração de seu <ph id="ph2">`throwOnInvalidBytes`</ph> argumento <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`byteOrderMark`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`byteOrderMark`</ph> parâmetro controla a operação de <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</source>
          <target state="translated">Se <ph id="ph1">`true`</ph>, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-16.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Se <ph id="ph1">`false`</ph>, ele retorna uma matriz de bytes de comprimento zero.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`byteOrderMark`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Entretanto, a configuração <ph id="ph1">`byteOrderMark`</ph> para <ph id="ph2">`true`</ph> não causa o <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método prefixar BOM no início da matriz de bytes, nem o <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método para incluir o número de bytes na BOM na contagem de bytes.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance specifying whether to support little endian or big endian byte ordering and the Unicode byte order mark.</source>
          <target state="translated">O exemplo a seguir demonstra como criar um novo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> marca de ordem de instância se oferecer suporte a ordem de little endian ou big bytes endian e o byte Unicode.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to use the big endian byte order (most significant byte first); <ph id="ph2">&lt;see langword="false" /&gt;</ph> to use the little endian byte order (least significant byte first).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para usar a ordem de byte big endian (byte mais significativo primeiro); <ph id="ph2">&lt;see langword="false" /&gt;</ph> para usar a ordem de byte little endian (byte menos significativo primeiro).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que o método <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> retorna uma marca de ordem de byte Unicode, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que uma exceção deverá ser gerada quando uma codificação inválida for detectada; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Os parâmetros especificam se é necessário usar a ordem de byte big endian, fornecer uma marca de ordem de byte Unicode e gerar uma exceção quando uma codificação inválida for detectada.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`byteOrderMark`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`byteOrderMark`</ph> parâmetro controla a operação de <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</source>
          <target state="translated">Se <ph id="ph1">`true`</ph>, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-16.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Se <ph id="ph1">`false`</ph>, ele retorna uma matriz de bytes de comprimento zero.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`byteOrderMark`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Entretanto, a configuração <ph id="ph1">`byteOrderMark`</ph> para <ph id="ph2">`true`</ph> não causa o <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método prefixar BOM no início da matriz de bytes, nem o <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método para incluir o número de bytes na BOM na contagem de bytes.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter is <ph id="ph2">`true`</ph>, a method that detects an invalid byte sequence throws <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se o <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro é <ph id="ph2">`true`</ph>, um método que detecta uma sequência de bytes inválido gera <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</source>
          <target state="translated">Caso contrário, o método não lança uma exceção, e a sequência inválida é ignorada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>For security reasons, your applications are recommended to use this constructor to create an instance of the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class and turn on error detection by setting <ph id="ph2">`throwOnInvalidBytes`</ph> to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, os aplicativos são recomendados para usar esse construtor para criar uma instância do <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> classe e ativar a detecção de erro definindo <ph id="ph2">`throwOnInvalidBytes`</ph> para <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>The following example demonstrates the behavior of <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, both with error detection enabled and without.</source>
          <target state="translated">O exemplo a seguir demonstra o comportamento de <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, com detecção de erro habilitada e sem.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>Represents the Unicode character size in bytes.</source>
          <target state="translated">Representa o tamanho do caractere Unicode em bytes.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>This field is a constant.</source>
          <target state="translated">Este campo é uma constante.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>The value of this field is a 32-bit signed constant with a value of 2.</source>
          <target state="translated">O valor desse campo é uma constante de 32 bits assinada com um valor de 2.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>The following example demonstrates how to return the value of <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.CharSize&gt;</ph> and display it.</source>
          <target state="translated">O exemplo a seguir demonstra como retornar o valor de <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.CharSize&gt;</ph> e exibi-lo.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">O objeto a ser comparado com o objeto atual.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> is equal to the current <ph id="ph2">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object.</source>
          <target state="translated">Determina se o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado é igual ao objeto <ph id="ph2">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> and is equal to the current object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> for uma instância de <ph id="ph3">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> e for igual ao objeto atual, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Two <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects are considered equal if all of the following conditions are true:</source>
          <target state="translated">Dois <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objetos são considerados iguais se todas as seguintes condições forem verdadeiras:</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same byte order (little-endian or big-endian).</source>
          <target state="translated">Os dois objetos usam a mesma ordem de byte (little endian ou big-endian).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects provide the byte order mark, or both do not.</source>
          <target state="translated">Os dois objetos fornecem a marca de ordem de byte, ou ambos não.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same encoder fallback.</source>
          <target state="translated">Os dois objetos usam o mesmo codificador de fallback.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same decoder fallback.</source>
          <target state="translated">Os dois objetos usam o mesmo decodificador de fallback.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.Equals%2A&gt;</ph> method to test whether the current <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object is equal to a different <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.Equals%2A&gt;</ph> método para testar se o atual <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto é igual a outro <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Five <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects are created and compared, and the results of the comparisons are displayed.</source>
          <target state="translated">Cinco <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objetos são criados e comparados e os resultados das comparações a são exibidos.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Calcula o número de bytes produzidos pela codificação de um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The string that contains the set of characters to encode.</source>
          <target state="translated">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Calculates the number of bytes produced by encoding the characters in the specified string.</source>
          <target state="translated">Calcula o número de bytes produzidos codificando os caracteres na cadeia de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> methods to calculate the maximum and actual number of bytes required to encode a string.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> métodos para calcular o número real e máximo de bytes necessários para codificar uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>It also displays the actual number of bytes required to store a byte stream with a byte order mark.</source>
          <target state="translated">Ele também exibe o número real de bytes necessários para armazenar um fluxo de bytes com uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Calcula o número de bytes produzidos ao codificar um conjunto de caracteres, começando no ponteiro de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requer para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Error detection is enabled and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Calcula o número de bytes produzidos codificando um conjunto de caracteres da matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>With error detection enabled, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erros habilitada, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a Latin uppercase and lowercase characters and calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">O exemplo a seguir preenche uma matriz com um latino letras maiusculas e minúsculas e chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método para determinar o número de bytes necessários para codificar caracteres latinos em minúsculas.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Ele compara esse número com o valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método, que indica o número máximo de bytes necessários para codificar caracteres latinos em minúsculas.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a combination of Greek and Cyrillic characters and calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Cyrillic characters.</source>
          <target state="translated">O exemplo a seguir preenche uma matriz com uma combinação de caracteres grego e cirílico e chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método para determinar o número de bytes necessários para codificar os caracteres cirílicos.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.</source>
          <target state="translated">Ele compara esse número com o valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método, que indica o número máximo de bytes necessários para codificar os caracteres cirílicos.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Codifica um conjunto de caracteres em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação da sequência de bytes resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">O número máximo de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados começando no ponteiro de byte especificado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by the <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> parameter.</source>
          <target state="translated">O número real de bytes gravados no local indicado pelo parâmetro <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requer para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que o número de bytes resultante.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Codifica um conjunto de caracteres da matriz de caracteres especificada na matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to encode a range of characters from a <ph id="ph2">&lt;xref:System.String&gt;</ph> and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método para codificar um intervalo de caracteres de um <ph id="ph2">&lt;xref:System.String&gt;</ph> e armazenar os bytes codificados em um intervalo de elementos em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into the specified byte array.</source>
          <target state="translated">Codifica um conjunto de caracteres do <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> especificado para a matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example demonstrates how to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">O exemplo a seguir demonstra como codificar um intervalo de elementos de uma matriz de caracteres Unicode e armazenar os bytes codificados em um intervalo de elementos em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requires to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requer para armazenar os caracteres resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method to return the number of characters produced by decoding a range of elements in a byte array using <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método para retornar o número de caracteres produzido decodificando um intervalo de elementos em uma matriz de bytes usando <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Decodifica uma sequência de bytes em um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação do conjunto de caracteres resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">O número máximo de caracteres a serem gravados.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Decodifica uma sequência de bytes começando no ponteiro de byte especificado em um conjunto de caracteres armazenados começando no ponteiro de caractere especificado.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by the <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> parameter.</source>
          <target state="translated">O número real de caracteres gravados no local indicado pelo parâmetro <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requires to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requer para armazenar os caracteres resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que o número de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">A matriz de caracteres que deve conter o conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">O número real de caracteres gravados em <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> method to decode a range of elements in a byte array and store the result in a character array.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> método para decodificar um intervalo de elementos em uma matriz de bytes e armazena o resultado em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> até o final da matriz para acomodar os caracteres resultantes.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Obtém um decodificador que converte uma sequência de bytes UTF-16 codificada em uma sequência de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> que converte uma sequência de bytes UTF-16 codificada em uma sequência de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> mantém informações de estado entre as chamadas para corretamente pode decodificar sequências de bytes que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> também preserva bytes à direita do final de blocos de dados e usa os bytes à direita na próxima operação de decodificação.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.</source>
          <target state="translated">Se detecção de erros está habilitada, ou seja, o <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro do construtor é definido como <ph id="ph2">`true`</ph>, detecção de erros também está habilitada no <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> retornado por esse método.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</source>
          <target state="translated">Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do decodificador é indefinido e processamento deve parar.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar os bytes para uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</source>
          <target state="translated">Obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-16.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-16.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method of this class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método dessa classe.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object maintains state information between calls so that it can correctly encode character sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objeto mantém informações de estado entre as chamadas para que ele pode codificar corretamente sequências de caracteres que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objeto também preserva caracteres à direita do final de blocos de dados e usa os caracteres à direita na próxima operação de codificação.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência e o correspondência substituto baixo seria o próximo bloco de dados.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> object returned by this method.</source>
          <target state="translated">Se detecção de erros está habilitada, ou seja, o <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro do construtor é definido como <ph id="ph2">`true`</ph>, detecção de erros também está habilitada no <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> objeto retornado por este método.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</source>
          <target state="translated">Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do codificador é indefinido e processamento deve parar.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar os bytes para uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Retorna o código hash para a instância atual.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetHashCode">
          <source>The hash code for the current <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object.</source>
          <target state="translated">O código hash do objeto <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>Calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Calcula o número máximo de bytes produzidos pela codificação do número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">O número máximo de bytes produzidos pela codificação do número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> recupera um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> pode retornar valores grandes.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método recupera números razoáveis para cadeias de caracteres pequenas.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> não tem nenhuma relação com <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo precisa de uma função semelhante para usar com <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>, ele deve usar <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method to return the maximum number of bytes required to encode a specified number of characters.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> método para retornar o número máximo de bytes exigido para codificar um número especificado de caracteres.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>Calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Calcula o número máximo de caracteres produzidos decodificando o número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">O número máximo de caracteres produzidos decodificando o número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, o aplicativo usa <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, o aplicativo deve usar <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> recupera um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> recupera valores grandes.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método recupera números razoáveis para cadeias de caracteres pequenas.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> não tem nenhuma relação com <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo precisa de uma função semelhante para usar com <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>, ele deve usar <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method to return the maximum number of characters produced by decoding a specified number of bytes.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> método para retornar o número máximo de caracteres produzido por um número especificado de bytes de decodificação.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</source>
          <target state="translated">Retorna uma marca de ordem de byte Unicode codificada no formato UTF-16 se o construtor dessa instância solicita uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>A byte array containing the Unicode byte order mark, if the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object is configured to supply one.</source>
          <target state="translated">Uma matriz de bytes que contém a marca de ordem de byte Unicode se o objeto <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> é configurado para fornecer uma.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Otherwise, this method returns a zero-length byte array.</source>
          <target state="translated">Caso contrário, esse método retorna uma matriz de bytes de tamanho zero.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto pode fornecer um preâmbulo, que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Iniciar uma sequência de bytes codificados com uma marca de ordem de byte (U + FEFF de ponto de código) ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</source>
          <target state="translated">A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Big endian byte order: FE FF</source>
          <target state="translated">Ordem de byte big endian: FF FE</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Little endian byte order: FF FE</source>
          <target state="translated">Ordem de bytes endian pouco: FF FE</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> do objeto cuja <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método retorna um BOM válido das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By retrieving the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Recuperando o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By calling the parameterless <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">Chamando o sem parâmetros <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By supplying <ph id="ph1">`true`</ph> as the value of the <ph id="ph2">`byteOrderMark`</ph> argument to the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> or <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructors.</source>
          <target state="translated">Fornecendo <ph id="ph1">`true`</ph> como o valor da <ph id="ph2">`byteOrderMark`</ph> argumento para o <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> construtores.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>We recommended that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</source>
          <target state="translated">É recomendável que você use o BOM, desde que ele fornece praticamente determinada identificação de uma codificação para arquivos que, caso contrário, perdeu uma referência para sua codificação, como não marcados ou marcado incorretamente dados da web ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged.</source>
          <target state="translated">Problemas de usuário geralmente podem ser evitados se dados são marcados de forma consistente e corretamente.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Para os padrões que fornecem um tipo de codificação, um BOM é um pouco redundante.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário, será perdida.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Há algumas desvantagens de usar um BOM.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Por exemplo, saber como limitar os campos de banco de dados que usam um BOM pode ser difícil.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode terminar no meio de dados.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should prefix the beginning of a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente, você deve prefixar o início de um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> método não preceda um BOM para uma sequência de bytes codificados; fornecer um BOM no início de um fluxo de bytes apropriado é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to retrieve the Unicode byte order mark in big endian or little endian byte order for an instance of a <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método para recuperar a marca de ordem de byte Unicode em big endian ou little endian bytes para uma instância de um <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The following example instantiates two <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects, the first of which does not provide a BOM, and the second of which does.</source>
          <target state="translated">O exemplo a seguir cria dois <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objetos, o primeiro deles não fornece um BOM e o segundo que não.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to write the BOM to a file before writing a Unicode-encoded string.</source>
          <target state="translated">Depois, ele chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método gravar BOM para um arquivo antes de gravar uma cadeia de caracteres codificado em Unicode.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</source>
          <target state="translated">Como mostra a saída do exemplo do console, o arquivo que salva os bytes do codificador do segundo tem três mais bytes que o primeiro.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>You can also compare the files by using the <ph id="ph1">`fc`</ph> command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</source>
          <target state="translated">Você também pode comparar os arquivos usando o <ph id="ph1">`fc`</ph> comando em uma janela de console, ou você pode inspecionar os arquivos em um editor de texto que inclui um modo de exibição hexadecimal.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Note that when the file is opened in an editor that supports UTF-16 encoding, the BOM is not displayed.</source>
          <target state="translated">Observe que, quando o arquivo é aberto em um editor que dá suporte à codificação UTF-16, a BOM não será exibida.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Decodes a range of bytes from a byte array into a string.</source>
          <target state="translated">Decodifica um intervalo de bytes de uma matriz de bytes em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example initializes an array by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</source>
          <target state="translated">O exemplo a seguir inicializa uma matriz chamando o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> método para determinar exatamente quantos bytes são necessários para uma cadeia de caracteres codificada e, em seguida, adicionar o tamanho da marca de ordem de byte (BOM).</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to store the BOM to the array before calling the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method to store the encoded bytes to the array.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> método para armazenar o BOM para a matriz antes de chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método para armazenar os bytes codificados para a matriz.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> method to decode the string.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> método decodificar a cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</source>
          <target state="translated">Observe que nesse caso a cadeia de caracteres decodificada é diferente de cadeia de caracteres original, desde que ela começa com uma marca de ordem de bytes de 16 bits U + FFFD.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</source>
          <target state="translated">Isso significa que compara duas cadeias de caracteres como diferente e que, se a cadeia de caracteres é a saída, a BOM será exibida como o caractere de substituição "?".</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>To remove the BOM at the beginning of the string, you can call the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para remover a BOM no início da cadeia de caracteres, você pode chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação mais completa)</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>