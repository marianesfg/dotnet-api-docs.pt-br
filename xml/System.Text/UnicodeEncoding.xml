<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adec01f981195b98a829302a2c5d5343b07e5e19" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39902919" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b8b35-101">Representa uma codificação de caracteres Unicode UTF-16.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b8b35-101">Represents a UTF-16 encoding of Unicode characters.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-102">Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="b8b35-103">Decodificação é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="b8b35-103">Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span>  
  
 <span data-ttu-id="b8b35-104">O [padrão Unicode](http://go.microsoft.com/fwlink/?linkid=37123) atribui um ponto de código (um número) para cada caractere em todos os scripts com suporte.</span><span class="sxs-lookup"><span data-stu-id="b8b35-104">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script.</span></span> <span data-ttu-id="b8b35-105">Um formato de transformação Unicode (UTF) é uma forma de codificar esse ponto de código.</span><span class="sxs-lookup"><span data-stu-id="b8b35-105">A Unicode Transformation Format (UTF) is a way to encode that code point.</span></span> <span data-ttu-id="b8b35-106">O [padrão Unicode](http://go.microsoft.com/fwlink/?linkid=37123) usa UTFs a seguir:</span><span class="sxs-lookup"><span data-stu-id="b8b35-106">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:</span></span>  
  
-   <span data-ttu-id="b8b35-107">UTF-8, que representa cada ponto de código como uma sequência de um a quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-107">UTF-8, which represents each code point as a sequence of one to four bytes.</span></span>  
  
-   <span data-ttu-id="b8b35-108">UTF-16, que representa cada ponto de código como uma sequência de inteiros de 16 bits de um ou dois.</span><span class="sxs-lookup"><span data-stu-id="b8b35-108">UTF-16, which represents each code point as a sequence of one to two 16-bit integers.</span></span>  
  
-   <span data-ttu-id="b8b35-109">UTF-32, que representa cada ponto de código como um inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="b8b35-109">UTF-32, which represents each code point as a 32-bit integer.</span></span>  
  
 <span data-ttu-id="b8b35-110">Para obter mais informações sobre os UTFs e outras codificações com suporte pelo <xref:System.Text>, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="b8b35-110">For more information about the UTFs and other encodings supported by <xref:System.Text>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="b8b35-111">O <xref:System.Text.UnicodeEncoding> classe representa uma codificação UTF-16.</span><span class="sxs-lookup"><span data-stu-id="b8b35-111">The <xref:System.Text.UnicodeEncoding> class represents a UTF-16 encoding.</span></span> <span data-ttu-id="b8b35-112">O codificador pode usar qualquer ordem de byte big endian (byte mais significativo primeiro) ou pouco ordem de byte endian (byte menos significativo primeiro).</span><span class="sxs-lookup"><span data-stu-id="b8b35-112">The encoder can use either big endian byte order (most significant byte first) or little endian byte order (least significant byte first).</span></span> <span data-ttu-id="b8b35-113">Por exemplo, a letra maiuscula latina um (ponto de código u+0041) é serializado como segue (em hexadecimal):</span><span class="sxs-lookup"><span data-stu-id="b8b35-113">For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="b8b35-114">Ordem de byte big endian: 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="b8b35-114">Big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="b8b35-115">Ordem de byte endian Little: 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="b8b35-115">Little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="b8b35-116">É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo de uma plataforma específica.</span><span class="sxs-lookup"><span data-stu-id="b8b35-116">It is generally more efficient to store Unicode characters using the native byte order of a particular platform.</span></span> <span data-ttu-id="b8b35-117">Por exemplo, é melhor usar a ordem de byte endian little em plataformas de endian pequeno, como computadores Intel.</span><span class="sxs-lookup"><span data-stu-id="b8b35-117">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span> <span data-ttu-id="b8b35-118">O <xref:System.Text.UnicodeEncoding> classe corresponde às páginas de código do Windows (ordem de byte endian little) de 1200 e 1201 (ordem de byte big endian).</span><span class="sxs-lookup"><span data-stu-id="b8b35-118">The <xref:System.Text.UnicodeEncoding> class corresponds to the Windows code pages 1200 (little endian byte order) and 1201 (big endian byte order).</span></span> <span data-ttu-id="b8b35-119">Você pode determinar a "endianness" de uma arquitetura específica chamando o <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-119">You can determine the "endianness" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b8b35-120">Opcionalmente, o <xref:System.Text.UnicodeEncoding> objeto fornece uma marca de ordem de byte (BOM), que é uma matriz de bytes que pode ser prefixado à sequência de bytes resultante do processo de codificação.</span><span class="sxs-lookup"><span data-stu-id="b8b35-120">Optionally, the <xref:System.Text.UnicodeEncoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="b8b35-121">Se o preâmbulo contiver uma marca de ordem de byte (BOM), ele ajuda o decodificador determinar a ordem de byte e o formato de transformação ou UTF.</span><span class="sxs-lookup"><span data-stu-id="b8b35-121">If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="b8b35-122">Se o <xref:System.Text.UnicodeEncoding> instância está configurada para fornecer um BOM, você pode recuperá-lo chamando o <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método; caso contrário, o método retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="b8b35-122">If the <xref:System.Text.UnicodeEncoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method; otherwise, the method returns an empty array.</span></span> <span data-ttu-id="b8b35-123">Observe que, mesmo se um <xref:System.Text.UnicodeEncoding> objeto está configurado para dar suporte a BOM, você deve incluir a BOM no início do fluxo de bytes codificados como apropriado; os métodos de codificação do <xref:System.Text.UnicodeEncoding> classe não fizer isso automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-123">Note that, even if a <xref:System.Text.UnicodeEncoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UnicodeEncoding> class do not do this automatically.</span></span>  
  
 <span data-ttu-id="b8b35-124">Para habilitar a detecção de erro e tornar a instância da classe mais seguro, você deve criar uma instância de um <xref:System.Text.UnicodeEncoding> objeto chamando o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidBytes` argumento `true`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-124">To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UnicodeEncoding> object by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span> <span data-ttu-id="b8b35-125">Com a detecção de erro, um método que detecta uma sequência de caracteres ou bytes inválida lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-125">With error detection, a method that detects an invalid sequence of characters or bytes throws a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-126">Sem detecção de erro, nenhuma exceção é lançada e a sequência inválida geralmente é ignorada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-126">Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</span></span>  
  
 <span data-ttu-id="b8b35-127">Você pode instanciar um <xref:System.Text.UnicodeEncoding> objeto de várias maneiras, dependendo se você deseja para que ele forneça uma marca de ordem de byte (BOM), se desejar que a codificação big-endian ou little endian e se você deseja habilitar a detecção de erro.</span><span class="sxs-lookup"><span data-stu-id="b8b35-127">You can instantiate a <xref:System.Text.UnicodeEncoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.</span></span> <span data-ttu-id="b8b35-128">A seguinte tabela lista os <xref:System.Text.UnicodeEncoding> construtores e os <xref:System.Text.Encoding> propriedades que retornam um <xref:System.Text.UnicodeEncoding> objeto.</span><span class="sxs-lookup"><span data-stu-id="b8b35-128">The following table lists the <xref:System.Text.UnicodeEncoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
|<span data-ttu-id="b8b35-129">Membro</span><span class="sxs-lookup"><span data-stu-id="b8b35-129">Member</span></span>|<span data-ttu-id="b8b35-130">Endianness</span><span class="sxs-lookup"><span data-stu-id="b8b35-130">Endianness</span></span>|<span data-ttu-id="b8b35-131">BOM</span><span class="sxs-lookup"><span data-stu-id="b8b35-131">BOM</span></span>|<span data-ttu-id="b8b35-132">Detecção de erros</span><span class="sxs-lookup"><span data-stu-id="b8b35-132">Error detection</span></span>|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|<span data-ttu-id="b8b35-133">Big-endian</span><span class="sxs-lookup"><span data-stu-id="b8b35-133">Big-endian</span></span>|<span data-ttu-id="b8b35-134">Sim</span><span class="sxs-lookup"><span data-stu-id="b8b35-134">Yes</span></span>|<span data-ttu-id="b8b35-135">Nenhum (fallback de substituição)</span><span class="sxs-lookup"><span data-stu-id="b8b35-135">No (Replacement fallback)</span></span>|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|<span data-ttu-id="b8b35-136">Little-endian</span><span class="sxs-lookup"><span data-stu-id="b8b35-136">Little-endian</span></span>|<span data-ttu-id="b8b35-137">Sim</span><span class="sxs-lookup"><span data-stu-id="b8b35-137">Yes</span></span>|<span data-ttu-id="b8b35-138">Nenhum (fallback de substituição)</span><span class="sxs-lookup"><span data-stu-id="b8b35-138">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|<span data-ttu-id="b8b35-139">Little-endian</span><span class="sxs-lookup"><span data-stu-id="b8b35-139">Little-endian</span></span>|<span data-ttu-id="b8b35-140">Sim</span><span class="sxs-lookup"><span data-stu-id="b8b35-140">Yes</span></span>|<span data-ttu-id="b8b35-141">Nenhum (fallback de substituição)</span><span class="sxs-lookup"><span data-stu-id="b8b35-141">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|<span data-ttu-id="b8b35-142">Configurável</span><span class="sxs-lookup"><span data-stu-id="b8b35-142">Configurable</span></span>|<span data-ttu-id="b8b35-143">Configurável</span><span class="sxs-lookup"><span data-stu-id="b8b35-143">Configurable</span></span>|<span data-ttu-id="b8b35-144">Nenhum (fallback de substituição)</span><span class="sxs-lookup"><span data-stu-id="b8b35-144">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|<span data-ttu-id="b8b35-145">Configurável</span><span class="sxs-lookup"><span data-stu-id="b8b35-145">Configurable</span></span>|<span data-ttu-id="b8b35-146">Configurável</span><span class="sxs-lookup"><span data-stu-id="b8b35-146">Configurable</span></span>|<span data-ttu-id="b8b35-147">Configurável</span><span class="sxs-lookup"><span data-stu-id="b8b35-147">Configurable</span></span>|  
  
 <span data-ttu-id="b8b35-148">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.UnicodeEncoding.GetBytes%2A> método executa a codificação real.</span><span class="sxs-lookup"><span data-stu-id="b8b35-148">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method performs the actual encoding.</span></span>  
  
 <span data-ttu-id="b8b35-149">Da mesma forma, o <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.UnicodeEncoding.GetChars%2A> e <xref:System.Text.UnicodeEncoding.GetString%2A> métodos executam a decodificação real.</span><span class="sxs-lookup"><span data-stu-id="b8b35-149">Likewise, the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UnicodeEncoding.GetChars%2A> and <xref:System.Text.UnicodeEncoding.GetString%2A> methods perform the actual decoding.</span></span>  
  
 <span data-ttu-id="b8b35-150">Para um codificador ou decodificador é capaz de salvar informações de estado ao codificar ou decodificar dados que abrange vários blocos (como cadeia de caracteres de 1 milhão de caracteres codificada em segmentos de caractere de 100.000), use o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> e <xref:System.Text.UnicodeEncoding.GetDecoder%2A> propriedades, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-150">For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> and <xref:System.Text.UnicodeEncoding.GetDecoder%2A> properties, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-151">O exemplo a seguir demonstra como codificar uma cadeia de caracteres Unicode em uma matriz de bytes usando uma <xref:System.Text.UnicodeEncoding> objeto.</span><span class="sxs-lookup"><span data-stu-id="b8b35-151">The following example demonstrates how to encode a string of Unicode characters into a byte array by using a <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="b8b35-152">A matriz de bytes é decodificada em uma cadeia de caracteres para demonstrar que não haja nenhuma perda de dados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-152">The byte array is decoded into a string to demonstrate that there is no loss of data.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 <span data-ttu-id="b8b35-153">O exemplo a seguir usa a mesma cadeia de caracteres que o anterior, exceto que ele grava os bytes codificados em um arquivo e prefixos de fluxo de bytes com uma marca de ordem de byte (BOM).</span><span class="sxs-lookup"><span data-stu-id="b8b35-153">The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</span></span> <span data-ttu-id="b8b35-154">Ele, em seguida, lê o arquivo de duas maneiras diferentes: como um arquivo de texto usando um <xref:System.IO.StreamReader> do objeto; e como um arquivo binário.</span><span class="sxs-lookup"><span data-stu-id="b8b35-154">It then reads the file in two different ways: as a text file by using a <xref:System.IO.StreamReader> object; and as a binary file.</span></span> <span data-ttu-id="b8b35-155">Como você esperaria, nem caso está BOM incluído na cadeia de leitura recentemente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-155">As you would expect, in neither case is the BOM included in the newly read string.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-156">Inicializa uma nova instância da classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-156">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-157">Inicializa uma nova instância da classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-157">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-158">Este construtor cria uma instância que usa a ordem de byte endian little, fornece uma marca de ordem de byte Unicode e não lança uma exceção quando uma codificação inválida for detectada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-158">This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-159">Por motivos de segurança, você deve habilitar a detecção de erro chamando o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidBytes` argumento `true`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-159">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-160">O exemplo a seguir demonstra como criar um novo <xref:System.Text.UnicodeEncoding> da instância e exibir o nome da codificação.</span><span class="sxs-lookup"><span data-stu-id="b8b35-160">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance and display the name of the encoding.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="b8b35-161">
            <see langword="true" /> para usar a ordem de byte big endian (byte mais significativo primeiro) ou <see langword="false" /> para usar a ordem de byte little endian (byte menos significativo primeiro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-161">
              <see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="b8b35-162">
            <see langword="true" /> para especificar que o método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retorna uma marca de ordem de byte Unicode, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-162">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-163">Inicializa uma nova instância da classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-163">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="b8b35-164">Os parâmetros especificam se é necessário usar a ordem de byte big endian e se o método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retorna uma marca de ordem de byte Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-164">Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-165">Este construtor cria uma instância que não gerará uma exceção quando uma codificação inválida for detectada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-165">This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-166">Por motivos de segurança, você deve habilitar a detecção de erro chamando o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidBytes` argumento `true`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-166">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
 <span data-ttu-id="b8b35-167">O `byteOrderMark` parâmetro controla a operação do <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-167">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="b8b35-168">Se `true`, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-16.</span><span class="sxs-lookup"><span data-stu-id="b8b35-168">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="b8b35-169">Se `false`, ele retorna uma matriz de bytes de comprimento zero.</span><span class="sxs-lookup"><span data-stu-id="b8b35-169">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="b8b35-170">No entanto, definindo `byteOrderMark` para `true` não causa a <xref:System.Text.UnicodeEncoding.GetBytes%2A> método prefixar a BOM no início da matriz de bytes, nem o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método incluir o número de bytes na BOM na contagem de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-170">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-171">O exemplo a seguir demonstra como criar um novo <xref:System.Text.UnicodeEncoding> marca de ordem de instância, especificando se é dar suporte à ordenação pouco byte de endian ou big endian e o byte Unicode.</span><span class="sxs-lookup"><span data-stu-id="b8b35-171">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance specifying whether to support little endian or big endian byte ordering and the Unicode byte order mark.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="b8b35-172">
            <see langword="true" /> para usar a ordem de byte big endian (byte mais significativo primeiro); <see langword="false" /> para usar a ordem de byte little endian (byte menos significativo primeiro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-172">
              <see langword="true" /> to use the big endian byte order (most significant byte first); <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="b8b35-173">
            <see langword="true" /> para especificar que o método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retorna uma marca de ordem de byte Unicode, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-173">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="throwOnInvalidBytes">
          <span data-ttu-id="b8b35-174">
            <see langword="true" /> para especificar que uma exceção deverá ser gerada quando uma codificação inválida for detectada; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-174">
              <see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-175">Inicializa uma nova instância da classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-175">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="b8b35-176">Os parâmetros especificam se é necessário usar a ordem de byte big endian, fornecer uma marca de ordem de byte Unicode e gerar uma exceção quando uma codificação inválida for detectada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-176">Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-177">O `byteOrderMark` parâmetro controla a operação do <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-177">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="b8b35-178">Se `true`, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-16.</span><span class="sxs-lookup"><span data-stu-id="b8b35-178">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="b8b35-179">Se `false`, ele retorna uma matriz de bytes de comprimento zero.</span><span class="sxs-lookup"><span data-stu-id="b8b35-179">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="b8b35-180">No entanto, definindo `byteOrderMark` para `true` não causa a <xref:System.Text.UnicodeEncoding.GetBytes%2A> método prefixar a BOM no início da matriz de bytes, nem o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método incluir o número de bytes na BOM na contagem de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-180">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
 <span data-ttu-id="b8b35-181">Se o `throwOnInvalidBytes` parâmetro é `true`, um método que detecta uma sequência de bytes inválido lança <xref:System.ArgumentException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-181">If the `throwOnInvalidBytes` parameter is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b8b35-182">Caso contrário, o método não lança uma exceção, e a sequência inválida é ignorada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-182">Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-183">Por motivos de segurança, os aplicativos são recomendados para usar esse construtor para criar uma instância das <xref:System.Text.UnicodeEncoding> de classe e ative a detecção de erro, definindo `throwOnInvalidBytes` para `true`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-183">For security reasons, your applications are recommended to use this constructor to create an instance of the <xref:System.Text.UnicodeEncoding> class and turn on error detection by setting `throwOnInvalidBytes` to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-184">O exemplo a seguir demonstra o comportamento de <xref:System.Text.UnicodeEncoding>, com a detecção de erro habilitada e sem.</span><span class="sxs-lookup"><span data-stu-id="b8b35-184">The following example demonstrates the behavior of <xref:System.Text.UnicodeEncoding>, both with error detection enabled and without.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-185">Representa o tamanho do caractere Unicode em bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-185">Represents the Unicode character size in bytes.</span>
          </span>
          <span data-ttu-id="b8b35-186">Este campo é uma constante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-186">This field is a constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-187">O valor desse campo é uma constante de com sinal de 32 bits com um valor de 2.</span><span class="sxs-lookup"><span data-stu-id="b8b35-187">The value of this field is a 32-bit signed constant with a value of 2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-188">O exemplo a seguir demonstra como retornar o valor de <xref:System.Text.UnicodeEncoding.CharSize> e exibi-lo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-188">The following example demonstrates how to return the value of <xref:System.Text.UnicodeEncoding.CharSize> and display it.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b8b35-189">O objeto a ser comparado com o objeto atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-189">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-190">Determina se o <see cref="T:System.Object" /> especificado é igual ao objeto <see cref="T:System.Text.UnicodeEncoding" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-190">Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-191">
            <see langword="true" /> se <paramref name="value" /> for uma instância de <see cref="T:System.Text.UnicodeEncoding" /> e for igual ao objeto atual, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-191">
              <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UnicodeEncoding" /> and is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-192">Dois <xref:System.Text.UnicodeEncoding> objetos são considerados iguais se todas as seguintes condições forem verdadeiras:</span><span class="sxs-lookup"><span data-stu-id="b8b35-192">Two <xref:System.Text.UnicodeEncoding> objects are considered equal if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="b8b35-193">Os dois objetos usam a mesma ordem de byte (little endian ou big-endian).</span><span class="sxs-lookup"><span data-stu-id="b8b35-193">Both objects use the same byte order (little-endian or big-endian).</span></span>  
  
-   <span data-ttu-id="b8b35-194">Os dois objetos fornecem a marca de ordem de byte, ou ambos não fizer isso.</span><span class="sxs-lookup"><span data-stu-id="b8b35-194">Both objects provide the byte order mark, or both do not.</span></span>  
  
-   <span data-ttu-id="b8b35-195">Os dois objetos usam o mesmo fallback do decodificador.</span><span class="sxs-lookup"><span data-stu-id="b8b35-195">Both objects use the same encoder fallback.</span></span>  
  
-   <span data-ttu-id="b8b35-196">Os dois objetos usam o mesmo fallback do decodificador.</span><span class="sxs-lookup"><span data-stu-id="b8b35-196">Both objects use the same decoder fallback.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-197">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.Equals%2A> método para testar se o atual <xref:System.Text.UnicodeEncoding> objeto é igual a outro <xref:System.Text.UnicodeEncoding> objeto.</span><span class="sxs-lookup"><span data-stu-id="b8b35-197">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.Equals%2A> method to test whether the current <xref:System.Text.UnicodeEncoding> object is equal to a different <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="b8b35-198">Cinco <xref:System.Text.UnicodeEncoding> objetos são criados e comparados e os resultados das comparações são exibidos.</span><span class="sxs-lookup"><span data-stu-id="b8b35-198">Five <xref:System.Text.UnicodeEncoding> objects are created and compared, and the results of the comparisons are displayed.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-199">Calcula o número de bytes produzidos pela codificação de um conjunto de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-199">Calculates the number of bytes produced by encoding a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="b8b35-200">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-200">The string that contains the set of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-201">Calcula o número de bytes produzidos codificando os caracteres na cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-201">Calculates the number of bytes produced by encoding the characters in the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-202">O número de bytes produzidos por codificação de caracteres especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-202">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-203">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-203">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-204">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-204">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-205">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-205">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-206">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-206">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-207">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-207">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-208">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-208">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-209">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-209">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-210">A exemplo a seguir chama o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> e <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> métodos para calcular o número real e máximo de bytes necessários para codificar uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-210">The following example calls the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> and <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> methods to calculate the maximum and actual number of bytes required to encode a string.</span></span> <span data-ttu-id="b8b35-211">Ele também exibe o número real de bytes necessários para armazenar um fluxo de bytes com uma marca de ordem de byte.</span><span class="sxs-lookup"><span data-stu-id="b8b35-211">It also displays the actual number of bytes required to store a byte stream with a byte order mark.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-212">
            <paramref name="s" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-212">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-213">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-213">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-214">A detecção de erros está habilitada e <paramref name="s" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-214">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-215">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-215">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-216">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-216">-and-</span>
          </span>
          <span data-ttu-id="b8b35-217">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-217">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="b8b35-218">Um ponteiro para o primeiro caractere a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-218">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b8b35-219">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-219">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-220">Calcula o número de bytes produzidos ao codificar um conjunto de caracteres, começando no ponteiro de caracteres especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-220">Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-221">O número de bytes produzidos por codificação de caracteres especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-221">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-222">Para calcular a matriz exata tamanho que <xref:System.Text.UnicodeEncoding.GetBytes%2A> requer para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-222">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-223">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-223">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-224">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-224">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-225">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-225">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-226">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-226">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-227">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-227">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-228">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UTF8Encoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-228">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-229">
            <paramref name="chars" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-229">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-230">
            <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-230">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-231">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-231">-or-</span>
          </span>
          <span data-ttu-id="b8b35-232">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-232">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-233">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-233">Error detection is enabled and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-234">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-234">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-235">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-235">-and-</span>
          </span>
          <span data-ttu-id="b8b35-236">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-236">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b8b35-237">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-237">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b8b35-238">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-238">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="b8b35-239">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-239">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="b8b35-240">O índice do primeiro caractere a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-240">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b8b35-241">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-241">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-242">Calcula o número de bytes produzidos codificando um conjunto de caracteres da matriz de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-242">Calculates the number of bytes produced by encoding a set of characters from the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-243">O número de bytes produzidos por codificação de caracteres especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-243">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-244">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetBytes%2A> para armazenar os bytes resultantes, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-244">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="b8b35-245">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-245">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-246">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-246">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-247">Com a detecção de erro habilitada, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-247">With error detection enabled, an invalid sequence causes this method to throw an <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-248">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-248">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-249">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-249">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-250">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-250">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-251">O exemplo a seguir preenche uma matriz com um latino maiusculos e minúsculos e chamadas a <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar o número de bytes necessários para codificar os caracteres latinos de letras minúsculas.</span><span class="sxs-lookup"><span data-stu-id="b8b35-251">The following example populates an array with a Latin uppercase and lowercase characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="b8b35-252">Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada a uma marca de ordem de byte.</span><span class="sxs-lookup"><span data-stu-id="b8b35-252">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="b8b35-253">Ele compara esse número com o valor retornado pelo <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica o número máximo de bytes necessários para codificar os caracteres latinos de letras minúsculas.</span><span class="sxs-lookup"><span data-stu-id="b8b35-253">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="b8b35-254">O exemplo a seguir preenche uma matriz com uma combinação de caracteres grego e cirílico e chama o <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar o número de bytes necessários para codificar os caracteres cirílicos.</span><span class="sxs-lookup"><span data-stu-id="b8b35-254">The following example populates an array with a combination of Greek and Cyrillic characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Cyrillic characters.</span></span> <span data-ttu-id="b8b35-255">Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada a uma marca de ordem de byte.</span><span class="sxs-lookup"><span data-stu-id="b8b35-255">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="b8b35-256">Ele compara esse número com o valor retornado pelo <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica o número máximo de bytes necessários para codificar os caracteres cirílicos.</span><span class="sxs-lookup"><span data-stu-id="b8b35-256">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-257">
            <paramref name="chars" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-257">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-258">
            <paramref name="index" /> ou <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-258">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-259">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-259">-or-</span>
          </span>
          <span data-ttu-id="b8b35-260">
            <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-260">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="b8b35-261">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-261">-or-</span>
          </span>
          <span data-ttu-id="b8b35-262">Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-262">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-263">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-263">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-264">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-264">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-265">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-265">-and-</span>
          </span>
          <span data-ttu-id="b8b35-266">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-266">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-267">Codifica um conjunto de caracteres em uma sequência de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-267">Encodes a set of characters into a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="b8b35-268">Um ponteiro para o primeiro caractere a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-268">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="b8b35-269">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-269">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="b8b35-270">Um ponteiro para o local no qual a gravação da sequência de bytes resultante deve ser iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-270">A pointer to the location at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="b8b35-271">O número máximo de bytes a serem gravados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-271">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-272">Codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados começando no ponteiro de byte especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-272">Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-273">O número real de bytes gravados no local indicado pelo parâmetro <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-273">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-274">Para calcular a matriz exata tamanho que <xref:System.Text.UnicodeEncoding.GetBytes%2A> requer para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-274">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-275">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-275">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-276">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-276">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-277">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-277">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-278">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-278">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-279">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-279">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-280">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> objeto fornecido pela <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-280">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-281">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-281">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-282">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="b8b35-282">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="b8b35-283">O <xref:System.Text.UnicodeEncoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-283">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-284">
            <paramref name="chars" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-284">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="b8b35-285">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-285">-or-</span>
          </span>
          <span data-ttu-id="b8b35-286">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-286">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-287">
            <paramref name="charCount" /> ou <paramref name="byteCount" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-287">
              <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-288">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-288">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="b8b35-289">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-289">-or-</span>
          </span>
          <span data-ttu-id="b8b35-290">
            <paramref name="byteCount" /> é menor que o número de bytes resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-290">
              <paramref name="byteCount" /> is less than the resulting number of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-291">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-291">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-292">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-292">-and-</span>
          </span>
          <span data-ttu-id="b8b35-293">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-293">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b8b35-294">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-294">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b8b35-295">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-295">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="b8b35-296">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-296">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="b8b35-297">O índice do primeiro caractere a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-297">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="b8b35-298">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-298">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="b8b35-299">A matriz de bytes que conterá a sequência de bytes resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-299">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="b8b35-300">O índice no qual será iniciada a gravação da sequência de bytes resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-300">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-301">Codifica um conjunto de caracteres da matriz de caracteres especificada na matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-301">Encodes a set of characters from the specified character array into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-302">O número real de bytes gravados no <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-302">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-303">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-303">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-304">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-304">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-305">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-305">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-306">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-306">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-307">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-307">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-308">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-308">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-309">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-309">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-310">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-310">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-311">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="b8b35-311">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="b8b35-312">O <xref:System.Text.UnicodeEncoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-312">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-313">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetBytes%2A> para codificar um intervalo de caracteres de um <xref:System.String> e armazenar os bytes codificados em um intervalo de elementos em uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-313">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to encode a range of characters from a <xref:System.String> and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-314">
            <paramref name="chars" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-314">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="b8b35-315">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-315">-or-</span>
          </span>
          <span data-ttu-id="b8b35-316">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-316">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-317">
            <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-317">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-318">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-318">-or-</span>
          </span>
          <span data-ttu-id="b8b35-319">
            <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-319">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="b8b35-320">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-320">-or-</span>
          </span>
          <span data-ttu-id="b8b35-321">
            <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-321">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-322">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-322">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="b8b35-323">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-323">-or-</span>
          </span>
          <span data-ttu-id="b8b35-324">O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-324">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-325">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-325">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-326">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-326">-and-</span>
          </span>
          <span data-ttu-id="b8b35-327">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-327">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="b8b35-328">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-328">The string containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="b8b35-329">O índice do primeiro caractere a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-329">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="b8b35-330">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-330">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="b8b35-331">A matriz de bytes que conterá a sequência de bytes resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-331">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="b8b35-332">O índice no qual será iniciada a gravação da sequência de bytes resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-332">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-333">Codifica um conjunto de caracteres do <see cref="T:System.String" /> especificado para a matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-333">Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-334">O número real de bytes gravados no <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-334">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-335">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-335">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-336">Para calcular o tamanho máximo da matriz, você deve chamar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-336">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="b8b35-337">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-337">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-338">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-338">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-339">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-339">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-340">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-340">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-341">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-341">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-342">Para garantir que os bytes codificados são decodificados corretamente quando eles são salvos como um arquivo ou como um fluxo, você pode prefixar um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-342">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-343">Inserir o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="b8b35-343">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="b8b35-344">O <xref:System.Text.UnicodeEncoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-344">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-345">O exemplo a seguir demonstra como codificar um intervalo de elementos de uma matriz de caracteres Unicode e armazenar os bytes codificados em um intervalo de elementos em uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-345">The following example demonstrates how to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-346">
            <paramref name="s" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-346">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b8b35-347">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-347">-or-</span>
          </span>
          <span data-ttu-id="b8b35-348">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-348">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-349">
            <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-349">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-350">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-350">-or-</span>
          </span>
          <span data-ttu-id="b8b35-351">
            <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-351">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="b8b35-352">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-352">-or-</span>
          </span>
          <span data-ttu-id="b8b35-353">
            <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-353">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-354">A detecção de erros está habilitada e <paramref name="s" /> contém uma sequência de caracteres inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-354">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="b8b35-355">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-355">-or-</span>
          </span>
          <span data-ttu-id="b8b35-356">O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-356">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-357">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-357">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-358">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-358">-and-</span>
          </span>
          <span data-ttu-id="b8b35-359">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-359">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-360">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-360">Calculates the number of characters produced by decoding a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="b8b35-361">Um ponteiro do primeiro byte a ser decodificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-361">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b8b35-362">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-362">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-363">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-363">Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-364">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-364">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-365">Para calcular a matriz exata tamanho que <xref:System.Text.UnicodeEncoding.GetChars%2A> requer para armazenar os caracteres resultantes, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-365">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="b8b35-366">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-366">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="b8b35-367">O <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-367">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-368">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-368">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-369">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-369">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-370">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-370">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-371">
            <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-371">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-372">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-372">-or-</span>
          </span>
          <span data-ttu-id="b8b35-373">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-373">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-374">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-374">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-375">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-375">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-376">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-376">-and-</span>
          </span>
          <span data-ttu-id="b8b35-377">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-377">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b8b35-378">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-378">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b8b35-379">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-379">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="b8b35-380">A matriz de bytes que contém a sequência de bytes a ser decodificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-380">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="b8b35-381">O índice do primeiro byte a ser decodificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-381">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b8b35-382">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-382">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-383">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-383">Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-384">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-384">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-385">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetChars%2A> para armazenar os caracteres do resultado, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-385">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="b8b35-386">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-386">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="b8b35-387">O <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-387">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-388">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-388">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-389">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-389">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-390">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método para retornar o número de caracteres produzidos pela decodificação de um intervalo de elementos em uma matriz de bytes usando <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-390">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method to return the number of characters produced by decoding a range of elements in a byte array using <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-391">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-391">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-392">
            <paramref name="index" /> ou <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-392">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-393">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-393">-or-</span>
          </span>
          <span data-ttu-id="b8b35-394">
            <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-394">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="b8b35-395">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-395">-or-</span>
          </span>
          <span data-ttu-id="b8b35-396">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-396">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-397">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-397">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-398">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-398">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-399">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-399">-and-</span>
          </span>
          <span data-ttu-id="b8b35-400">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-400">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-401">Decodifica uma sequência de bytes em um conjunto de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-401">Decodes a sequence of bytes into a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="b8b35-402">Um ponteiro do primeiro byte a ser decodificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-402">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="b8b35-403">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-403">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="b8b35-404">Um ponteiro para o local no qual a gravação do conjunto de caracteres resultante deve ser iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-404">A pointer to the location at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="b8b35-405">O número máximo de caracteres a serem gravados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-405">The maximum number of characters to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-406">Decodifica uma sequência de bytes começando no ponteiro de byte especificado em um conjunto de caracteres armazenados começando no ponteiro de caractere especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-406">Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-407">O número real de caracteres gravados no local indicado pelo parâmetro <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-407">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-408">Para calcular a matriz exata tamanho que <xref:System.Text.UnicodeEncoding.GetChars%2A> requer para armazenar os caracteres resultantes, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-408">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="b8b35-409">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-409">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="b8b35-410">O <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-410">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-411">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-411">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-412">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-412">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-413">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo de não-BOM ciente, o caractere U + FFFE está incluído na matriz de caracteres retornada por esse método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-413">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="b8b35-414">Você pode removê-lo chamando o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-414">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b8b35-415">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-415">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-416">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> objeto fornecido pela <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-416">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-417">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-417">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="b8b35-418">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-418">-or-</span>
          </span>
          <span data-ttu-id="b8b35-419">
            <paramref name="chars" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-419">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-420">
            <paramref name="byteCount" /> ou <paramref name="charCount" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-420">
              <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-421">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-421">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="b8b35-422">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-422">-or-</span>
          </span>
          <span data-ttu-id="b8b35-423">
            <paramref name="charCount" /> é menor que o número de caracteres resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-423">
              <paramref name="charCount" /> is less than the resulting number of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-424">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-424">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-425">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-425">-and-</span>
          </span>
          <span data-ttu-id="b8b35-426">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-426">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b8b35-427">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b8b35-428">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="b8b35-429">A matriz de bytes que contém a sequência de bytes a ser decodificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-429">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="b8b35-430">O índice do primeiro byte a ser decodificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-430">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="b8b35-431">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-431">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="b8b35-432">A matriz de caracteres que deve conter o conjunto de caracteres resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-432">The character array to contain the resulting set of characters.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="b8b35-433">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-433">The index at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-434">Decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-434">Decodes a sequence of bytes from the specified byte array into the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-435">O número real de caracteres gravados em <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-435">The actual number of characters written into <paramref name="chars" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-436">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetChars%2A> para armazenar os caracteres do resultado, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-436">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="b8b35-437">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-437">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="b8b35-438">O <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-438">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-439">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-439">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-440">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-440">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-441">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo de não-BOM ciente, o caractere U + FFFE está incluído na matriz de caracteres retornada por esse método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-441">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="b8b35-442">Você pode removê-lo chamando o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-442">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b8b35-443">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-443">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-444">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-444">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-445">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetChars%2A> método para decodificar um intervalo de elementos em uma matriz de bytes e armazena o resultado em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-445">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetChars%2A> method to decode a range of elements in a byte array and store the result in a character array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-446">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-446">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="b8b35-447">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-447">-or-</span>
          </span>
          <span data-ttu-id="b8b35-448">
            <paramref name="chars" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-448">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-449">
            <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-449">
              <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-450">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-450">-or-</span>
          </span>
          <span data-ttu-id="b8b35-451">
            <paramref name="byteindex" /> e <paramref name="byteCount" /> não denotam um intervalo válido em <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-451">
              <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="b8b35-452">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-452">-or-</span>
          </span>
          <span data-ttu-id="b8b35-453">
            <paramref name="charIndex" /> não é um índice válido em <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-453">
              <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-454">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-454">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="b8b35-455">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-455">-or-</span>
          </span>
          <span data-ttu-id="b8b35-456">
            <paramref name="chars" /> não tem capacidade suficiente do <paramref name="charIndex" /> até o final da matriz para acomodar os caracteres resultantes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-456">
              <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-457">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-457">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-458">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-458">-and-</span>
          </span>
          <span data-ttu-id="b8b35-459">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-459">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-460">Obtém um decodificador que converte uma sequência de bytes UTF-16 codificada em uma sequência de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-460">Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-461">Um <see cref="T:System.Text.Decoder" /> que converte uma sequência de bytes UTF-16 codificada em uma sequência de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-461">A <see cref="T:System.Text.Decoder" /> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-462">O <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-462">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="b8b35-463">No entanto, um <xref:System.Text.Decoder> mantém informações de estado entre chamadas para que ele corretamente pode decodificar sequências de bytes que abrangem os blocos.</span><span class="sxs-lookup"><span data-stu-id="b8b35-463">However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks.</span></span> <span data-ttu-id="b8b35-464">O <xref:System.Text.Decoder> também preserva bytes à direita no final de blocos de dados e usa os bytes à direita na próxima operação de decodificação.</span><span class="sxs-lookup"><span data-stu-id="b8b35-464">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="b8b35-465">Portanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> e <xref:System.Text.UnicodeEncoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações costumam lidam com os blocos de dados em vez de um fluxo de dados completo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-465">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="b8b35-466">Se a detecção de erro está habilitada, ou seja, o `throwOnInvalidBytes` parâmetro do construtor é definido como `true`, detecção de erro também é habilitada no <xref:System.Text.Decoder> retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-466">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method.</span></span> <span data-ttu-id="b8b35-467">Se a detecção de erros está habilitada e uma sequência inválida é encontrada, o estado do decodificador é indefinido e o processamento deve parar.</span><span class="sxs-lookup"><span data-stu-id="b8b35-467">If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-468">O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar bytes em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-468">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-469">Obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-16.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-469">Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-470">Um objeto <see cref="T:System.Text.Encoder" /> que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-16.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-470">A <see cref="T:System.Text.Encoder" /> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-471">O <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes de maneira semelhante para o <xref:System.Text.UnicodeEncoding.GetBytes%2A> método dessa classe.</span><span class="sxs-lookup"><span data-stu-id="b8b35-471">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes in a manner similar to the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="b8b35-472">No entanto, um <xref:System.Text.Encoder> objeto mantém informações de estado entre chamadas para que ele pode codificar corretamente as sequências de caracteres que abrangem os blocos.</span><span class="sxs-lookup"><span data-stu-id="b8b35-472">However, a <xref:System.Text.Encoder> object maintains state information between calls so that it can correctly encode character sequences that span blocks.</span></span> <span data-ttu-id="b8b35-473">O <xref:System.Text.Encoder> objeto também preserva caracteres à direita no final de blocos de dados e usa os caracteres à direita na próxima operação de codifica.</span><span class="sxs-lookup"><span data-stu-id="b8b35-473">The <xref:System.Text.Encoder> object also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="b8b35-474">Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência, e o substituto baixo correspondente pode ser no próximo bloco de dados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-474">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="b8b35-475">Portanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> e <xref:System.Text.UnicodeEncoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações costumam lidam com os blocos de dados em vez de um fluxo de dados completo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-475">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="b8b35-476">Se a detecção de erro está habilitada, ou seja, o `throwOnInvalidBytes` parâmetro do construtor é definido como `true`, detecção de erro também é habilitada no <xref:System.Text.Encoder> objeto retornado por esse método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-476">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> object returned by this method.</span></span> <span data-ttu-id="b8b35-477">Se a detecção de erros está habilitada e uma sequência inválida é encontrada, o estado do codificador é indefinido e o processamento deve parar.</span><span class="sxs-lookup"><span data-stu-id="b8b35-477">If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-478">O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar bytes em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-478">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-479">Retorna o código hash para a instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-479">Returns the hash code for the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-480">O código hash do objeto <see cref="T:System.Text.UnicodeEncoding" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-480">The hash code for the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">
          <span data-ttu-id="b8b35-481">O número de caracteres a ser codificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-481">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-482">Calcula o número máximo de bytes produzidos pela codificação do número de caracteres especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-482">Calculates the maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-483">O número máximo de bytes produzidos pela codificação do número de caracteres especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-483">The maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-484">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetBytes%2A> para armazenar os bytes resultantes, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-484">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="b8b35-485">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-485">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span> <span data-ttu-id="b8b35-486">O <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-486">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> recupera um número de pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="b8b35-488">Se um fallback for escolhido com uma cadeia de caracteres potencialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> pode retornar valores grandes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-488">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> can return large values.</span></span>  
  
 <span data-ttu-id="b8b35-489">Na maioria dos casos, esse método recupera números razoáveis para pequenas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-489">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="b8b35-490">Para grandes cadeias de caracteres, você terá que escolher entre o uso de buffers muito grandes e captura de erros no caso raro em que um buffer mais razoável é excedido.</span><span class="sxs-lookup"><span data-stu-id="b8b35-490">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="b8b35-491">Você também poderá considerar o uso uma abordagem diferente <xref:System.Text.UnicodeEncoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-491">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b8b35-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> não tem nenhuma relação com <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="b8b35-493">Se seu aplicativo precisa de uma função semelhante para usar com <xref:System.Text.UnicodeEncoding.GetChars%2A>, ele deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-493">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetChars%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-494">`GetMaxByteCount(N)` não é necessariamente o mesmo valor que `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-494">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-495">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método para retornar o número máximo de bytes necessários para codificar um número especificado de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-495">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method to return the maximum number of bytes required to encode a specified number of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-496">
            <paramref name="charCount" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-496">
              <paramref name="charCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-497">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-497">-or-</span>
          </span>
          <span data-ttu-id="b8b35-498">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-498">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="b8b35-499">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-499">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-500">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-500">-and-</span>
          </span>
          <span data-ttu-id="b8b35-501">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-501">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">
          <span data-ttu-id="b8b35-502">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-502">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-503">Calcula o número máximo de caracteres produzidos decodificando o número de bytes especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-503">Calculates the maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-504">O número máximo de caracteres produzidos decodificando o número de bytes especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-504">The maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-505">Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.UnicodeEncoding.GetChars%2A> para armazenar os caracteres do resultado, o aplicativo usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-505">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="b8b35-506">Para calcular o tamanho máximo da matriz, o aplicativo deve usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-506">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="b8b35-507">O <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-507">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="b8b35-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> recupera um número de pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="b8b35-509">Se um fallback for escolhido com uma cadeia de caracteres potencialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> recupera valores grandes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-509">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="b8b35-510">Na maioria dos casos, esse método recupera números razoáveis para pequenas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-510">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="b8b35-511">Para grandes cadeias de caracteres, você terá que escolher entre o uso de buffers muito grandes e captura de erros no caso raro em que um buffer mais razoável é excedido.</span><span class="sxs-lookup"><span data-stu-id="b8b35-511">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="b8b35-512">Você também poderá considerar o uso uma abordagem diferente <xref:System.Text.UnicodeEncoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-512">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.</span></span>  
  
 <span data-ttu-id="b8b35-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> não tem nenhuma relação com <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span></span> <span data-ttu-id="b8b35-514">Se seu aplicativo precisa de uma função semelhante para usar com <xref:System.Text.UnicodeEncoding.GetBytes%2A>, ele deve usar <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-514">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetBytes%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8b35-515">`GetMaxCharCount(N)` não é necessariamente o mesmo valor que `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="b8b35-515">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-516">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método para retornar o número máximo de caracteres produzidos pela decodificação de um número especificado de bytes.</span><span class="sxs-lookup"><span data-stu-id="b8b35-516">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method to return the maximum number of characters produced by decoding a specified number of bytes.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-517">
            <paramref name="byteCount" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-517">
              <paramref name="byteCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-518">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-518">-or-</span>
          </span>
          <span data-ttu-id="b8b35-519">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-519">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-520">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-520">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-521">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-521">-and-</span>
          </span>
          <span data-ttu-id="b8b35-522">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-522">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b8b35-523">Retorna uma marca de ordem de byte Unicode codificada no formato UTF-16 se o construtor dessa instância solicita uma marca de ordem de byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-523">Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-524">Uma matriz de bytes que contém a marca de ordem de byte Unicode se o objeto <see cref="T:System.Text.UnicodeEncoding" /> é configurado para fornecer uma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-524">A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UnicodeEncoding" /> object is configured to supply one.</span>
          </span>
          <span data-ttu-id="b8b35-525">Caso contrário, esse método retorna uma matriz de bytes de tamanho zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-525">Otherwise, this method returns a zero-length byte array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-526">O <xref:System.Text.UnicodeEncoding> objeto pode fornecer um preâmbulo, que é uma matriz de bytes que pode ser prefixada à sequência de bytes resultante do processo de codificação.</span><span class="sxs-lookup"><span data-stu-id="b8b35-526">The <xref:System.Text.UnicodeEncoding> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="b8b35-527">Preceder uma sequência de bytes codificados com uma marca de ordem de byte (ponto de código U + FEFF) ajuda o decodificador determinar a ordem de byte e o formato de transformação ou UTF.</span><span class="sxs-lookup"><span data-stu-id="b8b35-527">Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format or UTF.</span></span> <span data-ttu-id="b8b35-528">A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):</span><span class="sxs-lookup"><span data-stu-id="b8b35-528">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="b8b35-529">Ordem de byte big endian: FF FE</span><span class="sxs-lookup"><span data-stu-id="b8b35-529">Big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="b8b35-530">Ordem de byte endian Little: FF FE</span><span class="sxs-lookup"><span data-stu-id="b8b35-530">Little endian byte order: FF FE</span></span>  
  
 <span data-ttu-id="b8b35-531">Você pode criar uma instância de um <xref:System.Text.UnicodeEncoding> do objeto cuja <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método retorna um BOM válida das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="b8b35-531">You can instantiate a <xref:System.Text.UnicodeEncoding> object whose <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method returns a valid BOM in the following ways:</span></span>  
  
-   <span data-ttu-id="b8b35-532">Recuperando a <xref:System.Text.UnicodeEncoding> objeto retornado pela <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> ou <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="b8b35-532">By retrieving the <xref:System.Text.UnicodeEncoding> object returned by the <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> or <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="b8b35-533">Chamando sem o parâmetro <xref:System.Text.UnicodeEncoding.%23ctor> construtor para instanciar um <xref:System.Text.UnicodeEncoding> objeto.</span><span class="sxs-lookup"><span data-stu-id="b8b35-533">By calling the parameterless <xref:System.Text.UnicodeEncoding.%23ctor> constructor to instantiate a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
-   <span data-ttu-id="b8b35-534">Por meio do fornecimento `true` como o valor da `byteOrderMark` argumento para o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> ou <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtores.</span><span class="sxs-lookup"><span data-stu-id="b8b35-534">By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> or <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructors.</span></span>  
  
 <span data-ttu-id="b8b35-535">É recomendável que você use o BOM, pois ela fornece quase determinada identificação de uma codificação para arquivos que, caso contrário, perdeu uma referência para sua codificação, como sem marcas ou marcado incorretamente dados da web ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-535">We recommended that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</span></span> <span data-ttu-id="b8b35-536">Problemas do usuário geralmente podem ser evitados se os dados são marcados de forma consistente e corretamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-536">Often user problems might be avoided if data is consistently and properly tagged.</span></span>  
  
 <span data-ttu-id="b8b35-537">Para os padrões que fornecem um tipo de codificação, um BOM é algo redundante.</span><span class="sxs-lookup"><span data-stu-id="b8b35-537">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="b8b35-538">No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto.</span><span class="sxs-lookup"><span data-stu-id="b8b35-538">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="b8b35-539">Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário é perdido.</span><span class="sxs-lookup"><span data-stu-id="b8b35-539">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="b8b35-540">Há algumas desvantagens no uso de um BOM.</span><span class="sxs-lookup"><span data-stu-id="b8b35-540">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="b8b35-541">Por exemplo, saber como limitar os campos de banco de dados que usam uma BOM pode ser difícil.</span><span class="sxs-lookup"><span data-stu-id="b8b35-541">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="b8b35-542">Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode acabar no meio de dados.</span><span class="sxs-lookup"><span data-stu-id="b8b35-542">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="b8b35-543">Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.</span><span class="sxs-lookup"><span data-stu-id="b8b35-543">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b8b35-544">Para garantir que os bytes codificados são decodificados corretamente, você deve prefixar o início de um fluxo de bytes codificados com um preâmbulo.</span><span class="sxs-lookup"><span data-stu-id="b8b35-544">To ensure that the encoded bytes are decoded properly, you should prefix the beginning of a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="b8b35-545">Observe que o <xref:System.Text.UnicodeEncoding.GetBytes%2A> método não preceda uma BOM a uma sequência de bytes codificados; fornecer um BOM no início de um fluxo de bytes apropriado é responsabilidade do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="b8b35-545">Note that the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-546">O exemplo a seguir demonstra como usar o <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para recuperar a marca de ordem de byte Unicode big endian ou ordem de byte endian pequeno para uma instância de um <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-546">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to retrieve the Unicode byte order mark in big endian or little endian byte order for an instance of a <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 <span data-ttu-id="b8b35-547">O exemplo a seguir cria instancia dois <xref:System.Text.UnicodeEncoding> objetos, o primeiro deles não fornece um BOM e o segundo do que faz.</span><span class="sxs-lookup"><span data-stu-id="b8b35-547">The following example instantiates two <xref:System.Text.UnicodeEncoding> objects, the first of which does not provide a BOM, and the second of which does.</span></span> <span data-ttu-id="b8b35-548">Em seguida, ele chama o <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para gravar a BOM em um arquivo antes de gravar uma cadeia de caracteres codificado em Unicode.</span><span class="sxs-lookup"><span data-stu-id="b8b35-548">It then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to write the BOM to a file before writing a Unicode-encoded string.</span></span> <span data-ttu-id="b8b35-549">Como mostra a saída do exemplo do console, o arquivo que salva os bytes do segundo codificador tem três mais bytes que o primeiro.</span><span class="sxs-lookup"><span data-stu-id="b8b35-549">As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 <span data-ttu-id="b8b35-550">Você também pode comparar os arquivos usando o `fc` comando em uma janela de console, ou você pode inspecionar os arquivos em um editor de texto que inclui um modo de exibição hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="b8b35-550">You can also compare the files by using the `fc` command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</span></span> <span data-ttu-id="b8b35-551">Observe que, quando o arquivo é aberto em um editor que dá suporte à codificação UTF-16, a BOM não será exibida.</span><span class="sxs-lookup"><span data-stu-id="b8b35-551">Note that when the file is opened in an editor that supports UTF-16 encoding, the BOM is not displayed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="b8b35-552">A matriz de bytes que contém a sequência de bytes a ser decodificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-552">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="b8b35-553">O índice do primeiro byte a ser decodificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-553">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b8b35-554">O número de bytes a serem decodificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-554">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b8b35-555">Decodifica um intervalo de bytes de uma matriz de bytes em uma cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-555">Decodes a range of bytes from a byte array into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b8b35-556">Um objeto <see cref="T:System.String" /> que contém os resultados da decodificação da sequência de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-556">A <see cref="T:System.String" /> object containing the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8b35-557">Com a detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="b8b35-557">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="b8b35-558">Sem detecção de erro, sequências inválidas são ignoradas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="b8b35-558">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="b8b35-559">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo de não-BOM ciente, o caractere U + FFFE está incluído na matriz de caracteres retornada por esse método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-559">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="b8b35-560">Você pode removê-lo chamando o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-560">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b8b35-561">Dados a serem convertidos, como ler de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</span><span class="sxs-lookup"><span data-stu-id="b8b35-561">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="b8b35-562">Nesse caso, ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> objeto fornecido pela <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b8b35-562">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8b35-563">O exemplo a seguir inicializa uma matriz chamando o <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método para determinar exatamente quantos bytes são necessários para uma cadeia de caracteres codificada e, em seguida, adicionando o tamanho da marca de ordem de byte (BOM).</span><span class="sxs-lookup"><span data-stu-id="b8b35-563">The following example initializes an array by calling the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</span></span> <span data-ttu-id="b8b35-564">O exemplo, em seguida, chama o <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para armazenar a BOM para a matriz antes de chamar o <xref:System.Text.Encoding.GetBytes%2A> método para armazenar os bytes codificados para a matriz.</span><span class="sxs-lookup"><span data-stu-id="b8b35-564">The example then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to store the BOM to the array before calling the <xref:System.Text.Encoding.GetBytes%2A> method to store the encoded bytes to the array.</span></span> <span data-ttu-id="b8b35-565">O exemplo, em seguida, chama o <xref:System.Text.UnicodeEncoding.GetString%2A> para decodificar a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b8b35-565">The example then calls the <xref:System.Text.UnicodeEncoding.GetString%2A> method to decode the string.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 <span data-ttu-id="b8b35-566">Observe que nesse caso, a cadeia de caracteres decodificada é diferente da cadeia de caracteres original, desde que ele começa com uma marca de ordem de byte de 16 bits U + FFFD.</span><span class="sxs-lookup"><span data-stu-id="b8b35-566">Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</span></span> <span data-ttu-id="b8b35-567">Isso significa que as duas cadeias de caracteres serão comparados como diferentes, e que, se a cadeia de caracteres é a saída, a BOM será exibida como o caractere de substituição "?".</span><span class="sxs-lookup"><span data-stu-id="b8b35-567">This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</span></span> <span data-ttu-id="b8b35-568">Para remover a BOM no início da cadeia de caracteres, você pode chamar o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b8b35-568">To remove the BOM at the beginning of the string, you can call the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b8b35-569">
            <paramref name="bytes" /> é <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-569">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b8b35-570">
            <paramref name="index" /> ou <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-570">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="b8b35-571">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-571">-or-</span>
          </span>
          <span data-ttu-id="b8b35-572">
            <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-572">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b8b35-573">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-573">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="b8b35-574">Ocorreu um fallback (consulte [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação mais completa)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-574">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="b8b35-575">-e-</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-575">-and-</span>
          </span>
          <span data-ttu-id="b8b35-576">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b8b35-576">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>