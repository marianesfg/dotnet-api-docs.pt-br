<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f83aba724adf774847240af6da560b26e2de0d67" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52371998" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma codificação de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes. Por outro lado, a decodificação é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode. Para obter informações sobre formatos do Unicode Transformation (UTFs) e outras codificações com suporte pelo <xref:System.Text.Encoding>, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Observe que <xref:System.Text.Encoding> foi projetado para operar em caracteres Unicode em vez de dados binários arbitrários, como matrizes de bytes. Se você deve codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementada por métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O .NET fornece as seguintes implementações do <xref:System.Text.Encoding> classe para dar suporte a atual Unicode e outras codificações:  
  
-   <xref:System.Text.ASCIIEncoding> codifica caracteres Unicode como únicos caracteres ASCII de 7 bits. Essa codificação só dá suporte a valores de caractere entre U + 0000 e U + 007F. Página de código 20127. Também disponível por meio de <xref:System.Text.Encoding.ASCII%2A> propriedade.  
  
-   <xref:System.Text.UTF7Encoding> codifica caracteres Unicode usando a codificação UTF-7. Essa codificação dá suporte a todos os valores de caractere Unicode. Página de código 65000. Também disponível por meio de <xref:System.Text.Encoding.UTF7%2A> propriedade.  
  
-   <xref:System.Text.UTF8Encoding> codifica caracteres Unicode usando a codificação UTF-8. Essa codificação dá suporte a todos os valores de caractere Unicode. Página de código 65001. Também disponível por meio de <xref:System.Text.Encoding.UTF8%2A> propriedade.  
  
-   <xref:System.Text.UnicodeEncoding> codifica caracteres Unicode usando a codificação UTF-16. Há suporte para ambos os pedidos de pouco byte de endian e big endian. Também disponível por meio de <xref:System.Text.Encoding.Unicode%2A> propriedade e o <xref:System.Text.Encoding.BigEndianUnicode%2A> propriedade.  
  
-   <xref:System.Text.UTF32Encoding> codifica caracteres Unicode usando a codificação UTF-32. Little endian (página de código 12000) tanto byte big endian (página de código 12001) ordens têm suporte. Também disponível por meio de <xref:System.Text.Encoding.UTF32%2A> propriedade.  
  
 O <xref:System.Text.Encoding> classe é usado principalmente para converter entre codificações diferentes e Unicode. Geralmente, uma das classes derivadas do Unicode é a opção correta para seu aplicativo.  
  
 Use o <xref:System.Text.Encoding.GetEncoding%2A> método para obter outras codificações e chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma lista de todas as codificações.  
  
 A tabela a seguir lista as codificações suportadas pelo .NET Framework e .NET Core. Lista número de página de código do cada codificação e os valores da codificação <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> e <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propriedades. Uma marca de verificação de **suporte do .NET Framework** e **suporte do .NET Core** colunas indica que a página de código tem suporte nativo por essa implementação do .NET, independentemente da plataforma subjacente. Para o .NET Framework, a disponibilidade de outras codificações listadas na tabela depende do sistema operacional. Para o .NET Core, outras codificações estão disponíveis usando o <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> classe ou derivando pelo <xref:System.Text.EncodingProvider?displayProperty=nameWithType> classe.  

> [!NOTE]
> Páginas de código cujo <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propriedade corresponde a um padrão internacional não necessariamente são compatíveis por completo com esse padrão. 

|Página de código|Nome|Nome para exibição|Suporte do .NET framework| Suporte do .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (EUA-Canadá)|||  
|437|IBM437|OEM dos Estados Unidos|||  
|500|IBM500|IBM EBCDIC (Mezinárodní)|||  
|708|ASMO-708|Árabe (ASMO 708)|||  
|720|DOS-720|Árabe (DOS)|||  
|737|ibm737|Grego (DOS)|||  
|775|ibm775|Pobaltské Jazyky (DOS)|||  
|850|ibm850|Západoevropské Jazyky (DOS)|||  
|852|ibm852|Europeu central (DOS)|||  
|855|IBM855|OEM cirílico|||  
|857|ibm857|Turco (DOS)|||  
|858|IBM00858|OEM latino multilíngue I|||  
|860|IBM860|Português (DOS)|||  
|861|ibm861|Islandês (DOS)|||  
|862|DOS-862|Hebraico (DOS)|||  
|863|IBM863|Francês canadense (DOS)|||  
|864|IBM864|Arabské (jazyky 864)|||  
|865|IBM865|Severské Jazyky (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Grego, moderno (DOS)|||  
|870|IBM870|IBM EBCDIC (latino multilíngue-2)|||  
|874|windows-874|Tailandês (Windows)|||  
|875|cp875|IBM EBCDIC (Grego moderno)|||  
|932|shift_jis|Japonês (Shift-JIS)|||  
|936|gb2312|Chinês simplificado (GB2312)|✓||  
|949|ks_c_5601-1987|Coreano|||  
|950|Big5|Chinês tradicional (Big5)|||  
|1026|IBM1026|IBM EBCDIC (Turco Latino-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (EUA-Canadá-Euro)|||  
|1141|IBM01141|IBM EBCDIC (Alemanha-Euro)|||  
|1142|IBM01142|IBM EBCDIC (Dinamarca-Noruega-Euro)|||  
|1143|IBM01143|IBM EBCDIC (Finlândia-Suécia-Euro)|||  
|1144|IBM01144|IBM EBCDIC (Itálie-Euro)|||  
|1145|IBM01145|IBM EBCDIC (Espanha-Euro)|||  
|1146|IBM01146|IBM EBCDIC (Reino Unido-Euro)|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC (Mezinárodní-Euro)|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|Europeu central (Windows)|||  
|1251|windows-1251|Cirílico (Windows)|||  
|1252|Windows-1252|Europeu Ocidental (Windows)|✓||  
|1253|windows-1253|Grego (Windows)|||  
|1254|windows-1254|Turco (Windows)|||  
|1255|windows-1255|Hebraico (Windows)|||  
|1256|windows-1256|Árabe (Windows)|||  
|1257|windows-1257|Pobaltské Jazyky (Windows)|||  
|1258|windows-1258|Vietnamita (Windows)|||  
|1361|Johab|Coreano (Johab)|||  
|10000|Macintosh|Europeu Ocidental (Mac)|||  
|10001|x-mac-japonês|Japonês (Mac)|||  
|10002|x-mac-chinesetrad|Chinês tradicional (Mac)|||  
|10003|x-mac-coreano|Coreano (Mac)|✓||  
|10004|x-mac-árabe|Árabe (Mac)|||  
|10005|x-mac-hebraico|Hebraico (Mac)|||  
|10006|x-mac-grego|Grego (Mac)|||  
|10007|x-mac-cirílico|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|Chinês simplificado (Mac)|✓||  
|10010|x-mac-romeno|Romeno (Mac)|||  
|10017|Ucraniano-mac-x|Ucraniano (Mac)|||  
|10021|x-mac-tailandês|Tailandês (Mac)|||  
|10029|x-mac-ce|Europeu central (Mac)|||  
|10079|x-mac-Islandês|Islandês (Mac)|||  
|10081|x-mac-turco|Turco (Mac)|||  
|10082|x-mac-croata|Croata (Mac)|||  
|12000|utf-32|Unicode (UTF-32)|✓|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|Chinês-x-CNS|Chinês tradicional (CNS)|||  
|20001|x-cp20001|WAN TCA|||  
|20002|Chinês-x-Eten|Chinês tradicional (Eten)|||  
|20003|x-cp20003|IBM5550 Taiwan|||  
|20004|x-cp20004|WAN Teletext|||  
|20005|x-cp20005|Tchaj-WAN Wang|||  
|20105|x-IA5|Západoevropské Jazyky (IA5)|||  
|20106|x-IA5-alemão|Alemão (IA5)|||  
|20107|x-IA5-sueco|Sueco (IA5)|||  
|20108|x-IA5-Norueguês|Norueguês (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Alemanha)|||  
|20277|IBM277|IBM EBCDIC (Dánsko a Norsko)|||  
|20278|IBM278|IBM EBCDIC (Finlândia-Suécia)|||  
|20280|IBM280|IBM EBCDIC (Itálie)|||  
|20284|IBM284|IBM EBCDIC (Espanha)|||  
|20285|IBM285|IBM EBCDIC (REINO UNIDO)|||  
|20290|IBM290|IBM EBCDIC (Japonsko-katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (árabe)|||  
|20423|IBM423|IBM EBCDIC (grego)|||  
|20424|IBM424|IBM EBCDIC (hebraico)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (coreano estendido)|||  
|20838|IBM-Thai|IBM EBCDIC (tailandês)|||  
|20866|koi8-r|Cirílico (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Islandês)|||  
|20880|IBM880|IBM EBCDIC (Ruská cyrilice)|||  
|20905|IBM905|IBM EBCDIC (turco)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Japonês (JIS 0208 1990 e 0212 1990)|||  
|20936|x-cp20936|Chinês simplificado (GB2312-80)|✓||  
|20949|x-cp20949|Coreano Wansung|✓||  
|21025|cp1025|IBM EBCDIC (Srbská a Bulharská)|||  
|21866|koi8-u|Cirílico (KOI8-U)|||  
|28591|iso-8859-1|Europeu Ocidental (ISO)|✓|✓|  
|28592|iso-8859-2|Europeu central (ISO)|||  
|28593|iso-8859-3|Latino 3 (ISO)|||  
|28594|iso-8859-4|Pobaltské Jazyky (ISO)|||  
|28595|iso-8859-5|Cyrilice (ISO)|||  
|28596|iso-8859-6|Árabe (ISO)|||  
|28597|iso-8859-7|Grego (ISO)|||  
|28598|iso-8859-8|Hebraico (ISO-Visual)|✓||  
|28599|iso-8859-9|Turco (ISO)|||  
|28603|iso-8859-13|Estoniano (ISO)|||  
|28605|ISO 8859-15|Latino 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|Hebraico (ISO-lógico)|✓||  
|50220|ISO-2022-jp|Japonês (JIS)|✓||  
|50221|csISO2022JP|Japonês (JIS-Permitir 1 byte Kana)|✓||  
|50222|ISO-2022-jp|Japonês (JIS-Permitir 1 byte Kana - então / SI)|✓||  
|50225|iso-2022-kr|Coreano (ISO)|✓||  
|50227|x-cp50227|Chinês simplificado (ISO-2022)|✓||  
|51932|euc-jp|Japonês (EUC)|✓||  
|51936|EUC-CN|Chinês simplificado (EUC)|✓||  
|51949|EUC-kr|Coreano (EUC)|✓||  
|52936|hz-gb-2312|Chinês simplificado (HZ)|✓||  
|54936|GB18030|Chinês simplificado (GB18030)|✓||  
|57002|iscii-x-de|ISCII Devanágari|✓||  
|57003|iscii x ser|Bengali ISCII|✓||  
|57004|x-iscii-ta|ISCII Tâmil|✓||  
|57005|iscii-x-te|ISCII télugo|✓||  
|57006|iscii x como|ISCII Assamês|✓||  
|57007|x-iscii ou|Odia ISCII|✓||  
|57008|iscii-x-ka|Kannada ISCII|✓||  
|57009|x-iscii-ma|ISCII malaiala|✓||  
|57010|x-iscii-gu|ISCII guzerate|✓||  
|57011|x-iscii-pa|ISCII Punjabi|✓||  
|65000|UTF-7|Unicode (UTF-7)|✓|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|✓|  
  
 A exemplo a seguir chama o <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> e <xref:System.Text.Encoding.GetEncoding%28System.String%29> métodos para obter o grego (Windows) a codificação de página de código. Ele compara o <xref:System.Text.Encoding> objetos retornados por chamadas de método para mostrar que eles são iguais e, em seguida, mapeia exibe o ponto de código Unicode e o valor de página de código correspondente para cada caractere do alfabeto grego.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O UTF-16 e UTF-32 codificadores podem usar a ordem de byte big endian (byte mais significativo primeiro) ou a ordem de byte endian little (byte menos significativo primeiro). Por exemplo, a letra maiuscula latina um (u+0041) é serializado como segue (em hexadecimal):  
  
-   Ordem de byte big endian da UTF-16: 00 41  
  
-   Ordem de byte endian UTF-16 little: 41 00  
  
-   Ordem de byte big endian da UTF-32: 00 00 00 41  
  
-   Ordem de byte endian UTF-32 little: 41 00 00 00  
  
 É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo. Por exemplo, é melhor usar a ordem de byte endian little em plataformas de endian pequeno, como computadores Intel.  
  
 O <xref:System.Text.Encoding.GetPreamble%2A> método recupera uma matriz de bytes que inclui a marca de ordem de byte (BOM). Se a matriz de bytes é prefixada para um fluxo codificado, ele ajuda o decodificador para identificar o formato de codificação usado.  
  
 Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte padrão Unicode na [página inicial do Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Observe que as classes de codificação de erros para permitir que:  
  
-   Alterar silenciosamente para um "?" caracteres.  
  
-   Use um caractere de "melhor ajuste".  
  
-   Altere para um comportamento específico do aplicativo por meio do uso do <xref:System.Text.EncoderFallback> e <xref:System.Text.DecoderFallback> classes com o caractere de substituição U + FFFD Unicode.  
  
 Você deve lançar uma exceção qualquer erro de fluxo de dados. Um aplicativo usa um sinalizador de "throwonerror", quando aplicável ou usa o <xref:System.Text.EncoderExceptionFallback> e <xref:System.Text.DecoderExceptionFallback> classes. Fallback de ajuste recomendada geralmente não é recomendável porque pode causar perda de dados ou de confusão e é mais lenta que a substituição de caracteres simples. Codificações ANSI, o melhor comportamento de ajuste é o padrão.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
> [!NOTE]
>  A matriz do byte [] é o único tipo neste exemplo que contém os dados codificados. Os tipos .NET Char e String são as próprias Unicode, portanto, o <xref:System.Text.Encoding.GetChars%2A> chamada decodifica os dados novamente para Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas substituem esse construtor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">O identificador de página de código da codificação preferencial.  
  
- ou - 
0, para usar a codificação padrão.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" /> que corresponde à página de código especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas substituem esse construtor.  
  
 Chamadas para esse construtor de uma classe derivada é criar um <xref:System.Text.Encoding> objeto que usa o fallback de melhor ajuste para codificação e decodificação de operações. Tanto a <xref:System.Text.Encoding.DecoderFallback%2A> e <xref:System.Text.Encoding.EncoderFallback%2A> propriedades são somente leitura e não pode ser modificadas. Para controlar a estratégia de fallback para uma classe derivada de <xref:System.Text.Encoding>, chame o <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> é menor que zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">O identificador de página de código da codificação.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" /> que corresponde à página de código especificada com as estratégias de fallback de codificador e decodificador especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é `protected`; derivada classes substituem-la.  
  
 Você pode chamar esse construtor de uma classe derivada para controlar o fallback de codificação e decodificação de estratégias. O <xref:System.Text.Encoding> construtores de classe criam objetos de codificação somente leitura que não permitem o codificador ou decodificador de fallback para ser definida depois que o objeto é criado.  
  
 Se qualquer um dos `encoderFallback` ou `decoderFallback` for nulo, fallback de melhor ajuste é usado como a estratégia de fallback correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o conjunto de caracteres ASCII (7 bits).</summary>
        <value>Uma codificação para o conjunto de caracteres ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres ASCII são limitados para os caracteres Unicode 128 mais baixos, de u+0000 a U + 007F.  
  
 Ao selecionar a codificação ASCII para seu aplicativo, considere o seguinte:  
  
-   A codificação ASCII normalmente é adequada para protocolos que exijam ASCII.  
  
-   Se você exigir codificação de 8 bits (que, às vezes, incorretamente é conhecido como "ASCII"), a codificação UTF-8 é recomendável em vez de ASCII de codificação. Para os caracteres 7F 0, os resultados são idênticos, mas o uso de UTF-8 evita a perda de dados, permitindo que a representação de todos os caracteres Unicode que são representável. Observe que a codificação ASCII tem um 8 bits de ambiguidade que pode permitir o uso mal-intencionado, mas a codificação UTF-8 remove ambiguidade sobre o 8º bit.  
  
-   Antes do .NET Framework versão 2.0, o .NET Framework pode falsificação ignorando o 8º bit. Começando com o .NET Framework 2.0, pontos de código não-ASCII voltar durante a decodificação.  
  
 O <xref:System.Text.ASCIIEncoding> objeto que é retornado por essa propriedade pode não ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que ele não consegue codificar e cada byte que ele não consegue decodificar por um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> método para instanciar uma <xref:System.Text.ASCIIEncoding> objeto cujo retorno é um <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o efeito de ASCII de codificação de caracteres que estão fora do intervalo ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-16 que usa a ordem de byte big endian.</summary>
        <value>Um objeto de codificação para o formato UTF-16 que usa a ordem de byte big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UnicodeEncoding> objeto que é retornado por essa propriedade pode não ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que ele não consegue codificar e cada byte que ele não consegue decodificar por um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um big endian <xref:System.Text.UnicodeEncoding> objeto cujo retorno é um <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Retornado <xref:System.Text.UnicodeEncoding> objeto tem <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, e <xref:System.Text.Encoding.WebName%2A> propriedades, que geram o nome "unicodeFFFE". Embora a marca de ordem de byte big endian UTF-16 é FEFF hexadecimal, o nome "unicodeFFFE" foi escolhido porque a marca de ordem de byte é exibido como FFFE hexadecimal em little endian computadores do Windows.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo de texto com uma codificação UTF-16 usando a ordem de byte big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de corpo do agente de email.</summary>
        <value>Um nome para o <see cref="T:System.Text.Encoding" /> atual que pode ser usado com marcas de corpo do agente de email.  
  
- ou - 
Uma cadeia de caracteres vazia ("") se o <see cref="T:System.Text.Encoding" /> atual não puder ser usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar de uma codificação para um nome de corpo, você deve chamar <xref:System.Text.Encoding.GetEncoding%2A> com o <xref:System.Text.Encoding.BodyName%2A> propriedade. Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada. Geralmente, apenas os aplicativos de email precisam recuperar essa codificação; a maioria dos outros aplicativos que necessitam para descrever uma codificação deve usar seu <xref:System.Text.Encoding.WebName%2A>.  
  
 Em alguns casos, o valor da <xref:System.Text.Encoding.BodyName%2A> propriedade corresponde ao padrão internacional que define a codificação. Isso não significa que a implementação está em conformidade por completo com esse padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se comparam em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, cria uma cópia superficial do objeto <see cref="T:System.Text.Encoding" /> atual.</summary>
        <returns>Uma cópia do objeto <see cref="T:System.Text.Encoding" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O clone é gravável, mesmo que o original <xref:System.Text.Encoding> objeto é somente leitura. Portanto, as propriedades do clone podem ser modificadas.  
  
 Uma cópia superficial de um objeto é uma cópia do objeto apenas. Se o objeto contiver referências a outros objetos, a cópia superficial não cria cópias dos objetos referenciados. Ele se refere aos objetos originais em vez disso. Em contraste, uma cópia em profundidade de um objeto cria uma cópia do objeto e uma cópia de tudo direta ou indiretamente referenciado por esse objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o identificador de página de código do <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O identificador de página de código do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se comparam em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte uma matriz de bytes de uma codificação em outra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">O formato de codificação de <paramref name="bytes" />.</param>
        <param name="dstEncoding">O formato de codificação de destino.</param>
        <param name="bytes">Os bytes a serem convertidos.</param>
        <summary>Converte uma matriz de bytes inteira de uma codificação para outra.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Byte" /> que contém os resultados da conversão <paramref name="bytes" /> de <paramref name="srcEncoding" /> para <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres Unicode codificada em uma cadeia de caracteres codificada em ASCII. Porque o objeto de codificação ASCII retornada pelo <xref:System.Text.Encoding.ASCII%2A> propriedade usa o fallback de substituição e o caractere de Pi não é parte do conjunto de caracteres ASCII, o caractere de Pi é substituído por um ponto de interrogação, como a saída do exemplo mostra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="dstEncoding" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">A codificação de matriz de origem, <paramref name="bytes" />.</param>
        <param name="dstEncoding">A codificação da matriz de saída.</param>
        <param name="bytes">A matriz de bytes a ser convertida.</param>
        <param name="index">O índice do primeiro elemento de <paramref name="bytes" /> a ser convertido.</param>
        <param name="count">O número de bytes a serem convertidos.</param>
        <summary>Converte um intervalo de bytes em uma matriz de bytes de uma codificação para outra.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Byte" /> que contém o resultado da conversão de um intervalo de bytes em <paramref name="bytes" /> de <paramref name="srcEncoding" /> para <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="dstEncoding" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> e <paramref name="count" /> não especificam um intervalo válido na matriz de bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Text.DecoderFallback" /> para o objeto <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O objeto de fallback do decodificador para o objeto <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.DecoderFallback> objeto representa um manipulador de erro que é invocado quando uma sequência de bytes codificados não puder ser decodificada em um caractere. Há suporte para qualquer um dos seguintes tipos de manipulador:  
  
-   Um melhor ajuste manipulador de fallback, que substitui bytes que não podem ser decodificadas com algum caractere substituto adequado.  
  
-   Um manipulador de fallback de substituição, que substitui bytes que não podem ser decodificadas com algum caractere de substituição arbitrário. O .NET inclui um manipulador de fallback de substituição, <xref:System.Text.DecoderFallback>, que, por padrão substitui bytes que não podem ser decodificadas com um ponto de interrogação ("?") caracteres.  
  
-   Um manipulador de fallback de exceção, que gera uma exceção quando não não possível decodificar bytes. Um manipulador de fallback de exceção, o .NET inclui <xref:System.Text.DecoderExceptionFallback>, que gera um <xref:System.Text.DecoderFallbackException> quando bytes não podem ser decodificadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor em uma operação de definição é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <see cref="T:System.Text.Encoding" /> atual é somente leitura.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a codificação padrão para esta implementação .NET.</summary>
        <value>A codificação padrão para essa implementação do .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Computadores diferentes podem usar codificações diferentes como padrão e a codificação padrão pode alterar em um único computador. Se você usar o <xref:System.Text.Encoding.Default%2A> codificação para codificar e decodificar dados transmitidos entre computadores ou recuperado em momentos diferentes no mesmo computador, ele pode converter dados incorretamente. Além disso, a codificação retornada pelo <xref:System.Text.Encoding.Default%2A> propriedade usa o fallback de melhor ajuste para mapear caracteres sem suporte para caracteres suportados pela página de código. Por esses motivos, não é recomendável usar a codificação padrão. Para garantir que os bytes codificados são decodificados corretamente, você deve usar uma codificação Unicode, como <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>. Você também pode usar um protocolo de nível superior para garantir que o mesmo formato é usado para codificar e decodificar.  

### <a name="the-default-property-in-the-net-framework"></a>A propriedade padrão no .NET Framework

No .NET Framework na área de trabalho do Windows, o <xref:System.Text.Encoding.Default%2A> propriedade sempre obtém a página de código ativo do sistema e cria um <xref:System.Text.Encoding> objeto que corresponde a ele. A página de código ativo pode ser uma página de código ANSI, que inclui o caractere ASCII definido junto com caracteres adicionais que variam por página de código. Porque todos os <xref:System.Text.Encoding.Default%2A> codificações com base nas páginas de código ANSI perder dados, considere usar o <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> codificação em vez disso. UTF-8 geralmente é idêntica no U + 00 a U + 7F intervalo, mas pode codificar caracteres fora do intervalo ASCII sem perda.

## <a name="the-default-property-on-net-core"></a>A propriedade padrão no .NET Core

No .NET Core, o <xref:System.Text.Encoding.Default%2A> propriedade sempre retorna o <xref:System.Text.UTF8Encoding>. Suporte para UTF-8 em todos os sistemas operacionais (Windows, Linux e Max OS X) quais aplicativos .NET Core executado.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Text.EncoderFallback" /> para o objeto <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O objeto de fallback do codificador para o objeto <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.EncoderFallback> objeto representa um manipulador de erro que é invocado quando um caractere não pode ser convertido em uma sequência de bytes codificados. Há suporte para qualquer um dos seguintes tipos de manipulador:  
  
-   Um melhor ajuste manipulador de fallback, que substitui os caracteres que não podem ser codificados com algum caractere substituto adequado.  
  
-   Um manipulador de fallback de substituição, que substitui os caracteres que não podem ser codificados com algum caractere de substituição arbitrário. O .NET inclui um manipulador de fallback de substituição, <xref:System.Text.EncoderFallback>, que, por padrão substitui caracteres que não podem ser codificados com um ponto de interrogação ("?") caracteres.  
  
-   Um manipulador de fallback de exceção, que gera uma exceção quando caracteres não podem ser codificados. Um manipulador de fallback de exceção, o .NET inclui <xref:System.Text.EncoderExceptionFallback>, que gera um <xref:System.Text.EncoderFallbackException> quando os caracteres não podem ser decodificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor em uma operação de definição é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <see cref="T:System.Text.Encoding" /> atual é somente leitura.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a descrição legível por humanos da codificação atual.</summary>
        <value>A descrição legível por humanos do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.EncodingName%2A> propriedade destina-se a exibição. Para localizar um nome que pode ser passado para o <xref:System.Text.Encoding.GetEncoding%2A> método, use o <xref:System.Text.Encoding.WebName%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se comparam em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O <see cref="T:System.Object" /> de comparação com a instância atual.</param>
        <summary>Determina se o <see cref="T:System.Object" /> especificado é igual à instância atual.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for uma instância de <see cref="T:System.Text.Encoding" /> e for igual à instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Duas instâncias de <xref:System.Text.Encoding> são considerados iguais se eles correspondem a mesma página de código e suas `EncoderFallback` e `DecoderFallback` objetos são iguais. Em particular, páginas de códigos derivado todos têm uma página de código de 0 e suas sequências são normalmente `null` (`Nothing` no Visual Basic .NET). Portanto, eles são considerados iguais um ao outro. Uma consequência é que quando <xref:System.Text.Encoding.Equals%2A> é usado para popular uma tabela de hash, todos os derivados de codificações de comparação igual e se enquadram no mesmo slot de tabela de hash.  
  
   
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma por página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de todos os caracteres na matriz de caracteres especificada.</summary>
        <returns>O número de bytes produzidos codificando todos os caracteres na matriz de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar as versões de cadeia de caracteres da <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, você deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de caracteres na cadeia de caracteres especificada.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> é recomendado.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres começando no ponteiro de caracteres especificado.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetBytes%2A> requer para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações para usar esses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres da <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%2A> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="index">O índice do primeiro caractere a ser codificado.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres da matriz de caracteres especificada.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> é recomendado.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituído em uma classe derivada, decodifica um conjunto de caracteres em uma sequência de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, codifica todos os caracteres na matriz de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve chamar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, codifica todos os caracteres na cadeia de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="index">O índice do primeiro caractere a ser codificado.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres na matriz de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">Um ponteiro para o local no qual a gravação da sequência de bytes resultante deve ser iniciada.</param>
        <param name="byteCount">O número máximo de bytes a serem gravados.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados do ponteiro de bytes especificado.</summary>
        <returns>O número real de bytes gravados no local indicado pelo parâmetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetBytes%2A> requer para armazenar os bytes resultantes, chame o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> objeto fornecido pelo <xref:System.Text.Encoding.GetDecoder%2A> ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> é menor que o número de bytes resultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="charIndex">O índice do primeiro caractere a ser codificado.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes que conterá a sequência de bytes resultante.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres da matriz de caracteres especificada em uma matriz de bytes especificada.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
- ou - 
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</param>
        <param name="charIndex">O índice do primeiro caractere a ser codificado.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes que conterá a sequência de bytes resultante.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres da cadeia de caracteres especificada em uma matriz de bytes especificada.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina quantos bytes resultam em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que manipula conversões de múltiplas em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo pode precisar codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que inclui os pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrarão que substituto alto, de modo que ele pode ser combinado com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding> não será capaz de manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo lida com as entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão do buffer de caractere Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserção em buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que dá suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e gerar uma exceção se o buffer de saída é muito pequeno. Para a codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
- ou - 
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzidos decodificando todos os bytes na matriz de bytes especificada.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método. Para calcular o tamanho máximo da matriz, você deve usar o <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> método. O <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas.  
  
-   Se seu aplicativo lida com a cadeia de caracteres de saídas, você deve usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzidos usando a decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetChars%2A> requer para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas.  
  
-   Se seu aplicativo lida com as saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas.  
  
-   Se seu aplicativo lida com as saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes em um conjunto de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em um conjunto de caracteres.</summary>
        <returns>Uma matriz de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretas, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisar codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementada por métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, como sequências de bytes podem ser interrompidas quando processados em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode encerrar uma <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chamará o fallback para essas sequências incompletas, mas <xref:System.Text.Decoder> lembrará dessas sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com as saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em um conjunto de caracteres.</summary>
        <returns>Uma matriz de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretas, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisar codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementada por métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, como sequências de bytes podem ser interrompidas quando processados em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode encerrar uma <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chamará o fallback para essas sequências incompletas, mas <xref:System.Text.Decoder> lembrará dessas sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com as saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">Um ponteiro para o local no qual a gravação do conjunto de caracteres resultante deve ser iniciada.</param>
        <param name="charCount">O número máximo de caracteres a serem gravados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes iniciando no ponteiro de bytes especificado em um conjunto de caracteres começando no ponteiro de caractere especificado.</summary>
        <returns>O número real de caracteres gravados no local indicado pelo parâmetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetChars%2A> requer para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretas, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> objeto fornecido pelo <xref:System.Text.Encoding.GetDecoder%2A> ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisar codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementada por métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, como sequências de bytes podem ser interrompidas quando processados em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode encerrar uma <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chamará o fallback para essas sequências incompletas, mas <xref:System.Text.Decoder> lembrará dessas sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com a cadeia de caracteres de saídas, o <xref:System.Text.Encoding.GetString%2A> método é recomendado. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> é menor que o número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="byteIndex">O índice do primeiro byte a ser decodificado.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">A matriz de caracteres que deve conter o conjunto de caracteres resultante.</param>
        <param name="charIndex">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</summary>
        <returns>O número real de caracteres gravados em <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > obtém caracteres de uma sequência de bytes de entrada. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretas, enquanto <xref:System.Text.Decoder> foi projetado para várias passagens em um único fluxo de entrada.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisar codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementada por métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultam em decodificação de uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em contraste com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que lida com várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso desses métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre chamadas, como sequências de bytes podem ser interrompidas quando processados em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode encerrar um [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > chamar e continuar no início do próximo [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > chamar. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > chamará o fallback para essas sequências incompletas, mas <xref:System.Text.Decoder> lembrará dessas sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com a cadeia de caracteres de saídas, o <xref:System.Text.Encoding.GetString%2A> método é recomendado. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lento, mas resultante <xref:System.String> tipo deve ser preferencial.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é não seguro, uma vez que os ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a caracteres de saída buffers é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> é menor que zero.  
  
- ou - 
 <paramref name="byteindex" /> e <paramref name="byteCount" /> não denotam um intervalo válido em <paramref name="bytes" />.  
  
- ou - 
 <paramref name="charIndex" /> não é um índice válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> não tem capacidade suficiente do <paramref name="charIndex" /> até o final da matriz para acomodar os caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um decodificador que converte uma sequência de bytes codificada em uma sequência de caracteres.</summary>
        <returns>Um <see cref="T:System.Text.Decoder" /> que converte uma sequência de bytes codificada em uma sequência de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <xref:System.Text.Encoding.GetChars%2A> método dessa classe. No entanto, um <xref:System.Text.Decoder> mantém informações de estado entre chamadas para que ele corretamente decodifica as sequências de bytes que abrangem os blocos. O <xref:System.Text.Decoder> também preserva bytes à direita no final de blocos de dados e usa os bytes à direita na próxima operação de decodificação. Portanto, <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações costumam lidam com os blocos de dados em vez de um fluxo de dados completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A implementação padrão retorna um <see cref="T:System.Text.Decoder" /> que chama o <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> e <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> métodos do atual <see cref="T:System.Text.Encoding" />. Você deve substituir esse método para retornar um <see cref="T:System.Text.Decoder" /> que mantém o estado entre chamadas.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</summary>
        <returns>Um <see cref="T:System.Text.Encoder" /> que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes, de maneira semelhante para o <xref:System.Text.Encoding.GetBytes%2A> método dessa classe. No entanto, um <xref:System.Text.Encoder> mantém informações de estado entre chamadas para que ele codifica o sequências de caracteres que abrangem os blocos corretamente. O <xref:System.Text.Encoder> também preserva à direita caracteres do final de blocos de dados e usa os caracteres à direita na próxima operação de codifica. Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência, e o substituto baixo correspondente pode ser no próximo bloco de dados. Portanto, <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações costumam lidam com os blocos de dados em vez de um fluxo de dados completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A implementação padrão retorna um <see cref="T:System.Text.Encoder" /> que chama o <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> e <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> métodos do atual <see cref="T:System.Text.Encoding" />. Você deve substituir esse método para retornar um <see cref="T:System.Text.Encoder" /> que mantém o estado entre chamadas.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma codificação para a página de código especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">O identificador de página de código da codificação preferencial. Os valores possíveis são listados na coluna Página de Código da tabela exibida no tópico da classe <see cref="T:System.Text.Encoding" />.  
  
- ou - 
0 (zero), para usar a codificação padrão.</param>
        <summary>Retorna a codificação associada ao identificador de página de código especificado.</summary>
        <returns>A codificação associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O manipulador de fallback depende do tipo de codificação `codepage`. Se `codepage` é um caractere de byte duplo ou página de código de conjunto de codificação (DBCS), um manipulador de fallback de melhor ajuste é usado. Caso contrário, um manipulador de fallback de substituição é usado. Esses manipuladores de fallback podem não ser apropriados para seu aplicativo. Para especificar o manipulador de fallback usado pela codificação especificada por `codepage`, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  
  
 No .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método se baseia na plataforma subjacente para dar suporte à maioria das páginas de código. No entanto, o .NET Framework nativamente dá suporte a algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico da classe. No .NET Core, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna as codificações suportadas nativamente pelo .NET Core. Em ambas as implementações do .NET, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações disponíveis. 

 Além das codificações que estão disponíveis nativamente no .NET Core ou que intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que estão disponíveis ao registrar um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  

Você também pode fornecer um valor de 0 para o `codepage` argumento. Seu comportamento preciso depende se qualquer codificações foram disponibilizadas ao registrar um <xref:System.Text.EncodingProvider> objeto:

- Se um ou mais provedores de codificação tiveram sido registrados, ele retorna a codificação do último provedor registrado que optou por retornar uma codificação quando a <xref:System.Text.Encoding.GetEncoding%2A> método recebe um `codepage` argumento de 0.     

- No .NET Framework, se nenhuma codificação de provedor tiver sido registrado, se o <xref:System.Text.CodePagesEncodingProvider> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna a página de código ativo do sistema operacional. Para determinar a página de código ativo em sistemas Windows, chame o Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) função do .NET Framework na área de trabalho do Windows.

- No .NET Core, se nenhum provedor de codificação foi registrado ou se nenhum provedor de codificação registrado lida com uma `codepage` valor de 0, ele retorna o <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Algum código que não há suporte para páginas causa uma <xref:System.ArgumentException> ser lançada, enquanto outros fazem com que um <xref:System.NotSupportedException>. Portanto, seu código deve capturar todas as exceções indicadas na seção exceções.  
  
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem alterar em um único computador, levando à corrupção de dados. Por esse motivo, se a página de código ativo é uma página de código ANSI, codificação e decodificação de dados usando a página de código padrão retornado por `Encoding.GetEncoding(0)` não é recomendado. Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, o <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você ative a detecção de erros.  

   
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> é menor que zero ou maior que 65535.</exception>
        <exception cref="T:System.ArgumentException">Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O identificador da página de código da codificação preferencial. Qualquer valor retornado pela propriedade <see cref="P:System.Text.Encoding.WebName" /> é válido. Os valores possíveis são listados na coluna Nome da tabela exibida no tópico da classe <see cref="T:System.Text.Encoding" />.</param>
        <summary>Retorna a codificação associada ao nome da página de código especificada.</summary>
        <returns>A codificação associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O manipulador de fallback depende do tipo de codificação `name`. Se `name` é um caractere de byte duplo ou página de código de conjunto de codificação (DBCS), um manipulador de fallback de melhor ajuste é usado. Caso contrário, um manipulador de fallback de substituição é usado. Esses manipuladores de fallback podem não ser apropriados para seu aplicativo. Para especificar o manipulador de fallback usado pela codificação especificada por `name`, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  

No .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método se baseia na plataforma subjacente para dar suporte à maioria das páginas de código. No entanto, o .NET Framework nativamente dá suporte a algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico da classe. No .NET Core, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna as codificações suportadas nativamente pelo .NET Core. Em ambas as implementações do .NET, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações disponíveis. 

 Além das codificações que estão disponíveis nativamente no .NET Core ou que intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que estão disponíveis ao registrar um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  
   
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em diferentes computadores, ou podem ser alteradas para um único computador, levando à corrupção de dados. Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específica.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, o <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você ative a detecção de erros.  
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> não é um nome de página de código válido.  
  
- ou - 
A página de código indicada por <paramref name="name" /> não tem suporte da plataforma subjacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">O identificador de página de código da codificação preferencial. Os valores possíveis são listados na coluna Página de Código da tabela exibida no tópico da classe <see cref="T:System.Text.Encoding" />.  
  
- ou - 
0 (zero), para usar a codificação padrão.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Retorna a codificação associada ao identificador de página de código especificado. Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</summary>
        <returns>A codificação associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Algumas páginas de código sem suporte com que a exceção <xref:System.ArgumentException> ser lançada, enquanto outros fazem com que <xref:System.NotSupportedException>. Portanto, seu código deve capturar todas as exceções indicadas na seção exceções.  

No .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método se baseia na plataforma subjacente para dar suporte à maioria das páginas de código. No entanto, o .NET Framework nativamente dá suporte a algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico da classe. No .NET Core, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna as codificações suportadas nativamente pelo .NET Core. Em ambas as implementações do .NET, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações disponíveis. 

 Além das codificações que estão disponíveis nativamente no .NET Core ou que intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que estão disponíveis ao registrar um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  

Você também pode fornecer um valor de 0 para o `codepage` argumento. Seu comportamento preciso depende se qualquer codificações foram disponibilizadas ao registrar um <xref:System.Text.EncodingProvider> objeto:

- Se um ou mais provedores de codificação tiveram sido registrados, ele retorna a codificação do último provedor registrado que optou por retornar uma codificação quando a <xref:System.Text.Encoding.GetEncoding%2A> método recebe um `codepage` argumento de 0.     

- No .NET Framework, se nenhuma codificação de provedor tiver sido registrado, se o <xref:System.Text.CodePagesEncodingProvider> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna a página de código ativo.

- No .NET Core, se nenhum provedor de codificação foi registrado ou se nenhum provedor de codificação registrado lida com uma `codepage` valor de 0, ele retorna o <xref:System.Text.UTF8Encoding> codificação.

> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem alterar em um único computador, levando à corrupção de dados. Por esse motivo, se a página de código ativo é uma página de código ANSI, codificação e decodificação de dados usando a página de código padrão retornado por `Encoding.GetEncoding(0)` não é recomendado. Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específica. 
  
 Para obter a codificação associado à página de código ativo, você também pode fornecer um valor de 0 para o `codepage` argumento ou, se seu código está em execução no .NET Framework na área de trabalho do Windows, recupere o valor da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriedade. Para determinar a página de código ativo atual, chame o Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) função do .NET Framework na área de trabalho do Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, o <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você ative a detecção de erros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> é menor que zero ou maior que 65535.</exception>
        <exception cref="T:System.ArgumentException">Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">O identificador da página de código da codificação preferencial. Qualquer valor retornado pela propriedade <see cref="P:System.Text.Encoding.WebName" /> é válido. Os valores possíveis são listados na coluna Nome da tabela exibida no tópico da classe <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Retorna a codificação associada ao nome da página de código especificada. Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</summary>
        <returns>A codificação associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

No .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método se baseia na plataforma subjacente para dar suporte à maioria das páginas de código. No entanto, o .NET Framework nativamente dá suporte a algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico da classe. No .NET Core, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna as codificações suportadas nativamente pelo .NET Core. Em ambas as implementações do .NET, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações disponíveis. 

 Além das codificações que estão disponíveis nativamente no .NET Core ou que intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que estão disponíveis ao registrar um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  
  
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem alterar em um único computador, levando à corrupção de dados. Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, o <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você ative a detecção de erros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> não é um nome de página de código válido.  
  
- ou - 
A página de código indicada por <paramref name="name" /> não tem suporte da plataforma subjacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz que contém todas as codificações.</summary>
        <returns>Uma matriz que contém todas as codificações.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna uma lista de codificações com suporte, distinguidas exclusivamente pela página de código. Para uma tabela que lista as codificações com suporte, consulte o <xref:System.Text.Encoding> tópico da classe.  
  
> [!NOTE]
>  A lista de codificações com suporte retornadas pela <xref:System.Text.Encoding.GetEncodings%2A> método não inclui qualquer codificações adicionais disponibilizadas por qualquer <xref:System.Text.EncodingProvider> implementações que foram registradas por chamadas para o <xref:System.Text.Encoding.RegisterProvider%2A> método.  
  
 No .NET Framework, codificações 50220 e 50222 são ambos associado com o nome "iso-2022-jp", mas eles não são idênticos. Codificação 50220 converte caracteres Katakana de meia largura para caracteres Katakana de largura inteira, enquanto a codificação 50222 usa uma sequência de shift-in/shift-out para codificar caracteres Katakana de meia largura. É o nome de exibição para a codificação 50222 "japonês (JIS-Permitir 1 byte Kana - então / SI)" para distingui-lo de codificação 50220, que tem a exibição nomes "japonês (JIS)".  
  
 Se você solicitar a codificação nome "iso-2022-jp", a codificação 50220 para retornar do .NET Framework. No entanto, a codificação que é apropriada para seu aplicativo depende do tratamento preferencial dos caracteres Katakana de meia largura.  
  
 Para obter uma codificação específica, você deve usar o <xref:System.Text.Encoding.GetEncoding%2A> método.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> às vezes, é usado para apresentar ao usuário uma lista de codificações em um arquivo **Salvar como** caixa de diálogo. No entanto, várias codificações não-Unicode estão incompletos e converter o número de caracteres para "?", ou tem um comportamento um pouco diferente em diferentes plataformas. Considere o uso de UTF-8 ou UTF-16 como padrão.  
  
   
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para a instância atual.</summary>
        <returns>O código hash da instância atual.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número máximo de bytes produzidos pela codificação do número especificado de caracteres.</summary>
        <returns>O número máximo de bytes produzidos pela codificação do número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `charCount` parâmetro, na verdade, especifica o número de <xref:System.Char> objetos que representam os caracteres Unicode para codificar, porque o .NET usa UTF-16 internamente para representar caracteres Unicode. Consequentemente, a maioria dos caracteres Unicode podem ser representados por um <xref:System.Char> objeto, mas um caractere Unicode representado por um par substituto, por exemplo, requer dois <xref:System.Char> objetos.  
  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve usar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera um número de pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.EncoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres potencialmente grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera valores grandes, especialmente nos casos em que o pior caso para a codificação envolve alternar os modos para cada caractere. Por exemplo, isso pode ocorrer por ISO-2022-JP. Para obter mais informações, consulte a entrada de blog "[What ' s com Encoding.GetMaxByteCount() e Encoding.GetMaxCharCount()?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 Na maioria dos casos, esse método recupera valores razoáveis para pequenas cadeias de caracteres. Para grandes cadeias de caracteres, você terá que escolher entre o uso de buffers muito grandes e captura erros em casos raros, quando um buffer mais razoável é muito pequeno. Você também poderá considerar o uso uma abordagem diferente <xref:System.Text.Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Ao usar <xref:System.Text.Encoding.GetMaxByteCount%2A>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada. Se o buffer de saída é restrito de tamanho, você pode usar o <xref:System.Text.Encoding.Convert%2A> método.  
  
 Observe que <xref:System.Text.Encoding.GetMaxByteCount%2A> considera substitutos abandonados potencias de uma operação anterior do decodificador. Por causa do decodificador, passando um valor de 1 para o método recupera 2 para uma codificação de byte único, como ASCII. Você deve usar o <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propriedade se essas informações são necessárias.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` não é necessariamente o mesmo valor que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos os <see cref="T:System.Text.Encoding" /> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se os buffers são dimensionados de acordo com os resultados dos cálculos desse método.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número máximo de caracteres produzidos pela codificação do número especificado de bytes.</summary>
        <returns>O número máximo de caracteres produzidos decodificando o número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho da matriz exata exigido pelo <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres do resultado, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo da matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de menos memória, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera um número de pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.DecoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres potencialmente grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera valores grandes.  
  
 Na maioria dos casos, esse método recupera números razoáveis para pequenas cadeias de caracteres. Para grandes cadeias de caracteres, você terá que escolher entre o uso de buffers muito grandes e captura de erros no caso raro em que um buffer mais razoável é muito pequeno. Você também poderá considerar o uso uma abordagem diferente <xref:System.Text.Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> não tem nenhuma relação com <xref:System.Text.Encoding.GetBytes%2A>. Se você precisa de uma função semelhante para usar com <xref:System.Text.Encoding.GetBytes%2A>, você deve usar <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Ao usar <xref:System.Text.Encoding.GetMaxCharCount%2A>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada. Se o buffer de saída é restrito de tamanho, você pode usar o <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método.  
  
 Observe que <xref:System.Text.Encoding.GetMaxCharCount%2A> considera o pior caso para bytes restantes de uma operação de codificador anterior. Para a maioria das páginas de código, passando um valor de 0 para esse método recupera valores maiores que ou iguais a 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` não é necessariamente o mesmo valor que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos os <see cref="T:System.Text.Encoding" /> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se os buffers são dimensionados de acordo com os resultados dos cálculos desse método.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna uma sequência de bytes que especifica a codificação usada.</summary>
        <returns>Uma matriz de bytes que contém uma sequência de bytes que especifica a codificação usada.  
  
- ou - 
Uma matriz de bytes de tamanho zero, se um preâmbulo não for necessário.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcionalmente, o <xref:System.Text.Encoding> objeto fornece um preâmbulo que é uma matriz de bytes que pode ser prefixado à sequência de bytes resultante do processo de codificação. Se o preâmbulo contiver uma marca de ordem de byte (em Unicode, o ponto de código U + FEFF), ele ajuda o decodificador determinar a ordem de byte e o formato de transformação ou UTF.  
  
 A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):  
  
-   UTF-8: EF BB BF  
  
-   Ordem de byte do UTF-16 big endian: FF FE  
  
-   Ordem de byte endian UTF-16 little: FF FE  
  
-   Ordem de byte big endian da UTF-32: 00 00 FE FF  
  
-   Ordem de byte endian UTF-32 little: FF FE 00 00  
  
 Você deve usar o BOM, porque ele fornece quase determinada identificação de uma codificação para arquivos que de outra maneira tem perdido a referência para o <xref:System.Text.Encoding> objeto, por exemplo, sem marcas ou marcados incorretamente os dados da web ou arquivos de texto aleatório armazenados quando uma empresa não especificou ter preocupações internacionais ou outros dados. Problemas do usuário geralmente podem ser evitados se os dados são consistentemente e corretamente marcados, preferencialmente em UTF-8 ou UTF-16.  
  
 Para os padrões que fornecem um tipo de codificação, um BOM é algo redundante. No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto. Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário é perdido.  
  
 Há algumas desvantagens no uso de um BOM. Por exemplo, saber como limitar os campos de banco de dados que usam uma BOM pode ser difícil. Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode acabar no meio de dados. Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.  
  
 Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte padrão Unicode na [página inicial do Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para garantir que os bytes codificados são decodificados corretamente, você deve prefixar bytes codificados com um preâmbulo. No entanto, a maioria das codificações não fornecem um preâmbulo. Para garantir que os bytes codificados são decodificados corretamente, você deve usar uma codificação Unicode, ou seja, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, ou <xref:System.Text.UTF32Encoding>, com um preâmbulo.  
  
   
  
## Examples  
 O exemplo a seguir determina a ordem de byte da codificação com base no preâmbulo.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes em uma cadeia de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> objeto retornado pelo <xref:System.Text.Encoding.GetDecoder%2A> método de um deri classe vadas.  
  
 Consulte a seção de comentários do <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e considerações de decodificação.  
  
 Observe que o comportamento preciso dos <xref:System.Text.Encoding.GetString%2A> método para um determinado <xref:System.Text.Encoding> implementação depende a estratégia de fallback definida para aquela <xref:System.Text.Encoding> objeto. Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" a [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) tópico.  
  
   
  
## Examples  
 O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário, representado por um <xref:System.IO.FileStream> objeto. Para arquivos que são menores do que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> método para executar a decodificação. Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas a <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar quantos caracteres estão contidos na matriz e, em seguida, chama o <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para executar a decodificação.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 chamado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A matriz de bytes contém pontos de código Unicode inválidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro para uma matriz de bytes.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica um número especificado de bytes, começando em um endereço especificado em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.GetString%2A> método foi projetado para otimizar o desempenho quando você tem um ponteiro nativo em uma matriz de bytes. Em vez de criar uma matriz de bytes gerenciados e, em seguida, decodificá-lo, em vez disso, você pode chamar esse método sem ter de criar todos os objetos intermediários.  
  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> objeto retornado pelo <xref:System.Text.Encoding.GetDecoder%2A> método de um deri classe vadas.  
  
 Consulte a seção de comentários do <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e considerações de decodificação.  
  
 Observe que o comportamento preciso dos <xref:System.Text.Encoding.GetString%2A> método para um determinado <xref:System.Text.Encoding> implementação depende a estratégia de fallback definida para aquela <xref:System.Text.Encoding> objeto. Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" a [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) tópico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="bytes" /> é um ponteiro nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a ser convertido estão disponíveis somente em blocos sequenciais (como ler de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou o <xref:System.Text.Encoder> fornecidas pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 Consulte a seção de comentários do <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e considerações de decodificação.  
  
   
  
## Examples  
 O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário que é representado por um <xref:System.IO.FileStream> objeto. Para arquivos que são menores do que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para executar a decodificação. Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas a <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar quantos caracteres estão contidos na matriz e, em seguida, chama o <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para executar a decodificação.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 chamado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A matriz de bytes contém pontos de código Unicode inválidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (confira [Codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de cabeçalho do agente de email.</summary>
        <value>Um nome para o <see cref="T:System.Text.Encoding" /> atual a ser usado com marcas de cabeçalho do agente de email.  
  
- ou - 
Uma cadeia de caracteres vazia ("") se o <see cref="T:System.Text.Encoding" /> atual não puder ser usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar de uma codificação para um nome de cabeçalho, você deve chamar o <xref:System.Text.Encoding.GetEncoding%2A> método com o <xref:System.Text.Encoding.HeaderName%2A> propriedade. Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada. Geralmente, apenas os aplicativos de email precisam recuperar essa codificação.  
  
 Em alguns casos, o valor da <xref:System.Text.Encoding.BodyName%2A> propriedade corresponde ao padrão internacional que define a codificação. Isso não significa que a implementação está em conformidade por completo com esse padrão.  
  
 Observe que <xref:System.Text.Encoding.WebName%2A> retorna o nome a ser usado para descrever uma codificação. O <xref:System.Text.Encoding.HeaderName%2A> propriedade define uma codificação diferente que podem funcionar melhor para um aplicativo de email, por exemplo. No entanto, o uso da propriedade para definir a codificação não é recomendado.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se comparam em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um valor que indica se a codificação atual sempre é normalizada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a codificação atual sempre é normalizada usando o formulário de normalização padrão.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Text.Encoding" /> atual sempre é normalizado; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formulário de normalização padrão é <xref:System.Text.NormalizationForm.FormC>, que usa a decomposição canônica completa, seguida da substituição de sequências por seus compostos primários, se possível.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Um dos valores de <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual sempre é normalizada usando a forma de normalização especificada.</summary>
        <returns>
          <see langword="true" /> se o objeto <see cref="T:System.Text.Encoding" /> atual sempre é normalizado usando o valor <see cref="T:System.Text.NormalizationForm" /> especificado; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formulário de normalização padrão é <xref:System.Text.NormalizationForm.FormC>, que usa a decomposição canônica completa, seguida da substituição de sequências por seus compostos primários, se possível.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para exibir conteúdo.</summary>
        <value>
          <see langword="true" /> Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes do navegador para exibir o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para salvar conteúdo.</summary>
        <value>
          <see langword="true" /> Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes do navegador para salvar o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador e email para exibir conteúdo.</summary>
        <value>
          <see langword="true" /> Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes de email e notícias para exibir o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador e email para salvar conteúdo.</summary>
        <value>
          <see langword="true" /> Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes de email e notícias para salvar o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual é somente leitura.</summary>
        <value>
          <see langword="true" /> Se o atual <see cref="T:System.Text.Encoding" /> é somente leitura; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual usa pontos de código de byte único.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Text.Encoding" /> atual usa pontos de código de byte único; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um byte único de codificação, por exemplo, <xref:System.Text.ASCIIEncoding>, essa propriedade recupera `true`.  
  
> [!CAUTION]
>  Você deve ter cuidado com o que seu aplicativo faz com que o valor para <xref:System.Text.Encoding.IsSingleByte%2A>. Uma suposição de como uma codificação continuará ainda pode estar errada. Por exemplo, o Windows-1252 tem um valor de `true` para <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, mas Encoding.GetMaxByteCount(1) retorna 2. Isso ocorre porque o método considera substitutos abandonados potencias de uma operação anterior do decodificador.  
  
   
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Uma subclasse de <see cref="T:System.Text.EncodingProvider" /> que fornece acesso a codificações de caracteres adicionais.</param>
        <summary>Registra um provedor de codificação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.RegisterProvider%2A> método permite que você registre uma classe derivada de <xref:System.Text.EncodingProvider> que torna as codificações disponíveis em uma plataforma que não os suporta caso contrário. Depois que o provedor de codificação for registrado, as codificações que ele dá suporte podem ser recuperadas chamando qualquer <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> de sobrecarga. Se houver vários provedores de codificação, o <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> método tenta recuperar uma codificação especificada de cada provedor a partir daquele registrado mais recentemente.

Registrar um provedor de codificação usando o <xref:System.Text.Encoding.RegisterProvider%2A> método também modifica o comportamento do [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) e [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) métodos quando passou um argumento de `0`:

- Se o provedor registrado é o <xref:System.Text.CodePagesEncodingProvider>, o método retorna a codificação que corresponde à página de código ativa o sistema durante a execução no sistema operacional Windows.

- Um provedor de codificação personalizado pode escolher a codificação a ser retornado quando um desses <xref:System.Text.Encoding.GetEncoding%2A> sobrecargas do método é passado um argumento do `0`. O provedor também pode optar por não retornar uma codificação fazendo com que o <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> retorno de método `null`. 
  
Começando com o .NET Framework 4.6, o .NET Framework inclui um provedor de codificação, <xref:System.Text.CodePagesEncodingProvider>, que torna as codificações disponíveis que estão presentes no .NET Framework completo, mas não estão disponíveis na plataforma Universal do Windows. Por padrão, a plataforma Universal do Windows oferece suporte apenas a codificações Unicode, ASCII e página de código 28591.  
  
 Se o mesmo provedor de codificação é usado em várias chamadas para o <xref:System.Text.Encoding.RegisterProvider%2A> método, somente a primeira chamada de método registra o provedor. As chamadas subsequentes serão ignoradas.  
  
 Se o <xref:System.Text.Encoding.RegisterProvider%2A> método é chamado para registrar vários provedores que lidam com a mesma codificação, o último provedor registrado é usado para codificação e decodificação de operações de todos os. Nenhum provedor registrado anteriormente é ignorados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-16 usando a ordem de byte little endian.</summary>
        <value>Uma codificação para o formato UTF-16 usando a ordem de byte little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre as codificações suportadas pelo .NET e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
 O <xref:System.Text.UnicodeEncoding> objeto que é retornado por essa propriedade pode não ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que ele não consegue codificar e cada byte que ele não consegue decodificar por um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um pouco endian <xref:System.Text.UnicodeEncoding> objeto cujo retorno é um <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-32 usando a ordem de byte little endian.</summary>
        <value>Um objeto de codificação para o formato UTF-32 usando a ordem de byte little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UTF32Encoding> objeto que é retornado por essa propriedade pode não ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que ele não consegue codificar e cada byte que ele não consegue decodificar com o CARACTERE de substituição Unicode (U + FFFE). Em vez disso, você pode chamar o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar uma <xref:System.Text.UTF32Encoding> objeto cujo retorno é um <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Para uma discussão sobre a ordem de byte endian little, consulte o <xref:System.Text.Encoding> tópico da classe.  
  
 Para obter informações sobre as codificações suportadas pelo .NET e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-7.</summary>
        <value>Uma codificação para o formato UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificação UTF-7 é usado principalmente em ambientes que historicamente tem sido restrito para 7 bits, como NNTP e alguns aplicativos de email. Devido a problemas com eficiência e segurança, você não deve usar UTF7 codificação em ambientes de 8 bits em que a codificação UTF-8 pode ser usado em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-8.</summary>
        <value>Uma codificação para o formato UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna um <xref:System.Text.UTF8Encoding> objeto que codifica caracteres do Unicode (codificação UTF-16) em uma sequência de um a quatro bytes por caractere, e que decodifica uma matriz de bytes codificados em UTF-8 para caracteres do Unicode (codificação UTF-16). Para obter informações sobre as codificações de caracteres com suporte do .NET e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
 O <xref:System.Text.UTF8Encoding> objeto que é retornado por essa propriedade pode não ter o comportamento apropriado para seu aplicativo.  
  
-   Ele retorna um <xref:System.Text.UTF8Encoding> objeto que fornece uma marca de ordem de byte Unicode (BOM). Para criar uma instância de uma codificação UTF8 que não fornece um BOM, chamar qualquer sobrecarga da <xref:System.Text.UTF8Encoding.%23ctor%2A> construtor.  
  
-   Ele retorna um <xref:System.Text.UTF8Encoding> objeto que usa o fallback de substituição para substituir cada cadeia de caracteres que ele não consegue codificar e cada byte que ele não consegue decodificar por um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar uma <xref:System.Text.UTF8Encoding> objeto cujo retorno é um <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz que consiste dos seguintes caracteres:  
  
-   LETRA LATINA MINÚSCULA Z (U + 007A)  
  
-   UM (U + 0061) DE LETRA LATINA MINÚSCULA  
  
-   COMBINANDO BREVE (U + 0306)  
  
-   LETRA LATINA MINÚSCULA AE COM AGUDO (U + 01FD)  
  
-   LETRA MINÚSCULA GREGA BETA (U + 03B2)  
  
-   Um par substituto (U+D800 a U + DD54) que forma GREGA ACROPHONIC ATTIC um MILHARES STATERS (U + 10154).  
  
 Ele exibe as unidades de código de cada caractere UTF-16 e determina o número de bytes exigido por um codificador de UTF-8 para codificar a matriz de caracteres. Em seguida, ele codifica caracteres e exibe os bytes resultantes codificado em UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Noções básicas sobre codificações</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o nome registrado na IANA (Internet Assigned Numbers Authority) da codificação atual.</summary>
        <value>O nome IANA do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.WebName%2A> propriedade é o mesmo que o <xref:System.Text.EncodingInfo.Name%2A> propriedade.  
  
 Observe que <xref:System.Text.Encoding.WebName%2A> retorna um nome registrado pelo IANA da codificação. Quando seu valor é o nome de um padrão, a implementação da codificação não pode estar em conformidade por completo para esse padrão. O <xref:System.Text.Encoding.HeaderName%2A> propriedade define uma codificação diferente que podem funcionar melhor para cabeçalhos de email. No entanto, a maioria dos aplicativos deve usar <xref:System.Text.Encoding.WebName%2A> em vez disso.  
  
 Para obter mais informações sobre a IANA, acesse [www.iana.org](https://www.iana.org/).  
  
 O <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> é igual a <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> retornado pela <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Alguns dos nomes de web são duplicatas; Consulte os comentários para <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir inclui o <xref:System.Text.Encoding.WebName%2A> em um cabeçalho HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se comparam em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a página de código de sistema operacional Windows que mais bem corresponde à codificação atual.</summary>
        <value>A página de código de sistema operacional Windows que mais bem corresponde à <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida para compatibilidade com o multilíngue do Windows (MLang) APIs, por exemplo, determinar as famílias de fontes. Para a globalização, usar uma das codificações Unicode é recomendado em vez disso. Também é recomendável usar <xref:System.Text.Encoding.WebName%2A> em vez de <xref:System.Text.Encoding.WindowsCodePage%2A> para identificar a página de código.  
  
   
  
## Examples  
 O exemplo a seguir determina a página de código do Windows que mais corresponde à codificação de cada.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>