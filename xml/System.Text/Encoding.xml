<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Encoding.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5fc6c88231eb62b9546d10e0ac34250b51c4b7e10.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fc6c88231eb62b9546d10e0ac34250b51c4b7e10</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Represents a character encoding.</source>
          <target state="translated">Representa uma codificação de caracteres.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">Por outro lado, a decodificação é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter informações sobre os formatos do Unicode transformação (UTFs) e outras codificações com suporte <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> foi projetado para operar em caracteres Unicode em vez de dados arbitrários de binários, como matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deve codificar os dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The .NET Framework provides the following implementations of the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class to support current Unicode encodings and other encodings:</source>
          <target state="translated">O .NET Framework fornece as seguintes implementações de <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> classe para oferecer suporte a outras codificações e codificações de Unicode atuais:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> encodes Unicode characters as single 7-bit ASCII characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> codifica caracteres Unicode como único caracteres ASCII de 7 bits.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding only supports character values between U+0000 and U+007F.</source>
          <target state="translated">Esta codificação só dá suporte a valores de caractere entre U + 0000 e U + 007F.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 20127.</source>
          <target state="translated">Página de código 20127.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property.</source>
          <target state="translated">Também está disponível por meio de <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph> encodes Unicode characters using the UTF-7 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph> codifica caracteres Unicode usando a codificação UTF-7.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding supports all Unicode character values.</source>
          <target state="translated">Essa codificação dá suporte a todos os valores de caractere Unicode.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 65000.</source>
          <target state="translated">Página de código 65000.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> property.</source>
          <target state="translated">Também está disponível por meio de <ph id="ph1">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encodes Unicode characters using the UTF-8 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> codifica caracteres Unicode usando a codificação UTF-8.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding supports all Unicode character values.</source>
          <target state="translated">Essa codificação dá suporte a todos os valores de caractere Unicode.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 65001.</source>
          <target state="translated">Página de código 65001.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> property.</source>
          <target state="translated">Também está disponível por meio de <ph id="ph1">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> encodes Unicode characters using the UTF-16 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> codifica caracteres Unicode usando a codificação UTF-16.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Both little endian and big endian byte orders are supported.</source>
          <target state="translated">Há suporte para ambas as ordens little endian e big bytes endian.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> property.</source>
          <target state="translated">Também está disponível por meio de <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> propriedade e o <ph id="ph2">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> encodes Unicode characters using the UTF-32 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> codifica caracteres Unicode usando a codificação UTF-32.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</source>
          <target state="translated">Little endian (página de código 12000) tanto byte big endian (página de código 12001) ordens têm suporte.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> property.</source>
          <target state="translated">Também está disponível por meio de <ph id="ph1">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class is primarily intended to convert between different encodings and Unicode.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> classe é usado principalmente para converter entre codificações diferentes e Unicode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Often one of the derived Unicode classes is the correct choice for your app.</source>
          <target state="translated">Geralmente, uma das classes derivadas de Unicode é a opção correta para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method to obtain other encodings, and call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get a list of all encodings.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método para obter outras codificações e chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método para obter uma lista de todas as codificações.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following table lists the encodings supported by the .NET Framework.</source>
          <target state="translated">A tabela a seguir lista as codificações com suporte do .NET Framework.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It lists each encoding's code page number and the values of the encoding's <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Lista número de página de código do cada codificação e os valores da codificação <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform.</source>
          <target state="translated">Um asterisco na última coluna indica que a página de código nativo é suportada pelo .NET Framework, independentemente da plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that code pages whose <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> property corresponds to an international standard do not necessarily comply in full with that standard.</source>
          <target state="translated">Observe que o código de páginas cujo <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> propriedade corresponde a um padrão internacional não são necessariamente compatíveis por completo com esse padrão.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page</source>
          <target state="translated">Página de código</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Name</source>
          <target state="translated">Nome</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Display name</source>
          <target state="translated">Nome para exibição</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>.NET Framework support</source>
          <target state="translated">Suporte do .NET framework</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>37</source>
          <target state="translated">37</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM037</source>
          <target state="translated">IBM037</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (US-Canada)</source>
          <target state="translated">IBM EBCDIC (US-Canada)</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>437</source>
          <target state="translated">437</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM437</source>
          <target state="translated">IBM437</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM United States</source>
          <target state="translated">Estados Unidos de OEM</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>500</source>
          <target state="translated">500</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM500</source>
          <target state="translated">IBM500</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (International)</source>
          <target state="translated">IBM EBCDIC (International)</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>708</source>
          <target state="translated">708</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ASMO-708</source>
          <target state="translated">ASMO-708</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (ASMO 708)</source>
          <target state="translated">Árabe (ASMO 708)</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>720</source>
          <target state="translated">720</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>DOS-720</source>
          <target state="translated">DOS-720</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (DOS)</source>
          <target state="translated">Árabe (DOS)</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>737</source>
          <target state="translated">737</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm737</source>
          <target state="translated">ibm737</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (DOS)</source>
          <target state="translated">Grego (DOS)</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>775</source>
          <target state="translated">775</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm775</source>
          <target state="translated">ibm775</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (DOS)</source>
          <target state="translated">Báltico (DOS)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>850</source>
          <target state="translated">850</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm850</source>
          <target state="translated">ibm850</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (DOS)</source>
          <target state="translated">Europeu Ocidental (DOS)</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>852</source>
          <target state="translated">852</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm852</source>
          <target state="translated">ibm852</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (DOS)</source>
          <target state="translated">Europeu central (DOS)</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>855</source>
          <target state="translated">855</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM855</source>
          <target state="translated">IBM855</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM Cyrillic</source>
          <target state="translated">Cirílico OEM</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>857</source>
          <target state="translated">857</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm857</source>
          <target state="translated">ibm857</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (DOS)</source>
          <target state="translated">Turco (DOS)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>858</source>
          <target state="translated">858</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM00858</source>
          <target state="translated">IBM00858</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM Multilingual Latin I</source>
          <target state="translated">OEM latino multilíngue I</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>860</source>
          <target state="translated">860</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM860</source>
          <target state="translated">IBM860</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Portuguese (DOS)</source>
          <target state="translated">Português (DOS)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>861</source>
          <target state="translated">861</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm861</source>
          <target state="translated">ibm861</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Icelandic (DOS)</source>
          <target state="translated">Islandês (DOS)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>862</source>
          <target state="translated">862</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>DOS-862</source>
          <target state="translated">DOS-862</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (DOS)</source>
          <target state="translated">Hebraico (DOS)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>863</source>
          <target state="translated">863</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM863</source>
          <target state="translated">IBM863</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>French Canadian (DOS)</source>
          <target state="translated">Francês canadense (DOS)</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>864</source>
          <target state="translated">864</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM864</source>
          <target state="translated">IBM864</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (864)</source>
          <target state="translated">Árabe (864)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>865</source>
          <target state="translated">865</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM865</source>
          <target state="translated">IBM865</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Nordic (DOS)</source>
          <target state="translated">Nórdico (DOS)</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>866</source>
          <target state="translated">866</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp866</source>
          <target state="translated">cp866</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (DOS)</source>
          <target state="translated">Cirílico (DOS)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>869</source>
          <target state="translated">869</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm869</source>
          <target state="translated">ibm869</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek, Modern (DOS)</source>
          <target state="translated">Grego moderno (DOS)</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>870</source>
          <target state="translated">870</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM870</source>
          <target state="translated">IBM870</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Multilingual Latin-2)</source>
          <target state="translated">IBM EBCDIC (latino multilíngue-2)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>874</source>
          <target state="translated">874</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-874</source>
          <target state="translated">windows-874</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Thai (Windows)</source>
          <target state="translated">Tailandês (Windows)</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>875</source>
          <target state="translated">875</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp875</source>
          <target state="translated">cp875</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Greek Modern)</source>
          <target state="translated">IBM EBCDIC (Grego moderno)</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>932</source>
          <target state="translated">932</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>shift_jis</source>
          <target state="translated">shift_jis</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (Shift-JIS)</source>
          <target state="translated">Japonês (JIS-Shift)</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>936</source>
          <target state="translated">936</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>gb2312</source>
          <target state="translated">gb2312</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB2312)</source>
          <target state="translated">Chinês simplificado (GB2312)</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>949</source>
          <target state="translated">949</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ks_c_5601-1987</source>
          <target state="translated">ks_c_5601-1987</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean</source>
          <target state="translated">Coreano</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>950</source>
          <target state="translated">950</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>big5</source>
          <target state="translated">Big5</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Big5)</source>
          <target state="translated">Chinês tradicional (Big5)</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1026</source>
          <target state="translated">1026</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM1026</source>
          <target state="translated">IBM1026</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Turkish Latin-5)</source>
          <target state="translated">IBM EBCDIC (Turkish Latin-5)</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1047</source>
          <target state="translated">1047</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01047</source>
          <target state="translated">IBM01047</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM Latin-1</source>
          <target state="translated">IBM Latin-1</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1140</source>
          <target state="translated">1140</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01140</source>
          <target state="translated">IBM01140</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (US-Canada-Euro)</source>
          <target state="translated">IBM EBCDIC (EUA-Canadá-Euro)</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1141</source>
          <target state="translated">1141</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01141</source>
          <target state="translated">IBM01141</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Germany-Euro)</source>
          <target state="translated">IBM EBCDIC (Germany-Euro)</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1142</source>
          <target state="translated">1142</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01142</source>
          <target state="translated">IBM01142</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Denmark-Norway-Euro)</source>
          <target state="translated">IBM EBCDIC (Denmark-Norway-Euro)</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1143</source>
          <target state="translated">1143</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01143</source>
          <target state="translated">IBM01143</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Finland-Sweden-Euro)</source>
          <target state="translated">IBM EBCDIC (Finlândia-Suécia-Euro)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1144</source>
          <target state="translated">1144</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01144</source>
          <target state="translated">IBM01144</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Italy-Euro)</source>
          <target state="translated">IBM EBCDIC (Italy-Euro)</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1145</source>
          <target state="translated">1145</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01145</source>
          <target state="translated">IBM01145</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Spain-Euro)</source>
          <target state="translated">IBM EBCDIC (Spain-Euro)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1146</source>
          <target state="translated">1146</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01146</source>
          <target state="translated">IBM01146</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (UK-Euro)</source>
          <target state="translated">IBM EBCDIC (Euro do Reino Unido)</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1147</source>
          <target state="translated">1147</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01147</source>
          <target state="translated">IBM01147</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (France-Euro)</source>
          <target state="translated">IBM EBCDIC (France-Euro)</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1148</source>
          <target state="translated">1148</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01148</source>
          <target state="translated">IBM01148</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (International-Euro)</source>
          <target state="translated">IBM EBCDIC (International-Euro)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1149</source>
          <target state="translated">1149</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01149</source>
          <target state="translated">IBM01149</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Icelandic-Euro)</source>
          <target state="translated">IBM EBCDIC (Icelandic-Euro)</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1200</source>
          <target state="translated">1200</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode</source>
          <target state="translated">Unicode</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1201</source>
          <target state="translated">1201</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>unicodeFFFE</source>
          <target state="translated">unicodeFFFE</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (Big endian)</source>
          <target state="translated">Unicode (Big endian)</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1250</source>
          <target state="translated">1250</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1250</source>
          <target state="translated">windows-1250</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (Windows)</source>
          <target state="translated">Europeu central (Windows)</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1251</source>
          <target state="translated">1251</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1251</source>
          <target state="translated">windows-1251</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (Windows)</source>
          <target state="translated">Cirílico (Windows)</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1252</source>
          <target state="translated">1252</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Windows-1252</source>
          <target state="translated">Windows-1252</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (Windows)</source>
          <target state="translated">Europeu Ocidental (Windows)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1253</source>
          <target state="translated">1253</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1253</source>
          <target state="translated">windows-1253</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (Windows)</source>
          <target state="translated">Grego (Windows)</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1254</source>
          <target state="translated">1254</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1254</source>
          <target state="translated">windows-1254</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (Windows)</source>
          <target state="translated">Turco (Windows)</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1255</source>
          <target state="translated">1255</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1255</source>
          <target state="translated">windows-1255</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (Windows)</source>
          <target state="translated">Hebraico (Windows)</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1256</source>
          <target state="translated">1256</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1256</source>
          <target state="translated">windows-1256</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (Windows)</source>
          <target state="translated">Árabe (Windows)</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1257</source>
          <target state="translated">1257</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1257</source>
          <target state="translated">windows-1257</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (Windows)</source>
          <target state="translated">Báltico (Windows)</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1258</source>
          <target state="translated">1258</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1258</source>
          <target state="translated">windows-1258</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Vietnamese (Windows)</source>
          <target state="translated">Vietnamita (Windows)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1361</source>
          <target state="translated">1361</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Johab</source>
          <target state="translated">Johab</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (Johab)</source>
          <target state="translated">Coreano (Johab)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10000</source>
          <target state="translated">10000</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>macintosh</source>
          <target state="translated">macintosh</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (Mac)</source>
          <target state="translated">Europeu Ocidental (Mac)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10001</source>
          <target state="translated">10001</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-japanese</source>
          <target state="translated">x-mac-japonês</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (Mac)</source>
          <target state="translated">Japonês (Mac)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10002</source>
          <target state="translated">10002</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-chinesetrad</source>
          <target state="translated">x-mac-chinesetrad</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Mac)</source>
          <target state="translated">Chinês tradicional (Mac)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10003</source>
          <target state="translated">10003</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-korean</source>
          <target state="translated">x-mac-coreano</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (Mac)</source>
          <target state="translated">Coreano (Mac)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10004</source>
          <target state="translated">10004</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-arabic</source>
          <target state="translated">x-mac-arabic</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (Mac)</source>
          <target state="translated">Árabe (Mac)</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10005</source>
          <target state="translated">10005</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-hebrew</source>
          <target state="translated">x-mac-hebrew</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (Mac)</source>
          <target state="translated">Hebraico (Mac)</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10006</source>
          <target state="translated">10006</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-greek</source>
          <target state="translated">x-mac-grego</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (Mac)</source>
          <target state="translated">Grego (Mac)</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10007</source>
          <target state="translated">10007</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-cyrillic</source>
          <target state="translated">x-mac-cirílico</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (Mac)</source>
          <target state="translated">Cirílico (Mac)</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10008</source>
          <target state="translated">10008</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-chinesesimp</source>
          <target state="translated">x-mac-chinesesimp</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (Mac)</source>
          <target state="translated">Chinês simplificado (Mac)</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10010</source>
          <target state="translated">10010</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-romanian</source>
          <target state="translated">Romeno-mac-x</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Romanian (Mac)</source>
          <target state="translated">Romeno (Mac)</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10017</source>
          <target state="translated">10017</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-ukrainian</source>
          <target state="translated">Ucraniano-mac-x</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Ukrainian (Mac)</source>
          <target state="translated">Ucraniano (Mac)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10021</source>
          <target state="translated">10021</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-thai</source>
          <target state="translated">x-mac-thai</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Thai (Mac)</source>
          <target state="translated">Tailandês (Mac)</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10029</source>
          <target state="translated">10029</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-ce</source>
          <target state="translated">x-mac-ce</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (Mac)</source>
          <target state="translated">Europeu central (Mac)</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10079</source>
          <target state="translated">10079</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-icelandic</source>
          <target state="translated">x-mac-Islandês</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Icelandic (Mac)</source>
          <target state="translated">Islandês (Mac)</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10081</source>
          <target state="translated">10081</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-turkish</source>
          <target state="translated">x-mac-turco</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (Mac)</source>
          <target state="translated">Turco (Mac)</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10082</source>
          <target state="translated">10082</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-croatian</source>
          <target state="translated">x-mac-croata</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Croatian (Mac)</source>
          <target state="translated">Croata (Mac)</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>12000</source>
          <target state="translated">12000</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-32</source>
          <target state="translated">utf-32</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-32)</source>
          <target state="translated">Unicode (UTF-32)</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>12001</source>
          <target state="translated">12001</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-32BE</source>
          <target state="translated">UTF-32BE</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-32 Big endian)</source>
          <target state="translated">Unicode (UTF-32 Big endian)</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20000</source>
          <target state="translated">20000</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Chinese-CNS</source>
          <target state="translated">x-Chinese-CNS</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (CNS)</source>
          <target state="translated">Chinês tradicional (CNS)</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20001</source>
          <target state="translated">20001</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20001</source>
          <target state="translated">x-cp20001</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>TCA Taiwan</source>
          <target state="translated">TCA Taiwan</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20002</source>
          <target state="translated">20002</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Chinese-Eten</source>
          <target state="translated">Chinês-x-Eten</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Eten)</source>
          <target state="translated">Chinês tradicional (Eten)</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20003</source>
          <target state="translated">20003</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20003</source>
          <target state="translated">x-cp20003</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM5550 Taiwan</source>
          <target state="translated">IBM5550 Taiwan</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20004</source>
          <target state="translated">20004</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20004</source>
          <target state="translated">x-cp20004</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>TeleText Taiwan</source>
          <target state="translated">Teletexto Taiwan</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20005</source>
          <target state="translated">20005</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20005</source>
          <target state="translated">x-cp20005</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Wang Taiwan</source>
          <target state="translated">Wang Taiwan</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20105</source>
          <target state="translated">20105</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5</source>
          <target state="translated">x-IA5</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (IA5)</source>
          <target state="translated">Europeu Ocidental (IA5)</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20106</source>
          <target state="translated">20106</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-German</source>
          <target state="translated">x-IA5-alemão</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>German (IA5)</source>
          <target state="translated">Alemão (IA5)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20107</source>
          <target state="translated">20107</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-Swedish</source>
          <target state="translated">x-IA5-sueco</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Swedish (IA5)</source>
          <target state="translated">Sueco (IA5)</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20108</source>
          <target state="translated">20108</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-Norwegian</source>
          <target state="translated">x-IA5-Norueguês</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Norwegian (IA5)</source>
          <target state="translated">Norueguês (IA5)</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20127</source>
          <target state="translated">20127</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>us-ascii</source>
          <target state="translated">us-ascii</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>US-ASCII</source>
          <target state="translated">US-ASCII</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20261</source>
          <target state="translated">20261</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20261</source>
          <target state="translated">x-cp20261</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>T.61</source>
          <target state="translated">T.61</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20269</source>
          <target state="translated">20269</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20269</source>
          <target state="translated">x-cp20269</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISO-6937</source>
          <target state="translated">ISO-6937</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20273</source>
          <target state="translated">20273</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM273</source>
          <target state="translated">IBM273</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Germany)</source>
          <target state="translated">IBM EBCDIC (Alemanha)</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20277</source>
          <target state="translated">20277</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM277</source>
          <target state="translated">IBM277</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Denmark-Norway)</source>
          <target state="translated">IBM EBCDIC (Dinamarca-Noruega)</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20278</source>
          <target state="translated">20278</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM278</source>
          <target state="translated">IBM278</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Finland-Sweden)</source>
          <target state="translated">IBM EBCDIC (Finlândia-Suécia)</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20280</source>
          <target state="translated">20280</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM280</source>
          <target state="translated">IBM280</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Italy)</source>
          <target state="translated">IBM EBCDIC (Itália)</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20284</source>
          <target state="translated">20284</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM284</source>
          <target state="translated">IBM284</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Spain)</source>
          <target state="translated">IBM EBCDIC (Spain)</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20285</source>
          <target state="translated">20285</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM285</source>
          <target state="translated">IBM285</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (UK)</source>
          <target state="translated">IBM EBCDIC (UK)</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20290</source>
          <target state="translated">20290</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM290</source>
          <target state="translated">IBM290</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Japanese katakana)</source>
          <target state="translated">IBM EBCDIC (japonês katakana)</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20297</source>
          <target state="translated">20297</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM297</source>
          <target state="translated">IBM297</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (France)</source>
          <target state="translated">IBM EBCDIC (França)</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20420</source>
          <target state="translated">20420</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM420</source>
          <target state="translated">IBM420</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Arabic)</source>
          <target state="translated">IBM EBCDIC (Arabic)</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20423</source>
          <target state="translated">20423</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM423</source>
          <target state="translated">IBM423</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Greek)</source>
          <target state="translated">IBM EBCDIC (Greek)</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20424</source>
          <target state="translated">20424</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM424</source>
          <target state="translated">IBM424</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Hebrew)</source>
          <target state="translated">IBM EBCDIC (hebraico)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20833</source>
          <target state="translated">20833</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-EBCDIC-KoreanExtended</source>
          <target state="translated">x-EBCDIC-KoreanExtended</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Korean Extended)</source>
          <target state="translated">IBM EBCDIC (coreano estendido)</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20838</source>
          <target state="translated">20838</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM-Thai</source>
          <target state="translated">IBM-Thai</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Thai)</source>
          <target state="translated">IBM EBCDIC (Thai)</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20866</source>
          <target state="translated">20866</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>koi8-r</source>
          <target state="translated">koi8-r</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (KOI8-R)</source>
          <target state="translated">Cirílico (KOI8-R)</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20871</source>
          <target state="translated">20871</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM871</source>
          <target state="translated">IBM871</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Icelandic)</source>
          <target state="translated">IBM EBCDIC (Islandês)</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20880</source>
          <target state="translated">20880</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM880</source>
          <target state="translated">IBM880</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Cyrillic Russian)</source>
          <target state="translated">IBM EBCDIC (Cyrillic Russian)</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20905</source>
          <target state="translated">20905</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM905</source>
          <target state="translated">IBM905</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Turkish)</source>
          <target state="translated">IBM EBCDIC (Turkish)</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20924</source>
          <target state="translated">20924</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM00924</source>
          <target state="translated">IBM00924</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM Latin-1</source>
          <target state="translated">IBM Latin-1</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20932</source>
          <target state="translated">20932</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>EUC-JP</source>
          <target state="translated">EUC-JP</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS 0208-1990 and 0212-1990)</source>
          <target state="translated">Japonês (JIS 0208-1990 e 0212-1990)</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20936</source>
          <target state="translated">20936</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20936</source>
          <target state="translated">x-cp20936</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB2312-80)</source>
          <target state="translated">Chinês simplificado (GB2312-80)</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20949</source>
          <target state="translated">20949</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20949</source>
          <target state="translated">x-cp20949</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean Wansung</source>
          <target state="translated">Coreano Wansung</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>21025</source>
          <target state="translated">21025</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp1025</source>
          <target state="translated">cp1025</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Cyrillic Serbian-Bulgarian)</source>
          <target state="translated">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>21866</source>
          <target state="translated">21866</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>koi8-u</source>
          <target state="translated">koi8-u</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (KOI8-U)</source>
          <target state="translated">Cirílico (KOI8-U)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28591</source>
          <target state="translated">28591</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-1</source>
          <target state="translated">iso-8859-1</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (ISO)</source>
          <target state="translated">Europeu Ocidental (ISO)</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28592</source>
          <target state="translated">28592</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-2</source>
          <target state="translated">iso-8859-2</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (ISO)</source>
          <target state="translated">Europeu central (ISO)</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28593</source>
          <target state="translated">28593</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-3</source>
          <target state="translated">iso-8859-3</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Latin 3 (ISO)</source>
          <target state="translated">3 latinos (ISO)</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28594</source>
          <target state="translated">28594</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-4</source>
          <target state="translated">iso-8859-4</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (ISO)</source>
          <target state="translated">Báltico (ISO)</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28595</source>
          <target state="translated">28595</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-5</source>
          <target state="translated">iso-8859-5</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (ISO)</source>
          <target state="translated">Cirílico (ISO)</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28596</source>
          <target state="translated">28596</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-6</source>
          <target state="translated">iso-8859-6</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (ISO)</source>
          <target state="translated">Árabe (ISO)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28597</source>
          <target state="translated">28597</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-7</source>
          <target state="translated">iso-8859-7</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (ISO)</source>
          <target state="translated">Grego (ISO)</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28598</source>
          <target state="translated">28598</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-8</source>
          <target state="translated">iso-8859-8</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (ISO-Visual)</source>
          <target state="translated">Hebraico (ISO-Visual)</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28599</source>
          <target state="translated">28599</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-9</source>
          <target state="translated">iso-8859-9</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (ISO)</source>
          <target state="translated">Turco (ISO)</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28603</source>
          <target state="translated">28603</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-13</source>
          <target state="translated">iso-8859-13</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Estonian (ISO)</source>
          <target state="translated">Estoniano (ISO)</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28605</source>
          <target state="translated">28605</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-15</source>
          <target state="translated">iso-8859-15</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Latin 9 (ISO)</source>
          <target state="translated">Latino 9 (ISO)</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>29001</source>
          <target state="translated">29001</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Europa</source>
          <target state="translated">x-Europa</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Europa</source>
          <target state="translated">Europa</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>38598</source>
          <target state="translated">38598</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-8-i</source>
          <target state="translated">iso-8859-8-i</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (ISO-Logical)</source>
          <target state="translated">Hebraico (ISO-lógico)</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50220</source>
          <target state="translated">50220</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-jp</source>
          <target state="translated">iso-2022-jp</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS)</source>
          <target state="translated">Japonês (JIS)</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50221</source>
          <target state="translated">50221</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>csISO2022JP</source>
          <target state="translated">csISO2022JP</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS-Allow 1 byte Kana)</source>
          <target state="translated">Japonês (JIS-Permitir 1 byte Kana)</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50222</source>
          <target state="translated">50222</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-jp</source>
          <target state="translated">iso-2022-jp</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS-Allow 1 byte Kana - SO/SI)</source>
          <target state="translated">Japonês (JIS-Permitir 1 byte Kana - portanto / SI)</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50225</source>
          <target state="translated">50225</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-kr</source>
          <target state="translated">iso-2022-kr</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (ISO)</source>
          <target state="translated">Coreano (ISO)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50227</source>
          <target state="translated">50227</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp50227</source>
          <target state="translated">x-cp50227</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (ISO-2022)</source>
          <target state="translated">Chinês simplificado (ISO-2022)</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51932</source>
          <target state="translated">51932</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>euc-jp</source>
          <target state="translated">euc-jp</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (EUC)</source>
          <target state="translated">Japonês (EUC)</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51936</source>
          <target state="translated">51936</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>EUC-CN</source>
          <target state="translated">EUC-CN</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (EUC)</source>
          <target state="translated">Chinês simplificado (EUC)</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51949</source>
          <target state="translated">51949</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>euc-kr</source>
          <target state="translated">EUC-kr</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (EUC)</source>
          <target state="translated">Coreano (EUC)</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>52936</source>
          <target state="translated">52936</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>hz-gb-2312</source>
          <target state="translated">hz-gb-2312</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (HZ)</source>
          <target state="translated">Chinês simplificado (HZ)</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>54936</source>
          <target state="translated">54936</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>GB18030</source>
          <target state="translated">GB18030</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB18030)</source>
          <target state="translated">Chinês simplificado (GB18030)</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57002</source>
          <target state="translated">57002</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-de</source>
          <target state="translated">x-iscii-de</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Devanagari</source>
          <target state="translated">ISCII Devanagari</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57003</source>
          <target state="translated">57003</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-be</source>
          <target state="translated">x-iscii-be</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Bengali</source>
          <target state="translated">Bengali ISCII</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57004</source>
          <target state="translated">57004</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ta</source>
          <target state="translated">x-iscii-ta</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Tamil</source>
          <target state="translated">ISCII Tâmil</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57005</source>
          <target state="translated">57005</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-te</source>
          <target state="translated">x-iscii-te</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Telugu</source>
          <target state="translated">Télugo ISCII</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57006</source>
          <target state="translated">57006</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-as</source>
          <target state="translated">x-iscii-as</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Assamese</source>
          <target state="translated">Assamês ISCII</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57007</source>
          <target state="translated">57007</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-or</source>
          <target state="translated">x-iscii-or</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Oriya</source>
          <target state="translated">Oriá ISCII</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57008</source>
          <target state="translated">57008</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ka</source>
          <target state="translated">x-iscii-ka</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Kannada</source>
          <target state="translated">ISCII Kannada</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57009</source>
          <target state="translated">57009</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ma</source>
          <target state="translated">x-iscii-ma</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Malayalam</source>
          <target state="translated">ISCII Malaio</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57010</source>
          <target state="translated">57010</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-gu</source>
          <target state="translated">x-iscii-gu</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Gujarati</source>
          <target state="translated">Gujarati ISCII</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57011</source>
          <target state="translated">57011</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-pa</source>
          <target state="translated">x-iscii-pa</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Punjabi</source>
          <target state="translated">Punjabi ISCII</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>65000</source>
          <target state="translated">65000</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-7</source>
          <target state="translated">utf-7</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-7)</source>
          <target state="translated">Unicode (UTF-7)</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>65001</source>
          <target state="translated">65001</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-8</source>
          <target state="translated">utf-8</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-8)</source>
          <target state="translated">Unicode (UTF-8)</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> methods to get the Greek (Windows) code page encoding.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> a codificação de página de código de métodos para obter o grego (Windows).</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It compares the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</source>
          <target state="translated">Ele compara o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objetos retornados por chamadas de método para mostrar que forem iguais e, em seguida, o maps exibe o ponto de código Unicode e o valor de página de código correspondente para cada caractere do alfabeto grego.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</source>
          <target state="translated">O UTF-16 e os codificadores UTF-32 podem usar a ordem de byte big endian (byte mais significativo primeiro) ou a ordem de bytes endian pouca (byte menos significativo primeiro).</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</source>
          <target state="translated">Por exemplo, a letra maiuscula latina um (U + 0041) é serializado como segue (em hexadecimal):</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-16 big endian byte order: 00 41</source>
          <target state="translated">Ordem de byte big endian da UTF-16: 00 41</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-16 little endian byte order: 41 00</source>
          <target state="translated">Ordem de byte endian UTF-16 little: 41 00</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-32 big endian byte order: 00 00 00 41</source>
          <target state="translated">Ordem de byte big endian da UTF-32: 00 00 00 41</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-32 little endian byte order: 41 00 00 00</source>
          <target state="translated">Ordem de byte endian pouco UTF-32: 41 00 00 00</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It is generally more efficient to store Unicode characters using the native byte order.</source>
          <target state="translated">É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</source>
          <target state="translated">Por exemplo, é melhor usar a ordem de bytes endian pouco em plataformas endian pequeno, como computadores Intel.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> method retrieves an array of bytes that includes the byte order mark (BOM).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> método recupera uma matriz de bytes que inclui a marca de ordem de byte (BOM).</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</source>
          <target state="translated">Se a matriz de bytes é o prefixo para um fluxo codificado, isso ajuda o decodificador para identificar o formato de codificação usado.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no <bpt id="p1">[</bpt>home page do Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that the encoding classes allow errors to:</source>
          <target state="translated">Observe que as classes de codificação permitem erros:</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Silently change to a "?" character.</source>
          <target state="translated">Alterar modo silencioso para um "?" caracteres.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Use a "best fit" character.</source>
          <target state="translated">Use um caractere de "melhor ajuste".</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Change to an application-specific behavior through use of the <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes with the U+FFFD Unicode replacement character.</source>
          <target state="translated">Altere para um comportamento específico do aplicativo através do uso de <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes com o caractere de substituição de U + FFFD Unicode.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>You should throw an exception on any data stream error.</source>
          <target state="translated">Você deve lançar uma exceção em qualquer erro de fluxo de dados.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>An app either uses a "throwonerror" flag when applicable or uses the <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.</source>
          <target state="translated">Um aplicativo usa um sinalizador de "throwonerror" quando aplicável ou usa o <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</source>
          <target state="translated">Fallback se ajuste melhor geralmente não é recomendável porque pode causar perda de dados ou confusão e é mais lenta que a substituição de caracteres simples.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For ANSI encodings, the best fit behavior is the default.</source>
          <target state="translated">Para codificações ANSI, o melhor ajuste é o comportamento padrão.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The byte[] array is the only type in this example that contains the encoded data.</source>
          <target state="translated">A matriz do byte [] é o único tipo neste exemplo que contém os dados codificados.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The .NET Char and String types are themselves Unicode, so the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call decodes the data back to Unicode.</source>
          <target state="translated">Os tipos de .NET Char e cadeia de caracteres são Unicode, portanto, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamada decodifica os dados em Unicode.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor">
          <source>Derived classes override this constructor.</source>
          <target state="translated">Classes derivadas substituir este construtor.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">O identificador de página de código da codificação preferencial.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>0, to use the default encoding.</source>
          <target state="translated">0, para usar a codificação padrão.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class that corresponds to the specified code page.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> que corresponde à página de código especificada.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Derived classes override this constructor.</source>
          <target state="translated">Classes derivadas substituir este construtor.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Calls to this constructor from a derived class create an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object that uses best-fit fallback for both encoding and decoding operations.</source>
          <target state="translated">Criar chamadas para o construtor de classe derivada uma <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objeto que usa o retorno de melhor ajuste para codificação e decodificação de operações.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Both the <ph id="ph1">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> properties are read-only and cannot be modified.</source>
          <target state="translated">Tanto o <ph id="ph1">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> propriedades são somente leitura e não pode ser modificadas.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>To control the fallback strategy for a class derived from <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> constructor.</source>
          <target state="translated">Para controlar a estratégia de fallback para uma classe derivada de <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding code page identifier.</source>
          <target state="translated">O identificador de página de código da codificação.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> que corresponde à página de código especificada com as estratégias de fallback de codificador e decodificador especificadas.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>This constructor is <ph id="ph1">`protected`</ph>; derived classes override it.</source>
          <target state="translated">Este construtor é <ph id="ph1">`protected`</ph>; derivada classes substituem-la.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You call this constructor from a derived class to control the fallback encoding and decoding strategies.</source>
          <target state="translated">Você pode chamar esse construtor de uma classe derivada para controlar o fallback de codificação e decodificação estratégias.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> construtores de classe criam objetos de codificação somente leitura que não permitem o codificador ou decodificador de fallback a ser definido depois que o objeto é criado.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If either <ph id="ph1">`encoderFallback`</ph> or <ph id="ph2">`decoderFallback`</ph> is null, best-fit fallback is used as the corresponding fallback strategy.</source>
          <target state="translated">Se qualquer um dos <ph id="ph1">`encoderFallback`</ph> ou <ph id="ph2">`decoderFallback`</ph> for vazio, fallback melhor ajuste é usado como a estratégia de fallback correspondente.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.ASCII">
          <source>Gets an encoding for the ASCII (7-bit) character set.</source>
          <target state="translated">Obtém uma codificação para o conjunto de caracteres ASCII (7 bits).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>An  encoding for the ASCII (7-bit) character set.</source>
          <target state="translated">Uma codificação para o conjunto de caracteres ASCII (7 bits).</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</source>
          <target state="translated">Caracteres ASCII são limitados para os mais baixo 128 caracteres Unicode U + 0000 a U + 007F.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>When selecting the ASCII encoding for your app, consider the following:</source>
          <target state="translated">Ao selecionar a codificação ASCII para seu aplicativo, considere o seguinte:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The ASCII encoding is usually appropriate for protocols that require ASCII.</source>
          <target state="translated">A codificação ASCII normalmente é adequada para protocolos que exijam ASCII.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</source>
          <target state="translated">Se você exigir codificação de 8 bits (que às vezes incorretamente é conhecido como "ASCII"), a codificação UTF-8 é recomendada durante o ASCII de codificação.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</source>
          <target state="translated">Para os caracteres 0-7F, os resultados são idênticos, mas o uso de UTF-8 evita perda de dados, permitindo que a representação de todos os caracteres Unicode representável.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</source>
          <target state="translated">Observe que a codificação ASCII tem um 8 bits ambiguidade que pode permitir que o uso mal-intencionado, mas a codificação UTF-8 remove a ambiguidade de 8 bits.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</source>
          <target state="translated">Antes do .NET Framework versão 2.0, o .NET Framework permitidos falsificação ignorando os 8 bits.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</source>
          <target state="translated">Começando com o .NET Framework 2.0, pontos de código não-ASCII retornam durante a decodificação.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method to instantiate an <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Em vez disso, você pode chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> método para instanciar um <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> objeto cujo fallback é uma <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou um <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</source>
          <target state="translated">O exemplo a seguir demonstra o efeito da codificação de caracteres que estão fora do intervalo ASCII de ASCII.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Gets an encoding for the UTF-16 format that uses the big endian byte order.</source>
          <target state="translated">Obtém uma codificação para o formato UTF-16 que usa a ordem de byte big endian.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>An encoding object for the UTF-16 format that uses the big endian byte order.</source>
          <target state="translated">Um objeto de codificação para o formato UTF-16 que usa a ordem de byte big endian.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a big endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Em vez disso, você pode chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> construtor para instanciar um big endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto cujo fallback é uma <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The returned <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object has <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> properties, which yield the name "unicodeFFFE".</source>
          <target state="translated">Retornado <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto tem <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriedades, que geram o nome "unicodeFFFE".</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</source>
          <target state="translated">Embora a marca de ordem de byte big endian UTF-16 é FEFF hexadecimal, o nome "unicodeFFFE" foi escolhido porque a marca de ordem de byte é exibido como FFFE hexadecimal little endian em computadores com Windows.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The following example reads a text file with a UTF-16 encoding using the big endian byte order.</source>
          <target state="translated">O exemplo a seguir lê um arquivo de texto com uma codificação UTF-16 usando a ordem de byte big endian.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.BodyName">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de corpo do agente de email.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>A name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> that can be used with mail agent body tags.</source>
          <target state="translated">Um nome para o <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual que pode ser usado com marcas de corpo do agente de email.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>An empty string (""), if the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> cannot be used.</source>
          <target state="translated">Uma cadeia de caracteres vazia ("") se o <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual não puder ser usado.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>If you need an encoding for a body name, you should call <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property.</source>
          <target state="translated">Se você precisar de uma codificação para um nome de corpo, você deve chamar <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> com o <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
          <target state="translated">Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.</source>
          <target state="translated">Em geral somente aplicativos de email é necessário recuperar esses uma codificação; a maioria dos outros aplicativos que precisam para descrever uma codificação deve usar seus <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
          <target state="translated">Em alguns casos, o valor de <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriedade corresponde ao padrão internacional que define a codificação.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
          <target state="translated">Isso não significa que a implementação está em conformidade por completo com esse padrão.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Ele exibe <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mas não se compara em relação a ela.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Clone">
          <source>When overridden in a derived class, creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Quando substituído em uma classe derivada, cria uma cópia superficial do objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Clone">
          <source>A copy of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Uma cópia do objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>The clone is writable even if the original <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object is read-only.</source>
          <target state="translated">O clone é gravável mesmo que o original <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objeto é somente leitura.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>Therefore, the properties of the clone can be modified.</source>
          <target state="translated">Portanto, as propriedades do clone podem ser modificadas.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>A shallow copy of an object is a copy of the object only.</source>
          <target state="translated">Uma cópia superficial de um objeto é uma cópia do objeto somente.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</source>
          <target state="translated">Se o objeto contiver referências a outros objetos, a cópia superficial não cria cópias dos objetos referenciados.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>It refers to the original objects instead.</source>
          <target state="translated">Ela se refere aos objetos originais em vez disso.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</source>
          <target state="translated">Em contraste, uma cópia em profundidade de um objeto cria uma cópia do objeto e uma cópia de tudo direta ou indiretamente referenciado por esse objeto.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.CodePage">
          <source>When overridden in a derived class, gets the code page identifier of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">Quando é substituído em uma classe derivada, obtém o identificador de página de código do <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>The code page identifier of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">O identificador de página de código do <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Ele exibe <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mas não se compara em relação a ela.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Converts a byte array from one encoding to another.</source>
          <target state="translated">Converte uma matriz de bytes de uma codificação em outra.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The encoding format of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">O formato de codificação de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The target encoding format.</source>
          <target state="translated">O formato de codificação de destino.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The bytes to convert.</source>
          <target state="translated">Os bytes a serem convertidos.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>Converts an entire byte array from one encoding to another.</source>
          <target state="translated">Converte uma matriz de bytes inteira de uma codificação para outra.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> containing the results of converting <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> from <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> to <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os resultados da conversão <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> de <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> para <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The following example converts a Unicode-encoded string to an ASCII-encoded string.</source>
          <target state="translated">O exemplo a seguir converte uma cadeia de caracteres Unicode codificados em uma cadeia de caracteres codificados ASCII.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>Because the ASCII encoding object returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</source>
          <target state="translated">Porque o objeto de codificação ASCII retornado pelo <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> propriedade usa fallback de substituição e o caractere de Pi não faz parte do conjunto de caracteres ASCII, o caractere de Pi é substituído com um ponto de interrogação, como a saída mostra o exemplo.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The encoding of the source array, <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">A codificação de matriz de origem, <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The encoding of the output array.</source>
          <target state="translated">A codificação da matriz de saída.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The array of bytes to convert.</source>
          <target state="translated">A matriz de bytes a ser convertida.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first element of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> to convert.</source>
          <target state="translated">O índice do primeiro elemento de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> a ser convertido.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to convert.</source>
          <target state="translated">O número de bytes a serem convertidos.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>Converts a range of bytes in a byte array from one encoding to another.</source>
          <target state="translated">Converte um intervalo de bytes em uma matriz de bytes de uma codificação para outra.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> containing the result of converting a range of bytes in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> from <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> to <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém o resultado da conversão de um intervalo de bytes em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> de <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> para <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the byte array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não especificam um intervalo válido na matriz de bytes.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Text.DecoderFallback" /&gt;</ph> object for the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Obtém ou define o objeto <ph id="ph1">&lt;see cref="T:System.Text.DecoderFallback" /&gt;</ph> para o objeto <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The decoder fallback object for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">O objeto de fallback do decodificador para o objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph> objeto representa um manipulador de erro que é invocado quando não é possível decodificar uma sequência de bytes codificados em um caractere.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>Any one of the following handler types is supported:</source>
          <target state="translated">Há suporte para qualquer um dos seguintes tipos de manipulador:</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</source>
          <target state="translated">Um melhor ajuste manipulador de fallback, que substitui os bytes que não podem ser decodificadas com algum caractere substituto adequado.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</source>
          <target state="translated">Um manipulador de fallback de substituição, que substitui os bytes que não podem ser decodificadas com alguns caracteres de substituição arbitrário.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</source>
          <target state="translated">O .NET Framework inclui um manipulador de fallback de substituição, <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph>, que por padrão substitui bytes não podem ser decodificadas com um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>An exception fallback handler, which throws an exception when bytes cannot be decoded.</source>
          <target state="translated">Um manipulador de fallback de exceção, que gera uma exceção quando não não possível decodificar bytes.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, which throws a <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> when bytes cannot be decoded.</source>
          <target state="translated">O .NET Framework inclui um manipulador de fallback de exceção, <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, que gera um <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> quando bytes não podem ser decodificados.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The value in a set operation is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor em uma operação de definição é <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is read-only.</source>
          <target state="translated">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual é somente leitura.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.Default">
          <source>Gets the default encoding for this .NET implementation.</source>
          <target state="translated">Obtém a codificação padrão para esta implementação .NET.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The default encoding for this .NET implementation.</source>
          <target state="translated">A codificação padrão para essa implementação do .NET.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>Different computers can use different encodings as the default, and the default encoding can change on a single computer.</source>
          <target state="translated">Computadores diferentes podem usar diferentes codificações como o padrão, e a codificação padrão pode ser alterados em um único computador.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>If you use the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> codificação para codificar e decodificar dados transmitidos entre computadores ou recuperados em momentos diferentes no mesmo computador, ele pode converter dados incorretamente.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>In addition, the encoding returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</source>
          <target state="translated">Além disso, a codificação retornado pelo <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriedade usa fallback melhor ajuste para mapear caracteres sem suporte para caracteres suportados pela página de código.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>For these reasons, using the default encoding is not recommended.</source>
          <target state="translated">Por esses motivos, não é recomendável usar a codificação padrão.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente, você deve usar uma codificação Unicode, como <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</source>
          <target state="translated">Você também pode usar um protocolo de alto nível para garantir que o mesmo formato é usado para codificar e decodificar.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The Default property in the .NET Framework</source>
          <target state="translated">A propriedade padrão do .NET Framework</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>In the .NET Framework on the Windows desktop, the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property always gets the system's active code page and creates a <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> object that corresponds to it.</source>
          <target state="translated">No .NET Framework da área de trabalho do Windows, o <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriedade sempre obtém a página de código ativo do sistema e cria um <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> objeto correspondente a ele.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</source>
          <target state="translated">A página de código ativa pode ser uma página de código ANSI, que inclui um conjunto junto com os caracteres adicionais que variam por página de código de caracteres ASCII.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>Because all <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodings based on ANSI code pages lose data, consider using the <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> encoding instead.</source>
          <target state="translated">Como todos os <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> codificações com base nas páginas de código ANSI perda de dados, considere usar o <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> codificação em vez disso.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</source>
          <target state="translated">UTF-8 é geralmente idêntico no U + 00 ao intervalo de U + 7F, mas pode codificar caracteres fora do intervalo ASCII sem perda.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The Default property on .NET Core</source>
          <target state="translated">A propriedade padrão no .NET Core</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>On .NET Core, the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property always returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</source>
          <target state="translated">No núcleo do .NET, o <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriedade sempre retorna o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</source>
          <target state="translated">UTF-8 tem suporte em todos os sistemas operacionais (Windows, Linux e Max OS X) sobre quais aplicativos .NET Core executar.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> object for the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Obtém ou define o objeto <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> para o objeto <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The encoder fallback object for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">O objeto de fallback do codificador para o objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> objeto representa um manipulador de erro que é invocado quando um caractere não pode ser convertido em uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>Any one of the following handler types is supported:</source>
          <target state="translated">Há suporte para qualquer um dos seguintes tipos de manipulador:</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</source>
          <target state="translated">Um melhor ajuste manipulador de fallback, que substitui os caracteres que não podem ser codificados com algum caractere substituto adequado.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</source>
          <target state="translated">Um manipulador de fallback de substituição, que substitui os caracteres que não podem ser codificados com alguns caracteres de substituição arbitrário.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</source>
          <target state="translated">O .NET Framework inclui um manipulador de fallback de substituição, <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph>, que por padrão substitui caracteres que não podem ser codificados com um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>An exception fallback handler, which throws an exception when characters cannot be encoded.</source>
          <target state="translated">Um manipulador de fallback de exceção, que gera uma exceção quando caracteres não podem ser codificados.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, which throws an <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> when characters cannot be decoded.</source>
          <target state="translated">O .NET Framework inclui um manipulador de fallback de exceção, <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, que gera um <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> quando caracteres não podem ser decodificados.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The value in a set operation is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O valor em uma operação de definição é <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is read-only.</source>
          <target state="translated">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual é somente leitura.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncodingName">
          <source>When overridden in a derived class, gets the human-readable description of the current encoding.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém a descrição legível por humanos da codificação atual.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The human-readable description of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">A descrição legível por humanos do <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> property is intended for display.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> propriedade destina-se a exibição.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>To find a name that can be passed to the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property.</source>
          <target state="translated">Para localizar um nome que pode ser passado para o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Ele exibe <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mas não se compara em relação a ela.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to compare with the current instance.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> de comparação com a instância atual.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> is equal to the current instance.</source>
          <target state="translated">Determina se o <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificado é igual à instância atual.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> and is equal to the current instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> for uma instância de <ph id="ph3">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> e for igual à instância atual; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Two instances of <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> are considered equal if they correspond to the same code page and their <ph id="ph2">`EncoderFallback`</ph> and <ph id="ph3">`DecoderFallback`</ph> objects are equal.</source>
          <target state="translated">Duas instâncias do <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> são considerados iguais se eles correspondem à mesma página de código e seus <ph id="ph2">`EncoderFallback`</ph> e <ph id="ph3">`DecoderFallback`</ph> objetos são iguais.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>In particular, derived code pages all have a code page of 0 and their fallbacks are normally <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> in Visual Basic .NET).</source>
          <target state="translated">Em particular, páginas de código derivada todos têm uma página de código de 0 e suas sequências são normalmente <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> no Visual Basic .NET).</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Thus they are all considered equal to one another.</source>
          <target state="translated">Assim, eles são todos considerados iguais um ao outro.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>One consequence is that when <ph id="ph1">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</source>
          <target state="translated">Uma consequência é que quando <ph id="ph1">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> é usado para popular uma tabela de hash, todas as derivadas codificações de comparação igual e entram no mesmo slot de tabela de hash.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</source>
          <target state="translated">O exemplo a seguir obtém duas instâncias da mesma codificação (uma por página de código) e outra pelo nome e verifica sua igualdade.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The character array containing the characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém os caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de todos os caracteres na matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The number of bytes produced by encoding all the characters in the specified character array.</source>
          <target state="translated">O número de bytes produzidos codificando todos os caracteres na matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, chame o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>If your app handles string inputs, you should use the string versions of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar as versões de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>If your app must convert a large amount of data, you should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, você deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de caracteres na cadeia de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, chame o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
          <target state="translated">Se seu aplicativo lida com entradas de cadeia de caracteres, a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> é recomendado.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres começando no ponteiro de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requer para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The following are some considerations for using these methods:</source>
          <target state="translated">A seguir está algumas considerações para usar estes métodos:</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Your app may need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de um conjunto de caracteres da matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, chame o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
          <target state="translated">Se seu aplicativo lida com entradas de cadeia de caracteres, a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> é recomendado.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica um conjunto de caracteres em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The character array containing the characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém os caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica todos os caracteres na matriz de caracteres especificada em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If your app handles string inputs, you should call the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve chamar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The string containing the characters to encode.</source>
          <target state="translated">A cadeia de caracteres que contém os caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica todos os caracteres na cadeia de caracteres especificada em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica um conjunto de caracteres na matriz de caracteres especificada em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação da sequência de bytes resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">O número máximo de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados do ponteiro de bytes especificado.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by the <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> parameter.</source>
          <target state="translated">O número real de bytes gravados no local indicado pelo parâmetro <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requer para armazenar os bytes resultantes, chame o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que o número de bytes resultante.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica um conjunto de caracteres da matriz de caracteres especificada em uma matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</source>
          <target state="translated">Quando substituído em uma classe derivada, codifica um conjunto de caracteres da cadeia de caracteres especificada em uma matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias conversões em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> do objeto que está sendo usado.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> não será possível manter o estado, portanto, o caractere será enviado para o <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">A versão de buffer de caractere Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto ou inserindo buffers existentes.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> versão que ofereça suporte a matrizes de bytes é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de caracteres produzidos decodificando todos os bytes na matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>To calculate the maximum array size, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the  <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>If your app handles string outputs, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula saídas de cadeia de caracteres, você deve usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de caracteres produzidos usando a decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requer para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes em um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Uma matriz de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtém os caracteres de uma sequência de bytes de entrada.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> é diferente de <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> porque <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> espera conversões discretos, enquanto <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> destina-se a várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Observação<ept id="p1">**</ept> esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar e continuar no início do próximo <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> chamará o fallback para as sequências incompletas, mas <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> lembrará as sequências para a próxima chamada.)</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Uma matriz de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtém os caracteres de uma sequência de bytes de entrada.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> é diferente de <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> porque <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> espera conversões discretos, enquanto <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> destina-se a várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Observação<ept id="p1">**</ept> esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar e continuar no início do próximo <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> chamará o fallback para as sequências incompletas, mas <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> lembrará as sequências para a próxima chamada.)</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação do conjunto de caracteres resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">O número máximo de caracteres a serem gravados.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes iniciando no ponteiro de bytes especificado em um conjunto de caracteres começando no ponteiro de caractere especificado.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by the <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> parameter.</source>
          <target state="translated">O número real de caracteres gravados no local indicado pelo parâmetro <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular a matriz exata tamanho que <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requer para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtém os caracteres de uma sequência de bytes de entrada.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> é diferente de <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> porque <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> espera conversões discretos, enquanto <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> destina-se a várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Observação<ept id="p1">**</ept> esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar e continuar no início do próximo <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> chamará o fallback para as sequências incompletas, mas <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> lembrará as sequências para a próxima chamada.)</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
          <target state="translated">Se seu aplicativo lida com saídas de cadeia de caracteres, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método é recomendado.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que o número de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">A matriz de caracteres que deve conter o conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">O número real de caracteres gravados em <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; gets characters from an input byte sequence.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; obtém caracteres de uma sequência de bytes de entrada.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; is different than <ph id="ph3">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph4">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph5">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; é diferente de <ph id="ph3">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> porque <ph id="ph4">&lt;xref:System.Text.Encoding&gt;</ph> espera conversões discretos, enquanto <ph id="ph5">&lt;xref:System.Text.Decoder&gt;</ph> foi projetado para várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Observação<ept id="p1">**</ept> esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método executa a decodificação real.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> método espera conversões discretas, em comparação com o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método, que trata de várias passagens em um único fluxo de entrada.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Várias versões do <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> têm suporte.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">A seguir está algumas considerações de programação para uso dos seguintes métodos:</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call and continue at the beginning of the next [<ph id="ph3">\]</ph>, Int32, Int32, Char<ph id="ph4">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call.</source>
          <target state="translated">(Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A &gt; chamar e continuar no início do próximo [<ph id="ph3">\]</ph>, Int32, Int32, Char<ph id="ph4">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A &gt; chamar.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; will call the fallback for those incomplete sequences, but <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; chamará o fallback para as sequências incompletas, mas <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> lembrará as sequências para a próxima chamada.)</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
          <target state="translated">Se seu aplicativo lida com saídas de cadeia de caracteres, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método é recomendado.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <ph id="ph1">&lt;xref:System.String&gt;</ph> tipo é preferível.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">A versão de byte do <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Nesse caso, o [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; versão que dá suporte a buffers de caracteres de saída é a melhor opção.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Considere o uso de <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> até o final da matriz para acomodar os caracteres resultantes.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetDecoder">
          <source>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um decodificador que converte uma sequência de bytes codificada em uma sequência de caracteres.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetDecoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that converts an encoded sequence of bytes into a sequence of characters.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> que converte uma sequência de bytes codificada em uma sequência de caracteres.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method of this class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> método dessa classe.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it correctly decodes byte sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> mantém informações de estado entre as chamadas para ele decodifica corretamente sequências de bytes que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> também preserva bytes à direita do final de blocos de dados e usa os bytes à direita na próxima operação de decodificação.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The default implementation returns a <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that calls the <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /&gt;</ph> methods of the current <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">A implementação padrão retorna um <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> que chama o <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /&gt;</ph> e <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /&gt;</ph> métodos do atual <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>You must override this method to return a <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that maintains its state between calls.</source>
          <target state="translated">Você deve substituir este método para retornar um <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> que mantém seu estado entre as chamadas.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoder">
          <source>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method of this class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes, de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> método dessa classe.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it correctly encodes character sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> mantém informações de estado entre as chamadas para ele codifica corretamente sequências de caracteres que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> também preserva à direita caracteres do final de blocos de dados e usa os caracteres à direita na próxima operação de codificação.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência e o correspondência substituto baixo seria o próximo bloco de dados.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The default implementation returns a <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that calls the <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /&gt;</ph> methods of the current <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">A implementação padrão retorna um <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que chama o <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /&gt;</ph> e <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /&gt;</ph> métodos do atual <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>You must override this method to return a <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that maintains its state between calls.</source>
          <target state="translated">Você deve substituir este método para retornar um <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que mantém seu estado entre as chamadas.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Returns an encoding for the specified code page.</source>
          <target state="translated">Retorna uma codificação para a página de código especificada.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">O identificador de página de código da codificação preferencial.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Os valores possíveis são listados na coluna Página de Código da tabela exibida no tópico da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>0 (zero), to use the default encoding.</source>
          <target state="translated">0 (zero), para usar a codificação padrão.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Returns the encoding associated with the specified code page identifier.</source>
          <target state="translated">Retorna a codificação associada ao identificador de página de código especificado.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">A codificação associada à página de código especificada.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`codepage`</ph>.</source>
          <target state="translated">O manipulador de fallback depende do tipo de codificação de <ph id="ph1">`codepage`</ph>.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If <ph id="ph1">`codepage`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
          <target state="translated">Se <ph id="ph1">`codepage`</ph> for configurado com um caractere de byte duplo ou página de código (DBCS) de codificação, um manipulador de fallback de melhor ajuste é usado.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Otherwise, a replacement fallback handler is used.</source>
          <target state="translated">Caso contrário, um manipulador de fallback de substituição será usado.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>These fallback handlers may not be appropriate for your app.</source>
          <target state="translated">Esses manipuladores de retorno não podem ser apropriados para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`codepage`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
          <target state="translated">Para especificar o manipulador de fallback usado pela codificação especificada pelo <ph id="ph1">`codepage`</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método depende da plataforma subjacente para dar suporte a maioria das páginas de código.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">No entanto, o .NET Framework suporta nativamente algumas codificações.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para obter uma lista de páginas de código, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Alternatively, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.</source>
          <target state="translated">Como alternativa, você pode chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método para obter uma matriz de <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objetos que contém informações sobre todas as codificações.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Se a mesma codificação tiver sido registrada por vários <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objetos, esse método retorna o último deles registrado.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>You can also supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument.</source>
          <target state="translated">Você também pode fornecer um valor de 0 para o <ph id="ph1">`codepage`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Its precise behavior depends on whether any encodings have been made available by registering an <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> object:</source>
          <target state="translated">Seu comportamento preciso depende se qualquer codificações foram disponibilizadas Registrando um <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto:</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method is passed a <ph id="ph2">`codepage`</ph> argument of 0.</source>
          <target state="translated">Se um ou mais provedores de codificação for registrados, ele retorna a codificação do último provedor registrado que escolheu para retornar uma codificação quando a <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método é passado um <ph id="ph2">`codepage`</ph> argumento de 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>On the .NET Framework, if no encoding provider has been registered, if the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> is the registered encoding provider, or if no registered encoding provider handles a <ph id="ph2">`codepage`</ph> value of 0, it returns the operating system's active code page.</source>
          <target state="translated">No .NET Framework, se nenhuma codificação provedor tiver sido registrado, se o <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um <ph id="ph2">`codepage`</ph> valor de 0, ele retorna a página de código ativo do sistema operacional.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>To determine the active code page on Windows systems, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the .NET Framework on the Windows desktop.</source>
          <target state="translated">Para determinar a página de código ativo em sistemas Windows, chame o Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> função do .NET Framework da área de trabalho do Windows.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a <ph id="ph1">`codepage`</ph> value of 0, it returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</source>
          <target state="translated">No núcleo do .NET, se nenhum provedor de codificação tiver sido registrado ou se nenhum provedor de codificação registrado manipula um <ph id="ph1">`codepage`</ph> valor de 0, ele retorna o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Some unsupported code pages cause an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Um código sem suporte páginas causa uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> seja gerada, enquanto outros causam um <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
          <target state="translated">Portanto, seu código deve capturar todas as exceções indicadas na seção de exceções.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
          <target state="translated">Por esse motivo, se a página de código ativo é uma página de código ANSI, codificar e decodificar dados usando a página de código padrão retornado por <ph id="ph1">`Encoding.GetEncoding(0)`</ph> não é recomendado.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retorna uma instância armazenada em cache com as configurações padrão.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Por exemplo, a <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fornece um construtor que permite que você habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</source>
          <target state="translated">O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is less than zero or greater than 65535.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> é menor que zero ou maior que 65535.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">Não há suporte para <ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> na plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">Não há suporte para <ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> na plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The code page name of the preferred encoding.</source>
          <target state="translated">O identificador da página de código da codificação preferencial.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Any value returned by the <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> property is valid.</source>
          <target state="translated">Qualquer valor retornado pela propriedade <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> é válido.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Os valores possíveis são listados na coluna Nome da tabela exibida no tópico da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Returns the encoding associated with the specified code page name.</source>
          <target state="translated">Retorna a codificação associada ao nome da página de código especificada.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The encoding  associated with the specified code page.</source>
          <target state="translated">A codificação associada à página de código especificada.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`name`</ph>.</source>
          <target state="translated">O manipulador de fallback depende do tipo de codificação de <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>If <ph id="ph1">`name`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
          <target state="translated">Se <ph id="ph1">`name`</ph> for configurado com um caractere de byte duplo ou página de código (DBCS) de codificação, um manipulador de fallback de melhor ajuste é usado.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Otherwise, a replacement fallback handler is used.</source>
          <target state="translated">Caso contrário, um manipulador de fallback de substituição será usado.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>These fallback handlers may not be appropriate for your app.</source>
          <target state="translated">Esses manipuladores de retorno não podem ser apropriados para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`name`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
          <target state="translated">Para especificar o manipulador de fallback usado pela codificação especificada pelo <ph id="ph1">`name`</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método depende da plataforma subjacente para dar suporte a maioria das páginas de código.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">No entanto, o .NET Framework suporta nativamente algumas codificações.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para obter uma lista de páginas de código, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Alternatively, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.</source>
          <target state="translated">Como alternativa, você pode chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método para obter uma matriz de <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objetos que contém informações sobre todas as codificações.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Se a mesma codificação tiver sido registrada por vários <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objetos, esse método retorna o último deles registrado.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
          <target state="translated">As páginas de código ANSI podem ser diferentes em computadores diferentes, ou podem ser alteradas para um único computador, levando a corrupção de dados.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retorna uma instância armazenada em cache com as configurações padrão.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Por exemplo, a <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fornece um construtor que permite que você habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</source>
          <target state="translated">O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid code page name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> não é um nome de página de código válido.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The code page indicated by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">A página de código indicada por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> não tem suporte da plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">O identificador de página de código da codificação preferencial.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Os valores possíveis são listados na coluna Página de Código da tabela exibida no tópico da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>0 (zero), to use the default encoding.</source>
          <target state="translated">0 (zero), para usar a codificação padrão.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Returns the encoding associated with the specified code page identifier.</source>
          <target state="translated">Retorna a codificação associada ao identificador de página de código especificado.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
          <target state="translated">Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">A codificação associada à página de código especificada.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Some unsupported code pages cause the exception <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Algumas páginas de código não há suporte para fazer com que a exceção <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> seja gerada, enquanto outros causam <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
          <target state="translated">Portanto, seu código deve capturar todas as exceções indicadas na seção de exceções.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método depende da plataforma subjacente para dar suporte a maioria das páginas de código.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">No entanto, o .NET Framework suporta nativamente algumas codificações.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para obter uma lista de páginas de código, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
          <target state="translated">Você pode chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método no .NET Framework completo na área de trabalho do Windows para obter uma lista de todas as codificações.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Se a mesma codificação tiver sido registrada por vários <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objetos, esse método retorna o último deles registrado.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can also supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument.</source>
          <target state="translated">Você também pode fornecer um valor de 0 para o <ph id="ph1">`codepage`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Its precise behavior depends on whether any encodings have been made available by registering an <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> object:</source>
          <target state="translated">Seu comportamento preciso depende se qualquer codificações foram disponibilizadas Registrando um <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto:</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method is passed a <ph id="ph2">`codepage`</ph> argument of 0.</source>
          <target state="translated">Se um ou mais provedores de codificação for registrados, ele retorna a codificação do último provedor registrado que escolheu para retornar uma codificação quando a <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método é passado um <ph id="ph2">`codepage`</ph> argumento de 0.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>On the .NET Framework, if no encoding provider has been registered, if the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> is the registered encoding provider, or if no registered encoding provider handles a <ph id="ph2">`codepage`</ph> value of 0, it returns the active code page.</source>
          <target state="translated">No .NET Framework, se nenhuma codificação provedor tiver sido registrado, se o <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um <ph id="ph2">`codepage`</ph> valor de 0, ele retorna a página de código ativo.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a <ph id="ph1">`codepage`</ph> value of 0, it returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encoding.</source>
          <target state="translated">No núcleo do .NET, se nenhum provedor de codificação tiver sido registrado ou se nenhum provedor de codificação registrado manipula um <ph id="ph1">`codepage`</ph> valor de 0, ele retorna o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> codificação.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
          <target state="translated">Por esse motivo, se a página de código ativo é uma página de código ANSI, codificar e decodificar dados usando a página de código padrão retornado por <ph id="ph1">`Encoding.GetEncoding(0)`</ph> não é recomendado.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>To get the encoding associated with the active code page, you can either supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter a codificação associado à página de código ativo, ou você pode fornecer um valor de 0 para o <ph id="ph1">`codepage`</ph> argumento ou, se seu código está em execução no .NET Framework completo na área de trabalho do Windows, recuperar o valor da <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>To determine the current active code page, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the .NET Framework on the Windows desktop.</source>
          <target state="translated">Para determinar a página de código ativa atual, chame o Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> função do .NET Framework da área de trabalho do Windows.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retorna uma instância armazenada em cache com as configurações padrão.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Por exemplo, a <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fornece um construtor que permite que você habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is less than zero or greater than 65535.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> é menor que zero ou maior que 65535.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">Não há suporte para <ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> na plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">Não há suporte para <ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> na plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page name of the preferred encoding.</source>
          <target state="translated">O identificador da página de código da codificação preferencial.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Any value returned by the <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> property is valid.</source>
          <target state="translated">Qualquer valor retornado pela propriedade <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> é válido.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Os valores possíveis são listados na coluna Nome da tabela exibida no tópico da classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando um caractere não pode ser codificado com a codificação atual.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Um objeto que fornece um procedimento de tratamento de erro quando uma sequência de bytes não pode ser decodificada com a codificação atual.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Returns the encoding associated with the specified code page name.</source>
          <target state="translated">Retorna a codificação associada ao nome da página de código especificada.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
          <target state="translated">Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">A codificação associada à página de código especificada.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método depende da plataforma subjacente para dar suporte a maioria das páginas de código.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">No entanto, o .NET Framework suporta nativamente algumas codificações.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Se a mesma codificação tiver sido registrada por vários <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objetos, esse método retorna o último deles registrado.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para obter uma lista de páginas de código, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method on the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
          <target state="translated">Você pode chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método no .NET Framework completo na área de trabalho do Windows para obter uma lista de todas as codificações.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retorna uma instância armazenada em cache com as configurações padrão.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Por exemplo, a <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fornece um construtor que permite que você habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid code page name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> não é um nome de página de código válido.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page indicated by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">A página de código indicada por <ph id="ph1">&lt;paramref name="name" /&gt;</ph> não tem suporte da plataforma subjacente.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncodings">
          <source>Returns an array that contains all encodings.</source>
          <target state="translated">Retorna uma matriz que contém todas as codificações.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncodings">
          <source>An array that contains all encodings.</source>
          <target state="translated">Uma matriz que contém todas as codificações.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>This method returns a list of supported encodings, uniquely distinguished by code page.</source>
          <target state="translated">Esse método retorna uma lista de codificações com suporte, diferenciadas exclusivamente pela página de código.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>For a table that lists the supported encodings, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para uma tabela que lista as codificações com suporte, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The list of supported encodings returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method does not include any additional encodings made available by any <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> implementations that were registered by calls to the <ph id="ph3">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method.</source>
          <target state="translated">A lista de codificações com suporte retornadas pelo <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> método não inclui qualquer codificações adicionais disponibilizadas por qualquer <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> implementações que foram registradas por chamadas para o <ph id="ph3">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</source>
          <target state="translated">Codificações 50220 e 50222 são ambos associado com o nome "iso-2022-jp", mas eles não são idênticos.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</source>
          <target state="translated">Codificação 50220 converte caracteres Katakana de meia largura para caracteres Katakana de largura total, enquanto codificação 50222 usa uma sequência de shift-em/shift-out para codificar caracteres Katakana de meia largura.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</source>
          <target state="translated">É o nome de exibição para codificação 50222 "japonês (JIS-Permitir 1 byte Kana - portanto / SI)" para diferenciá-lo da codificação 50220, que tem a exibição nome "japonês (JIS)".</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</source>
          <target state="translated">Se você solicitar a codificação nome "iso-2022-jp", retorna o .NET Framework que codificação 50220.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</source>
          <target state="translated">No entanto, a codificação é apropriado para seu aplicativo depende o tratamento preferencial dos caracteres Katakana de meia largura.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>To get a specific encoding, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method.</source>
          <target state="translated">Para obter uma codificação específica, você deve usar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> is sometimes used to present the user with a list of encodings in a File <bpt id="p1">**</bpt>Save as<ept id="p1">**</ept> dialog box.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> às vezes, é usado para apresentar ao usuário uma lista de codificações em um arquivo <bpt id="p1">**</bpt>Salvar como<ept id="p1">**</ept> caixa de diálogo.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</source>
          <target state="translated">No entanto, várias codificações de não Unicode são incompleta e traduzir o número de caracteres para "?", ou tem um comportamento um pouco diferente em diferentes plataformas.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Consider using UTF-8 or UTF-16 as the default.</source>
          <target state="translated">Considere o uso de UTF-8 ou UTF-16 como padrão.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Retorna o código hash para a instância atual.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetHashCode">
          <source>The hash code for the current instance.</source>
          <target state="translated">O código hash da instância atual.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número máximo de bytes produzidos pela codificação do número especificado de caracteres.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">O número máximo de bytes produzidos pela codificação do número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">`charCount`</ph> parameter actually specifies the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters.</source>
          <target state="translated">O <ph id="ph1">`charCount`</ph> parâmetro, na verdade, especifica o número de <ph id="ph2">&lt;xref:System.Char&gt;</ph> objetos que representam os caracteres Unicode para codificar, como o .NET Framework usa internamente UTF-16 para representar caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Consequently, most Unicode characters can be represented by one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object, but a Unicode character represented by a surrogate pair, for example, requires two <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">Consequentemente, a maioria dos caracteres Unicode pode ser representado por um <ph id="ph1">&lt;xref:System.Char&gt;</ph> objeto, mas um caractere Unicode representado por um par substituto, por exemplo, são necessárias duas <ph id="ph2">&lt;xref:System.Char&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> recupera um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> recupera valores grandes, especialmente nos casos em que o pior caso de codificação envolve alternar os modos para cada caractere.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For example, this can happen for ISO-2022-JP.</source>
          <target state="translated">Por exemplo, isso pode acontecer de ISO-2022-JP.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For more information, see the blog entry "<bpt id="p1">[</bpt>What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>"</source>
          <target state="translated">Para obter mais informações, consulte a postagem do blog "<bpt id="p1">[</bpt>novidades com Encoding.GetMaxByteCount() e Encoding.GetMaxCharCount()?<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>"</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>(<ph id="ph1">http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx)</ph>.</source>
          <target state="translated">(<ph id="ph1">http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx)</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable values for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método recupera valores razoáveis para pequenas cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura erros em casos raros, quando um buffer mais razoável é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
          <target state="translated">Ao usar <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> method.</source>
          <target state="translated">Se o buffer de saída é restrito em tamanho, você pode usar o <ph id="ph1">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> considers potential leftover surrogates from a previous decoder operation.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> considera possíveis substitutos restantes de uma operação de decodificador anterior.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</source>
          <target state="translated">Por causa do decodificador, passando um valor de 1 para o método recupera 2 para uma codificação de byte único, como ASCII.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> property if this information is necessary.</source>
          <target state="translated">Você deve usar o <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> propriedade se essas informações são necessárias.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>All <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</source>
          <target state="translated">Todos os <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se buffers são dimensionados de acordo com os resultados dos cálculos desse método.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Quando substituído em uma classe derivada, calcula o número máximo de caracteres produzidos pela codificação do número especificado de bytes.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">O número máximo de caracteres produzidos decodificando o número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, você deve usar o <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, use o <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> método geralmente permite a alocação de memória inferior, enquanto o <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> recupera um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> recupera valores grandes.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método recupera números razoáveis para cadeias de caracteres pequenas.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável é muito pequeno.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> não tem nenhuma relação com <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If you needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, you should use <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Se você precisar de uma função semelhante para usar com <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, você deve usar <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
          <target state="translated">Ao usar <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se o buffer de saída é restrito em tamanho, você pode usar o <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considers the worst case for leftover bytes from a previous encoder operation.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considera o pior caso para bytes restantes de uma operação anterior do codificador.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</source>
          <target state="translated">Para a maioria das páginas de código, passando um valor de 0 a esse método recupera valores maiores que ou iguais a 1.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>All <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</source>
          <target state="translated">Todos os <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se buffers são dimensionados de acordo com os resultados dos cálculos desse método.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</source>
          <target state="translated">Quando substituído em uma classe derivada, retorna uma sequência de bytes que especifica a codificação usada.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>A byte array containing a sequence of bytes that specifies the encoding used.</source>
          <target state="translated">Uma matriz de bytes que contém uma sequência de bytes que especifica a codificação usada.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>A byte array of length zero, if a preamble is not required.</source>
          <target state="translated">Uma matriz de bytes de tamanho zero, se um preâmbulo não for necessário.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">Opcionalmente, o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objeto fornece um preâmbulo que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Se o preâmbulo contiver uma marca de ordem de byte (em Unicode, o ponto de código de U + FEFF), ele ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</source>
          <target state="translated">A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-8: EF BB BF</source>
          <target state="translated">UTF-8: EF BB BF</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-16 big endian byte order: FE FF</source>
          <target state="translated">Ordem de byte do UTF-16 big endian: FF FE</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-16 little endian byte order: FF FE</source>
          <target state="translated">Ordem de byte endian UTF-16 little: FF FE</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-32 big endian byte order: 00 00 FE FF</source>
          <target state="translated">Ordem de byte big endian da UTF-32: 00 00 FE FF</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-32 little endian byte order: FF FE 00 00</source>
          <target state="translated">Ordem de byte endian pouco UTF-32: FF FE 00 00</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</source>
          <target state="translated">Você deve usar o BOM, porque fornece quase determinada identificação de uma codificação para arquivos que foram perdidos referência para o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objeto, por exemplo, sem marcas ou marcada incorretamente os dados da web ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais ou outros dados.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</source>
          <target state="translated">Problemas de usuário geralmente podem ser evitados se dados são consistentemente e corretamente marcados, preferencialmente em UTF-8 ou UTF-16.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Para os padrões que fornecem um tipo de codificação, um BOM é um pouco redundante.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário, será perdida.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Há algumas desvantagens de usar um BOM.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Por exemplo, saber como limitar os campos de banco de dados que usam um BOM pode ser difícil.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode terminar no meio de dados.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no <bpt id="p1">[</bpt>home page do Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente, você deve prefixar bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>However, most encodings do not provide a preamble.</source>
          <target state="translated">No entanto, a maioria das codificações não fornecem um preâmbulo.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, or <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente, você deve usar uma codificação Unicode, ou seja, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>The following example determines the byte order of the encoding based on the preamble.</source>
          <target state="translated">O exemplo a seguir determina a ordem de byte da codificação com base no preâmbulo.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, decodes a sequence of bytes into a string.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consulte a seção comentários a <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated">Observe que o comportamento preciso do <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método para um determinado <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementação depende da estratégia de fallback definida para que <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" o <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> tópico.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The following example reads a UTF-8 encoded string from a binary file represented by a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário, representado por um <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Para arquivos que são menores que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29&gt;</ph> método para executar a decodificação.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For larger files, it reads 2,048 bytes at a time into a byte array, calls the <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to determine how many characters are contained in the array, and then calls the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas de <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para determinar o número de caracteres estão contidos na matriz e, em seguida, chama o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para executar a decodificação.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</source>
          <target state="translated">O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 denominado Utf8Example.txt.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The byte array contains invalid Unicode code points.</source>
          <target state="translated">A matriz de bytes contém pontos de código Unicode inválidos.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A pointer to a byte array.</source>
          <target state="translated">Um ponteiro para uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica um número especificado de bytes, começando em um endereço especificado em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is designed to optimize performance when you have a native pointer to a byte array.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método foi projetado para otimizar o desempenho quando você tem um ponteiro nativo para uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</source>
          <target state="translated">Em vez de criar uma matriz de bytes gerenciado e, em seguida, codificá-lo, em vez disso, você pode chamar esse método sem a necessidade de criar os objetos intermediários.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consulte a seção comentários a <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated">Observe que o comportamento preciso do <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> método para um determinado <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementação depende da estratégia de fallback definida para que <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" o <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> tópico.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is a null pointer.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é um ponteiro nulo.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A   fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</source>
          <target state="translated">Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Uma cadeia de caracteres que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> método, respectivamente, de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consulte a seção comentários a <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example reads a UTF-8 encoded string from a binary file that is represented by a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário que é representado por um <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Para arquivos que são menores que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método para executar a decodificação.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>For larger files, it reads 2,048 bytes at a time into a byte array, calls the <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to determine how many characters are contained in the array, and then calls the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas de <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para determinar o número de caracteres estão contidos na matriz e, em seguida, chama o <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para executar a decodificação.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</source>
          <target state="translated">O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 denominado Utf8Example.txt.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array contains invalid Unicode code points.</source>
          <target state="translated">A matriz de bytes contém pontos de código Unicode inválidos.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.HeaderName">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de cabeçalho do agente de email.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>A name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> to use with mail agent header tags.</source>
          <target state="translated">Um nome para o <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual a ser usado com marcas de cabeçalho do agente de email.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>An empty string (""), if the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> cannot be used.</source>
          <target state="translated">Uma cadeia de caracteres vazia ("") se o <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual não puder ser usado.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>If you need an encoding for a header name, you should call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property.</source>
          <target state="translated">Se você precisar de uma codificação para um nome de cabeçalho, você deve chamar o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> método com o <ph id="ph2">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
          <target state="translated">Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Generally only email applications need to retrieve such an encoding.</source>
          <target state="translated">Geralmente somente aplicativos de email necessário recuperar esses uma codificação.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
          <target state="translated">Em alguns casos, o valor de <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriedade corresponde ao padrão internacional que define a codificação.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
          <target state="translated">Isso não significa que a implementação está em conformidade por completo com esse padrão.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns the name to use to describe an encoding.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> retorna o nome a ser usado para descrever uma codificação.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for an email application, for example.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriedade define uma codificação diferente que pode funcionar melhor para um aplicativo de email, por exemplo.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>However, use of the property to define the encoding is not recommended.</source>
          <target state="translated">No entanto, o uso da propriedade para definir a codificação não é recomendado.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Ele exibe <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mas não se compara em relação a ela.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Gets a value indicating whether the current encoding is always normalized.</source>
          <target state="translated">Obtém um valor que indica se a codificação atual sempre é normalizada.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</source>
          <target state="translated">Obtém um valor que indica se a codificação atual sempre é normalizada usando o formulário de normalização padrão.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> is always normalized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual sempre é normalizado; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
          <target state="translated">O formulário de normalização padrão é <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, que usa a decomposição canônica completo, seguida pela substituição de sequências com suas composições primárias, se possível.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual sempre é normalizada usando a forma de normalização especificada.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is always normalized using the specified <ph id="ph3">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual sempre é normalizado usando o valor <ph id="ph3">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> especificado; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
          <target state="translated">O formulário de normalização padrão é <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, que usa a decomposição canônica completo, seguida pela substituição de sequências com suas composições primárias, se possível.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para exibir conteúdo.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by browser clients for displaying content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> pode ser usado por clientes do navegador para exibir o conteúdo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsBrowserSave">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para salvar conteúdo.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserSave">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by browser clients for saving content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> pode ser usado por clientes do navegador para salvar o conteúdo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserSave">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador e email para exibir conteúdo.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by mail and news clients for displaying content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> pode ser usado por clientes de email e notícias para exibir o conteúdo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador e email para salvar conteúdo.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by mail and news clients for saving content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> pode ser usado por clientes de email e notícias para salvar o conteúdo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsReadOnly">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual é somente leitura.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> é somente leitura; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsSingleByte">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual usa pontos de código de byte único.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> uses single-byte code points; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual usa pontos de código de byte único; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>For a single-byte encoding, for example, <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, this property retrieves <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para um único byte de codificação, por exemplo, <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, essa propriedade recupera <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>You should be careful in what your application does with the value for <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.</source>
          <target state="translated">Você deve ter cuidado ao que o aplicativo faz com o valor de <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>An assumption of how an Encoding will proceed may still be wrong.</source>
          <target state="translated">Uma suposição de como uma codificação continuará ainda pode estar incorreta.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>For example, Windows-1252 has a value of <ph id="ph1">`true`</ph> for <ph id="ph2">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType&gt;</ph>, but Encoding.GetMaxByteCount(1) returns 2.</source>
          <target state="translated">Por exemplo, Windows-1252 tem um valor de <ph id="ph1">`true`</ph> para <ph id="ph2">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType&gt;</ph>, mas Encoding.GetMaxByteCount(1) retorna 2.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>This is because the method considers potential leftover surrogates from a previous decoder operation.</source>
          <target state="translated">Isso ocorre porque o método considera possíveis substitutos restantes de uma operação de decodificador anterior.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>A subclass of <ph id="ph1">&lt;see cref="T:System.Text.EncodingProvider" /&gt;</ph> that provides access to additional character encodings.</source>
          <target state="translated">Uma subclasse de <ph id="ph1">&lt;see cref="T:System.Text.EncodingProvider" /&gt;</ph> que fornece acesso a codificações de caracteres adicionais.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Registers an encoding provider.</source>
          <target state="translated">Registra um provedor de codificação.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method allows you to register a class derived from <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> that makes character encodings available on a platform that does not otherwise support them.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> método permite que você registre uma classe derivada de <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> que torna as codificações disponíveis em uma plataforma que não suporte-los.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> overload.</source>
          <target state="translated">Depois que o provedor de codificação é registrado, as codificações que ele suporta podem ser recuperadas chamando qualquer <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> de sobrecarga.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If there are multiple encoding providers, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</source>
          <target state="translated">Se houver vários provedores de codificação, o <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> método tenta recuperar uma codificação especificada de cada provedor começando com o mais recentemente registrados.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Registering an encoding provider by using the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method also modifies the behavior of the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](&lt;xref:System.Text.Encoding.GetEncoding(System.Int32)&gt;)</ept> and <bpt id="p2">[</bpt>EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> methods when passed an argument of <ph id="ph2">`0`</ph>:</source>
          <target state="translated">Registrar um provedor de codificação usando o <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> método também modifica o comportamento do <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](&lt;xref:System.Text.Encoding.GetEncoding(System.Int32)&gt;)</ept> e <bpt id="p2">[</bpt>EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> métodos quando passou um argumento de <ph id="ph2">`0`</ph>:</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the registered provider is the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</source>
          <target state="translated">Se o provedor registrado é o <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, o método retorna a codificação que corresponde à página de código ativo do sistema quando em execução no sistema operacional Windows.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>A custom encoding provider can choose which encoding to return when either of these <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method overloads is passed an argument of <ph id="ph2">`0`</ph>.</source>
          <target state="translated">Um provedor de codificação personalizado pode escolher qual codificação para retornar quando um desses <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> sobrecargas do método é passado um argumento de <ph id="ph2">`0`</ph>.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>The provider can also choose to not return an encoding by having the <ph id="ph1">&lt;xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> method return <ph id="ph2">`null`</ph>.</source>
          <target state="translated">O provedor também pode optar por não retornar uma codificação tendo o <ph id="ph1">&lt;xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> retorno do método <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source><ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> includes one encoding provider, <ph id="ph2">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, that makes the encodings available that are present in the full .NET Framework but are not available in <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> inclui um provedor de codificação, <ph id="ph2">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, que torna as codificações disponíveis que estão presentes no .NET Framework completo, mas não estão disponíveis em <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>By default, <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> only supports the Unicode encodings, ASCII, and code page 28591.</source>
          <target state="translated">Por padrão, <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> só dá suporte a Unicode codificações, ASCII e a página de código 28591.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the same encoding provider is used in multiple calls to the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method, only the first method call registers the provider.</source>
          <target state="translated">Se o mesmo provedor de codificação é usado em várias chamadas para o <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> método, somente a primeira chamada do método registra o provedor.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Subsequent calls are ignored.</source>
          <target state="translated">As chamadas subsequentes serão ignoradas.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> método é chamado para registrar vários provedores que lidam com a mesma codificação, o último provedor registrado é usado para todos os codificação e decodificação de operações.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Any previously registered providers are ignored.</source>
          <target state="translated">Nenhum provedor registrado anteriormente é ignorados.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source><ph id="ph1">&lt;paramref name="provider" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="provider" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.Unicode">
          <source>Gets an encoding for the UTF-16 format using the little endian byte order.</source>
          <target state="translated">Obtém uma codificação para o formato UTF-16 usando a ordem de byte little endian.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>An encoding for the UTF-16 format using the little endian byte order.</source>
          <target state="translated">Uma codificação para o formato UTF-16 usando a ordem de byte little endian.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter informações sobre as codificações com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a little endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Em vez disso, você pode chamar o <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> construtor para instanciar um pouco endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objeto cujo fallback é uma <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF32">
          <source>Gets an encoding for the UTF-32 format using the little endian byte order.</source>
          <target state="translated">Obtém uma codificação para o formato UTF-32 usando a ordem de byte little endian.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>An  encoding object for the UTF-32 format using the little endian byte order.</source>
          <target state="translated">Um objeto de codificação para o formato UTF-32 usando a ordem de byte little endian.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</source>
          <target state="translated">Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar o CARACTERE de substituição Unicode (U + FFFE).</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Em vez disso, você pode chamar o <ph id="ph1">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Text.UTF32Encoding&gt;</ph> objeto cujo fallback é uma <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou um <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>For a discussion of little endian byte order, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Para obter uma discussão de ordem de byte endian pouco, consulte o <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter informações sobre as codificações com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF7">
          <source>Gets an encoding for the UTF-7 format.</source>
          <target state="translated">Obtém uma codificação para o formato UTF-7.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>An encoding for the UTF-7 format.</source>
          <target state="translated">Uma codificação para o formato UTF-7.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</source>
          <target state="translated">Codificação UTF-7 é usado principalmente em ambientes que historicamente tem sido restrito a 7 bits, como NNTP e alguns aplicativos de email.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</source>
          <target state="translated">Devido a problemas com eficiência e segurança, você não deve usar codificação UTF7 em ambientes de 8 bits em codificação UTF-8 pode ser usado em vez disso.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF8">
          <source>Gets an encoding for the UTF-8 format.</source>
          <target state="translated">Obtém uma codificação para o formato UTF-8.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>An encoding for the UTF-8 format.</source>
          <target state="translated">Uma codificação para o formato UTF-8.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>This property returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</source>
          <target state="translated">Essa propriedade retorna um <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto que codifica caracteres de Unicode (codificação UTF-16) em uma sequência de um a quatro bytes por caractere, e que decodifica uma matriz de bytes codificados em UTF-8 para Unicode (codificação UTF-16) caracteres.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter informações sobre as codificações de caracteres com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that provides a Unicode byte order mark (BOM).</source>
          <target state="translated">Ele retorna um <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto que fornece uma marca de ordem de byte Unicode (BOM).</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Para criar uma instância de uma codificação UTF8 que não fornece um BOM, chamar qualquer sobrecarga do <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</source>
          <target state="translated">Ele retorna um <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto que usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Em vez disso, você pode chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto cujo fallback é uma <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou um <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>The following example defines an array that consists of the following characters:</source>
          <target state="translated">O exemplo a seguir define uma matriz que consiste dos seguintes caracteres:</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER Z (U+007A)</source>
          <target state="translated">LETRA MINÚSCULA LATINA Z (U + 007A)</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER A (U+0061)</source>
          <target state="translated">MINÚSCULA LATINA UM (U + 0061)</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>COMBINING BREVE (U+0306)</source>
          <target state="translated">COMBINING BREVE (U+0306)</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</source>
          <target state="translated">LETRA LATINA MINÚSCULA AE COM ACENTO AGUDO (U + 01FD)</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>GREEK SMALL LETTER BETA (U+03B2)</source>
          <target state="translated">LETRA GREGA MINÚSCULA BETA (U + 03B2)</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</source>
          <target state="translated">Um par substituto (U + D800 U + DD54) que forma GREGA ACROPHONIC ATTIC um MILHAR STATERS (U + 10154).</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</source>
          <target state="translated">Exibe as unidades de código UTF-16 de cada caractere e determina o número de bytes exigido por um codificador de UTF-8 para codificar a matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It then encodes the characters and displays the resulting UTF-8-encoded bytes.</source>
          <target state="translated">Em seguida, ele codifica os caracteres e exibe os bytes resultantes codificado em UTF-8.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.WebName">
          <source>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém o nome registrado na IANA (Internet Assigned Numbers Authority) da codificação atual.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The IANA name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">O nome IANA do <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> property.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriedade é o mesmo que o <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns an IANA-registered name for the encoding.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> retorna um nome registrado IANA para a codificação.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</source>
          <target state="translated">Quando seu valor é o nome de um padrão, a implementação da codificação não pode estar em conformidade por completo para esse padrão.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for email headers.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriedade define uma codificação diferente que pode funcionar melhor para cabeçalhos de email.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>However, most apps should use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead.</source>
          <target state="translated">No entanto, a maioria dos aplicativos devem usar <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>For more information on the IANA, go to <bpt id="p1">[</bpt>www.iana.org<ept id="p1">](http://www.iana.org/)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o IANA, vá para <bpt id="p1">[</bpt>www.iana.org<ept id="p1">](http://www.iana.org/)</ept>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType&gt;</ph> is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> returned by <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType&gt;</ph> é igual a <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> retornado por <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>Some of the web names are duplicates; see the remarks for <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Alguns dos nomes de web são duplicatas; Consulte os comentários para <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph> para obter mais informações.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The following example includes the <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> in an HTML header.</source>
          <target state="translated">O exemplo a seguir inclui o <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> em um cabeçalho HTML.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Ele exibe <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mas não se compara em relação a ela.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém a página de código de sistema operacional Windows que mais bem corresponde à codificação atual.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>The Windows operating system code page that most closely corresponds to the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">A página de código de sistema operacional Windows que mais bem corresponde à <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</source>
          <target state="translated">Esta propriedade é fornecida para compatibilidade com o multilíngue do Windows (MLang) APIs, por exemplo, para determinar as famílias de fontes.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>For globalization, using one of the Unicode encodings is recommended instead.</source>
          <target state="translated">Para globalização, usar uma das codificações Unicode é recomendado em vez disso.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>It is also recommended to use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> to identify the code page.</source>
          <target state="translated">Também é recomendável usar <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> em vez de <ph id="ph2">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> para identificar a página de código.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>The following example determines the Windows code page that most closely corresponds to each encoding.</source>
          <target state="translated">O exemplo a seguir determina a página de código do Windows que melhor corresponde a cada codificação.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>