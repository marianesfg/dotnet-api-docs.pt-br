<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9400910a9b479507f698dda5b833c16e8e1557de" /><Meta Name="ms.sourcegitcommit" Value="b99ec7065534584bfab2aebde9f144bedabb075a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="58185318" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma cadeia de caracteres mutável. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe representa um objeto como cadeia de caracteres cujo valor é uma sequência de caracteres de mutável.  
  
 Nesta seção:  
  
-   [Os tipos String e StringBuilder](#StringAndSB)  
  
-   [Como StringBuilder funciona](#HowWorks)  
  
-   [Alocação de memória](#Memory)  
  
-   [Criando uma instância de um objeto StringBuilder](#Instantiating)  
  
-   [Chamando métodos StringBuilder](#Calling)  
  
-   [Executando operações StringBuilder](#Operations)  
  
    -   [Iterando caracteres StringBuilder](#Iterating)  
  
    -   [Adicionar texto a um objeto StringBuilder](#Adding)  
  
    -   [Excluindo o texto de um objeto StringBuilder](#Deleting)  
  
    -   [Alterando o texto em um objeto StringBuilder](#Modifying)  
  
-   [Pesquisando o texto em um objeto StringBuilder](#Searching)  
  
-   [Convertendo o objeto StringBuilder em uma cadeia de caracteres](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Os tipos String e StringBuilder  
 Embora <xref:System.Text.StringBuilder> e <xref:System.String> ambos representam sequências de caracteres, elas são implementadas de maneira diferente. <xref:System.String> é um tipo imutável. Ou seja, cada operação que aparece para modificar um <xref:System.String> objeto realmente cria uma nova cadeia de caracteres.  
  
 Por exemplo, a chamada para o <xref:System.String.Concat%2A?displayProperty=nameWithType> método no exemplo a seguir em C# é exibido alterar o valor de uma variável de cadeia de caracteres chamada `value`. Na verdade, o <xref:System.String.Concat%2A> método retorna um `value` que tem um valor diferente e o endereço do objeto a `value` objeto que foi passado para o método. Observe que o exemplo deve ser compilado usando o `/unsafe` opção de compilador.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Para rotinas que executam a manipulação de cadeia de caracteres amplo (como aplicativos que modificam uma cadeia de caracteres várias vezes em um loop), a modificação de uma cadeia de caracteres repetidamente pode exata uma penalidade de desempenho significativa. A alternativa é usar <xref:System.Text.StringBuilder>, que é uma classe de cadeia de caracteres mutável. Mutabilidade significa que, quando uma instância da classe tiver sido criada, ele pode ser modificado pelo acréscimo, removendo, substituindo ou inserção de caracteres. Um <xref:System.Text.StringBuilder> objeto mantém um buffer para acomodar as expansões na cadeia de caracteres. Novos dados são adicionados ao buffer se espaço está disponível. Caso contrário, um novo buffer maior é alocado, dados do buffer original são copiados para o novo buffer e os novos dados, são acrescentados ao novo buffer.  
  
> [!IMPORTANT]
>  Embora o <xref:System.Text.StringBuilder> classe geralmente oferece desempenho melhor do que o <xref:System.String> classe, você não deve automaticamente substituir <xref:System.String> com <xref:System.Text.StringBuilder> sempre que você deseja manipular cadeias de caracteres. Desempenho depende do tamanho da cadeia de caracteres, a quantidade de memória a ser alocado para a nova cadeia de caracteres, o sistema em que seu aplicativo está sendo executado e o tipo de operação. Você deve estar preparado para testar seu aplicativo para determinar se <xref:System.Text.StringBuilder> realmente oferece uma melhoria de desempenho significativa.  
  
 Considere o uso de <xref:System.String> classe sob estas condições:  
  
-   Quando o número de alterações que seu aplicativo fará uma cadeia de caracteres é pequeno. Nesses casos, <xref:System.Text.StringBuilder> talvez oferta insignificante ou nenhuma melhoria de desempenho em relação a <xref:System.String>.  
  
-   Quando você está executando um número fixo de operações de concatenação, particularmente com literais de cadeia de caracteres. Nesse caso, o compilador pode combinar as operações de concatenação em uma única operação.  
  
-   Quando você tem que executar operações de pesquisa significativo enquanto você estiver compilando sua cadeia de caracteres. O <xref:System.Text.StringBuilder> não tem a classe métodos de pesquisa, como `IndexOf` ou `StartsWith`. Você terá que converter o <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> para essas operações e isso podem invalidar o benefício de desempenho do uso de <xref:System.Text.StringBuilder>. Para obter mais informações, consulte o [pesquisando o texto em um objeto StringBuilder](#Searching) seção.  
  
 Considere o uso de <xref:System.Text.StringBuilder> classe sob estas condições:  
  
-   Quando você espera que seu aplicativo para verificar um número desconhecido de alterações para uma cadeia de caracteres em tempo de design (por exemplo, quando você estiver usando um loop de concatenar um número aleatório de cadeias de caracteres que contém a entrada do usuário).  
  
-   Quando você espera que seu aplicativo para verificar um número significativo de alterações para uma cadeia de caracteres.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Como StringBuilder funciona  
 O <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> propriedade indica o número de caracteres a <xref:System.Text.StringBuilder> atualmente contém um objeto. Se você adicionar caracteres para o <xref:System.Text.StringBuilder> do objeto, seu tamanho aumenta até que ele é igual ao tamanho do <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriedade, que define o número de caracteres que o objeto pode conter. Se o número de caracteres adicionados faz com que o comprimento do <xref:System.Text.StringBuilder> objeto exceda sua capacidade atual, a nova memória é alocada, o valor da <xref:System.Text.StringBuilder.Capacity%2A> propriedade for dobrada, novos caracteres são adicionados à <xref:System.Text.StringBuilder> objeto e seu <xref:System.Text.StringBuilder.Length%2A>propriedade é ajustada. Memória adicional para o <xref:System.Text.StringBuilder> objeto é alocado dinamicamente até atingir o valor definido pelo <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propriedade. Quando a capacidade máxima é atingida, nenhuma memória adicional pode ser alocada para o <xref:System.Text.StringBuilder> objeto e tentar adicionar caracteres ou expandi-lo além da sua capacidade máxima gera uma <xref:System.ArgumentOutOfRangeException> ou um <xref:System.OutOfMemoryException> exceção.  
  
 O exemplo a seguir ilustra como um <xref:System.Text.StringBuilder> objeto aloca memória novos e aumenta sua capacidade dinamicamente à medida que expande a cadeia de caracteres atribuída ao objeto. O código cria um <xref:System.Text.StringBuilder> objeto chamando seu construtor (sem parâmetros) do padrão. A capacidade padrão desse objeto é 16 caracteres e sua capacidade máxima é maior que 2 bilhões de caracteres. Acrescentando a cadeia de caracteres "Esta é uma frase". resulta em uma nova alocação de memória porque o comprimento de cadeia de caracteres (19 caracteres) excede a capacidade padrão da <xref:System.Text.StringBuilder> objeto. A capacidade do objeto dobra a 32 caracteres, a nova cadeia de caracteres é adicionada e o comprimento do objeto agora é igual a 19 caracteres. O código, em seguida, acrescenta a cadeia de caracteres "Esta é uma frase adicional." para o valor da <xref:System.Text.StringBuilder> 11 vezes do objeto. Sempre que a operação de acréscimo faz com que o comprimento do <xref:System.Text.StringBuilder> objeto exceda sua capacidade, sua capacidade existente é dobrado e o <xref:System.Text.StringBuilder.Append%2A> operação for bem-sucedida.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Alocação de memória  
 A capacidade padrão de um <xref:System.Text.StringBuilder> objeto é 16 caracteres e sua capacidade máxima de padrão é <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Esses valores padrão são usados se você chamar o <xref:System.Text.StringBuilder.%23ctor> e <xref:System.Text.StringBuilder.%23ctor%28System.String%29> construtores.  
  
 Você pode definir explicitamente a capacidade inicial de um <xref:System.Text.StringBuilder> objeto das seguintes maneiras:  
  
-   Chamando o <xref:System.Text.StringBuilder> construtores que inclui um `capacity` quando você cria o objeto de parâmetro.  
  
-   Ao atribuir explicitamente um novo valor para o <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriedade para expandir uma existente <xref:System.Text.StringBuilder> objeto. Observe que a propriedade gera uma exceção se a nova capacidade for menor que o existente capacidade ou maior que o <xref:System.Text.StringBuilder> capacidade máxima de um objeto.  
  
-   Chamando o <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> método com a nova capacidade. A nova capacidade não deve ser maior que o <xref:System.Text.StringBuilder> capacidade máxima de um objeto. No entanto, ao contrário de uma atribuição para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade, <xref:System.Text.StringBuilder.EnsureCapacity%2A> não lançará uma exceção se a nova capacidade desejada é menor que a capacidade existente; nesse caso, a chamada de método não tem efeito.  
  
 Se o comprimento da cadeia de caracteres atribuída à <xref:System.Text.StringBuilder> objeto na chamada do construtor excede a capacidade padrão ou a capacidade especificada, o <xref:System.Text.StringBuilder.Capacity%2A> estiver definida como o comprimento da cadeia de caracteres especificada com o `value` parâmetro.  
  
 Você pode definir explicitamente a capacidade máxima de um <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> construtor. Você não pode alterar a capacidade máxima, atribuindo um novo valor para o <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade, porque ele é somente leitura.  
  
 Como a seção anterior mostra, sempre que a capacidade existente for inadequada, mais memória é alocada e a capacidade de um <xref:System.Text.StringBuilder> objeto duplos até o valor definido pelo <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade.  
  
 Em geral, a capacidade padrão e a capacidade máxima são adequadas para a maioria dos aplicativos. Você pode definir esses valores nas seguintes condições:  
  
-   Se o tamanho final do <xref:System.Text.StringBuilder> objeto é provavelmente aumentará extremamente grande, normalmente excedente vários megabytes. Nesse caso, pode haver algum benefício de desempenho, desde a configuração inicial <xref:System.Text.StringBuilder.Capacity%2A> propriedade para um valor muito alto para eliminar a necessidade de realocações número excessivo de memória.  
  
-   Se seu aplicativo estiver em execução em um sistema com memória limitada. Nesse caso, você talvez queira considerar a configuração do <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade para menos de <xref:System.Int32.MaxValue?displayProperty=nameWithType> se seu aplicativo está manipulando grandes cadeias de caracteres que podem causar a executar em um ambiente de restrição de memória.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Criando uma instância de um objeto StringBuilder  
 Você instancia um <xref:System.Text.StringBuilder> objeto chamando um dos seus seis construtores de classe sobrecarregados, que são listados na tabela a seguir. Três dos construtores instanciar uma <xref:System.Text.StringBuilder> objeto cujo valor é uma cadeia de caracteres vazia, mas definir seus <xref:System.Text.StringBuilder.Capacity%2A> e <xref:System.Text.StringBuilder.MaxCapacity%2A> valores de maneira diferente. Os três construtores restantes definem um <xref:System.Text.StringBuilder> objeto que tem um valor de cadeia de caracteres específica e a capacidade. Dois dos três construtores usam a capacidade máxima de padrão de <xref:System.Int32.MaxValue?displayProperty=nameWithType>, enquanto o terceiro permite que você defina a capacidade máxima.  
  
|Construtor|Valor da cadeia de caracteres|Capacidade|Capacidade máxima|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido pelo `capacity` parâmetro|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido pelo `capacity` parâmetro|Definido pelo `maxCapacity` parâmetro|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definido pelo `value` parâmetro|16 ou `value`. <xref:System.String.Length%2A>, o que for maior|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definido pelo `value` parâmetro|Definido pela `capacity` parâmetro ou `value`. <xref:System.String.Length%2A>, o que for maior.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definido por `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definido pela `capacity` parâmetro ou `value`. <xref:System.String.Length%2A>, o que for maior.|Definido pelo `maxCapacity` parâmetro|  
  
 O exemplo a seguir usa três dessas sobrecargas de construtor para instanciar <xref:System.Text.StringBuilder> objetos.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Chamando métodos StringBuilder  
 A maioria dos métodos que modificam a cadeia de caracteres em um <xref:System.Text.StringBuilder> instância retornam uma referência a essa mesma instância. Isso permite que você chame <xref:System.Text.StringBuilder> métodos de duas maneiras:  
  
-   Você pode fazer chamadas de método individual e ignorar o valor de retorno, como o exemplo a seguir faz.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Você pode fazer uma série de chamadas de método em uma única instrução. Isso pode ser conveniente se você quiser gravar uma única instrução que encadeia operações sucessivas. O exemplo a seguir consolida três chamadas de método do exemplo anterior em uma única linha de código.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Executando operações StringBuilder  
 Você pode usar os métodos do <xref:System.Text.StringBuilder> classe para iterar, adicionar, excluir ou modificar caracteres em um <xref:System.Text.StringBuilder> objeto.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Iterando caracteres StringBuilder  
 Você pode acessar os caracteres em uma <xref:System.Text.StringBuilder> objeto usando o <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriedade. No c#, <xref:System.Text.StringBuilder.Chars%2A> é um indexador; no Visual Basic, é a propriedade padrão do <xref:System.Text.StringBuilder> classe. Isso permite que você definir ou recuperar caracteres individuais usando seu índice somente, sem referenciar explicitamente o <xref:System.Text.StringBuilder.Chars%2A> propriedade. Caracteres em uma <xref:System.Text.StringBuilder> objeto começam no índice 0 (zero) e continuar indexar <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 O exemplo a seguir ilustra o <xref:System.Text.StringBuilder.Chars%2A> propriedade. Ele acrescenta dez números aleatórios para um <xref:System.Text.StringBuilder> de objeto e, em seguida, itera cada caractere. Se a categoria Unicode do caractere é <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, ele diminui o número 1 (ou altera o número para 9 se seu valor é 0). O exemplo exibe o conteúdo do <xref:System.Text.StringBuilder> objeto ambos antes e depois os valores de caracteres individuais foram alterados.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Adicionando texto a um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui os seguintes métodos para expandir o conteúdo de um <xref:System.Text.StringBuilder> objeto:  
  
-   O <xref:System.Text.StringBuilder.Append%2A> método acrescenta uma cadeia de caracteres, uma subcadeia de caracteres, uma matriz de caracteres, uma parte de uma matriz de caracteres, um único caractere repetida várias vezes, ou a representação de cadeia de caracteres de dados primitivos de tipo para um <xref:System.Text.StringBuilder> objeto.  
  
-   O <xref:System.Text.StringBuilder.AppendLine%2A> método acrescenta um terminador de linha ou uma cadeia de caracteres junto com um terminador de linha para um <xref:System.Text.StringBuilder> objeto.  
  
-   O <xref:System.Text.StringBuilder.AppendFormat%2A> método acrescenta um para um <xref:System.Text.StringBuilder> objeto. As representações de cadeia de caracteres de objetos incluídos na cadeia de caracteres de resultado podem refletir as convenções de formatação da cultura atual do sistema ou de uma cultura específica.  
  
-   O <xref:System.Text.StringBuilder.Insert%2A> método insere uma cadeia de caracteres, uma subcadeia de caracteres, várias repetições de uma cadeia de caracteres, uma matriz de caracteres, uma parte de uma matriz de caracteres ou a representação de cadeia de caracteres de dados primitivos de tipo em uma posição especificada no <xref:System.Text.StringBuilder> objeto. A posição é definida por um índice baseado em zero.  
  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, e <xref:System.Text.StringBuilder.Insert%2A> métodos para expandir o texto de um <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Excluindo texto de um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui métodos que podem reduzir o tamanho do atual <xref:System.Text.StringBuilder> instância. O <xref:System.Text.StringBuilder.Clear%2A> método Remove todos os caracteres e define o <xref:System.Text.StringBuilder.Length%2A> propriedade como zero. O <xref:System.Text.StringBuilder.Remove%2A> método exclui um número especificado de caracteres começando em uma posição de índice específico. Além disso, você pode remover os caracteres do final de uma <xref:System.Text.StringBuilder> objeto definindo suas <xref:System.Text.StringBuilder.Length%2A> propriedade para um valor que é menor que o comprimento da instância atual.  
  
 O exemplo a seguir remove a parte do texto de um <xref:System.Text.StringBuilder> objeto, exibe sua capacidade resultante, capacidade máxima e valores de propriedade de comprimento e, em seguida, chama o <xref:System.Text.StringBuilder.Clear%2A> método para remover todos os caracteres da <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Alterando o texto em um objeto StringBuilder  
 O <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> método substitui todas as ocorrências de um caractere ou uma cadeia de caracteres em todo o <xref:System.Text.StringBuilder> objeto ou em um intervalo de caracteres em particular. O exemplo a seguir usa o <xref:System.Text.StringBuilder.Replace%2A> método para substituir todos os pontos de exclamação (!) com pontos de interrogação (?) na <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Pesquisando o texto em um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui métodos semelhantes para o <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos fornecidos pelo <xref:System.String> classe, que permitem que você pesquise o objeto para um determinado caractere ou uma subcadeia de caracteres. Determinar a presença ou a posição do caractere de uma subcadeia de caracteres inicial exige que você pesquisa um <xref:System.String> valor usando um método de pesquisa de cadeia de caracteres ou um método de expressão regular. Há quatro maneiras de implementar essas pesquisas, como mostra a tabela a seguir.  
  
|Técnica|Profissionais|Contras|  
|---------------|----------|----------|  
|Valores de cadeia de caracteres de pesquisa antes de adicioná-los para o <xref:System.Text.StringBuilder> objeto.|Útil para determinar se uma subcadeia de caracteres existe.|Não pode ser usado quando a posição do índice de uma subcadeia de caracteres é importante.|  
|Chame <xref:System.Text.StringBuilder.ToString%2A> e pesquise retornado <xref:System.String> objeto.|Fácil de usar se você atribuir todo o texto de um <xref:System.Text.StringBuilder> de objeto e, em seguida, começar a modificá-lo.|Complicado de chamar repetidamente <xref:System.Text.StringBuilder.ToString%2A> se você deve fazer modificações antes de todo o texto é adicionado ao <xref:System.Text.StringBuilder> objeto.<br /><br /> Você deve se lembrar de trabalhar do final do <xref:System.Text.StringBuilder> texto do objeto, se você estiver fazendo alterações.|  
|Use o <xref:System.Text.StringBuilder.Chars%2A> propriedade para um intervalo de caracteres de pesquisa em sequência.|É útil se você está preocupado com caracteres individuais ou uma subcadeia de caracteres pequena.|Inconveniente se o número de caracteres a procurar é grande ou se a lógica de pesquisa é complexa.<br /><br />Resulta em desempenho muito ruim para objetos que cresceram muito grandes por meio de chamadas de método repetida.  |  
|Converter o <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> do objeto e executar modificações no <xref:System.String> objeto.|É útil se o número de modificações for pequeno.|Nega o benefício de desempenho de <xref:System.Text.StringBuilder> classe se o número de modificações for grande.|  
  
 Vamos examinar essas técnicas mais detalhadamente.  
  
-   Se o objetivo da pesquisa é determinar se uma subcadeia de caracteres específica existe (ou seja, se você não esteja interessado na posição da subcadeia de caracteres), você pode pesquisar cadeias de caracteres antes de armazená-los no <xref:System.Text.StringBuilder> objeto. O exemplo a seguir fornece uma implementação possível. Ele define uma `StringBuilderFinder` classe cujo construtor é passado uma referência a um <xref:System.Text.StringBuilder> objeto e a subcadeia de caracteres para localizar na cadeia de caracteres. Nesse caso, o exemplo tenta determinar se gravado temperaturas em Fahrenheit ou Celsius e adiciona o texto introdutório apropriado para o início do <xref:System.Text.StringBuilder> objeto. Um gerador de número aleatório é usado para selecionar uma matriz que contém os dados em graus Celsius ou Fahrenheit graus.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Chame o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para converter os <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> objeto. Você pode pesquisar a cadeia de caracteres usando métodos como <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> ou <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, ou você pode usar expressões regulares e o <xref:System.Text.RegularExpressions.Regex> classe para procurar padrões. Porque ambos <xref:System.Text.StringBuilder> e <xref:System.String> objetos usam para armazenar os caracteres, as posições de índice de caracteres, subcadeias de caracteres, de codificação UTF-16 e correspondências de expressões regulares são os mesmos em ambos os objetos. Isso permite que você use <xref:System.Text.StringBuilder> métodos para fazer alterações na mesma posição na qual esse texto é encontrado no <xref:System.String> objeto.  
  
    > [!NOTE]
    >  Se você adotar essa abordagem, você deve trabalhar do final do <xref:System.Text.StringBuilder> objeto para o seu início para que você não precisa converter repetidamente o <xref:System.Text.StringBuilder> objeto a ser uma cadeia de caracteres.  
  
     O exemplo a seguir ilustra esta abordagem. Ele armazena quatro ocorrências de cada letra do alfabeto inglês em um <xref:System.Text.StringBuilder> objeto. Em seguida, converte o texto para um <xref:System.String> do objeto e usa uma expressão regular para identificar a posição inicial de cada sequência de quatro caracteres. Por fim, adiciona um caractere de sublinhado antes de cada sequência de quatro caracteres, exceto a primeira sequência e converte o primeiro caractere da sequência em maiusculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Use o <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriedade para pesquisar em sequência um intervalo de caracteres em um <xref:System.Text.StringBuilder> objeto. Essa abordagem pode não ser prática, se o número de caracteres a ser pesquisada for grande ou a lógica de pesquisa for particularmente complexa. Para as implicações de desempenho de acesso com base no índice de caractere por caractere para muito grandes, chunked <xref:System.Text.StringBuilder> objetos, consulte a documentação para o <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriedade. 
  
     O exemplo a seguir é idêntico em funcionalidade ao exemplo anterior, mas difere na implementação. Ele usa o <xref:System.Text.StringBuilder.Chars%2A> propriedade para detectar quando um valor de caractere foi alterado, insere um caractere de sublinhado nessa posição e converte o primeiro caractere na nova sequência de letras maiusculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store todo o texto sem modificações na <xref:System.Text.StringBuilder> do objeto, chame o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para converter o <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> de objeto e executar as modificações no <xref:System.String> objeto. Você pode usar essa abordagem se você tiver apenas algumas modificações; Caso contrário, o custo de trabalhar com cadeias de caracteres imutáveis pode invalidar os benefícios de desempenho do uso de um <xref:System.Text.StringBuilder> objeto.  
  
     O exemplo a seguir é idêntico em funcionalidade para os dois exemplos anteriores, mas difere na implementação. Ele cria uma <xref:System.Text.StringBuilder> do objeto, converte-a para um <xref:System.String> de objeto e, em seguida, usa uma expressão regular para executar todas as modificações restantes na cadeia de caracteres. O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método usa uma expressão lambda para executar a substituição em cada correspondência.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Convertendo o objeto StringBuilder em uma cadeia de caracteres  
 Você deve converter o objeto <xref:System.Text.StringBuilder> em um objeto <xref:System.String>para transmitir a cadeia de caracteres representada pelo objeto <xref:System.Text.StringBuilder> para um método que tem um parâmetro <xref:System.String> ou exibi-lo na interface do usuário. Realizar essa conversão chamando o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método. Para obter uma ilustração, consulte o exemplo anterior, que chama o <xref:System.Text.StringBuilder.ToString%2A> método para converter um <xref:System.Text.StringBuilder> do objeto para uma cadeia de caracteres para que ele pode ser passado para um método de expressão regular.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar muitos dos métodos definidos pelo <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de cadeia de caracteres desta instância é definido como <xref:System.String.Empty?displayProperty=nameWithType>, e a capacidade é definida como a capacidade padrão de implementação específica.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor sem parâmetros.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O tamanho inicial sugerido desta instância.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a capacidade especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede isso `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 O valor de cadeia de caracteres desta instância é definido como <xref:System.String.Empty?displayProperty=nameWithType>. Se `capacity` for zero, a capacidade de específico da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma capacidade especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> é menor que zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres usada para inicializar o valor da instância. Se <paramref name="value" /> for <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele conterá <see cref="F:System.String.Empty" />).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a cadeia de caracteres especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for `null`, o novo <xref:System.Text.StringBuilder> conterá a cadeia de caracteres vazia (ou seja, ele conterá <xref:System.String.Empty>).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com a cadeia de caracteres especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">O número máximo de caracteres que a cadeia de caracteres atual pode conter.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> que começa com uma capacidade especificada e pode crescer até um máximo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede isso `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade de específico da implementação padrão é usada.  
  
 O `maxCapacity` propriedade define o número máximo de caracteres que a instância atual pode conter. Seu valor é atribuído para o <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede isso `maxCapacity` valor, o <xref:System.Text.StringBuilder> objeto não aloca memória adicional, mas em vez disso, gera uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma capacidade especificada e a capacidade máxima.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> é menor que 1, <paramref name="capacity" /> é menor que zero ou <paramref name="capacity" /> é maior que <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres usada para inicializar o valor da instância. Se <paramref name="value" /> for <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele conterá <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a cadeia de caracteres e a capacidade especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede isso `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade de específico da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma cadeia de caracteres inicial e uma capacidade especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> é menor que zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres que contém a subcadeia de caracteres usada para inicializar o valor dessa instância. Se <paramref name="value" /> for <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele conterá <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">A posição dentro de <paramref name="value" /> na qual a subcadeia de caracteres começa.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres.</param>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> da capacidade e da subcadeia de caracteres especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede isso `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade de específico da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com a cadeia de caracteres especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> além de <paramref name="length" /> não é uma posição no <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta a representação de cadeia de caracteres de um objeto especificado à essa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um valor booliano especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Boolean%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Boolean%29> chamadas de método de <xref:System.Boolean.ToString?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 8 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Byte%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Byte%29> chamadas de método de <xref:System.Byte.ToString%28System.IFormatProvider%29> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">A unidade de código codificado em UTF-16 a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um objeto <see cref="T:System.Char" /> especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Char%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">A matriz de caracteres a ser acrescentada.</param>
        <summary>Acrescenta a representação de cadeia de caracteres dos caracteres Unicode em uma matriz especificada a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método acrescenta todos os caracteres na matriz especificada à instância atual na mesma ordem que aparecem no `value`. Se `value` é `null`, nenhuma alteração é feita.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número decimal especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Decimal%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Decimal%29> chamadas de método de <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número de ponto flutuante de precisão dupla especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Double%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Double%29> chamadas de método de <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 16 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int16%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int16%29> chamadas de método de <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 32 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int32%29> chamadas de método de <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 64 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int64%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int64%29> chamadas de método de <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um objeto especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Object%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir. Ele define uma `Dog` classe, cria um `Dog` objeto e faz três chamadas para o <xref:System.Text.StringBuilder.Append%2A> método para criar uma cadeia de caracteres que contém o nome e a linhagem de dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Object%29> chamadas de método de <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. Se `value` está `null`, nenhuma alteração é feita para o <xref:System.Text.StringBuilder> objeto.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 8 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.SByte%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.SByte%29> chamadas de método de <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número de ponto flutuante de precisão simples especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Single%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Single%29> chamadas de método de <xref:System.Single.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser acrescentada.</param>
        <summary>Acrescenta uma cópia da cadeia de caracteres especificada a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.String%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Se `value` é `null`, nenhuma alteração é feita.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 16 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt16%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt16%29> chamadas de método de <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 32 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt32%29> chamadas a <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 64 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt64%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt64%29> chamadas de método de <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação da `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere a ser acrescentado.</param>
        <param name="repeatCount">O <paramref name="value" /> do número de vezes para acrescentar.</param>
        <summary>Acrescenta um número de cópias especificado da representação de cadeia de caracteres de um caractere Unicode a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> é menor que zero.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres.</param>
        <param name="valueCount">O número de caracteres na matriz.</param>
        <summary>Acrescenta uma matriz de caracteres Unicode começando em um endereço especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método acrescenta `valueCount` caracteres começando no endereço `value` à instância atual.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> objeto.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> é menor que zero.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">O <paramref name="value" /> é um ponteiro nulo.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres.</param>
        <param name="startIndex">A posição inicial em <paramref name="value" />.</param>
        <param name="charCount">O número de caracteres a serem acrescentados.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de uma submatriz especificada de caracteres Unicode à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método acrescenta o intervalo especificado de caracteres em `value` à instância atual. Se `value` está `null` e `startIndex` e `count` são ambos zero, sem alterações.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="charCount" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> + <paramref name="charCount" /> é maior que o comprimento do <paramref name="value" />.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres que contém a subcadeia de caracteres a ser acrescentada.</param>
        <param name="startIndex">A posição inicial da subcadeia de caracteres dentro de <paramref name="value" />.</param>
        <param name="count">O número de caracteres em <paramref name="value" /> a serem acrescentados.</param>
        <summary>Acrescenta uma cópia de uma subcadeia de caracteres especificada a esta instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método acrescenta o intervalo especificado de caracteres em `value` à instância atual. Se `value` está `null` e `startIndex` e `count` são ambos zero, sem alterações.  
  
 O <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> método modifica a instância existente dessa classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade na referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="count" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> + <paramref name="count" /> é maior que o comprimento do <paramref name="value" />.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres do argumento de um objeto correspondente.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">Um objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um único argumento.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato em <paramref name="format" /> é substituído pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato. O índice de itens de formato deve ser 0, para corresponder ao `arg0`, o único objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres de `arg0`.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` representa o objeto a ser formatado. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres de `arg0`. Se o item de formato inclui `formatString` e `arg0` implementa a <xref:System.IFormattable> interface, em seguida, `arg0.ToString(formatString, null)` define a formatação. Caso contrário, `arg0.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por sua doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por sua doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="args">Uma matriz de objetos a ser formatada.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um argumento correspondente em uma matriz de parâmetros.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` representa os objetos a serem formatados. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres do objeto correspondente no `args`. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa a <xref:System.IFormattable> interface, em seguida, `args[index].ToString(formatString, provider)` define a formatação. Caso contrário, `args[index].ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por sua doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por sua doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um único argumento usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de `arg0` em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato. O índice de cada item de formato deve ser zero (0), pois esse método inclui uma lista de argumentos com um único argumento. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres de `arg0`.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Nesse caso, desde o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> o método tem um único argumento na lista de argumentos, o valor da *índice* deve ser sempre 0. Se não, é um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para os objetos no `args`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específicas da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específicas da cultura para `arg0` se ele é um valor numérico.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específicas da cultura para `arg0` se ele for um valor de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para `arg0`. Normalmente, tal implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, formatação informações são obtidas da cultura atual.  
  
 `arg0` representa o objeto a ser formatado. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres de `arg0`. Se o item de formato inclui `formatString` e `arg0` implementa a <xref:System.IFormattable> interface, em seguida, `arg0.ToString(formatString, provider)` define a formatação. Caso contrário, `arg0.ToString()` define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir inclui duas chamadas para o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> método. Ambos usam as convenções de formatação da cultura inglês-Grã-Bretanha (en-GB). O primeiro insere a representação de cadeia de caracteres de um <xref:System.Decimal> moeda em uma cadeia de caracteres de resultado de valor. O segundo insere um <xref:System.DateTime> valor em dois locais em um resultado de cadeia de caracteres, incluindo primeiro, somente curto Data da cadeia de caracteres e o segundo a cadeia de caracteres de hora abreviada.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 1 (um).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Como definir e usar provedores de formatos numéricos personalizados</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="args">Uma matriz de objetos a ser formatada.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de um argumento correspondente em uma matriz de parâmetro usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para os objetos no `args`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específicas da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específicas da cultura para valores numéricos em `args`.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específicas da cultura para valores de data e hora em `args`.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para uma ou mais dos objetos no `args`. Normalmente, tal implementação também implementa o <xref:System.ICustomFormatter> interface. O segundo exemplo na próxima seção ilustra uma <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> chamada de método com um personalizado <xref:System.IFormatProvider> implementação.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `args` representa os objetos a serem formatados. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres do objeto correspondente no `args`. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa a <xref:System.IFormattable> interface, em seguida, `args[index].ToString(formatString, provider)` define a formatação. Caso contrário, `args[index].ToString()` define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 O exemplo a seguir define um personalizado <xref:System.IFormatProvider> implementação chamada `CustomerFormatter` que formata um número com hifens de cliente de 10 dígitos após o quarto e o sétimo dígitos. Ele é passado para o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método para criar uma cadeia de caracteres que inclui o número formatado de cliente e o nome do cliente.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Como definir e usar provedores de formatos numéricos personalizados</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um dos dois argumentos.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos `arg0` e `arg1`, os dois objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` e `arg1` representam os objetos a serem formatados. Cada item de formato em `format` é substituída pela representação de cadeia de caracteres de um `arg0` ou `arg1`. Se o item de formato inclui `formatString` e implementa o objeto correspondente a <xref:System.IFormattable> interface, em seguida, `arg` *x* `.ToString(formatString, provider)` define a formatação, onde *x* é o índice do argumento. Caso contrário, `arg` *x* `.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por sua doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por sua doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um de dois argumentos usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> que pode fornecer informações de formatação para implementação `arg0` e `arg1`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específicas da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específicas da cultura `arg0` ou `arg1` se eles são valores numéricos.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específicas da cultura `arg0` ou `arg1` se eles forem valores de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação `arg0` e `arg1`. Normalmente, tal implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `arg0` e `arg1` representam os objetos a serem formatados. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres do objeto que tem o índice correspondente. Se o item de formato inclui `formatString` e implementa o argumento correspondente a <xref:System.IFormattable> interface e, em seguida, o argumento `ToString(formatString, provider)` método define a formatação. Caso contrário, o argumento `ToString()` método define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> método para exibir dados de tempo e a temperatura armazenados em um genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Observe que a cadeia de caracteres de formato tem três itens de formato, embora haja somente a objetos a serem formatados. Isso ocorre porque o primeiro objeto na lista (um valor de data e hora) é usado pelos itens de formato de dois: O primeiro formato item exibe a hora e a segunda exibe a data.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 2 (dois).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Como definir e usar provedores de formatos numéricos personalizados</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um dos três argumentos.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos `arg0` por meio de `arg2`, os objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, e `arg2` representam os objetos a serem formatados. Cada item de formato em `format` é substituída pela representação de cadeia de caracteres de um `arg0`, `arg1`, ou `arg2`, dependendo do índice do item de formato. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa a <xref:System.IFormattable> interface, em seguida, `arg` *x* `.ToString(formatString, null)` define a formatação, onde  *x* é o índice do argumento. Caso contrário, `arg` *x* `.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por sua doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por sua doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato de composição.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um de três argumentos usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste de zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é da seguinte maneira:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*index*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado pelo *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro na *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Se positivo, o parâmetro é alinhado à direita; Se for negativo, ele é alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> que pode fornecer informações de formatação para implementação `arg0` e `arg1`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específicas da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específicas da cultura `arg0` ou `arg1` se eles são valores numéricos.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específicas da cultura `arg0`, `arg1`, ou `arg2` se eles forem valores de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação `arg0`, `arg1`, e `arg2`. Normalmente, tal implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `arg0`, `arg1`, e `arg2` representam os objetos a serem formatados. Cada item de formato em `format` é substituído pela representação de cadeia de caracteres do objeto que tem o índice correspondente. Se o item de formato inclui `formatString` e implementa o argumento correspondente a <xref:System.IFormattable> interface e, em seguida, o argumento `ToString(formatString, provider)` método define a formatação. Caso contrário, o argumento `ToString()` método define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para ilustrar o resultado de um valor booliano `And` operação com valores inteiros. Observe que a cadeia de caracteres de formato inclui seis itens de formato, mas o método tem apenas três itens na lista de argumentos, porque cada item é formatada de duas maneiras diferentes.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que 0 (zero) ou maior ou igual a 3 (três).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Como definir e usar provedores de formatos numéricos personalizados</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta o terminador de linha padrão ou uma cópia de uma cadeia de caracteres especificada e o terminador de linha padrão, ao final dessa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acrescenta o terminador de linha padrão ao final do atual objeto <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é o valor atual do <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriedade.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendLine%2A> método.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser acrescentada.</param>
        <summary>Acrescenta uma cópia da cadeia de caracteres especificada seguida pelo terminador de linha padrão para o fim do objeto <see cref="T:System.Text.StringBuilder" /> atual.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é o valor atual do <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriedade.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para acrescentar cadeias de caracteres pequenas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de caracteres que podem ser contidos na memória alocada pela instância atual.</summary>
        <value>O número máximo de caracteres que podem ser contidos na memória alocada pela instância atual. Seu valor pode variar de <see cref="P:System.Text.StringBuilder.Length" /> para <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> não afeta o valor de cadeia de caracteres da instância atual. <xref:System.Text.StringBuilder.Capacity%2A> pode ser diminuído desde que não é menor que <xref:System.Text.StringBuilder.Length%2A>.  
  
 O <xref:System.Text.StringBuilder> aloca mais espaço quando necessário e aumenta dinamicamente <xref:System.Text.StringBuilder.Capacity%2A> adequadamente. Por motivos de desempenho, um <xref:System.Text.StringBuilder> pode alocar mais memória do que o necessário. A quantidade de memória alocada é específico da implementação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Capacity%2A> propriedade.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de conjuntos é menor que o tamanho atual dessa instância.  
  
- ou - 
O valor especificado para uma operação de definição é maior que a capacidade máxima.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição do caractere.</param>
        <summary>Obtém ou define o caractere na posição de caractere especificada nessa instância.</summary>
        <value>O caractere Unicode na posição <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `index` parâmetro é a posição de um caractere dentro de <xref:System.Text.StringBuilder>. O primeiro caractere na cadeia de caracteres está no índice 0. O comprimento de uma cadeia de caracteres é o número de caracteres que ele contém. O último caractere acessível de um <xref:System.Text.StringBuilder> instância está no índice <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> é a propriedade padrão do <xref:System.Text.StringBuilder> classe. No c#, é um indexador. Isso significa que os caracteres individuais podem ser recuperadas do <xref:System.Text.StringBuilder.Chars%2A> como mostrado no exemplo a seguir, que conta o número de alfabético, espaço em branco e caracteres de pontuação em uma cadeia de caracteres.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Desempenho e a indexação baseada em caractere

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fora dos limites dessa instância ao definir um caractere.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> está fora dos limites dessa instância ao obter um caractere.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os caracteres da instância <see cref="T:System.Text.StringBuilder" /> atual.</summary>
        <returns>Um objeto cujo <see cref="P:System.Text.StringBuilder.Length" /> é 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> é um método de conveniência que equivale a definir o <xref:System.Text.StringBuilder.Length%2A> propriedade da instância atual como 0 (zero).  
  
## Examples

O exemplo a seguir instancia um <xref:System.Text.StringBuilder> objeto com uma cadeia de caracteres, chama o <xref:System.Text.StringBuilder.Clear%2A> método e, em seguida, acrescenta uma nova cadeia de caracteres.  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">A posição inicial nessa instância de onde os caracteres serão copiados. O índice é baseado em zero.</param>
        <param name="destination">A matriz na qual os caracteres serão copiados.</param>
        <param name="destinationIndex">A posição inicial no <paramref name="destination" /> na qual os caracteres serão copiados. O índice é baseado em zero.</param>
        <param name="count">O número de caracteres a serem copiados.</param>
        <summary>Copia os caracteres de um segmento especificado desta instância para um segmento especificado de uma matriz <see cref="T:System.Char" /> de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.CopyTo%2A> método é destinado a ser usado em situações raras, quando você precisa copiar com eficiência sucessivas seções de um <xref:System.Text.StringBuilder> objeto em uma matriz. A matriz deve ter um tamanho fixo, pré-alocado, possivelmente globalmente acessível e reutilizável.  
  
 Por exemplo, seu aplicativo pode preencher uma <xref:System.Text.StringBuilder> com um grande número de caracteres do objeto, em seguida, usar o <xref:System.Text.StringBuilder.CopyTo%2A> método para copiar partes pequenas, sucessivas do <xref:System.Text.StringBuilder> objeto em uma matriz em que as partes são processadas. Quando todos os dados de <xref:System.Text.StringBuilder> objeto for processado, o tamanho do <xref:System.Text.StringBuilder> objeto é definido como zero e o ciclo é repetido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.CopyTo%2A> método.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="sourceIndex" /> é maior que o tamanho desta instância.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> é maior que o tamanho desta instância.  
  
- ou - 
 <paramref name="destinationIndex" /> + <paramref name="count" /> é maior que o comprimento do <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">A capacidade mínima para garantia.</param>
        <summary>Garante que a capacidade desta instância do <see cref="T:System.Text.StringBuilder" /> tenha pelo menos o valor especificado.</summary>
        <returns>A nova capacidade desta instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a capacidade atual for menor do que o `capacity` parâmetro, a memória para esta instância é realocada para manter pelo menos `capacity` número de caracteres; caso contrário, o uso de memória não é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.EnsureCapacity%2A> método.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> é menor que zero.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">O intervalo de caracteres a ser comparado com a instância atual.</param>
        <summary>Retorna um valor que indica se os caracteres nessa instância são iguais aos caracteres em um intervalo de caracteres somente leitura especificado.</summary>
        <returns><see langword="true" /> se os caracteres nessa instância e <paramref name="span" /> são iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

O `Equals` método executa uma comparação ordinal para determinar se os caracteres na instância atual e `span` são iguais.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns><see langword="true" /> se essa instância e <paramref name="sb" /> tem a cadeia de caracteres igual, <see cref="P:System.Text.StringBuilder.Capacity" /> e <see cref="P:System.Text.StringBuilder.MaxCapacity" /> valores; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET framework e .NET Core 2.2 e versões anteriores:** A instância atual e `sb` são iguais se tiverem a cadeia de caracteres igual <xref:System.Text.StringBuilder.Capacity>, e <xref:System.Text.StringBuilder.MaxCapacity> valores. O `Equals` método usa comparação ordinal para determinar se as cadeias de caracteres são iguais.

**.NET core 3.0 e versões posteriores:** A instância atual e `sb` são iguais se as cadeias de caracteres atribuída a ambos <xref:System.Text.StringBuilder> objetos são iguais.  Para determinar a igualdade, o `Equals` método usa comparação ordinal. O <xref:System.Text.StringBuilder.Capacity> e <xref:System.Text.StringBuilder.MaxCapacity> valores de propriedade não são usados na comparação.

## Examples  
 O código a seguir usa o <xref:System.Text.StringBuilder.Equals%2A> método para verificar se dois <xref:System.Text.StringBuilder> objetos são iguais. O método é chamado repetidamente após pequenas alterações são feitas para cada objeto, e os resultados são exibidos no console.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insere a representação de cadeia de caracteres de um objeto especificado nessa instância na posição do caractere especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um valor booliano nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro sem sinal de 8 bits especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um caractere Unicode especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A matriz de caracteres a ser inserida.</param>
        <summary>Insere a representação de cadeia de caracteres de uma matriz de caracteres Unicode especificada nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Se `value` está `null`, o <xref:System.Text.StringBuilder> não é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número decimal nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número de ponto flutuante de precisão dupla nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro com sinal de 16 bits especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro com sinal de 32 bits especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro com sinal de 64 bits nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O objeto a ser inserido ou <see langword="null" />.</param>
        <summary>Insere a representação de cadeia de caracteres de um objeto nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Se `value` é `null`, o valor dessa instância é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro com sinal de 8 bits especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número de ponto flutuante de precisão simples nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <summary>Insere uma cadeia de caracteres nesta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
 Esta instância do <xref:System.Text.StringBuilder> não será alterado se `value` é `null`, ou `value` não é `null` , mas seu tamanho é zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que zero ou maior que o tamanho atual dessa instância.  
  
- ou - 
O tamanho atual deste objeto <see cref="T:System.Text.StringBuilder" /> mais o tamanho de <paramref name="value" /> ultrapassa <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro sem sinal de 16 bits nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro sem sinal de 32 bits nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro sem sinal de 64 bits nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e chamadas para esse método de versões anteriores, lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método lança um <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <param name="count">O número de vezes para inserir <paramref name="value" />.</param>
        <summary>Insere uma ou mais cópias de uma cadeia de caracteres especificada nesta instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a conclusão da inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Isso <xref:System.Text.StringBuilder> objeto não será alterado se `value` é `null`, `value` não é `null` , mas seu tamanho é zero, ou `count` é zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que zero ou maior que o tamanho atual dessa instância.  
  
- ou - 
 <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.OutOfMemoryException">O tamanho atual deste objeto <see cref="T:System.Text.StringBuilder" /> mais o tamanho de <paramref name="value" /> vezes <paramref name="count" /> excede <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">Uma matriz de caracteres.</param>
        <param name="startIndex">O índice inicial em <paramref name="value" />.</param>
        <param name="charCount">O número de caracteres a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de uma submatriz de caracteres Unicode especificada nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância depois que a operação de inserção é concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="charCount" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" /> ou <paramref name="charCount" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> é maior que o tamanho desta instância.  
  
- ou - 
 <paramref name="startIndex" /> além de <paramref name="charCount" /> não é uma posição no <paramref name="value" />.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho do objeto atual <see cref="T:System.Text.StringBuilder" />.</summary>
        <value>O tamanho dessa instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento de uma <xref:System.Text.StringBuilder> objeto é definido por seu número de <xref:System.Char> objetos.  
  
 Como o <xref:System.String.Length%2A?displayProperty=nameWithType> propriedade, o <xref:System.Text.StringBuilder.Length%2A> propriedade indica o comprimento do objeto de cadeia de caracteres atual. Ao contrário o <xref:System.String.Length%2A?displayProperty=nameWithType> propriedade, que é somente leitura, o <xref:System.Text.StringBuilder.Length%2A> propriedade permite que você modificar o comprimento da cadeia de caracteres armazenado para o <xref:System.Text.StringBuilder> objeto.  
  
 Se o comprimento especificado é menor que o tamanho atual, atual <xref:System.Text.StringBuilder> objeto será truncado para o comprimento especificado. Se o comprimento especificado é maior que o tamanho atual, o final do valor de cadeia de caracteres do atual <xref:System.Text.StringBuilder> objeto é preenchido com o caractere Unicode NULL (u+0000).  
  
 Se o comprimento especificado é maior que a capacidade atual, <xref:System.Text.StringBuilder.Capacity%2A> aumenta para que ele seja maior que ou igual ao comprimento especificado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Length%2A> propriedade.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que zero ou maior que <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a capacidade máxima desta instância.</summary>
        <value>O número máximo de caracteres que esta instância pode conter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade máxima para esta implementação é <xref:System.Int32.MaxValue?displayProperty=nameWithType>. No entanto, esse valor é específico da implementação e pode ser diferente em implementações de outras ou posteriores. Você pode definir explicitamente a capacidade máxima de um <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> construtor.  
  
No .NET Core e no .NET Framework 4.0 e versões posteriores, quando você cria uma instância de <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> construtor, o comprimento e a capacidade do <xref:System.Text.StringBuilder> instância pode crescer além do valor de seu <xref:System.Text.StringBuilder.MaxCapacity> propriedade. Isso pode ocorrer especialmente quando você chama o <xref:System.Text.StringBuilder.Append(System.String)> e <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> métodos para acrescentar cadeias de caracteres pequenas.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de base zero nesta instância na qual começa a remoção.</param>
        <param name="length">O número de caracteres a serem removidos.</param>
        <summary>Remove o intervalo especificado de caracteres dessa instância.</summary>
        <returns>Uma referência a essa instância após a operação de imposto embutido tiver sido concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método atual remove o intervalo especificado de caracteres da instância atual. Os caracteres em (`startIndex` + `length`) são movidos para `startIndex`, e o valor de cadeia de caracteres da instância atual é reduzido em `length`. A capacidade da instância atual não é afetada.  
  
> [!NOTE]
>  O <xref:System.Text.StringBuilder.Remove%2A> método modifica o valor do atual <xref:System.Text.StringBuilder> da instância e retorna essa instância. Não criar e retornar um novo <xref:System.Text.StringBuilder> objeto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Remove%2A> método.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="startIndex" /> ou <paramref name="length" /> for menor que zero ou <paramref name="startIndex" /> + <paramref name="length" /> for maior que o tamanho dessa instância.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Substitui todas as ocorrências de um caractere ou cadeia de caracteres especificada nessa instância por outro caractere ou cadeia de caracteres especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere a ser substituído.</param>
        <param name="newChar">O caractere que substitui <paramref name="oldChar" />.</param>
        <summary>Substitui todas as ocorrências de um caractere especificado nesta instância por outro caractere especificado.</summary>
        <returns>Uma referência a essa instância com <paramref name="oldChar" /> substituído por <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldChar` na instância atual. O tamanho do atual <xref:System.Text.StringBuilder> instância não é alterada após a substituição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres que substitui <paramref name="oldValue" /> ou <see langword="null" />.</param>
        <summary>Substitui todas as ocorrências de uma cadeia de caracteres especificada nesta instância por outra cadeia de caracteres especificada.</summary>
        <returns>Uma referência a essa instância com todas as instâncias de <paramref name="oldValue" /> substituídas por <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldValue` na instância atual. Se `newValue` está `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, todas as ocorrências de `oldValue` são removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="oldValue" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere a ser substituído.</param>
        <param name="newChar">O caractere que substitui <paramref name="oldChar" />.</param>
        <param name="startIndex">A posição nessa instância em que a subcadeia é iniciada.</param>
        <param name="count">O tamanho da subcadeia.</param>
        <summary>Substitui, dentro de uma subcadeia dessa instância, todas as ocorrências um caractere especificado por outro caractere especificado.</summary>
        <returns>Uma referência a essa instância com <paramref name="oldChar" /> substituído por <paramref name="newChar" /> no intervalo de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldChar` na instância atual. O tamanho do atual <xref:System.Text.StringBuilder> objeto não é alterado após a substituição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> é maior que o tamanho do valor desta instância.  
  
- ou - 
 <paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres que substitui <paramref name="oldValue" /> ou <see langword="null" />.</param>
        <param name="startIndex">A posição nessa instância em que a subcadeia é iniciada.</param>
        <param name="count">O tamanho da subcadeia.</param>
        <summary>Substitui, dentro de uma subcadeia dessa instância, todas as ocorrências de uma cadeia de caracteres especificada por outra cadeia de caracteres especificada.</summary>
        <returns>Uma referência a essa instância com todas as instâncias de <paramref name="oldValue" /> substituídas por <paramref name="newValue" /> no intervalo de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> – 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldValue` na subcadeia de caracteres especificada. Se `newValue` está `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, todas as ocorrências de `oldValue` são removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="oldValue" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 A soma de <paramref name="startIndex" /> e <paramref name="count" /> indica uma posição de caractere que não está nessa instância.  
  
- ou - 
Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">O objeto a ser preenchido com informações de serialização.</param>
        <param name="context">O local para armazenar e recuperar dados serializados. Reservado para uso futuro.</param>
        <summary>Popula um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para desserializar o objeto <see cref="T:System.Text.StringBuilder" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `context` parâmetro é reservado para uso futuro e não participa dessa operação.  
  
 Para obter mais informações, consulte o método <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte o valor de um <see cref="T:System.Text.StringBuilder" /> em um <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor dessa instância em um <see cref="T:System.String" />.</summary>
        <returns>Uma cadeia de caracteres cujo valor é o mesmo que essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar o <xref:System.Text.StringBuilder.ToString%2A> método para converter os <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> objeto antes que você pode passar a cadeia de caracteres representada pelo <xref:System.Text.StringBuilder> objeto para um método que tem um <xref:System.String> parâmetro ou exibi-lo na interface do usuário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamada a <xref:System.Text.StringBuilder.ToString%2A> método. Este exemplo é parte de um exemplo maior fornecido para o <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição inicial da subcadeia de caracteres nessa instância.</param>
        <param name="length">O tamanho da subcadeia.</param>
        <summary>Converte o valor de uma subcadeia de caracteres dessa instância em um <see cref="T:System.String" />.</summary>
        <returns>Uma cadeia de caracteres cujo valor é igual ao da subcadeia de caracteres especificada dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar o <xref:System.Text.StringBuilder.ToString%2A> método para converter os <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> objeto antes que você pode passar a cadeia de caracteres representada pelo <xref:System.Text.StringBuilder> objeto para um método que tem um <xref:System.String> parâmetro ou exibi-lo na interface do usuário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
- ou - 
A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o tamanho da instância atual.</exception>
      </Docs>
    </Member>
  </Members>
</Type>