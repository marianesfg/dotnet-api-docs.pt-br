<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UTF8Encoding.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Represents a UTF-8 encoding of Unicode characters.</source>
          <target state="translated">Representa uma codificação de caracteres Unicode UTF-8. </target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">Decodificação de é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>UTF-8 is a Unicode encoding that represents each code point as a sequence of one to four bytes.</source>
          <target state="translated">UTF-8 é a codificação Unicode representa cada ponto de código como uma sequência de um a quatro bytes.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Unlike the UTF-16 and UTF-32 encodings, the UTF-8 encoding does not require "endianness"; the encoding scheme is the same regardless of whether the processor is big-endian or little-endian.</source>
          <target state="translated">Diferentemente de codificações UTF-16 e UTF-32, a codificação UTF-8 não exige "endian"; o esquema de codificação é o mesmo, independentemente se o processador está big-endian ou little endian.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> corresponds to the Windows code page 65001.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> corresponde à página de código 65001 de Windows.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information about the UTFs and other encodings supported by <ph id="ph1">&lt;xref:System.Text&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre os UTFs e outras codificações com suporte <ph id="ph1">&lt;xref:System.Text&gt;</ph>, consulte <bpt id="p1">[</bpt>codificação de caracteres no .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM) and whether you want to enable error detection.</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto de várias maneiras, dependendo se você deseja a ele para fornecer uma marca de ordem de byte (BOM) e se você deseja habilitar a detecção de erro.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following table lists the constructors and the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> property that return a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">A tabela a seguir lista os construtores e <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> propriedades que retornam uma <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Member</source>
          <target state="translated">Membro</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>BOM</source>
          <target state="translated">BOM</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Error detection</source>
          <target state="translated">Detecção de erro</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Yes</source>
          <target state="translated">Sim</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No</source>
          <target state="translated">Não</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Nenhum (fallback de substituição)</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurável</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método executa a codificação real.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Likewise, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> methods perform the actual decoding.</source>
          <target state="translated">Da mesma forma, o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> os métodos executam a decodificação real.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> properties, respectively.</source>
          <target state="translated">Para um codificador ou decodificador é capaz de salvar informações de estado quando a codificação ou decodificação de dados que abrange vários blocos (como cadeia de caracteres de 1 milhão de caracteres codificada em segmentos de caractere de 100.000), use o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> propriedades, respectivamente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the beginning of the byte stream that results from the encoding process.</source>
          <target state="translated">Opcionalmente, o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto fornece uma marca de ordem de byte (BOM), que é uma matriz de bytes que pode ter como prefixo para o início do fluxo de bytes que é o resultado do processo de codificação.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If a UTF-8 encoded byte stream is prefaced with a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Se um fluxo de bytes codificados UTF-8 é precedido por uma marca de ordem de byte (BOM), ele ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note, however, that the Unicode Standard neither requires nor recommends a BOM in UTF-8 encoded streams.</source>
          <target state="translated">No entanto, observe que o padrão Unicode não exige nem recomenda um BOM UTF-8 codificados fluxos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no <bpt id="p1">[</bpt>home page do Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If the encoder is configured to provide a BOM, you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.</source>
          <target state="translated">Se o codificador é configurado para fornecer um BOM, você pode recuperá-lo chamando o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método; caso contrário, o método retorna uma matriz vazia.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note that, even if a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> class do not do this automatically.</source>
          <target state="translated">Observe que, mesmo se um <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto é configurado para dar suporte a BOM, você deve incluir a BOM no início do fluxo de bytes codificados como apropriado; os métodos de codificação do <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> classe não faça isso automaticamente.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>To enable error detection and to make the class instance more secure, you should call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and set the <ph id="ph2">`throwOnInvalidBytes`</ph> parameter to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Para habilitar a detecção de erro e tornar a instância da classe mais seguro, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> construtor e defina o <ph id="ph2">`throwOnInvalidBytes`</ph> parâmetro <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>With error detection enabled, a method that detects an invalid sequence of characters or bytes throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Com detecção de erros habilitada, um método que detecta uma sequência inválida de caracteres ou bytes lança um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</source>
          <target state="translated">Sem detecção de erro, nenhuma exceção é lançada e a sequência inválida geralmente é ignorada.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The state of a UTF-8 encoded object is not preserved if the object is serialized and deserialized using different .NET Framework versions.</source>
          <target state="translated">O estado de um objeto codificado UTF-8 não é preservado se o objeto é serializado e desserializado com diferentes versões do .NET Framework.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object to encode a string of Unicode characters and store them in a byte array.</source>
          <target state="translated">O exemplo a seguir usa uma <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto codificar uma cadeia de caracteres Unicode e armazená-los em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The Unicode string includes two characters, Pi (U+03A0) and Sigma (U+03A3), that are outside the ASCII character range.</source>
          <target state="translated">A cadeia de caracteres Unicode inclui dois caracteres, Pi (U + 03A0) e Sigma (U + 03A3), que estão fora do intervalo de caractere ASCII.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>When the encoded byte array is decoded back to a string, the Pi and Sigma characters are still present.</source>
          <target state="translated">Quando a matriz de bytes codificados é decodificada para uma cadeia de caracteres, os caracteres de Pi e Sigma ainda estão presentes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses the same string as the previous example, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</source>
          <target state="translated">O exemplo a seguir usa a mesma cadeia de caracteres como no exemplo anterior, exceto que ele grava os bytes codificados em um arquivo e prefixos de fluxo de bytes com uma marca de ordem de byte (BOM).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>It then reads the file in two different ways: as a text file by using a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object; and as a binary file.</source>
          <target state="translated">Ele lê o arquivo de duas maneiras diferentes: como um arquivo de texto usando um <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> objeto; e como um arquivo binário.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>As you would expect, in neither case is the BOM included in the newly read string.</source>
          <target state="translated">Como se esperaria em nenhum caso é BOM incluído na cadeia de caracteres leitura recentemente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>This constructor creates an instance that does not provide a Unicode byte order mark and does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este construtor cria uma instância que não tem uma marca de ordem de byte Unicode e não gerará uma exceção quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>For security reasons, we recommend that you enable error detection by calling a constructor with a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, recomendamos que você habilite a detecção de erro chamando um construtor com um <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro e definindo seu valor como <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and displays its name.</source>
          <target state="translated">O exemplo a seguir cria um novo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instância e exibe seu nome.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que o método <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> retorna uma marca de ordem de byte Unicode, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>A parameter specifies whether to provide a Unicode byte order mark.</source>
          <target state="translated">Um parâmetro especifica se deve ser fornecida uma marca de ordem de byte Unicode.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este construtor cria uma instância que não lança uma exceção quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, você deve habilitar a detecção de erro chamando um construtor que inclui um <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro e definindo seu valor como <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parâmetro controla a operação de <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Se <ph id="ph1">`true`</ph>, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-8.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Se <ph id="ph1">`false`</ph>, ele retorna uma matriz de bytes de comprimento zero.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Entretanto, a configuração <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> para <ph id="ph2">`true`</ph> não causa o <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método prefixar BOM no início da matriz de bytes, nem o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método para incluir o número de bytes na BOM na contagem de bytes.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and specifies that a Unicode byte order mark prefix should be emitted by the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir cria um novo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instância e especifica que um prefixo de marca de ordem de byte Unicode deve ser emitido pelo <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method then returns the Unicode byte order mark prefix.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método retorna, em seguida, o prefixo de marca de ordem de byte Unicode.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method should return a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que o método <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> deve retornar uma marca de ordem de byte Unicode; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception when an invalid encoding is detected; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para gerar uma exceção quando uma codificação inválida é detectada; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Parameters specify whether to provide a Unicode byte order mark and whether to throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Os parâmetros especificam se uma marca de ordem de byte Unicode será fornecida e se uma exceção será gerada quando uma codificação inválida for detectada.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parâmetro controla a operação de <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Se <ph id="ph1">`true`</ph>, o método retorna uma matriz de bytes que contém a marca de ordem de byte (BOM) Unicode em formato UTF-8.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Se <ph id="ph1">`false`</ph>, ele retorna uma matriz de bytes de comprimento zero.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Entretanto, a configuração <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> para <ph id="ph2">`true`</ph> não causa o <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método prefixar BOM no início da matriz de bytes, nem o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método para incluir o número de bytes na BOM na contagem de bytes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnInvalidBytes`</ph> is <ph id="ph2">`true`</ph>, a method that detects an invalid byte sequence throws an <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> exception.</source>
          <target state="translated">Se <ph id="ph1">`throwOnInvalidBytes`</ph> é <ph id="ph2">`true`</ph>, um método que detecta uma sequência de bytes inválido gera um <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</source>
          <target state="translated">Caso contrário, o método não lança uma exceção, e a sequência inválida é ignorada.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting that parameter to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de segurança, você deve habilitar a detecção de erro chamando um construtor que inclui um <ph id="ph1">`throwOnInvalidBytes`</ph> parâmetro e a definição desse parâmetro como <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance, specifying that the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method should not emit a Unicode byte order mark prefix, and an exception should be thrown when an invalid encoding is detected.</source>
          <target state="translated">O exemplo a seguir cria um novo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instância, especificando que o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método não deve emitir um prefixo de marca de ordem de byte Unicode e uma exceção deve ser gerada quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The behavior of this constructor is compared to the default <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">O comportamento desse construtor é comparado com o padrão <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> construtor, que não lança uma exceção quando uma codificação inválido é detectada.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances encode a character array that contains two high surrogates (U+D801 and U+D802) in a row, which is an invalid character sequence; a high surrogate should always be followed by a low surrogate.</source>
          <target state="translated">Os dois <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instâncias codificar uma matriz de caracteres que contém dois substitutos alta (U + D801 e U + D802) em uma linha, que é uma sequência de caracteres inválida; um substituto alto deve sempre ser seguido por um substituto baixo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">O objeto a ser comparado com a instância atual.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> object.</source>
          <target state="translated">Determina se o objeto especificado é igual ao objeto <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> and is equal to the current object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> for uma instância de <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> e for igual ao objeto atual, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are considered equal if all of the following conditions are true:</source>
          <target state="translated">Dois <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos são considerados iguais se todas as seguintes condições forem verdadeiras:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects provide the byte order mark, or both do not.</source>
          <target state="translated">Os dois objetos fornecem a marca de ordem de byte, ou ambos não.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same encoder fallback.</source>
          <target state="translated">Os dois objetos usam o mesmo codificador de fallback.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same decoder fallback.</source>
          <target state="translated">Os dois objetos usam o mesmo decodificador de fallback.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> method to test whether the current <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is equal to a different <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> método para testar se o atual <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto é igual a outro <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Four <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are created and compared and the results of the comparisons are displayed.</source>
          <target state="translated">Quatro <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos são criados e comparados e os resultados das comparações a são exibidos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Calcula o número de bytes produzidos pela codificação de um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Calculates the number of bytes produced by encoding the characters in the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Calcula o número de bytes produzidos codificando todos os caracteres no <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> methods to calculate the maximum and actual number of bytes required to encode a string.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> métodos para calcular o número real e máximo de bytes necessários para codificar uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>It also displays the actual number of bytes required to store a byte stream with a byte order mark.</source>
          <target state="translated">Ele também exibe o número real de bytes necessários para armazenar um fluxo de bytes com uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Calcula o número de bytes produzidos ao codificar um conjunto de caracteres, começando no ponteiro de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size required by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exata necessário para o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para armazenar os bytes resultantes, você chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Calcula o número de bytes produzidos codificando um conjunto de caracteres da matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">O número de bytes produzidos por codificação de caracteres especificados.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the uses <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você chama o usa <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a Latin uppercase and lowercase characters and calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">O exemplo a seguir preenche uma matriz com um latino letras maiusculas e minúsculas e chama o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método para determinar o número de bytes necessários para codificar caracteres latinos em minúsculas.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada uma marca de ordem de byte.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Ele compara esse número com o valor retornado pelo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método, que indica o número máximo de bytes necessários para codificar caracteres latinos em minúsculas.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> property is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definida como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Codifica um conjunto de caracteres em uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Um ponteiro para o primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação da sequência de bytes resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">O número máximo de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados começando no ponteiro de byte especificado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no local indicado por <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> retornado pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que o número de bytes resultante.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Codifica um conjunto de caracteres da matriz de caracteres especificada na matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of characters from a string and stores the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para codificar um intervalo de caracteres de uma cadeia de caracteres e lojas de bytes codificados em um intervalo de elementos em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém o conjunto de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">O índice do primeiro caractere a ser codificado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">A matriz de bytes que conterá a sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">O índice no qual será iniciada a gravação da sequência de bytes resultante.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into the specified byte array.</source>
          <target state="translated">Codifica um conjunto de caracteres do <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> especificado para a matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">O número real de bytes gravados no <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para codificar um intervalo de elementos de uma matriz de caracteres Unicode e armazenar os bytes codificados em um intervalo de elementos em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contém uma sequência de caracteres inválida.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> ao final da matriz para acomodar os bytes resultantes.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, chame o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">O número de caracteres produzido pela decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, chame o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method to return the number of characters produced by decoding a range of elements in a byte array.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método para retornar o número de caracteres produzido por um intervalo de elementos em uma matriz de bytes de decodificação.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Decodifica uma sequência de bytes em um conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Um ponteiro do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Um ponteiro para o local no qual a gravação do conjunto de caracteres resultante deve ser iniciada.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">O número máximo de caracteres a serem gravados.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Decodifica uma sequência de bytes começando no ponteiro de byte especificado em um conjunto de caracteres armazenados começando no ponteiro de caractere especificado.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">O número real de caracteres gravados no local indicado por <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, chame o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto fornecido pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que o número de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">A matriz de caracteres que deve conter o conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">O número real de caracteres gravados em <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, chame o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, chame o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method to decode a range of elements in a byte array and store the result in a character array.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> método para decodificar um intervalo de elementos em uma matriz de bytes e armazena o resultado em uma matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> não é um índice válido em <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> não tem capacidade suficiente do <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> até o final da matriz para acomodar os caracteres resultantes.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Obtains a decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Obtém um decodificador que converte uma sequência de bytes codificados em UTF-8 em uma sequência de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>A decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Um decodificador que converte uma sequência de bytes codificados em UTF-8 em uma sequência de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method of this class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> método dessa classe.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> mantém informações de estado entre as chamadas para corretamente pode decodificar sequências de bytes que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> também preserva bytes à direita do final de blocos de dados e usa os bytes à direita na próxima operação de decodificação.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.</source>
          <target state="translated">Se detecção de erros está habilitada, ou seja, o <ph id="ph1">`throwOnInvalidCharacters`</ph> parâmetro do construtor é definido como <ph id="ph2">`true`</ph>, detecção de erros também está habilitada no <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> retornado por esse método.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</source>
          <target state="translated">Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do decodificador é indefinido e processamento deve parar.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method to obtain a UTF-8 decoder.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método para obter um decodificador de UTF-8.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The decoder converts a sequence of bytes into a sequence of characters.</source>
          <target state="translated">O decodificador converte uma sequência de bytes em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Obtains an encoder that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-8.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que converte uma sequência de caracteres Unicode em uma sequência de bytes codificada em UTF-8.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes, de maneira semelhante para o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it can correctly encode character sequences that span blocks.</source>
          <target state="translated">No entanto, um <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> mantém informações de estado entre as chamadas para que ele pode codificar corretamente sequências de caracteres que abrangem os blocos.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> também preserva à direita caracteres do final de blocos de dados e usa os caracteres à direita na próxima operação de codificação.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência e o correspondência substituto baixo seria o próximo bloco de dados.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> returned by this method.</source>
          <target state="translated">Se detecção de erros está habilitada, ou seja, o <ph id="ph1">`throwOnInvalidCharacters`</ph> parâmetro do construtor é definido como <ph id="ph2">`true`</ph>, detecção de erros também está habilitada no <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> retornado por esse método.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</source>
          <target state="translated">Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do codificador é indefinido e processamento deve parar.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method to obtain an encoder to convert a sequence of characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método para obter um codificador para converter uma cadeia de caracteres em um UTF-8 codificados sequência de bytes.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Retorna o código hash para a instância atual.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The hash code for the current instance.</source>
          <target state="translated">O código hash da instância atual.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> method to return a hash code for <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> método para retornar um código hash para <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instâncias.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Notice that the hash code returned by this method depends on the constructor used to create the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">Observe que o código de hash retornado por esse método depende do construtor usado para criar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">O número de caracteres a ser codificado.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>Calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Calcula o número máximo de bytes produzidos pela codificação do número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">O número máximo de bytes produzidos pela codificação do número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para armazenar os bytes resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> é um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> pode retornar valores grandes.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método retorna números razoáveis para cadeias de caracteres pequenas.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For example, text in English and many other languages often needs only one UTF-8 byte to represent a character, but the number returned by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has to allow for the possibility that the string to be converted will consist entirely of characters that each require four bytes.</source>
          <target state="translated">Por exemplo, o texto em inglês e muitos outros idiomas geralmente precisa apenas um byte de UTF-8 para representar um caractere, mas o número retornado por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> tem que permitir a possibilidade de que a cadeia de caracteres a ser convertida consiste inteiramente caracteres que cada requer quatro bytes.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> não tem nenhuma relação com <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo precisa de uma função semelhante para usar com <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, ele deve usar <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method to return the maximum number of bytes required to encode a specified number of characters.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método para retornar o número máximo de bytes exigido para codificar um número especificado de caracteres.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>Calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Calcula o número máximo de caracteres produzidos decodificando o número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">O número máximo de caracteres produzidos decodificando o número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho de matriz exato necessário por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para armazenar os caracteres resultantes, você deve chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o tamanho máximo de matriz, você deve chamar o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método aloca geralmente menos memória, enquanto o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método geralmente é executado mais rapidamente.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> é um número pior caso, incluindo o pior caso para selecionado no momento <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> pode retornar valores grandes.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">Na maioria dos casos, esse método retorna números razoáveis para cadeias de caracteres pequenas.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também poderá considerar uma abordagem diferente usando <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> não tem nenhuma relação com <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Se seu aplicativo precisa de uma função semelhante para usar com <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, ele deve usar <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> não é necessariamente o mesmo valor como <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method to return the maximum number of characters produced by decoding a specified number of bytes.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método para retornar o número máximo de caracteres produzido por um número especificado de bytes de decodificação.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Returns a Unicode byte order mark encoded in UTF-8 format, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Retorna uma marca de ordem de byte Unicode codificada no formato UTF-8, se o objeto de codificação <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> é configurado para fornecer um.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>A byte array containing the Unicode byte order mark, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Uma matriz de bytes que contém a marca de ordem de byte Unicode, se o objeto de codificação <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> é configurado para fornecer um.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Otherwise, this method returns a zero-length byte array.</source>
          <target state="translated">Caso contrário, esse método retorna uma matriz de bytes de tamanho zero.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes that result from the encoding process.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto pode fornecer um preâmbulo, que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes que resultam do processo de codificação.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF.</source>
          <target state="translated">Iniciar uma sequência de bytes codificados com uma marca de ordem de byte (U + FEFF de ponto de código) ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as 0xEF 0xBB 0xBF.</source>
          <target state="translated">A marca de ordem de byte Unicode (BOM) é serializada como 0xEF 0xBB 0xBF.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the Unicode Standard neither requires nor recommends the use of a BOM for UTF-8 encoded streams.</source>
          <target state="translated">Observe que o padrão Unicode não requer nem recomenda o uso de um BOM UTF-8 codificados fluxos.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> do objeto cuja <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método retorna um BOM válido das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By retrieving the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Recuperando o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By calling a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> constructor with a <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> parameter and setting its value set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Chamando um <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> construtor com um <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> parâmetro e definir seu valor definido como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>All other <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are configured to return an empty array rather than a valid BOM.</source>
          <target state="translated">Todos os outros <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos são configurados para retornar uma matriz vazia em vez de um BOM válido.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The BOM provide nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</source>
          <target state="translated">O BOM fornecem quase determinada identificação de uma codificação para arquivos que, caso contrário, perdeu uma referência para sua codificação, como web sem marcas ou marcada incorretamente dados ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged.</source>
          <target state="translated">Problemas de usuário geralmente podem ser evitados se dados são marcados de forma consistente e corretamente.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Para os padrões que fornecem um tipo de codificação, um BOM é um pouco redundante.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário, será perdida.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Há algumas desvantagens de usar um BOM.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Por exemplo, saber como limitar os campos de banco de dados que usam um BOM pode ser difícil.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode terminar no meio de dados.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no <bpt id="p1">[</bpt>home page do Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix the beginning of a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar o início de um fluxo de bytes codificados com um preâmbulo.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método não preceda um BOM para uma sequência de bytes codificados; fornecer um BOM no início de um fluxo de bytes apropriado é responsabilidade do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to return the Unicode byte order mark encoded in UTF-8 format.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> codificada no formato UTF-8 de marca de ordem de método para retornar o byte Unicode.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Notice that the default constructor for <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> does not provide a preamble.</source>
          <target state="translated">Observe que o construtor padrão para <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> não fornece um preâmbulo.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example instantiates two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects, the first by calling the parameterless <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not provide a BOM, and the second by calling the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> constructor with its <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> argument set to <ph id="ph5">`true`</ph>.</source>
          <target state="translated">O exemplo a seguir cria dois <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos, o primeiro chamando o sem parâmetros <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> construtor, que não fornece um BOM e a segunda chamando o <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> construtor com seu <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> argumento definido como <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to write the BOM to a file before writing a UF8-encoded string.</source>
          <target state="translated">Depois, ele chama o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método gravar BOM para um arquivo antes de gravar uma cadeia de caracteres codificada em UF8.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</source>
          <target state="translated">Como mostra a saída do exemplo do console, o arquivo que salva os bytes do codificador do segundo tem três mais bytes que o primeiro.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can also compare the files by using the <ph id="ph1">`fc`</ph> command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</source>
          <target state="translated">Você também pode comparar os arquivos usando o <ph id="ph1">`fc`</ph> comando em uma janela de console, ou você pode inspecionar os arquivos em um editor de texto que inclui um modo de exibição hexadecimal.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that when the file is opened in an editor that supports UTF-8, the BOM is not displayed.</source>
          <target state="translated">Observe que, quando o arquivo é aberto em um editor que dá suporte a UTF-8, a BOM não será exibida.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">A matriz de bytes que contém a sequência de bytes a ser decodificada.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">O índice do primeiro byte a ser decodificado.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">O número de bytes a serem decodificados.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Decodes a range of bytes from a byte array into a string.</source>
          <target state="translated">Decodifica um intervalo de bytes de uma matriz de bytes em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém os resultados da decodificação da sequência de bytes especificada.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Detecção de erro, uma sequência inválida faz com que esse método lançar uma <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode removê-lo ao chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Neste caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, use o <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fornecidos pelo <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método ou o <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example initializes an array by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</source>
          <target state="translated">O exemplo a seguir inicializa uma matriz chamando o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método para determinar exatamente quantos bytes são necessários para uma cadeia de caracteres codificada e, em seguida, adicionar o tamanho da marca de ordem de byte (BOM).</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to store the BOM to the array before calling the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the encoded bytes to the array.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método para armazenar o BOM para a matriz antes de chamar o <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para armazenar os bytes codificados para a matriz.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> method to decode the string.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> método decodificar a cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</source>
          <target state="translated">Observe que nesse caso a cadeia de caracteres decodificada é diferente de cadeia de caracteres original, desde que ela começa com uma marca de ordem de bytes de 16 bits U + FFFD.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</source>
          <target state="translated">Isso significa que compara duas cadeias de caracteres como diferente e que, se a cadeia de caracteres é a saída, a BOM será exibida como o caractere de substituição "?".</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>To remove the BOM at the beginning of the string, you can call the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para remover a BOM no início da cadeia de caracteres, você pode chamar o <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> não denotam um intervalo válido em <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">A detecção de erros está habilitada e <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contém uma sequência de bytes inválida.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Ocorreu um fallback (consulte <bpt id="p1">[</bpt>Codificação de caracteres no .NET<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obter uma explicação completa)</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>