<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DataContext.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56cbfb225f9d8295e7bf1faa0cef5897f808b990c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6cbfb225f9d8295e7bf1faa0cef5897f808b990c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Represents the main entry point for the LINQ to SQL framework.</source>
          <target state="translated">Representa o ponto de entrada principal para a estrutura de LINQ to SQL.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is the source of all entities mapped over a database connection.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> é a origem de todas as entidades mapeado sobre uma conexão de banco de dados.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>It tracks changes that you made to all retrieved entities and maintains an "identity cache" that guarantees that entities retrieved more than one time are represented by using the same object instance.</source>
          <target state="translated">Ele rastreia as alterações feitas a todas as entidades recuperadas e mantém um "cache de identidade" garante que as entidades recuperadas mais de uma vez é representados por usando a mesma instância de objeto.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>In general, a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instance is designed to last for one "unit of work" however your application defines that term.</source>
          <target state="translated">Em geral, um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instância foi projetada para a última para uma "unidade de trabalho", no entanto, o aplicativo define termo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is lightweight and is not expensive to create.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> é leve e não é caro criar.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>A typical <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> application creates <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instances at method scope or as a member of short-lived classes that represent a logical set of related database operations.</source>
          <target state="translated">Um típico <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> aplicativo cria <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instâncias no escopo do método ou como um membro de curta duração classes que representam um conjunto lógico de relacionadas a operações de banco de dados.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>The connection string you use can be an ADO.NET connection string.</source>
          <target state="translated">A cadeia de conexão que você usa pode ser uma cadeia de conexão ADO.NET.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>You can also specify a filename to a SQL Server Express or SQL Server Compact file.</source>
          <target state="translated">Você também pode especificar um nome de arquivo para um arquivo SQL Server Express ou SQL Server Compact.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>The connection used by the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">A conexão usada pelo <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing the connection used by the <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> referenciando a conexão usada pelo <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> opens and closes a database connection as needed if you provide a closed connection or a connection string.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> abre e fecha uma conexão de banco de dados conforme necessário, se você fornecer uma conexão fechada ou uma cadeia de caracteres de conexão.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>In general, you should never have to call <ph id="ph1">`Dispose`</ph> on a <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Em geral, você nunca deve chamar <ph id="ph1">`Dispose`</ph> em um <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>If you provide an open connection, the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> will not close it.</source>
          <target state="translated">Se você fornecer uma conexão aberta, o <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> não será fechado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>Therefore, do not instantiate a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> with an open connection unless you have a good reason to do this.</source>
          <target state="translated">Portanto, não criar uma instância de um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> com uma conexão aberta, a menos que você tem uma boa razão para isso.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>In a <ph id="ph1">&lt;xref:System.Transactions&gt;</ph> transaction, a <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> will not open or close a connection to avoid promotion.</source>
          <target state="translated">Em um <ph id="ph1">&lt;xref:System.Transactions&gt;</ph> transação, um <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> não abrir ou fechar uma conexão para evitar a promoção.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>The connection used by the .NET Framework.</source>
          <target state="translated">A conexão usada pelo .NET Framework.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>A source for mapping.</source>
          <target state="translated">Uma fonte de mapeamento.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a connection and a mapping source.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> referenciando uma conexão e uma fonte de mapeamento.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>This argument can be any one of the following:</source>
          <target state="translated">Esse argumento pode ser um dos seguintes:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>The name of a file where a SQL Server Express database resides.</source>
          <target state="translated">O nome de um arquivo em que reside um banco de dados SQL Server Express.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>The name of a server where a database is present.</source>
          <target state="translated">O nome de um servidor em que existe um banco de dados.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>In this case the provider uses the default database for a user.</source>
          <target state="translated">Nesse caso, o provedor usa o banco de dados padrão de um usuário.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>A complete connection string.</source>
          <target state="translated">Uma cadeia de conexão completa.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> just passes the string to the provider without modification.</source>
          <target state="translated">O <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> passa apenas a cadeia de caracteres para o provedor sem modificação.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>A source for mapping.</source>
          <target state="translated">Uma fonte de mapeamento.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a file source and a mapping source.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> referenciando uma fonte de arquivo e fonte de mapeamento.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a file source.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> referenciando uma fonte de arquivo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>Gets a collection of objects that caused concurrency conflicts when <ph id="ph1">&lt;see cref="M:System.Data.Linq.DataContext.SubmitChanges" /&gt;</ph> was called.</source>
          <target state="translated">Obtém uma coleção de objetos que causaram conflitos de simultaneidade quando o <ph id="ph1">&lt;see cref="M:System.Data.Linq.DataContext.SubmitChanges" /&gt;</ph> foi chamado.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>A collection of objects that caused concurrency conflicts.</source>
          <target state="translated">Uma coleção de objetos que causaram conflitos de simultaneidade.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>The following example shows how the collection can be iterated over to retrieve conflict information.</source>
          <target state="translated">O exemplo a seguir mostra como a coleção pode ser iterada para recuperar informações de conflito.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>Gets or sets a value that increases the time-out period for queries that would otherwise time out during the default time-out period.</source>
          <target state="translated">Obtém ou define um valor que aumenta o período de tempo limite para consultas que, de outra forma, atingir o tempo limite durante o período de tempo limite padrão.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>An integer value that increases the time-out period for queries that would otherwise time out during the default time-out period.</source>
          <target state="translated">Um valor que aumenta o período de tempo limite para consultas que, de outra forma, atingir o tempo limite durante o período de tempo limite padrão.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>This property gets or sets the command time-out used to execute generated commands (<ph id="ph1">`IDbCommands`</ph>).</source>
          <target state="translated">Essa propriedade obtém ou define o tempo limite do comando usado para executar comandos gerados (<ph id="ph1">`IDbCommands`</ph>).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>When this property is not set, the default value of <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph> is used for query command execution.</source>
          <target state="translated">Quando essa propriedade não é definida, o valor padrão de <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph> é usado para a execução do comando de consulta.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>This default value is set by the storage provider.</source>
          <target state="translated">O valor padrão é definido pelo provedor de armazenamento.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>Note that some providers may throw exceptions if this value is set to a non-zero value.</source>
          <target state="translated">Observe que alguns provedores podem gerar exceções se esse valor é definido como um valor diferente de zero.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Connection">
          <source>Gets the connection used by the framework.</source>
          <target state="translated">Obtém a conexão usada pela estrutura.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>The connection used by the framework.</source>
          <target state="translated">A conexão usada pela estrutura.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>You can use this property to interoperate with relational ADO.NET code.</source>
          <target state="translated">Você pode usar essa propriedade para a interoperação com código do ADO.NET relacional.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>The returned connection will be closed unless it has been explicitly opened by the user.</source>
          <target state="translated">A conexão retornado será fechado, a menos que ele foi aberto explicitamente pelo usuário.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>Creates a database on the server.</source>
          <target state="translated">Cria um banco de dados no servidor.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>The name of the database is derived by using the following algorithm:</source>
          <target state="translated">O nome do banco de dados será derivado usando o seguinte algoritmo:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a database is identified in the connection string, its name is used.</source>
          <target state="translated">Se um banco de dados for identificado na cadeia de conexão, seu nome será usado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a <ph id="ph1">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute&gt;</ph> attribute is present, its <ph id="ph2">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A&gt;</ph> property is used as the name of the database.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute&gt;</ph> atributo estiver presente, seu <ph id="ph2">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A&gt;</ph> propriedade é usada como o nome do banco de dados.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If there is no database tag in the connection string and a strongly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is used, a database that has the same name as the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> inheriting class is checked.</source>
          <target state="translated">Se não houver nenhuma marca de banco de dados na cadeia de conexão e fortemente tipadas <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> for usado, um banco de dados que tem o mesmo nome que o <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> herança de classe está marcada.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a weakly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is used, an exception is thrown.</source>
          <target state="translated">Se um fracamente tipada <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> é usado, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> has been created by using a file name, the database corresponding to that file name is created.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> foi criado usando um nome de arquivo, o banco de dados correspondente para o nome do arquivo é criado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>The following code shows how to set up a temporary database and then remove it.</source>
          <target state="translated">O código a seguir mostra como configurar um banco de dados temporário e, em seguida, removê-lo.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The type of the elements in the returned collection.</source>
          <target state="translated">O tipo dos elementos na coleção retornada.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The instance of the method invocation (the current object).</source>
          <target state="translated">A instância da invocação do método (o objeto atual).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> that identifies the CLR method that corresponds to a database method.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que identifica o método CLR que corresponde a um método de banco de dados.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">A matriz de parâmetros a serem passados para o comando.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Executes the table-valued database function associated with the specified CLR method.</source>
          <target state="translated">Executa a função de banco de dados com valor de tabela associada ao método CLR especificado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>A collection of resultant values returned by the database query.</source>
          <target state="translated">Uma coleção de valores resultantes retornada pela consulta de banco de dados.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A&gt;</ph> method is used in automatically generated code and acts as a proxy to database functions.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A&gt;</ph> método é usado no código gerado automaticamente e atua como um proxy para funções de banco de dados.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>Determines whether the associated database can be opened.</source>
          <target state="translated">Determina se o banco de dados associado pode ser aberto.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified database can be opened; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o banco de dados especificado puder ser aberto; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>This method uses the connection in the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> property to attempt to open the associated database.</source>
          <target state="translated">Esse método usa a conexão no <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> propriedade para tentar abrir o banco de dados associado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>The following example uses this method to determine whether a database already exists.</source>
          <target state="translated">O exemplo a seguir usa esse método para determinar se um banco de dados já existe.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Gets or sets a value that indicates whether to delay-load one-to-many or one-to-one relationships.</source>
          <target state="translated">Obtém ou define um valor que indica se relações de um-para-muitos ou de um-para-um devem ter o carregamento adiado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if deferred loading is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o adiamento de carregamento for habilitado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>When the code accesses one of these relationships, null is returned if the relationship is one-to-one, and an empty collection is returned if it is one-to-many.</source>
          <target state="translated">Quando o código acessa uma dessas relações, null será retornado se a relação é um para um, e uma coleção vazia é retornada se ele for um-para-muitos.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The relationships can still be filled by setting the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.LoadOptions%2A&gt;</ph> property.</source>
          <target state="translated">As relações ainda podem ser preenchidas, definindo o <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.LoadOptions%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The main scenario for this property is to enable you to extract a piece of the object model and send it out (for example, to a Web service).</source>
          <target state="translated">O cenário principal para essa propriedade é habilitar a extração de uma parte do modelo de objeto e enviá-lo (por exemplo, para um serviço da Web).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>If this property is set to <ph id="ph1">`false`</ph> after a query has been executed, an exception is thrown.</source>
          <target state="translated">Se essa propriedade é definida como <ph id="ph1">`false`</ph> depois que uma consulta tiver sido executada, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>See the <bpt id="p1">**</bpt>Valid Modes<ept id="p1">**</ept> section below for more information.</source>
          <target state="translated">Consulte o <bpt id="p1">**</bpt>os modos válidos<ept id="p1">**</ept> seção abaixo para obter mais informações.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Valid modes</source>
          <target state="translated">Modos válidos</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Deferred loading requires object tracking.</source>
          <target state="translated">O carregamento Deferido requer controle de objeto.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Only the following three modes are valid:</source>
          <target state="translated">Somente os seguintes modos são válidos:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is ignored and inferred to be <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> é ignorado e inferido para ser <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This behavior corresponds to a read-only <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Esse comportamento corresponde a um somente leitura <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This situation corresponds to a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> that allows users to load an object graph by using <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, but it does not enable deferred loading.</source>
          <target state="translated">Essa situação corresponde a um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> que permite que os usuários carreguem um gráfico de objeto usando <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> diretivas, mas não habilitar o carregamento adiado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Both are set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Ambos são definidos como <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This is the default.</source>
          <target state="translated">Esse é o padrão.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The flags may not be changed after a query has been executed.</source>
          <target state="translated">Os sinalizadores não podem ser alterados depois que uma consulta é executada.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Any change after the execution of the first query that uses that <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> throws an exception.</source>
          <target state="translated">Qualquer alteração após a execução da primeira consulta que usa <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> lança uma exceção.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>Deletes the associated database.</source>
          <target state="translated">Exclui o banco de dados associado.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>This method uses the connection in the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> property to identify the database to be deleted.</source>
          <target state="translated">Esse método usa a conexão no <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> propriedade para identificar o banco de dados a ser excluído.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>The following example shows how to delete a database that has been temporarily created.</source>
          <target state="translated">O exemplo a seguir mostra como excluir um banco de dados que tenha sido criado temporariamente.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Releases the resources used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Libera os recursos usados pela classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual da classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar recursos gerenciados e não gerenciados; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar apenas recursos não gerenciados.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class and optionally releases the managed resource.</source>
          <target state="translated">Libera os recursos não gerenciados usados pela classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> e, opcionalmente, libera o recurso gerenciado.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The SQL command to be executed.</source>
          <target state="translated">O comando SQL ser executado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">A matriz de parâmetros a serem passados para o comando.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Observe o seguinte comportamento:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Se o número de objetos na matriz for menor que o maior número identificado na cadeia de caracteres de comando, uma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Se a matriz contiver objetos que não são referenciados na cadeia de caracteres de comando, nenhuma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If any one of the parameters is null, it is converted to <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Se um dos parâmetros for nulo, ele será convertido em <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Executes SQL commands directly on the database.</source>
          <target state="translated">Executa comandos SQL diretamente no banco de dados.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The number of rows modified by the executed command.</source>
          <target state="translated">O número de linhas modificadas pelo comando executado.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>This method is a pass-through mechanism for cases where <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not adequately provide for a particular scenario.</source>
          <target state="translated">Esse método é um mecanismo de passagem para casos onde <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> não fornece adequado para um determinado cenário.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The syntax for the command is almost the same as the syntax used to create an ADO.NET <ph id="ph1">`DataCommand`</ph>.</source>
          <target state="translated">A sintaxe do comando é quase o mesmo que a sintaxe usada para criar um ADO.NET <ph id="ph1">`DataCommand`</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The only difference is in how the parameters are specified.</source>
          <target state="translated">A única diferença está em como os parâmetros são especificados.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0.</source>
          <target state="translated">Especificamente, você pode especificar parâmetros, colocando-os entre chaves ({…}) e enumerá-los a partir de 0.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The parameter is associated with the equally numbered object in the parameters array.</source>
          <target state="translated">O parâmetro é associado ao objeto igualmente numerado na matriz de parâmetros.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source><ph id="ph1">`ExecuteQuery`</ph> and <ph id="ph2">`ExecuteCommand`</ph> allow you to specify a variable number of arguments for parameter substitution.</source>
          <target state="translated"><ph id="ph1">`ExecuteQuery`</ph> e <ph id="ph2">`ExecuteCommand`</ph> permitem que você especifique um número variável de argumentos para a substituição de parâmetro.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>For example, you can specify the parameters when invoking ExecuteQuery<ph id="ph1">\&lt;</ph>TResult&gt;:</source>
          <target state="translated">Por exemplo, você pode especificar os parâmetros ao chamar ExecuteQuery<ph id="ph1">\&lt;</ph>TResult &gt;:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>And, another example:</source>
          <target state="translated">E outro exemplo:</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The following example opens a connection and passes a SQL <ph id="ph1">`UPDATE`</ph> command to the SQL engine.</source>
          <target state="translated">O exemplo a seguir abre uma conexão e passa um SQL <ph id="ph1">`UPDATE`</ph> comando para o mecanismo do SQL.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>The entity to be deleted.</source>
          <target state="translated">A entidade a ser excluída.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>Executes, inside delete override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for delete operations.</source>
          <target state="translated">É executado, dentro de métodos de substituição de exclusão, para redelegar para <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> a tarefa de geração e execução de SQL dinâmico para operações de exclusão.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The entity to be inserted.</source>
          <target state="translated">A entidade a ser inserida.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Executes, inside insert override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for insert operations.</source>
          <target state="translated">É executado, dentro de métodos de substituição de inserção, para delegar novamente para <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> a tarefa de gerar e executar SQL dinâmico para operações de inserção.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Note the following considerations:</source>
          <target state="translated">Observe as seguintes considerações:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Because the method has a protected modifier, its use requires subclassing <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Como o método tem um modificador protegido, seu uso exige subclassificação <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>An exception is thrown if this operation is not called inside a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operation.</source>
          <target state="translated">Uma exceção é gerada se essa operação não é chamada dentro de um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operação.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is not intended to be called as a stand-alone operation outside the scope of a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operation.</source>
          <target state="translated">Ele não se destina a ser chamado como uma operação autônoma fora do escopo de um <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operação.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> itself calls override methods if they are implemented and the previous methods are intended to be called inside the override methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> chamadas substituem métodos se eles são implementados e os métodos anteriores devem ser chamado dentro de métodos de substituição.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is the responsibility of the developer to pass in the correct entity.</source>
          <target state="translated">É responsabilidade do desenvolvedor para passar a entidade correta.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The implementation verifies that the passed-in entity is tracked.</source>
          <target state="translated">A implementação verifica que a entidade transmitido é controlada.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>However, it is the responsibility of the developer to maintain the order or pass in the same entity two times.</source>
          <target state="translated">No entanto, é responsabilidade do desenvolvedor para manter a ordem ou passe na mesma entidade duas vezes.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is the responsibility of the developer to invoke the correct dynamic API.</source>
          <target state="translated">É responsabilidade do desenvolvedor para chamar a API dinâmica correta.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>For example, in the <ph id="ph1">`Update`</ph> override method, only the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A&gt;</ph> method can be called.</source>
          <target state="translated">Por exemplo, o <ph id="ph1">`Update`</ph> substituir o método, somente o <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A&gt;</ph> método pode ser chamado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not detect or verify whether the invoked dynamic method matches the applicable operation.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> não detecta ou não verifica se o método dinâmico chamado corresponde a operação aplicável.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The results are undefined if an inapplicable method is called (for example, calling <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A&gt;</ph> for an object to be updated).</source>
          <target state="translated">Os resultados serão definidos se for chamado um método aplicável (por exemplo, chamar <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A&gt;</ph> para um objeto a ser atualizado).</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>The entity to be updated.</source>
          <target state="translated">A entidade a ser atualizada.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>Executes, inside update override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for update operations.</source>
          <target state="translated">É executado, dentro de métodos de substituição de atualização, para redelegar para <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> a tarefa de geração e execução de SQL dinâmico para operações de atualização.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The instance of the method invocation (the current object).</source>
          <target state="translated">A instância da invocação do método (o objeto atual).</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Identifies the CLR method that corresponds to a database method.</source>
          <target state="translated">Identifica o método CLR que corresponde a um método de banco de dados.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">A matriz de parâmetros a serem passados para o comando.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Executes the stored database procedure or scalar function associated with the specified CLR method.</source>
          <target state="translated">Executa o procedimento armazenado do banco de dados ou a função escalar associada com o método CLR especificado.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The result (the return value and output parameters) of executing the specified method.</source>
          <target state="translated">O resultado (o valor retornado e parâmetros de saída) da execução do método especificado.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A&gt;</ph> method is used in automatically generated code and acts as a proxy to database functions.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A&gt;</ph> método é usado no código gerado automaticamente e atua como um proxy para funções de banco de dados.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">O tipo dos <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> a serem retornados.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The algorithm for matching columns in the result of the query to fields or properties in the object works as follows:</source>
          <target state="translated">O algoritmo para colunas correspondentes nos resultados da consulta para campos ou propriedades no objeto funciona da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade é mapeado para um nome de coluna em particular, o nome dessa coluna é esperado no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade não for mapeado, uma coluna com o mesmo nome do campo ou propriedade é esperada no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The comparison is performed by looking for a case-sensitive match first.</source>
          <target state="translated">A comparação é realizada procurando, primeiro, uma correspondência que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If this match is not found, a subsequent search occurs for a case-insensitive match.</source>
          <target state="translated">Se essa correspondência não for encontrada, uma pesquisa subsequente ocorre para uma correspondência que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</source>
          <target state="translated">A consulta deve retornar todos os campos rastreados e propriedades do objeto (exceto aqueles que são carregados de forma adiada) quando todas as seguintes condições forem verdadeiras:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is an entity explicitly tracked by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> é uma entidade explicitamente controlada por <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The entity has a primary key.</source>
          <target state="translated">A entidade tem uma chave primária.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Do contrário, uma exceção será acionada.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The SQL query to be executed.</source>
          <target state="translated">A consulta SQL a ser executada.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">A matriz de parâmetros a serem passados para o comando.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Observe o seguinte comportamento:</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Se o número de objetos na matriz for menor que o maior número identificado na cadeia de caracteres de comando, uma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Se a matriz contiver objetos que não são referenciados na cadeia de caracteres de comando, nenhuma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, it is converted to <ph id="ph2">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Se um parâmetro for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ele será convertido em <ph id="ph2">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Executes SQL queries directly on the database.</source>
          <target state="translated">Executa consultas SQL diretamente no banco de dados.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of objects returned by the query.</source>
          <target state="translated">Uma coleção de objetos <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> retornada pela consulta.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The type of the elements in the returned collection.</source>
          <target state="translated">O tipo dos elementos na coleção retornada.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The SQL query to be executed.</source>
          <target state="translated">A consulta SQL a ser executada.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">A matriz de parâmetros a serem passados para o comando.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Observe o seguinte comportamento:</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Se o número de objetos na matriz for menor que o maior número identificado na cadeia de caracteres de comando, uma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Se a matriz contiver objetos que não são referenciados na cadeia de caracteres de comando, nenhuma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a parameter is null, it is converted to <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Se um parâmetro for nulo, ele será convertido em <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Executes SQL queries directly on the database and returns objects.</source>
          <target state="translated">Executa consultas SQL diretamente no banco de dados e retorna objetos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>A collection of objects returned by the query.</source>
          <target state="translated">Uma coleção de objetos retornada pela consulta.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>This method is a pass-through mechanism for cases where <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not provide for a particular scenario.</source>
          <target state="translated">Esse método é um mecanismo de passagem para casos onde <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> não fornece um cenário específico.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The algorithm for matching columns in the result of the query to fields and properties in the object works as follows:</source>
          <target state="translated">O algoritmo para as colunas correspondentes no resultado da consulta aos campos e propriedades no objeto funciona da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade é mapeado para um nome de coluna em particular, o nome dessa coluna é esperado no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade não for mapeado, uma coluna com o mesmo nome do campo ou propriedade é esperada no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The comparison is performed by first looking for a case-sensitive match.</source>
          <target state="translated">A comparação é executada primeiro procurando uma correspondência diferencia maiusculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If such a match is not found, a subsequent search occurs for a case-insensitive match.</source>
          <target state="translated">Se essa correspondência não for encontrada, uma pesquisa subsequente ocorre uma correspondência diferencia maiusculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The query must return all the tracked fields and properties of the object (apart from those subject to deferred loading) when all the following are true:</source>
          <target state="translated">A consulta deve retornar todas as propriedades do objeto (exceto aquelas sujeito a carregamento adiado) e rastreados campos quando todos os itens a seguir forem verdadeiras:</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If <ph id="ph1">`&lt;T&gt;`</ph> is an entity explicitly tracked by the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`&lt;T&gt;`</ph> uma entidade explicitamente controlada pelo <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>ObjectTrackingEnabled is true.</source>
          <target state="translated">ObjectTrackingEnabled é true.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The entity has a primary key.</source>
          <target state="translated">A entidade tem uma chave primária.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Do contrário, uma exceção será acionada.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>In all other cases, the query can retrieve just a subset of the tracked fields and properties for the object.</source>
          <target state="translated">Em todos os outros casos, a consulta pode recuperar apenas um subconjunto dos campos rastreados e propriedades do objeto.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The following C# snippet shows one use for this method:</source>
          <target state="translated">O trecho c# a seguir mostra um uso para este método:</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>In Visual Basic</source>
          <target state="translated">No Visual Basic</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Gets the modified objects tracked by <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated">Obtém os objetos modificados controlados pelo <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set of objects is returned as three read-only collections.</source>
          <target state="translated">O conjunto de objetos é retornado como três coleções somente leitura.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Note the following considerations:</source>
          <target state="translated">Observe as seguintes considerações:</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetChangeSet%2A&gt;</ph> might have side effects, such as inference of insert and delete operations that are usually performed at the time of <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetChangeSet%2A&gt;</ph> pode ter efeitos colaterais, como inferência de inserir e excluir operações que geralmente são executadas no momento da <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>For example, objects that are used in the following operations can create corresponding inferred operations in the following list:</source>
          <target state="translated">Por exemplo, objetos que são usados em operações a seguir podem criar operações deduzidas correspondentes na lista a seguir:</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.EntitySet%601.Add%2A&gt;</ph> to <ph id="ph2">&lt;xref:System.Data.Linq.Table%601.InsertOnSubmit%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.EntitySet%601.Add%2A&gt;</ph> para <ph id="ph2">&lt;xref:System.Data.Linq.Table%601.InsertOnSubmit%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.EntityRef%601&gt;</ph> assignment to null (possibly because of <ph id="ph2">&lt;xref:System.Data.Linq.EntitySet%601.Remove%2A&gt;</ph> to <ph id="ph3">&lt;xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.EntityRef%601&gt;</ph> atribuição para nulo (possivelmente por causa da <ph id="ph2">&lt;xref:System.Data.Linq.EntitySet%601.Remove%2A&gt;</ph> para <ph id="ph3">&lt;xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set may not be ordered according to foreign key constraints.</source>
          <target state="translated">O conjunto não pode ser ordenado de acordo com as restrições de chave estrangeiras.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Database-generated values (for example, primary and foreign key values, timestamps, and so forth) are not available.</source>
          <target state="translated">Os valores gerados pelo banco de dados (por exemplo, valores de chave primários e estrangeiras, os carimbos de hora e assim por diante) não estão disponíveis.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Such information requires database command execution and perhaps the propagation of retrieved information (for example, foreign key from primary key).</source>
          <target state="translated">Essas informações requerem a execução do comando de banco de dados e talvez a propagação de informações recuperadas (por exemplo, chave estrangeira da chave primária).</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set of changed objects is computed at the time of the call.</source>
          <target state="translated">O conjunto de objetos alterados é calculado no momento da chamada.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> can produce a different set if additional changes are made.</source>
          <target state="translated">As chamadas subsequentes para <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> pode produzir um conjunto diferente, se forem feitas alterações adicionais.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Output when no changes have been made appears as follows:</source>
          <target state="translated">Saída quando nenhuma alteração foi feita aparece da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The query whose SQL command information is to be retrieved.</source>
          <target state="translated">A consulta cujas informações de comando SQL devem ser recuperadas.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Gets the information about SQL commands generated by <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>.</source>
          <target state="translated">Obtém as informações sobre os comandos SQL gerados pelo <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The requested command information object.</source>
          <target state="translated">O objeto de informações do comando solicitado.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>This method is only a getter and does not affect <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> state.</source>
          <target state="translated">Este método é somente um getter e não afeta <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Note the following considerations:</source>
          <target state="translated">Observe as seguintes considerações:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The argument must be non-null.</source>
          <target state="translated">O argumento deve ser não-nulo.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Otherwise, a null argument exception is thrown.</source>
          <target state="translated">Caso contrário, será gerada uma exceção de argumento nulo.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Normal query translation exceptions thrown during <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> query execution apply for a query that cannot be translated.</source>
          <target state="translated">Exceções de conversão de consulta normal lançadas durante a <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> se aplicam a execução da consulta para uma consulta que não pode ser convertida.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Only the first query command is returned.</source>
          <target state="translated">Somente o primeiro comando de consulta é retornado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Specifically, additional commands that are used for eager loading (<ph id="ph1">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph>) are not included.</source>
          <target state="translated">Especificamente, os comandos adicionais que são usados para carregamento adiantado (<ph id="ph1">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph>) não são incluídos.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> does not track what the user does with the command.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> não controla o que o usuário faz com o comando.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>For example, results from the execution of the returned command are not tracked and do not affect <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> state.</source>
          <target state="translated">Por exemplo, os resultados da execução do comando retornado não são rastreados e não afetam <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>The type of the objects to be returned.</source>
          <target state="translated">O tipo dos objetos a serem retornados.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>Returns a collection of objects of a particular type, where the type is defined by the <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Retorna uma coleção de objetos de um tipo específico, em que o tipo é definido pelo parâmetro <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>A collection of objects defined by the <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Uma coleção de objetos definidos pelo parâmetro <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>This is a weakly typed version of <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetTable%2A&gt;</ph>.</source>
          <target state="translated">Esta é uma versão sem rigidez de tipos de <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetTable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>It is important to have a weakly typed version because it is a relatively common practice to construct queries dynamically.</source>
          <target state="translated">É importante ter uma versão sem rigidez de tipos porque é uma prática comum relativamente para construir consultas dinamicamente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>It would be inconvenient to force the application to use reflection to call the correct generic method.</source>
          <target state="translated">Seria inconveniente forçar o aplicativo usar reflexão para chamar o método genérico correto.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>If there is no collection for a particular type, an exception is thrown.</source>
          <target state="translated">Se não houver nenhuma coleção para um determinado tipo, uma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>The type of the objects to be returned.</source>
          <target state="translated">O tipo dos objetos a serem retornados.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>Returns a collection of objects of a particular type, where the type is defined by the <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph> parameter.</source>
          <target state="translated">Retorna uma coleção de objetos de um tipo específico, em que o tipo é definido pelo parâmetro <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>A collection of objects defined by the <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph> parameter.</source>
          <target state="translated">Uma coleção de objetos definidos pelo parâmetro <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>This method is the main entry point for querying.</source>
          <target state="translated">Esse método é o ponto de entrada principal para a consulta.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>When a strongly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is created, new generated properties encapsulate calls to this method.</source>
          <target state="translated">Quando um fortemente tipada <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> é criadas, novas propriedades geradas encapsular chamadas para esse método.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>For example, a <ph id="ph1">`Customers`</ph> property is generated that returns <ph id="ph2">`GetTable&lt;Customer&gt;`</ph>.</source>
          <target state="translated">Por exemplo, um <ph id="ph1">`Customers`</ph> propriedade gerada retorna <ph id="ph2">`GetTable&lt;Customer&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>If there is no collection for a particular type, an exception is thrown.</source>
          <target state="translated">Se não houver nenhuma coleção para um determinado tipo, uma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataLoadOptions" /&gt;</ph> associated with this <ph id="ph2">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define o <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataLoadOptions" /&gt;</ph> associado a esse <ph id="ph2">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>The prefetch load options for related data.</source>
          <target state="translated">As opções de carregamento da pré-busca para os dados relacionados.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>This property gets or sets the options that are used to define prefetch behavior for deferred-loaded members and membership of related collections.</source>
          <target state="translated">Esta propriedade obtém ou define as opções que são usadas para definir o comportamento de pré-busca para membros carregados adiada e associação de coleções relacionadas.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Log">
          <source>Gets or sets the destination to write the SQL query or command.</source>
          <target state="translated">Obtém ou define o destino para escrever a consulta ou o comando SQL.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> to use for writing the command.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> a ser usado para gravar o comando.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>Set this property to <ph id="ph1">`null`</ph> to disable command logging.</source>
          <target state="translated">Defina essa propriedade como <ph id="ph1">`null`</ph> para desabilitar o log de comando.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>The following example displays generated SQL in the console window before it displays the results of the query.</source>
          <target state="translated">O exemplo a seguir exibe o SQL gerado na janela do console antes de exibir os resultados da consulta.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Mapping">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Data.Linq.Mapping.MetaModel" /&gt;</ph> on which the mapping is based.</source>
          <target state="translated">Obtém o <ph id="ph1">&lt;see cref="T:System.Data.Linq.Mapping.MetaModel" /&gt;</ph> no qual o mapeamento é baseado.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Mapping">
          <source>The mapping between a database and domain objects.</source>
          <target state="translated">O mapeamento entre objetos de banco de dados e de domínio.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>Gets or sets a value that indicates whether object tracking is enabled.</source>
          <target state="translated">Obtém ou define um valor que indica se o rastreamento do objeto está habilitado.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object tracking is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o rastreamento do objeto estiver habilitado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>Setting this property to <ph id="ph1">`false`</ph> improves performance at retrieval time, because there are fewer items to track.</source>
          <target state="translated">Definir essa propriedade como <ph id="ph1">`false`</ph> melhora o desempenho em tempo de recuperação, pois há menos itens para rastrear.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>An exception is thrown:</source>
          <target state="translated">Uma exceção é gerada:</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If the property is set to <ph id="ph1">`false`</ph> after a query has been executed.</source>
          <target state="translated">Se a propriedade é definida como <ph id="ph1">`false`</ph> depois que uma consulta é executada.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>For more information, see the Valid Modes section in <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte a seção modos válidos <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If the property is set to <ph id="ph1">`false`</ph> and <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is called.</source>
          <target state="translated">Se a propriedade é definida como <ph id="ph1">`false`</ph> e <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> is <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is ignored and treated as <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> é <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> é ignorada e tratada como <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is read-only.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> is <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> for <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> será <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>In this case, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> allows you to load an object graph by using <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, but does not enable deferred loading.</source>
          <target state="translated">Nesse caso, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> permite que você carregue um gráfico de objeto usando <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> diretivas, mas não habilitar o carregamento adiado.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Refreshes object state by using data in the database.</source>
          <target state="translated">Atualiza o estado do objeto usando os dados no banco de dados.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>This method is useful after an optimistic concurrency error to bring items into a state for another attempt.</source>
          <target state="translated">Esse método é útil após um erro de simultaneidade otimista para colocar itens em um estado para outra tentativa.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>It updates the state of the primitive fields and properties on the objects.</source>
          <target state="translated">Ele atualizará o estado dos primitivos campos e propriedades nos objetos.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>If an object is on the <bpt id="p1">*</bpt>many<ept id="p1">*</ept> side of a one-to-many relationship, the foreign key on the object will be set and the object pointer for the other side of the relationship will be set to the new value.</source>
          <target state="translated">Se o objeto de <bpt id="p1">*</bpt>muitos<ept id="p1">*</ept> lados de uma relação um-para-muitos, a chave estrangeira no objeto serão definido e o ponteiro de objeto para o outro lado da relação será definido para o novo valor.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Um valor que especifica como os conflitos de simultaneidade otimista são tratados.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>The collection of entities to be refreshed.</source>
          <target state="translated">A coleção de entidades a ser atualizada.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>Refreshes a collection of entity objects according to the specified mode.</source>
          <target state="translated">Atualiza uma coleção de objetos de entidade de acordo com o modo especificado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Um valor que especifica como os conflitos de simultaneidade otimista são tratados.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>The object to be refreshed.</source>
          <target state="translated">O objeto a ser atualizado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>Refreshes an entity object according to the specified mode.</source>
          <target state="translated">Atualiza um objeto de entidade de acordo com o modo especificado.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Um valor que especifica como os conflitos de simultaneidade otimista são tratados.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>The array of entity objects to be refreshed.</source>
          <target state="translated">A matriz de objetos de entidade a ser atualizada.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>Refreshes an array of entity objects according to the specified mode.</source>
          <target state="translated">Atualiza uma matriz de objetos de entidade de acordo com o modo especificado.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</source>
          <target state="translated">Calcula o conjunto de objetos modificados a serem inseridos, atualizados ou excluídos e executa os comandos adequados para implementar as alterações no banco de dados.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>If override methods are present for insert, update, or delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executes these methods instead of the default <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commands.</source>
          <target state="translated">Se houver métodos de substituição para insert, update ou delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executa esses métodos em vez do padrão <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> comandos.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> starts a transaction and will roll back if an exception occurs while <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> inicia uma transação e será revertida se ocorrer uma exceção enquanto <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> está em execução.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>However, this does not roll back the changes in memory or tracked by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>; those changes will need to be rolled back manually.</source>
          <target state="translated">No entanto, isso não reverte as alterações na memória ou controlada pelo <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>; essas alterações precisará ser revertido manualmente.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>You can start with a new instance of the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> if the changes in memory are to be discarded.</source>
          <target state="translated">Você pode iniciar com uma nova instância do <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> se as alterações na memória devem ser descartadas.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges">
          <source>Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</source>
          <target state="translated">Calcula o conjunto de objetos modificados a serem inseridos, atualizados ou excluídos e executa os comandos adequados para implementar as alterações no banco de dados.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.SubmitChanges">
          <source>If override methods are present for insert, update, or delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executes these methods instead of the default <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commands.</source>
          <target state="translated">Se houver métodos de substituição para insert, update ou delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executa esses métodos em vez do padrão <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> comandos.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>The action to be taken if the submission fails.</source>
          <target state="translated">A ação a ser tomada se o envio falhar.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Valid arguments are as follows:</source>
          <target state="translated">Os argumentos válidos são da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Sends changes that were made to retrieved objects to the underlying database, and specifies the action to be taken if the submission fails.</source>
          <target state="translated">Envia as alterações que foram feitas para recuperar objetos de banco de dados subjacente e especifica a ação a ser tomada se o envio falhar.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Default failure mode is <ph id="ph1">&lt;xref:System.Data.Linq.ConflictMode.FailOnFirstConflict&gt;</ph>.</source>
          <target state="translated">Modo de falha padrão é <ph id="ph1">&lt;xref:System.Data.Linq.ConflictMode.FailOnFirstConflict&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>Gets or sets a local transaction for the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> to use to access the database.</source>
          <target state="translated">Obtém ou define uma transação local para o <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> para usar para acessar o banco de dados.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>The transaction object used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> when executing queries and commands.</source>
          <target state="translated">O objeto de transação usado pelo <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> ao executar consultas e comandos.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>The primary scenario for this property is interoperability with relational <ph id="ph1">[!INCLUDE[vstecado](~/includes/vstecado-md.md)]</ph> code.</source>
          <target state="translated">O cenário principal para essa propriedade é a interoperabilidade com relacional <ph id="ph1">[!INCLUDE[vstecado](~/includes/vstecado-md.md)]</ph> código.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>For example, use this property when you write your own <ph id="ph1">`Create`</ph><ph id="ph2">/</ph><ph id="ph3">`Update`</ph><ph id="ph4">/</ph><ph id="ph5">`Delete`</ph> methods to set the <ph id="ph6">`Transaction`</ph> property on the ADO <ph id="ph7">`Command`</ph> object.</source>
          <target state="translated">Por exemplo, use essa propriedade quando você escrever seu próprio <ph id="ph1">`Create`</ph> <ph id="ph2">/</ph> <ph id="ph3">`Update`</ph> <ph id="ph4">/</ph> <ph id="ph5">`Delete`</ph> métodos para definir o <ph id="ph6">`Transaction`</ph> propriedade ADO <ph id="ph7">`Command`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>Note the following:</source>
          <target state="translated">Observe o seguinte:</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If this property has not been explicitly set, the getter returns null.</source>
          <target state="translated">Se essa propriedade não foi definida explicitamente, o getter retorna nulo.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If the code is executing in a <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> context, setting this property throws an exception.</source>
          <target state="translated">Se o código está sendo executado em um <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> contexto, a definição dessa propriedade gera uma exceção.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If this property is set and a new <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> is opened, an exception is thrown when a query or update is executed.</source>
          <target state="translated">Se essa propriedade for conjunto e um novo <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> é aberto, uma exceção é lançada quando uma consulta ou atualização é executada.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Converte um <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> existente em objetos.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Each row in the <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> is converted to an object in the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Cada linha de <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> é convertido em um objeto no <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Description: This method is used to convert an existing <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> to objects.</source>
          <target state="translated">Descrição: Este método é usado para converter um existente <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> a objetos.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Each row in the <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> is converted to an object in the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Cada linha de <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> é convertido em um objeto no <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Generic parameters:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Parâmetros genéricos:<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`T`</ph>: See <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteQuery%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`T`</ph>: Consulte <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteQuery%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Parameters:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Parâmetros:<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`Query`</ph>: See the description for command under <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Query`</ph>: Consulte a descrição do comando em <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`Parameters`</ph>: See the description for parameters under <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Parameters`</ph>: Consulte a descrição de parâmetros em <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Return type:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Tipo de retorno:<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: collection of objects returned by the conversion.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: a coleção de objetos retornados pela conversão.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> a ser convertido.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Converte um <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existente em objetos.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>A list of objects returned by the conversion.</source>
          <target state="translated">Uma lista de objetos retornada pela conversão.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">O tipo dos <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> a serem retornados.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The algorithm for matching columns in the result to fields and properties in the object works as follows:</source>
          <target state="translated">O algoritmo para colunas correspondentes no resultado para os campos e propriedades no objeto funciona da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade é mapeado para um nome de coluna em particular, o nome dessa coluna é esperado no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Se um campo ou propriedade não for mapeado, uma coluna com o mesmo nome do campo ou propriedade é esperada no conjunto de resultados.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The comparison is performed by looking for a case-sensitive match first.</source>
          <target state="translated">A comparação é realizada procurando, primeiro, uma correspondência que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If this match is not found, a subsequent search is occurs for a case-insensitive match.</source>
          <target state="translated">Se essa correspondência não for encontrada, uma pesquisa subsequente ocorre para uma correspondência que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</source>
          <target state="translated">A consulta deve retornar todos os campos rastreados e propriedades do objeto (exceto aqueles que são carregados de forma adiada) quando todas as seguintes condições forem verdadeiras:</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is an entity explicitly tracked by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> é uma entidade explicitamente controlada por <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The entity has a primary key.</source>
          <target state="translated">A entidade tem uma chave primária.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Do contrário, uma exceção será acionada.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> a ser convertido.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Converte um <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existente em objetos.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>A list of objects returned by the conversion.</source>
          <target state="translated">Uma lista de objetos retornada pela conversão.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">O tipo dos <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> a serem retornados.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> a ser convertido.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Converte um <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existente em objetos.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>A collection of objects returned by the conversion.</source>
          <target state="translated">Uma coleção de objetos retornada pela conversão.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>