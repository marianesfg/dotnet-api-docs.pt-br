<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8dbd7c54611eae4fc67bc3cfb380e97f4369f241" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58699710" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece interação com logs de eventos do Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> permite acessar ou personalizar os logs de eventos do Windows, que registram informações sobre eventos importantes de software ou hardware. Usando <xref:System.Diagnostics.EventLog>, você pode ler logs existentes, gravar entradas em logs, criar ou excluir fontes de evento, excluir os logs e responder a entradas de log. Você também pode criar novos logs durante a criação de uma origem do evento.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em C#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 Além de fornecer acesso aos logs de evento individuais e suas entradas, a <xref:System.Diagnostics.EventLog> classe permite que você acesse a coleção de todos os logs de eventos. Você pode usar o `static` membros de <xref:System.Diagnostics.EventLog> para excluir os logs, obter listas de log, criar ou excluir uma fonte ou determinar se um computador já contém uma fonte específica.  
  
 Há três logs de eventos padrão: Aplicativo, sistema e segurança. Um log de segurança é somente leitura. Outros aplicativos e serviços que você instala, como o Active Directory, podem ter os logs de evento adicionais.  
  
 Há considerações de segurança ao usar o <xref:System.Diagnostics.EventLog> classe. <xref:System.Diagnostics.EventLog> requer <xref:System.Diagnostics.EventLogPermission> permissões para ações específicas no .NET Framework 2.0 e versões posteriores, ou de confiança total no .NET Framework 1.0 e 1.1. É recomendável que <xref:System.Diagnostics.EventLogPermission> não ser concedida a código parcialmente confiável.  Você nunca deve passar qualquer objeto de log de eventos, inclusive <xref:System.Diagnostics.EventLogEntryCollection> e <xref:System.Diagnostics.EventLogEntry> objetos, para código menos confiável. Por exemplo, criando uma <xref:System.Diagnostics.EventLog> objeto, gravar uma entrada e, em seguida, passando o <xref:System.Diagnostics.EventLog> objeto para código parcialmente confiável pode criar um problema de segurança, pois a capacidade de ler e gravar no log de eventos permite que o código executar ações como emitir mensagens de log de eventos no nome de outro aplicativo.  
  
 Começando com o Windows Vista, o controle de conta de usuário (UAC) determina as credenciais de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, você deve primeiro elevar suas credenciais de usuário padrão para o administrador. Você pode fazer isso quando você inicia um aplicativo abrindo o menu de atalho para o aplicativo (se você estiver usando um mouse, clique com botão direito no ícone do aplicativo) e que indica que você deseja executar como administrador.  
  
 Você pode usar <xref:System.Diagnostics.EventLog> para criar logs de eventos personalizados que podem ser exibidos por meio do servidor do Visualizador de eventos. Use o <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> método para exibir um nome localizado para o log de eventos no Visualizador de eventos. Use o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para configurar o comportamento do seu log de eventos quando ele atinge seu tamanho máximo do log.  
  
 Para ler de um log de eventos, especifique o nome do log (<xref:System.Diagnostics.EventLog.Log%2A> propriedade) e o nome de computador do servidor (<xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para o log de eventos. Se você não especificar o nome de computador do servidor, o computador local, ".", será assumido. Não é necessário especificar a origem do evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade), pois uma origem só é necessária para gravar em logs. O <xref:System.Diagnostics.EventLog.Entries%2A> propriedade é preenchida automaticamente com a lista de eventos do log de entradas.  
  
 Para gravar um log de eventos, especificar ou criar uma fonte de evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade). Você deve ter credenciais administrativas no computador para criar uma nova fonte de evento. A origem do evento registra seu aplicativo com o log de eventos como uma fonte válida de entradas. Você pode usar a origem do evento para gravar no log apenas uma por vez. O <xref:System.Diagnostics.EventLog.Source%2A> propriedade pode ser qualquer cadeia de caracteres aleatória, mas o nome deve ser diferente de outras fontes no computador. A origem do evento normalmente é o nome do aplicativo ou outra cadeia de caracteres de identifica. Ao tentar criar uma duplicata <xref:System.Diagnostics.EventLog.Source%2A> valor lança uma exceção. No entanto, um único log de eventos pode ser associado a várias fontes.  
  
 Se a origem do evento para o log de eventos associado com o <xref:System.Diagnostics.EventLog> instância não existe, uma nova origem do evento é criada. Para criar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter credenciais administrativas.  
  
 Esse requisito existe porque todos os logs de eventos, incluindo logs de segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não têm permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
  
> [!IMPORTANT]
>  Criar ou excluir uma fonte de evento requer a sincronização do código subjacente por meio de um mutex nomeado. Se um aplicativo altamente privilegiado bloqueia o mutex nomeado, tentando criar ou excluir uma fonte de evento faz com que o aplicativo pare de responder até que o bloqueio seja liberado. Para ajudar a evitar esse problema, não conceda <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permissão para código não confiável. Além disso, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> potencialmente permissão permite que outras permissões para ser ignorada e deve ser concedida apenas a código altamente confiável.  
  
 Aplicativos e serviços devem gravar no log de aplicativo ou em um log personalizado. Drivers de dispositivo devem gravar no log do sistema. Se você não definir explicitamente o <xref:System.Diagnostics.EventLog.Log%2A> propriedade, o log de eventos assume como padrão o log do aplicativo.  
  
> [!NOTE]
>  Não há nada para proteger um aplicativo contra gravação como qualquer fonte registrada.  Se um aplicativo é concedido <xref:System.Diagnostics.EventLogPermissionAccess.Write> permissão, ele pode gravar eventos para qualquer fonte válido registrado no computador.  
  
 Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> métodos para gravar eventos em um log de eventos. Você deve especificar uma origem de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não tiver atualizado sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller> objeto ou o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter credenciais administrativas no computador para criar uma nova fonte de evento.  
  
 Cada fonte pode gravar apenas um log de eventos ao mesmo tempo; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, seu aplicativo pode exigir várias fontes, configurados para arquivos de recurso diferente ou logs de eventos diferentes. Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam o código-fonte existente, crie uma nova fonte com a configuração atualizada em vez de excluir o código-fonte existente.  
  
 Você pode registrar a origem do evento com os recursos localizados para suas cadeias de caracteres de categoria e mensagem de evento. Seu aplicativo pode gravar entradas de log de eventos usando identificadores de recurso em vez de especificar os valores de cadeia de caracteres real. Consulte a <xref:System.Diagnostics.EventLogInstaller> e <xref:System.Diagnostics.EventSourceCreationData> classes para obter mais informações sobre como configurar sua fonte com arquivos de recurso.  
  
 Se seu aplicativo grava os valores de cadeia de caracteres diretamente ao log de eventos, você não precisa definir o recurso de propriedades de arquivo para a fonte. A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
 Ao gravar eventos, você deve especificar pelo menos uma cadeia de caracteres de mensagem ou o identificador de recurso para uma cadeia de caracteres de mensagem. Outras propriedades de evento são opcionais. Exemplos de configurações de evento opcional incluem o seguinte:  
  
-   Você pode definir o <xref:System.Diagnostics.EventLogEntryType> para especificar o ícone exibido do Visualizador de eventos para a entrada.  
  
-   Você pode especificar um identificador de categoria de evento, se seu aplicativo usa categorias para filtrar os eventos.  
  
-   Você pode anexar dados binários a sua inscrição de evento, se você quiser associar informações adicionais um determinado evento.  
  
> [!IMPORTANT]
>  O log de eventos consome espaço em disco, o tempo do processador e outros recursos do sistema. É importante fazer logon somente informações essenciais. É recomendável que você coloque chamadas de log de eventos em um caminho de erro, em vez de no caminho do código principal, portanto, eles não afetarem negativamente o desempenho.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>, consulte o <xref:System.Diagnostics.EventLog.%23ctor%2A> construtor.  
  
   
  
## Examples  
 O exemplo a seguir cria a origem do evento `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
> [!NOTE]
>  Começando com o Windows Vista, você deve executar esse aplicativo como administrador.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.EventLog" />. Não associe a instância a nenhum log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A> propriedade do <xref:System.Diagnostics.EventLog> instância. Se você só estiver lendo <xref:System.Diagnostics.EventLog.Entries%2A> do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades.  
  
> [!NOTE]
>  Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (".") é assumido.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Uma cadeia de caracteres vazia ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Uma cadeia de caracteres vazia ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|O computador local (".").|  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log no computador local.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.EventLog" />. Associa a instância a log no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga define o <xref:System.Diagnostics.EventLog.Log%2A> propriedade para o `logName` parâmetro. Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A> propriedade do <xref:System.Diagnostics.EventLog> instância. Se você só estiver lendo <xref:System.Diagnostics.EventLog.Entries%2A> do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades.  
  
> [!NOTE]
>  Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (".") é assumido. Essa sobrecarga do construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A> propriedade, mas você pode alterar isso antes de ler o <xref:System.Diagnostics.EventLog.Entries%2A> propriedade.  
  
 Se a fonte que você especificar na <xref:System.Diagnostics.EventLog.Source%2A> propriedade é exclusiva de outras fontes no computador, uma chamada subsequente para <xref:System.Diagnostics.EventLog.WriteEntry%2A> cria um log com o nome especificado, se ele ainda não existir.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Uma cadeia de caracteres vazia ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|O parâmetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|O computador local (".").|  
  
   
  
## Examples  
 O exemplo a seguir lê as entradas no log de eventos, "myNewLog", no computador local.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O nome do log é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do log é inválido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log no computador especificado.</param>
        <param name="machineName">O computador no qual o log existe.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.EventLog" />. Associa a instância a um log no computador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga define o <xref:System.Diagnostics.EventLog.Log%2A> propriedade para o `logName` parâmetro e o <xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para o `machineName` parâmetro. Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A> propriedade do <xref:System.Diagnostics.EventLog>. Se você só estiver lendo <xref:System.Diagnostics.EventLog.Entries%2A> do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades.  
  
> [!NOTE]
>  Essa sobrecarga do construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades, mas você pode alterar qualquer uma antes de ler o <xref:System.Diagnostics.EventLog.Entries%2A> propriedade.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Uma cadeia de caracteres vazia ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|O parâmetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|O parâmetro `machineName`.|  
  
   
  
## Examples  
 O exemplo a seguir lê as entradas no log de eventos, "myNewLog", no computador "meuservidor".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O nome do log é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do log é inválido.  
  
- ou - 
O nome do computador é inválido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log no computador especificado</param>
        <param name="machineName">O computador no qual o log existe.</param>
        <param name="source">A origem das entradas de log de eventos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.EventLog" />. Associa a instância a um log no computador especificado e cria ou atribui a origem indicada para o <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor define a <xref:System.Diagnostics.EventLog.Log%2A> propriedade para o `logName` parâmetro, o <xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para o `machineName` parâmetro e o <xref:System.Diagnostics.EventLog.Source%2A> propriedade para o `source` parâmetro. O <xref:System.Diagnostics.EventLog.Source%2A> propriedade é necessária ao gravar em um log de eventos. No entanto, se você estiver lendo apenas de um log de eventos, apenas o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades são necessárias (desde que o log de eventos no servidor tem uma fonte que já está associada a ele). Se você estiver lendo apenas do log de eventos, outra sobrecarga do construtor deve ser suficiente.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|O parâmetro `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|O parâmetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|O parâmetro `machineName`.|  
  
   
  
## Examples  
 O exemplo a seguir grava uma entrada para um log de eventos "MyNewLog" no computador local, usando a fonte "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O nome do log é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do log é inválido.  
  
- ou - 
O nome do computador é inválido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a inicialização de um <see cref="T:System.Diagnostics.EventLog" /> usado em um formulário ou por outro componente. A inicialização ocorre em tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente usa esse método para iniciar a inicialização de um componente usado em um formulário ou por outro componente de design. O <xref:System.Diagnostics.EventLog.EndInit%2A> método encerra a inicialização. Usando o <xref:System.Diagnostics.EventLog.BeginInit%2A> e <xref:System.Diagnostics.EventLog.EndInit%2A> métodos impedir que o controle que está sendo usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> já foi inicializado.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todas as entradas do log de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Logs de eventos são definidos com um tamanho máximo que determina quantas entradas podem conter. Quando um log de eventos estiver cheio, ele interrompe a gravação de novas informações de evento ou começa a substituir entradas anteriores. Se parar a gravação de eventos, você pode usar esse método para limpar o log de entradas existentes e permitir que ele inicie novamente o registro de eventos. Você deve ter permissões de administrador no computador no qual o log reside para limpar entradas de log de eventos.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> Fecha o log de eventos, libera os identificadores de eventos, recupera a nova leitura e gravação de identificadores e reabrir o log de eventos. Eventos recebidos após a chamada para o método não são removidos, juntamente com os eventos existentes.  
  
   
  
## Examples  
 O exemplo a seguir limpa um log de eventos.  
  
> [!CAUTION]
>  Porque o aplicativo, sistema, segurança e outros logs não personalizado podem conter informações cruciais; Certifique-se de especificar um log personalizado antes de executar esse código de exemplo. Este exemplo exclui o log personalizado `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível limpar o log de eventos.  
  
- ou - 
Não é possível abrir o log. Um código de erro do Windows não está disponível.</exception>
        <exception cref="T:System.ArgumentException">Não há valor especificado para a propriedade <see cref="P:System.Diagnostics.EventLog.Log" />. Verifique se que o nome do log não é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.InvalidOperationException">Log inexistente.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o log de eventos e libera os identificadores de leitura e gravação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.EventLog.Close%2A> método é chamado pelo protegido <xref:System.ComponentModel.Component.Dispose%2A> método. Você não precisa invocar <xref:System.Diagnostics.EventLog.Close%2A> antes de chamar <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">O identificador de leitura ou de gravação do log de evento não foi liberado com êxito.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Estabelece um aplicativo como capaz de gravar informações de evento em um log específico no sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">As propriedades de configuração para a origem do evento e seu log de eventos de destino.</param>
        <summary>Estabelece uma origem do evento válido para a gravação de mensagens de evento localizadas, usando as propriedades de configuração especificadas para a origem do evento e o log de eventos correspondente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para configurar uma nova fonte para gravar entradas em um log de eventos no computador local ou em um computador remoto. Não é necessário usar esse método para ler de um log de eventos.  
  
 O <xref:System.Diagnostics.EventLog.CreateEventSource%2A> usa o método de entrada `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> e <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> as propriedades para criar valores do registro no computador de destino para a nova fonte e seu log de eventos associado. Um novo nome de origem não pode corresponder a um nome de origem existente ou um nome de log de eventos existente no computador de destino. Se o <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> não está definida, a origem é registrada para o log de eventos do aplicativo. Se o <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> não for definido, a fonte é registrada no computador local.  
  
> [!NOTE]
>  Para criar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter privilégios administrativos.  
>   
>  O motivo para esse requisito é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não têm permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
>   
>  Começando com o Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> para gravar eventos em um log de eventos. Você deve especificar uma origem de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Você pode criar uma fonte de evento para um log de eventos existente ou um novo log de eventos. Quando você cria uma nova origem para um novo log de eventos, o sistema registra a origem para que o log, mas o log não é criado até que a primeira entrada seja gravada nele.  
  
 O sistema operacional armazena os logs de eventos como arquivos. Quando você usa <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para criar um novo log de eventos, o arquivo associado é armazenado no diretório %SystemRoot%\System32\Config no computador especificado. O nome do arquivo é definido por meio do acréscimo 8 primeiros caracteres da <xref:System.Diagnostics.EventLog.Log%2A> propriedade com a extensão de nome de arquivo ". evt".  
  
 Cada fonte pode gravar apenas em apenas um log de eventos ao mesmo tempo; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, seu aplicativo pode exigir várias fontes, configurados para arquivos de recurso diferente ou logs de eventos diferentes.  
  
 Você pode registrar a origem do evento com os arquivos de recurso localizado para suas cadeias de caracteres de categoria e mensagem de evento. Seu aplicativo pode gravar entradas de log de eventos usando identificadores de recurso, em vez de especificar a cadeia de caracteres real. O Visualizador de eventos usa o identificador de recurso para localizar e exibir a cadeia de caracteres correspondente do arquivo de recurso localizada com base nas configurações de idioma atual. Você pode registrar um arquivo separado para categorias de evento, mensagens e cadeias de caracteres de inserção de parâmetro, ou você pode registrar o mesmo arquivo de recurso para todos os três tipos de cadeias de caracteres. Use o <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, e <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> propriedades para configurar a fonte para gravar entradas localizadas para o log de eventos. Se seu aplicativo grava os valores de cadeias de caracteres diretamente ao log de eventos, você precisa definir essas propriedades.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
 Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam o código-fonte existente, crie uma nova fonte com a configuração atualizada, em vez de excluir o código-fonte existente.  
  
> [!NOTE]
>  Se uma fonte é configurada para um log de eventos e reconfigurá-lo para outro log de eventos, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir determina se a origem do evento nomeado `SampleApplicationSource` está registrado no computador local. Se a origem do evento não existir, o exemplo define o arquivo de recurso de mensagem para a fonte e cria a nova origem do evento. Por fim, o exemplo define o nome de exibição localizado para o log de eventos, usando o valor do identificador de recurso de `DisplayNameMsgId` e o caminho do arquivo de recurso no `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro. Especificamente, o identificador de recurso 5001 é definido para o nome localizado do log de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do computador especificado em <paramref name="sourceData" /> não é válido.  
  
- ou - 
O nome da origem especificado em <paramref name="sourceData" /> é <see langword="null" />.  
  
- ou - 
O nome do log especificado em <paramref name="sourceData" /> não é válido. Os nomes de log de eventos precisam serem compostos por caracteres imprimíveis e não podem incluir os caracteres “*”, “?” ou “\\”.  
  
- ou - 
O nome do log especificado em <paramref name="sourceData" /> não é válido para a criação de log do usuário. Os nomes de log de eventos AppEvent, SysEvent e SecEvent são reservados para uso do sistema.  
  
- ou - 
O nome do log corresponde a um nome de origem de evento existente.  
  
- ou - 
O nome da origem especificado no <paramref name="sourceData" /> resulta em um caminho de chave do Registro com mais de 254 caracteres.  
  
- ou - 
Os primeiros oito caracteres do nome do log especificado em <paramref name="sourceData" /> não são exclusivos.  
  
- ou - 
O nome da origem especificado em <paramref name="sourceData" /> já está registrado.  
  
- ou - 
O nome de origem especificado no <paramref name="sourceData" /> corresponde a um nome de log de eventos existente.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome de origem com o qual o aplicativo está registrado no computador local.</param>
        <param name="logName">O nome do log no qual as entradas da fonte são gravadas. Os valores possíveis incluem Aplicativo, Sistema ou um log de eventos personalizado.</param>
        <summary>Estabelece o nome de origem especificado como uma origem de evento válida para gravar entradas em um log no computador local. Esse método também pode criar um novo log personalizado no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um log personalizado ou para criar e registrar um <xref:System.Diagnostics.EventLog.Source%2A> em um log existente no computador local.  
  
 Se `logName` está `null` ou uma cadeia de caracteres vazia ("") quando você chama <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, o log padrão é o log de aplicativo. Se o log não existe no computador local, o sistema cria um log personalizado e registra seu aplicativo como um <xref:System.Diagnostics.EventLog.Source%2A> para que o log.  
  
> [!NOTE]
>  Para criar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter privilégios administrativos.  
>   
>  O motivo para esse requisito é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não têm permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
>   
>  No Windows Vista e posterior, UAC (Controle de Conta de Usuário) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Você só precisa criar uma fonte de evento, se você estiver gravando no log de eventos. Antes de gravar uma entrada para um log de eventos, você deve registrar a origem do evento no log de eventos como uma origem válida de eventos. Quando você grava uma entrada de log, o sistema usa o <xref:System.Diagnostics.EventLog.Source%2A> para localizar o log adequado no qual colocar sua entrada. Se você estiver lendo o log de eventos, você pode especificar o <xref:System.Diagnostics.EventLog.Source%2A>, ou uma <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Não é necessário especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> se você estiver se conectando a um log no computador local. Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> ao ler de um log, o computador local (".") é assumido.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> para gravar eventos em um log de eventos. Você deve especificar uma origem de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Você pode criar uma fonte de evento para um log de eventos existente ou um novo log de eventos. Quando você cria uma nova origem para um novo log de eventos, o sistema registra a origem para que o log, mas o log não é criado até que a primeira entrada seja gravada nele.  
  
 O sistema operacional armazena os logs de eventos como arquivos. Quando você usa <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para criar um novo log de eventos, o arquivo associado é armazenado no diretório %SystemRoot%\System32\Config no computador especificado. O nome do arquivo é definido por meio do acréscimo 8 primeiros caracteres da <xref:System.Diagnostics.EventLog.Log%2A> propriedade com a extensão de nome de arquivo ". evt".  
  
 A origem deve ser exclusiva no computador local; um novo nome de origem não pode corresponder a um nome de origem existente ou um nome de log de eventos existente. Cada fonte pode gravar apenas um log de eventos ao mesmo tempo; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, seu aplicativo pode exigir várias fontes, configurados para arquivos de recurso diferente ou logs de eventos diferentes.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
 Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam o código-fonte existente, crie uma nova fonte com a configuração atualizada, em vez de excluir o código-fonte existente.  
  
> [!NOTE]
>  Se uma fonte já tiver sido mapeada para um log e remapeá-la para um novo log, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> é uma cadeia de caracteres vazia ("") ou <see langword="null" />.  
  
- ou - 
 <paramref name="logName" /> não é um nome válido de log de eventos. Os nomes de log de eventos devem conter caracteres imprimíveis e não podem incluir os caracteres “*”, “?” ou “\\”.  
  
- ou - 
 <paramref name="logName" /> não é válido para a criação de log de usuário. Os nomes de log de eventos AppEvent, SysEvent e SecEvent são reservados para uso do sistema.  
  
- ou - 
O nome do log corresponde a um nome de origem de evento existente.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.  
  
- ou - 
Os 8 primeiros caracteres de <paramref name="logName" /> correspondem aos 8 primeiros caracteres de um log de eventos existente.  
  
- ou - 
A fonte não pode ser registrada porque já existe no computador local.  
  
- ou - 
O nome de origem corresponde a um nome de log de eventos existente.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro do log de eventos no computador local.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="logName">O nome do log no qual as entradas da fonte são gravadas. Os valores possíveis incluem Aplicativo, Sistema ou um log de eventos personalizado. Se você não especificar um valor, <paramref name="logName" /> o definirá com o padrão Aplicativo.</param>
        <param name="machineName">O nome do computador que registrará essa origem de evento ou "." para o computador local.</param>
        <summary>Estabelece o nome de origem especificado como uma origem de evento válida para gravar entradas em um log no computador especificado. Também é possível usar esse método para criar um novo log personalizado no computador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um log personalizado ou para criar e registrar um <xref:System.Diagnostics.EventLog.Source%2A> em um log existente no computador especificado.  
  
 Se `logName` está `null` ou uma cadeia de caracteres vazia ("") quando você chama <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, o log padrão é o log de aplicativo. Se o log não existe no computador especificado, o sistema cria um log personalizado e registra seu aplicativo como um <xref:System.Diagnostics.EventLog.Source%2A> para que o log.  
  
 Você só precisa criar uma fonte de evento, se você estiver gravando no log de eventos. Antes de gravar uma entrada para um log de eventos, você deve registrar a origem do evento no log de eventos como uma origem válida de eventos. Quando você grava uma entrada de log, o sistema usa o <xref:System.Diagnostics.EventLog.Source%2A> para localizar o log adequado no qual colocar sua entrada. Se você estiver lendo o log de eventos, você pode especificar o <xref:System.Diagnostics.EventLog.Source%2A>, ou uma <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Para criar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter privilégios administrativos.  
>   
>  O motivo para esse requisito é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. No Windows Vista e versões posteriores, os usuários não tem permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
>   
>  No Windows Vista e posterior, UAC (Controle de Conta de Usuário) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> para gravar eventos em um log de eventos. Você deve especificar uma origem de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Você pode criar uma fonte de evento para um log de eventos existente ou um novo log de eventos. Quando você cria uma nova origem para um novo log de eventos, o sistema registra a origem para que o log, mas o log não é criado até que a primeira entrada seja gravada nele.  
  
 O sistema operacional armazena os logs de eventos como arquivos. Quando você usa <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para criar um novo log de eventos, o arquivo associado é armazenado no diretório %SystemRoot%\System32\Config no computador especificado. O nome do arquivo é definido por meio do acréscimo 8 primeiros caracteres da <xref:System.Diagnostics.EventLog.Log%2A> propriedade com a extensão de nome de arquivo ". evt".  
  
 A origem deve ser exclusiva no computador local; um novo nome de origem não pode corresponder a um nome de origem existente ou um nome de log de eventos existente. Cada fonte pode gravar apenas um log de eventos ao mesmo tempo; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, seu aplicativo pode exigir várias fontes, configurados para arquivos de recurso diferente ou logs de eventos diferentes.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
 Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam o código-fonte existente, crie uma nova fonte com a configuração atualizada, em vez de excluir o código-fonte existente.  
  
> [!NOTE]
>  Se uma fonte já tiver sido mapeada para um log e remapeá-la para um novo log, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` no computador `MyServer`e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> não é um nome do computador válido.  
  
- ou - 
 <paramref name="source" /> é uma cadeia de caracteres vazia ("") ou <see langword="null" />.  
  
- ou - 
 <paramref name="logName" /> não é um nome válido de log de eventos. Os nomes de log de eventos devem conter caracteres imprimíveis e não podem incluir os caracteres “*”, “?” ou “\\”.  
  
- ou - 
 <paramref name="logName" /> não é válido para a criação de log de usuário. Os nomes de log de eventos AppEvent, SysEvent e SecEvent são reservados para uso do sistema.  
  
- ou - 
O nome do log corresponde a um nome de origem de evento existente.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.  
  
- ou - 
Os oito primeiros caracteres de <paramref name="logName" /> correspondem aos oito primeiros caracteres de um log de eventos existente no computador especificado.  
  
- ou - 
A origem não pode ser registrada porque já existe no computador especificado.  
  
- ou - 
O nome da origem corresponde a um nome de origem de evento existente.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro do log de eventos no computador especificado.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove um recurso de log.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log a ser excluído. Os possíveis valores incluem: Aplicativo, Segurança, Sistema e todos os outros logs de eventos personalizados no computador.</param>
        <summary>Remove um log de eventos do computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando o log que deseja excluir está no computador local. Você pode excluir qualquer log no computador, desde que você tenha as permissões de registro apropriadas.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Remove o log especificado pelo `logName` do computador local. Se você quiser excluir apenas a fonte é registrado em um log, chame <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> são `static` métodos, portanto, eles podem ser chamados na classe em si. Não é necessário criar uma nova instância da <xref:System.Diagnostics.EventLog> para chamar qualquer um dos métodos.  
  
 O <xref:System.Diagnostics.EventLog.Delete%2A> método primeiro exclui o arquivo que contém o conteúdo do log. Em seguida, ele acessa o registro e remove todas as fontes de evento registradas para que o log. Se você recriar o log em um momento posterior, você deve registrar as fontes de evento novamente, se eles devem ser reutilizado. Se você não registrar as fontes de evento e outros usuários de gravação a uma fonte de evento sem especificar um nome de log, a origem do evento será criada no log de eventos do aplicativo. Portanto, os aplicativos que anteriormente eram capazes de gravar entradas no log que você excluiu e recriou gravará no log de aplicativo em vez disso, porque agora ele contém a origem do evento.  
  
> [!NOTE]
>  Recriar um log de eventos pode ser um processo difícil. Evite a exclusão de qualquer um dos logs de eventos criado pelo sistema, como o log de aplicativo.  
  
 Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A> exclui automaticamente fontes registradas nesse log. Isso pode tornar a outros aplicativos que usam esse log inoperante.  
  
   
  
## Examples  
 O exemplo a seguir exclui um log do computador local. O exemplo determina o log de sua origem.  
  
> [!NOTE]
>  Mais de uma fonte pode gravar um log de eventos. Antes de excluir um log personalizado, verifique se há não há outras fontes de gravação nesse log.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> é uma cadeia de caracteres vazia ("") ou <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro do log de eventos no computador local.  
  
- ou - 
O log não existe no computador local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível limpar o log de eventos.  
  
- ou - 
Não é possível abrir o log. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log a ser excluído. Os possíveis valores incluem: Aplicativo, Segurança, Sistema e todos os outros logs de eventos personalizados no computador especificado.</param>
        <param name="machineName">O nome do computador a ser excluído do log ou "." para o computador local.</param>
        <summary>Remove um log de eventos do computador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando o log que deseja excluir está em um computador remoto. Você pode excluir qualquer log no computador, desde que você tenha as permissões de registro apropriadas.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Remove o log especificado pelo `logName` do computador especificado pelo `machineName`. Se você quiser excluir apenas a fonte é registrado em um log, chame <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> são `static` métodos, portanto, eles podem ser chamados na classe em si. Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog> para chamar qualquer um dos métodos.  
  
 Esse método primeiro exclui o arquivo que contém o conteúdo do log. Em seguida, ele acessa o registro e remove todas as fontes de evento registradas para que o log. Se você recriar o log em um momento posterior, você deve registrar as fontes de evento novamente, se eles devem ser reutilizado. Se você não registrar as fontes de evento e outros usuários de gravação a uma fonte de evento sem especificar um nome de log, a origem do evento será criada no log de eventos do aplicativo. Portanto, os aplicativos que anteriormente eram capazes de gravar entradas no log que você excluiu e recriou gravará no log de aplicativo em vez disso, porque agora ele contém a origem do evento.  
  
> [!NOTE]
>  Recriar um log de eventos pode ser um processo difícil. Evite a exclusão de qualquer um dos logs de eventos criado pelo sistema, como o log de aplicativo.  
  
 Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A> exclui automaticamente fontes registradas nesse log. Isso pode tornar a outros aplicativos que usam esse log inoperante.  
  
   
  
## Examples  
 O exemplo a seguir exclui um log do computador especificado. O exemplo determina o log de sua origem.  
  
> [!NOTE]
>  Mais de uma fonte pode gravar um log de eventos. Antes de excluir um log personalizado, verifique se há não há outras fontes de gravação nesse log.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> é uma cadeia de caracteres vazia ("") ou <see langword="null" />.  
  
- ou - 
 <paramref name="machineName" /> não é um nome do computador válido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro do log de eventos no computador especificado.  
  
- ou - 
O log não existe no computador especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível limpar o log de eventos.  
  
- ou - 
Não é possível abrir o log. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove o registro da origem do evento de um aplicativo do log de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome pelo qual o aplicativo está registrado no sistema de log de eventos.</param>
        <summary>Remove o registro da origem do evento do log de eventos do computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para remover o registro de um <xref:System.Diagnostics.EventLog.Source%2A> do computador local. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> acessa o registro no computador local e remove o registro do seu aplicativo como uma origem válida de eventos.  
  
 Você pode remover seu componente como uma origem válida de eventos se você não precisa gravar entradas nesse log. Por exemplo, você pode fazer isso se você precisar alterar seu componente de um log para outro. Como uma origem só pode ser registrada para um log cada vez, alterar o log exige que você remover o registro atual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Remove somente a fonte registrada em um log. Se você quiser remover o log em si, chame <xref:System.Diagnostics.EventLog.Delete%2A>. Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> são `static` métodos, portanto, eles podem ser chamados na classe em si. Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog> para chamar qualquer um dos métodos.  
  
 Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A> exclui automaticamente fontes registradas nesse log. Isso pode tornar a outros aplicativos que usam esse log inoperante.  
  
> [!NOTE]
>  Se uma fonte já tiver sido mapeada para um log e remapeá-la para um novo log, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir exclui uma fonte do computador local. O exemplo determina o log de sua origem e, em seguida, exclui o log.  
  
> [!NOTE]
>  Mais de uma fonte pode gravar um log de eventos. Antes de excluir um log personalizado, verifique se há não há outras fontes de gravação nesse log.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="source" /> não existe no Registro do computador local.  
  
- ou - 
Você não tem acesso para gravação na chave do Registro para o log de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome pelo qual o aplicativo está registrado no sistema de log de eventos.</param>
        <param name="machineName">O nome do computador do qual remover o registro ou "." para o computador local.</param>
        <summary>Remove o registro da fonte de eventos do aplicativo do computador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para remover o registro de um <xref:System.Diagnostics.EventLog.Source%2A> de um computador remoto. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> acessa o registro no computador especificado pelo `machineName` e remove o registro do seu aplicativo como uma origem válida de eventos.  
  
 Você pode remover seu componente como uma origem válida de eventos se você não precisa gravar entradas nesse log. Por exemplo, você pode fazer isso se você precisar alterar seu componente de um log para outro. Como uma origem só pode ser registrada para um log cada vez, alterar o log exige que você remover o registro atual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Remove somente a fonte registrada em um log. Se você quiser remover o log em si, chame <xref:System.Diagnostics.EventLog.Delete%2A>. Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> são `static` métodos, portanto, eles podem ser chamados na classe em si. Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog> para chamar qualquer um dos métodos.  
  
 Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A> exclui automaticamente fontes registradas nesse log. Isso pode tornar a outros aplicativos que usam esse log inoperante.  
  
> [!NOTE]
>  Se uma fonte já tiver sido mapeada para um log e remapeá-la para um novo log, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir exclui uma fonte do computador especificado. O exemplo determina o log de sua origem e, em seguida, exclui o log.  
  
> [!NOTE]
>  Mais de uma fonte pode gravar um log de eventos. Antes de excluir um log personalizado, verifique se há não há outras fontes de gravação nesse log.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> é inválido.  
  
- ou - 
O parâmetro <paramref name="source" /> não existe no Registro do computador especificado.  
  
- ou - 
Você não tem acesso para gravação na chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> não pode ser excluída porque no Registro, a chave do Registro pai para <paramref name="source" /> não contém uma subchave com o mesmo nome.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Diagnostics.EventLog" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método <xref:System.Object.Finalize%2A>. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro for true, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Diagnostics.EventLog> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" /> tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Diagnostics.EventLog" /> recebe notificações do evento <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value><see langword="true" /> se o <see cref="T:System.Diagnostics.EventLog" /> receber uma notificação quando uma entrada for escrita no log; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> propriedade determina se o <xref:System.Diagnostics.EventLog> gera eventos quando as entradas são gravadas no log. Quando a propriedade é `true`, componentes que recebem a <xref:System.Diagnostics.EventLog.EntryWritten> evento receberão a notificação sempre que uma entrada é gravada no log especificado no <xref:System.Diagnostics.EventLog.Log%2A> propriedade. Se <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> é `false`, nenhum evento é gerado.  
  
> [!NOTE]
>  Você pode receber notificações de eventos somente quando as entradas são gravadas no computador local. Você não pode receber notificações para entradas gravadas em computadores remotos.  
  
   
  
## Examples  
 A exemplo a seguir identifica um <xref:System.Diagnostics.EventLog.EntryWritten> eventos.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O log do evento está em um computador remoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra a inicialização de um <see cref="T:System.Diagnostics.EventLog" /> usado em um formulário ou por outro componente. A inicialização ocorre em tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente usa esse método para terminar a inicialização de um componente usado em um formulário ou por outro componente de design. O <xref:System.Diagnostics.EventLog.BeginInit%2A> método começa a inicialização. Usando o <xref:System.Diagnostics.EventLog.BeginInit%2A> e <xref:System.Diagnostics.EventLog.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o conteúdo do log de eventos.</summary>
        <value>Um <see cref="T:System.Diagnostics.EventLogEntryCollection" /> que contém as entradas no log de eventos. Cada entrada é associada a uma instância da classe <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Diagnostics.EventLog.Entries%2A> membro durante a leitura do log de eventos.  
  
 Como a propriedade é somente leitura, você não pode modificar uma entrada ou gravar no log usando <xref:System.Diagnostics.EventLog.Entries%2A>. Em vez disso, especifique um <xref:System.Diagnostics.EventLog.Source%2A> e chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A> para gravar uma nova entrada de log. Você pode usar <xref:System.Diagnostics.EventLog.Entries%2A> para contar o número de entradas no log de eventos e exibir cada <xref:System.Diagnostics.EventLogEntry> na coleção. Use o indexada <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> membro para recuperar informações sobre uma entrada específica, como <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, ou <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Não é necessário especificar um <xref:System.Diagnostics.EventLog.Source%2A> quando somente leitura de um log. Você pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> nome e <xref:System.Diagnostics.EventLog.MachineName%2A> propriedades de (nome de computador do servidor) para o <xref:System.Diagnostics.EventLog> instância. Em ambos os casos, o <xref:System.Diagnostics.EventLog.Entries%2A> membro é preenchido automaticamente com a lista de eventos do log de entradas. Você pode selecionar o índice apropriado para um item nessa lista para ler as entradas individuais.  
  
 Uma importante distinção entre leitura e gravação de entradas de log é que não é necessário chamar explicitamente um método read. Após o <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> forem especificados, o <xref:System.Diagnostics.EventLog.Entries%2A> propriedade é preenchida automaticamente. Se você alterar o valor da <xref:System.Diagnostics.EventLog.Log%2A> ou <xref:System.Diagnostics.EventLog.MachineName%2A> propriedade, o <xref:System.Diagnostics.EventLog.Entries%2A> propriedade é preenchida novamente na próxima vez que você lê-lo.  
  
> [!NOTE]
>  Não é necessário especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> se você estiver se conectando a um log. Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local, ".", será assumido.  
  
   
  
## Examples  
 O exemplo a seguir lê as entradas no log de eventos, "MyNewLog" no computador local.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma entrada é gravada em um log de eventos no computador local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter notificações de eventos, você deve definir <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> para `true`. Você só pode receber notificações de eventos quando as entradas são gravadas no computador local. Você não pode receber notificações para entradas gravadas em computadores remotos.  
  
 Quando você cria um <xref:System.Diagnostics.EventLog.EntryWritten> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do delegado ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, até que você remova o delegado. Para obter mais informações sobre como manipular eventos com delegados, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 O sistema responde a <xref:System.Diagnostics.EventLog.WriteEntry%2A> somente se o último evento de gravação ocorreu pelo menos seis segundos anteriormente. Isso significa que você só receberá um <xref:System.Diagnostics.EventLog.EntryWritten> notificação de eventos dentro de um intervalo de seis segundos, mesmo se mais de um evento de alteração de log ocorre. Se você inserir um intervalo de suspensão suficientemente longa (cerca de 10 segundos) entre as chamadas para <xref:System.Diagnostics.EventLog.WriteEntry%2A>, é menos prováveis de perder um evento. No entanto, se os eventos de gravação ocorrem com mais frequência, você pode não receber a notificação de eventos até o próximo intervalo. Normalmente, as notificações de eventos ausentes não são perdidas, mas atrasadas.  
  
   
  
## Examples  
 O exemplo a seguir lida com uma entrada de evento de gravação.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o log especificado existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O nome do log a ser pesquisado. Os possíveis valores incluem: Aplicativo, Segurança, Sistema, outros logs específicos do aplicativo (como aqueles associados ao Active Directory) ou qualquer log personalizado no computador.</param>
        <summary>Determina se o log existe no computador local.</summary>
        <returns><see langword="true" /> se o log existir no computador local; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se um log existe no computador local. Se você deseja determinar se existe uma fonte no computador local, use <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador local; Caso contrário, a consulta retorna `false`.  
  
 Porque você não pode dar um novo log o nome de um log existente no mesmo computador, use esse método antes de criar um novo log para determinar se especificado `logName` já existe no computador local. O `logName` parâmetro não diferencia maiusculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> é um `static` método, ele pode ser chamado na classe em si. Não é necessário criar uma instância do <xref:System.Diagnostics.EventLog> chamar <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O logName é <see langword="null" /> ou o valor está vazio.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">O log pelo qual pesquisar. Os possíveis valores incluem: Aplicativo, Segurança, Sistema, outros logs específicos do aplicativo (como aqueles associados ao Active Directory) ou qualquer log personalizado no computador.</param>
        <param name="machineName">O nome do computador no qual pesquisar pelo log ou "." para o computador local.</param>
        <summary>Determina se o log existe no computador especificado.</summary>
        <returns><see langword="true" /> se o log existir no computador especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se existe um log em um computador remoto. Se você deseja determinar se existe uma fonte em um computador remoto, use <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador especificado. Caso contrário, a consulta retorna `false`.  
  
 Porque você não pode dar um novo log o nome de um log existente no mesmo computador, use esse método antes de criar um novo log para determinar se um com a especificada `logName` já existe no servidor especificado pelo `machineName` parâmetro. O `logName` e `machineName` parâmetros não diferenciam maiusculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> é um `static` método, ele pode ser chamado na classe em si. Não é necessário criar uma nova instância da <xref:System.Diagnostics.EventLog> chamar <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> está em um formato inválido. Verifique se que você usou a sintaxe apropriada para o computador no qual você está pesquisando.  
  
- ou - 
O <paramref name="logName" /> é <see langword="null" /> ou o valor está vazio.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma matriz dos logs de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pesquisa todos os logs de eventos em um computador local e cria uma matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contêm a lista.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.EventLog" /> que representa os logs no computador local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz de <xref:System.Diagnostics.EventLog> objetos é um instantâneo de todos os logs de eventos no computador local quando a chamada para <xref:System.Diagnostics.EventLog.GetEventLogs%2A> é feita. Isso não é uma coleção dinâmica, portanto, ele não reflete a exclusão ou a criação de logs em tempo real. Você deve verificar se um log na matriz existe antes de ler ou gravar nele. A matriz geralmente inclui pelo menos três logs: Aplicativo, sistema e segurança. Se você criou logs personalizados no computador local, eles serão exibidos na matriz também.  
  
 Para recuperar a lista de logs de eventos, você deve ter as permissões de registro apropriadas. Essas permissões são idênticas àquelas necessárias para chamar <xref:System.Diagnostics.EventLog.Exists%2A> e <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 O exemplo a seguir enumera os logs de evento definidos no computador local e exibe os detalhes de configuração para cada log de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Você não tem acesso de leitura ao Registro.  
  
- ou - 
Não há nenhum serviço de log de eventos no computador.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O computador no qual os logs de eventos serão pesquisados.</param>
        <summary>Pesquisa todos os logs de eventos em determinado computador e cria uma matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contêm a lista.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.EventLog" /> que representa os logs em determinado computador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz de <xref:System.Diagnostics.EventLog> objetos é um instantâneo de todos os logs de eventos no computador especificado o `machineName` parâmetro quando a chamada para <xref:System.Diagnostics.EventLog.GetEventLogs%2A> é feita. Isso não é uma coleção dinâmica, portanto, ele não reflete a exclusão ou a criação de logs em tempo real. Você deve verificar se um log na matriz existe antes de ler ou gravar nele. A matriz geralmente inclui pelo menos três logs: Aplicativo, sistema e segurança. Se você criou logs personalizados no computador especificado, eles serão exibidos na matriz também.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> é um `static` método, ele pode ser chamado no <xref:System.Diagnostics.EventLog> própria classe. Não é necessário criar uma instância de um <xref:System.Diagnostics.EventLog> objeto para fazer uma chamada ao método.  
  
 Para recuperar a lista de logs de eventos, você deve ter as permissões de registro apropriadas. Essas permissões são idênticas àquelas necessárias para chamar <xref:System.Diagnostics.EventLog.Exists%2A> e <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma lista dos logs no computador "meuservidor". Em seguida, ele gera o nome de cada log.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> é um nome do computador inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Você não tem acesso de leitura ao Registro.  
  
- ou - 
Não há nenhum serviço de log de eventos no computador.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do log a ser lido ou gravado.</summary>
        <value>O nome do log. Pode ser o log de Aplicativo, Sistema, Segurança ou um nome de log personalizado. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existem três arquivos de log por padrão no servidor: Aplicativo, sistema e segurança. Aplicativos e serviços usam o arquivo de log do aplicativo. Drivers de dispositivo usam o arquivo de log do sistema. O sistema gera eventos de auditoria de êxito e falha no log de segurança quando a auditoria está ativada. Se você tiver outros aplicativos instalados, como o Active Directory em servidores Windows, pode haver outros arquivos de log padrão. Além disso, você pode criar arquivos de log personalizado em um computador local ou remoto. Logs personalizados ajudam a organizar suas entradas em uma forma mais detalhada do que é permitido quando seus componentes gravar eventos no log de aplicativo padrão.  
  
> [!NOTE]
>  Nomes de log são limitados a oito caracteres. De acordo com o sistema, MyLogSample1 e MyLogSample2 são do mesmo log.  
  
 Se você gravar um log de eventos, não é suficiente especificar o <xref:System.Diagnostics.EventLog.Log%2A> propriedade. Você deve associar um <xref:System.Diagnostics.EventLog.Source%2A> propriedade com o recurso de log de eventos para conectá-lo em um log específico. Não é necessário especificar um <xref:System.Diagnostics.EventLog.Source%2A> quando lendo apenas de um log, mas uma origem do evento deve ser associado com o recurso de log de eventos no registro do servidor. Você pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> nome e <xref:System.Diagnostics.EventLog.MachineName%2A> (nome do computador de servidor) para lê-lo.  
  
> [!NOTE]
>  Não é necessário especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> se você estiver se conectando a um log. Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (".") é assumido.  
  
 Se o <xref:System.Diagnostics.EventLog.Source%2A> propriedade não foi especificada, uma chamada para <xref:System.Diagnostics.EventLog.Log%2A> retorna uma cadeia de caracteres vazia se <xref:System.Diagnostics.EventLog.Log%2A> não tiver sido definido explicitamente (definindo o <xref:System.Diagnostics.EventLog.Log%2A> propriedade, ou por meio do construtor). Se o <xref:System.Diagnostics.EventLog.Source%2A> tiver sido especificada, <xref:System.Diagnostics.EventLog.Log%2A> retorna o nome do log em que essa fonte foi registrada.  
  
 Uma origem só pode ser registrada para um log cada vez. Se o <xref:System.Diagnostics.EventLog.Source%2A> propriedade foi definida para uma instância do <xref:System.Diagnostics.EventLog>, não é possível alterar o <xref:System.Diagnostics.EventLog.Log%2A> propriedade para fazer isso <xref:System.Diagnostics.EventLog> sem alterar o valor de <xref:System.Diagnostics.EventLog.Source%2A> ou chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primeiro. Se você alterar o <xref:System.Diagnostics.EventLog.Log%2A> propriedade após o <xref:System.Diagnostics.EventLog.Source%2A> propriedade tiver sido definida, escrever uma entrada de log gera uma exceção.  
  
 O sistema operacional armazena os logs de eventos como arquivos. Quando você usa <xref:System.Diagnostics.EventLogInstaller> ou <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para criar um novo log de eventos, o arquivo associado é armazenado no diretório %SystemRoot%\System32\Config no computador especificado. O nome do arquivo é definido por meio do acréscimo 8 primeiros caracteres da <xref:System.Diagnostics.EventLog.Log%2A> propriedade com a extensão de nome de arquivo ". evt".  
  
 Você não pode criar um novo log usando o <xref:System.Diagnostics.EventLog.Log%2A> propriedade sozinha (sem especificar uma origem para o log). Você pode chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passando um novo nome de log como um parâmetro e, em seguida, chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. No entanto, a intenção é geralmente criar (e gravar entradas) novos logs específicos do aplicativo, ou para ler de logs existentes.  
  
 Se o <xref:System.Diagnostics.EventLog.Log%2A> alterações de valor, o log de eventos é fechado e todos os identificadores de eventos são liberados.  
  
> [!CAUTION]
>  Se você definir a <xref:System.Diagnostics.EventLog.Log%2A> o sistema de propriedade para o nome de um log que não existe, anexa o <xref:System.Diagnostics.EventLog> no log de aplicativo, mas não avisa que ele está usando um log diferente daquele especificado por você.  
  
   
  
## Examples  
 O exemplo a seguir lê as entradas no log de eventos, "NewEventLog" no computador local.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome amigável do log de eventos.</summary>
        <value>Um nome que representa o log de eventos no Visualizador de Eventos do sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No Windows Vista e versões posteriores, os usuários não tem permissão para acessar o log de segurança. Se você estiver executando o Windows Vista ou posterior como um usuário, você obterá um <xref:System.Security.SecurityException> quando você tenta acessar o nome de exibição para um evento no log de segurança.  
>   
>  No Windows Vista e posterior, UAC (Controle de Conta de Usuário) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
   
  
## Examples  
 O exemplo a seguir enumera os logs de evento definidos no computador local e exibe o <xref:System.Diagnostics.EventLog.LogDisplayName%2A> para cada log de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="P:System.Diagnostics.EventLog.Log" /> especificado não existe no Registro deste computador.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">para a capacidade de ler a chave do Registro especificada. Enumeração associada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar a chave do Registro especificada caso ela seja uma chave remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome da origem do evento.</param>
        <param name="machineName">O nome do computador no qual procurar ou "." para o computador local.</param>
        <summary>Obtém o nome do log no qual a origem especificada é registrada.</summary>
        <returns>O nome do log associado à origem especificada no Registro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A origem do evento indica que o que registra o evento. Geralmente é o nome do aplicativo ou o nome de um subcomponente do aplicativo, se o aplicativo for grande. Aplicativos e serviços devem gravar no log do aplicativo ou um log personalizado. Drivers de dispositivo devem gravar no log do sistema.  
  
 Quando você cria uma nova origem, que pode gravar apenas em um log cada vez, o sistema registra seu aplicativo com o log de eventos como uma fonte válida de entradas. O <xref:System.Diagnostics.EventLog.Source%2A> propriedade pode ser qualquer cadeia de caracteres, mas o nome não pode ser usado por outras fontes no computador. Uma tentativa de criar um duplicado <xref:System.Diagnostics.EventLog.Source%2A> valor lança uma exceção. No entanto, um único log de eventos pode ter várias fontes diferentes, gravando a ele.  
  
   
  
## Examples  
 O exemplo a seguir exclui uma fonte do computador local. O exemplo determina o log de sua origem e, em seguida, exclui o log.  
  
> [!NOTE]
>  Mais de uma fonte pode gravar um log de eventos. Antes de excluir um log personalizado, verifique se há não há outras fontes de gravação nesse log.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do computador em que os eventos devem ser lidos ou gravados.</summary>
        <value>O nome do servidor no qual reside o log de eventos. O padrão é o computador local (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você gravar um log de eventos, você deve associar um <xref:System.Diagnostics.EventLog.Source%2A> com seu objeto de log de eventos para conectá-lo em um log específico. Não é necessário especificar o <xref:System.Diagnostics.EventLog.Source%2A> propriedade quando somente leitura de um log. Você pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A> nome e <xref:System.Diagnostics.EventLog.MachineName%2A> (nome de computador do servidor).  
  
> [!NOTE]
>  Você não precisa especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> se você estiver se conectando a um log. Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (".") é assumido.  
  
 Uma origem só pode ser registrada para um log cada vez. Se o <xref:System.Diagnostics.EventLog.Source%2A> propriedade foi definida para uma instância do <xref:System.Diagnostics.EventLog>, não é possível alterar o <xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para fazer isso <xref:System.Diagnostics.EventLog> sem alterar o valor de <xref:System.Diagnostics.EventLog.Source%2A> ou chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primeiro. Se você alterar o <xref:System.Diagnostics.EventLog.MachineName%2A> propriedade, o <xref:System.Diagnostics.EventLog> fecha todos os identificadores e anexa novamente para o log e o código-fonte no novo computador.  
  
 O <xref:System.Diagnostics.EventLog.MachineName%2A> valor não pode ser uma cadeia de caracteres vazia. Se ele não for definido explicitamente, ele assume como padrão no computador local (".").  
  
   
  
## Examples  
 O exemplo a seguir lê as entradas no log de eventos, "NewEventLog", em um computador especificado.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do computador é inválido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo do log de eventos em quilobytes.</summary>
        <value>O tamanho máximo do log de eventos em quilobytes. O padrão é 512, indicando um tamanho do arquivo máximo de 512 KB.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriedade representa o limite de tamanho do arquivo de log de eventos. Quando o log de eventos atinge o limite de tamanho configurado <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor determina se as novas entradas são descartadas, ou se novas entradas de substituir as entradas mais antigas.  
  
> [!NOTE]
>  Esta propriedade representa uma definição de configuração para o log de evento representado por esta instância. Quando o log de eventos atinge seu tamanho máximo, essa propriedade especifica como o sistema operacional trata as novas entradas gravadas por todas as fontes de evento registradas para o log de eventos.  
  
   
  
## Examples  
 O exemplo a seguir enumera os logs de evento definidos no computador local e exibe os detalhes de configuração para cada log de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado é menor do que 64 ou maior que 4194240 ou é não um múltiplo par de 64.</exception>
        <exception cref="T:System.InvalidOperationException">O valor <see cref="P:System.Diagnostics.EventLog.Log" /> não é um nome de log válido.  
  
- ou - 
Não foi possível abrir a chave do Registro do log de eventos no computador de destino.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de dias para reter as entradas no log de eventos.</summary>
        <value>O número de dias durante os quais as entradas no log de eventos são retidas. O valor padrão é 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> propriedade para examinar a configuração atual de um log de eventos. Use <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> para alterar o número mínimo de dias que cada entrada no log de eventos deve ser mantida.  
  
 O <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor depende do comportamento de estouro de configurado o log de eventos. Se o <xref:System.Diagnostics.OverflowAction> propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, em seguida, a <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor é 0. Se o <xref:System.Diagnostics.OverflowAction> propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, em seguida, a <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor é -1. Se o <xref:System.Diagnostics.OverflowAction> propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, em seguida, a <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor é maior que zero e representa o número de dias para manter entradas do log de eventos quando o log de eventos está cheio.  
  
 O comportamento de estouro ocorre apenas quando um log de eventos atinge seu limite de tamanho. Quando um <xref:System.Diagnostics.EventLog> tem sua <xref:System.Diagnostics.EventLog.OverflowAction%2A> definido como <xref:System.Diagnostics.OverflowAction.OverwriteOlder>e o log de eventos atinge seu tamanho máximo, em seguida, novas entradas são gravadas somente se eles podem substituir entradas cuja idade excede o <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> período. Retenção de entradas de eventos por um período mínimo é apropriado quando o log de eventos é arquivado regularmente. Caso contrário, você corre o risco de perder novas entradas quando o log de eventos atinge seu limite. Para evitar perder as novas informações de evento, defina os dias de retenção mínimo para eventos com base em seu agendamento de arquivo morto para um determinado log de eventos.  
  
   
  
## Examples  
 O exemplo a seguir enumera os logs de evento definidos no computador local e exibe os detalhes de configuração para cada log de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">O comportamento de estouro para gravar novas entradas no log de eventos.</param>
        <param name="retentionDays">O número mínimo de dias durante os quais cada entrada de log de eventos é mantida. Este parâmetro será usado apenas se <paramref name="action" /> for definido como <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Altera o comportamento configurado para gravar novas entradas quando o log de eventos atinge o tamanho máximo do arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento de estouro para um log de eventos especifica o que acontece quando novas entradas devem ser gravados em um log que atingiu seu tamanho máximo do arquivo.  
  
> [!NOTE]
>  O comportamento de estouro entra em vigor somente quando um log de eventos atinge o tamanho máximo de arquivo. O comportamento de estouro não afeta a gravar uma nova entrada em um log que possa acomodar as entradas de log de eventos adicionais.  
  
 O <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método configura o comportamento de estouro de um log de eventos. <xref:System.Diagnostics.EventLog> instância. Depois de chamar esse método para o log de eventos especificado pelo <xref:System.Diagnostics.EventLog.Log%2A> propriedade, o <xref:System.Diagnostics.EventLog.OverflowAction%2A> e <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valores de propriedade refletem o comportamento de estouro recém-configurado.  
  
> [!NOTE]
>  Esta propriedade representa uma definição de configuração para o log de evento representado por esta instância. Quando o log de eventos atinge seu tamanho máximo, essa propriedade especifica como o sistema operacional trata as novas entradas gravadas por todas as fontes de evento registradas para o log de eventos.  
  
 Defina as `action` parâmetro para <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> para indicar que uma nova entrada substitui a entrada mais antiga quando o <xref:System.Diagnostics.EventLog> atinge seu tamanho máximo. Se o `action` parâmetro é definido como <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, o `retentionDays` valor do parâmetro é ignorado.  
  
 Defina as `action` parâmetro para <xref:System.Diagnostics.OverflowAction.OverwriteOlder> para indicar que cada nova entrada substitui as entradas mais antigas quando o <xref:System.Diagnostics.EventLog> atinge seu tamanho máximo. Especifique o número de dias que os eventos devem ser mantidos no log usando o `retentionDays` parâmetro. Eventos gravados dentro do intervalo de retenção não são substituídos por novas entradas.  
  
 Defina as `action` parâmetro para <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> para descartar os novos eventos quando o tamanho máximo do log for atingido. Se o `action` parâmetro é definido como <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, o `retentionDays` valor do parâmetro é ignorado.  
  
> [!CAUTION]
>  Configuração da diretiva de estouro <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> Especifica que novas entradas são descartadas quando o log de eventos está cheio. Se você usar essa configuração, verifique se o log de eventos regularmente é arquivado e limpo para evitar atingir seu limite de tamanho máximo.  
  
   
  
## Examples  
 O exemplo a seguir exibe a política de estouro configurado para um log de eventos especificado e permite que o usuário selecionar uma nova configuração de política de estouro do log de eventos.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> não é um valor <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> é menor do que um ou maior que 365.</exception>
        <exception cref="T:System.InvalidOperationException">O valor <see cref="P:System.Diagnostics.EventLog.Log" /> não é um nome de log válido.  
  
- ou - 
Não foi possível abrir a chave do Registro do log de eventos no computador de destino.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o comportamento configurado para armazenar novas entradas quando o log de eventos atinge o tamanho máximo do arquivo de log.</summary>
        <value>O valor <see cref="T:System.Diagnostics.OverflowAction" /> que especifica o comportamento configurado para armazenar novas entradas quando o log de eventos atinge o tamanho máximo do log. O padrão é <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Logs de eventos crescem em tamanho, como novos eventos são gravados neles. Cada log de eventos tem um limite de tamanho máximo configurado; o <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propriedade define o número máximo de kilobytes permitidos para o tamanho do arquivo de log de eventos.  
  
 Use o <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor da propriedade para examinar o comportamento de estouro configurado para um log de eventos em seu tamanho máximo. Use o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para alterar o comportamento de estouro para um log de eventos.  
  
> [!NOTE]
>  O comportamento de estouro entra em vigor somente quando um log de eventos atinge o tamanho máximo de arquivo. O comportamento de estouro não afeta a gravar uma nova entrada em um log que possa acomodar as entradas de log de eventos adicionais.  
  
   
  
## Examples  
 O exemplo a seguir enumera os logs de evento definidos no computador local e exibe os detalhes de configuração para cada log de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">O caminho totalmente especificado para um arquivo de recurso localizado.</param>
        <param name="resourceId">O identificador de recurso que indexa uma cadeia de caracteres localizada dentro do arquivo de recurso.</param>
        <summary>Especifica o nome localizado do log de eventos, que é exibido no Visualizador de Eventos do servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> para registrar e exibir um nome localizado no Visualizador de eventos para logs de eventos personalizados.  
  
 O identificador de recurso especificado deve corresponder a uma cadeia de caracteres localizada definida no arquivo de recurso. O Visualizador de eventos exibe o nome do log de eventos personalizado usando a cadeia de caracteres localizada e as configurações de cultura atual. Por exemplo, você pode definir vários nomes de log de eventos, localizados para culturas diferentes em seu arquivo de recurso. O Visualizador de eventos exibe a cadeia de caracteres localizada correspondente às configurações de cultura do usuário atual.  
  
 Se o Visualizador de eventos não é possível carregar a cadeia de caracteres localizada do arquivo de recurso, ou se nenhum nome de exibição foi registrado para o log de eventos, o Visualizador de eventos exibe o nome do log de eventos definido no <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Você não precisa registrar um nome de exibição para os logs de eventos predefinidos. O sistema operacional registra os nomes de exibição localizado para os logs de eventos do aplicativo, sistema e segurança.  
  
   
  
## Examples  
 O exemplo a seguir determina se a origem do evento nomeado `SampleApplicationSource` está registrado no computador local. Se a origem do evento não existir, o exemplo define o arquivo de recurso de mensagem para a fonte e cria a nova origem do evento. Por fim, o exemplo define o nome de exibição localizado para o log de eventos, usando o valor do identificador de recurso de `DisplayNameMsgId` e o caminho do arquivo de recurso no `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro. Especificamente, o identificador de recurso 5001 é definido para o nome localizado do log de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O valor <see cref="P:System.Diagnostics.EventLog.Log" /> não é um nome de log válido.  
  
- ou - 
Não foi possível abrir a chave do Registro do log de eventos no computador de destino.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome da fonte a ser registrado e usado ao gravar no log de eventos.</summary>
        <value>O nome registrado com o log de eventos como uma fonte de entradas. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A origem do evento indica que o que registra o evento. Geralmente é o nome do aplicativo ou o nome de um subcomponente do aplicativo, se o aplicativo for grande. Aplicativos e serviços devem gravar no log do aplicativo ou um log personalizado. Drivers de dispositivo devem gravar no log do sistema.  
  
 Você só precisa especificar uma origem do evento, se você estiver gravando em um log de eventos. Antes de gravar uma entrada para um log de eventos, você deve registrar a origem do evento no log de eventos como uma origem válida de eventos. Quando você grava uma entrada de log, o sistema usa o <xref:System.Diagnostics.EventLog.Source%2A> propriedade para localizar o log adequado no qual colocar sua entrada. Se você estiver lendo o log de eventos, você pode especificar o <xref:System.Diagnostics.EventLog.Source%2A>, ou uma <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Não é necessário especificar o <xref:System.Diagnostics.EventLog.MachineName%2A> se você estiver se conectando a um log no computador local. Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (".") é assumido.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> para gravar eventos em um log de eventos. Você deve especificar uma origem de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Você pode criar uma fonte de evento para um log de eventos existente ou um novo log de eventos. Quando você cria uma nova origem para um novo log de eventos, o sistema registra a origem para que o log, mas o log não é criado até que a primeira entrada seja gravada nele.  
  
 A origem deve ser exclusiva no computador local; um novo nome de origem não pode corresponder a um nome de origem existente ou um nome de log de eventos existente. Cada fonte pode gravar apenas um log de eventos ao mesmo tempo; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, seu aplicativo pode exigir várias fontes, configurados para arquivos de recurso diferente ou logs de eventos diferentes.  
  
 Se você alterar o <xref:System.Diagnostics.EventLog.Source%2A> valor, o <xref:System.Diagnostics.EventLog> para que ele esteja registrado é fechado e todos os identificadores de eventos são liberados.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
 Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam o código-fonte existente, crie uma nova fonte com a configuração atualizada, em vez de excluir o código-fonte existente.  
  
> [!NOTE]
>  Se uma fonte já tiver sido mapeada para um log e remapeá-la para um novo log, você deve reiniciar o computador para que as alterações entrem em vigor.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa determinada origem do evento no Registro do computador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome da origem do evento.</param>
        <summary>Determina se um evento de origem foi registrado no computador local.</summary>
        <returns><see langword="true" /> se a origem do evento for registrada no computador local; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se uma fonte de eventos existe no computador local. Se você deseja determinar se um log existe no computador local, use <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador local; Caso contrário, um <xref:System.Security.SecurityException> será lançada.  
  
> [!NOTE]
>  Para procurar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter privilégios administrativos.  
>   
>  O motivo para esse requisito é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não têm permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
>   
>  Começando com o Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa os contadores de desempenho, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
> [!NOTE]
>  Um serviço que está executando sob o <xref:System.ServiceProcess.ServiceAccount.LocalSystem> conta não tem os privilégios necessários para executar esse método. A solução é verificar se a origem do evento existe no <xref:System.ServiceProcess.ServiceInstaller>, e se ele não existir, para criar a fonte no instalador.  
  
 Porque você não pode dar uma nova origem o nome de uma fonte existente no mesmo computador, use esse método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para garantir que uma fonte com o nome especificado pelo `source` ainda não existir no computador local. O `source` parâmetro não diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> não foi encontrado, mas alguns ou todos os logs de evento não puderam ser pesquisados.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">O nome da origem do evento.</param>
        <param name="machineName">O nome do computador no qual procurar, ou "." para o computador local.</param>
        <summary>Determina se uma origem do evento está registrada em um computador especificado.</summary>
        <returns><see langword="true" /> se a origem do evento for registrada no computador especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se uma fonte de eventos existe no computador especificado pelo `machineName` parâmetro. Se você deseja determinar se um log existe no computador especificado, use <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Como esse método acessa o registro, você deve ter as permissões de registro apropriadas em determinado servidor; Caso contrário, um <xref:System.Security.SecurityException> será lançada.  
  
> [!NOTE]
>  Para procurar uma fonte de eventos no Windows Vista e posterior ou o Windows Server 2003, você deve ter privilégios administrativos.  
>   
>  O motivo para esse requisito é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não têm permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException> é gerada.  
>   
>  Começando com o Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa os contadores de desempenho, você deve primeiro elevar seus privilégios de usuário padrão ao administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
> [!NOTE]
>  Um serviço que está executando sob o <xref:System.ServiceProcess.ServiceAccount.LocalSystem> conta não tem os privilégios necessários para executar esse método. A solução é verificar se a origem do evento existe no <xref:System.ServiceProcess.ServiceInstaller>, e se ele não existir, para criar a fonte no instalador.  
  
 Porque você não pode dar uma nova origem o nome de uma fonte existente no mesmo computador, use esse método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para garantir que uma fonte com o nome especificado pelo `source` ainda não existir no computador. O `source` e `machineName` parâmetros não diferenciam maiusculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> é um `static` método, ele pode ser chamado na classe em si. Não é necessário criar uma instância do <xref:System.Diagnostics.EventLog> chamar <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` no computador `MyServer`e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> é um nome do computador inválido.</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> não foi encontrado, mas alguns ou todos os logs de evento não puderam ser pesquisados.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento de gravação na entrada <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de uma <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> eventos no log de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> é `null`, os métodos de tratamento de <xref:System.Diagnostics.EventLog.EntryWritten> eventos são chamados em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.Diagnostics.EventLog.EntryWritten> evento é manipulado por um visual de formulários do Windows a componente, como um botão, acessando o componente através do pool de threads do sistema pode não funcionar ou pode resultar em uma exceção. Evitar isso, definindo <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> a um componente de Windows Forms, que faz com que os métodos de tratamento de <xref:System.Diagnostics.EventLog.EntryWritten> evento a ser chamado no mesmo thread em que o componente foi criado.  
  
 Se o <xref:System.Diagnostics.EventLog> é usado dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] em um designer de formulários do Windows <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> é definida automaticamente como o controle que contém o <xref:System.Diagnostics.EventLog>. Por exemplo, se você colocar um <xref:System.Diagnostics.EventLog> em um designer para Form1 (que herda de <xref:System.Windows.Forms.Form>) a <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> propriedade do <xref:System.Diagnostics.EventLog> está definido para a instância de Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava uma entrada no log de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <summary>Grava uma entrada de tipo de informação, com o texto da mensagem fornecido, no log de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada de informações no log de eventos associado a este <xref:System.Diagnostics.EventLog> instância. Se você quiser especificar qualquer outro <xref:System.Diagnostics.EventLogEntryType>, use uma sobrecarga diferente de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> antes que você pode gravar entradas no log de componente. Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Se a fonte especificada na <xref:System.Diagnostics.EventLog.Source%2A> propriedade deste <xref:System.Diagnostics.EventLog> instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A> chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra o código-fonte.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (".") é assumido.  
  
 Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A> por meio de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A> e o <xref:System.Diagnostics.EventLog.Log%2A> propriedade não foi definida no seu <xref:System.Diagnostics.EventLog> instância, o log padrão é o log de aplicativo.  
  
> [!NOTE]
>  Muitas das exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) não pode ser o esperado se o computador remoto não está em execução do .NET Framework.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Grava uma entrada de erro, aviso, informação, auditoria de êxito ou auditoria de falha com o texto da mensagem fornecido no log de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType> ao log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> antes que você pode gravar entradas no log de componente. Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Se a fonte especificada na <xref:System.Diagnostics.EventLog.Source%2A> propriedade deste <xref:System.Diagnostics.EventLog> instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A> chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra o código-fonte.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (".") é assumido.  
  
 Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A> por meio de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A> e o <xref:System.Diagnostics.EventLog.Log%2A> propriedade não foi definida no seu <xref:System.Diagnostics.EventLog> instância, o log padrão é o log de aplicativo.  
  
> [!NOTE]
>  Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) não pode ser o esperado se o computador remoto não está em execução do .NET Framework.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 O exemplo a seguir grava uma entrada de aviso para um log de eventos "MyNewLog" no computador local.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <summary>Grava uma entrada de tipo de informação com o texto da mensagem especificado no log de eventos usando a origem do evento registrada especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada de informações no log de eventos, usando uma fonte que já está registrada como uma origem de evento para o log adequado. Se você quiser especificar qualquer outro <xref:System.Diagnostics.EventLogEntryType>, use uma sobrecarga diferente de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
>   
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
   
  
## Examples  
 O exemplo a seguir cria a fonte `MySource` se ele ainda não existir e grava uma entrada no log de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <summary>Grava no log de eventos uma entrada com o texto da mensagem especificado e o identificador de evento definido pelo aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada com um aplicativo definido `eventID` ao log de eventos. O `eventID` junto com a fonte de identificar exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de eventos exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Além do identificador de evento, você pode especificar um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> antes que você pode gravar entradas no log de componente. Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Se a fonte especificada na <xref:System.Diagnostics.EventLog.Source%2A> propriedade deste <xref:System.Diagnostics.EventLog> instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A> chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra o código-fonte.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (".") é assumido.  
  
 Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A> por meio de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A> e o <xref:System.Diagnostics.EventLog.Log%2A> propriedade não foi definida no seu <xref:System.Diagnostics.EventLog> instância, o log padrão é o log de aplicativo.  
  
> [!NOTE]
>  Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) não pode ser o esperado se o computador remoto não está em execução do .NET Framework.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Grava uma entrada de erro, aviso, informação, auditoria de êxito ou auditoria de falha com o texto da mensagem fornecido no log de eventos, usando a origem do evento registrado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType> ao log de eventos, usando uma fonte já registrado como uma origem de evento para o log adequado. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 O exemplo a seguir grava uma entrada de aviso para um log de eventos "MyNewLog" no computador local.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <param name="category">A subcategoria específica do aplicativo associada à mensagem.</param>
        <summary>Grava uma entrada com o texto da mensagem especificado, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo no log de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada com um aplicativo definido `category` ao log de eventos. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma origem do evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou ele pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.  
  
> [!NOTE]
>  O `category` parâmetro deve ser um valor positivo. Valores negativos de categorias aparecem como um número positivo complementar no Visualizador de eventos. Por exemplo, um -10 aparece como 65,526, -1 como 65.535.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso da categoria e defina o `category` para um identificador de recurso no arquivo de recurso da categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso da categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso da categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recurso, usando o <xref:System.Diagnostics.EventLogInstaller> ou o <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Além da categoria, você pode especificar um identificador de evento para o evento que está sendo gravado no log de eventos. Identificadores de eventos, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de eventos exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
 Por fim, você pode especificar um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> antes que você pode gravar entradas no log de componente. Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Se a fonte especificada na <xref:System.Diagnostics.EventLog.Source%2A> propriedade deste <xref:System.Diagnostics.EventLog> instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A> chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra o código-fonte.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (".") é assumido.  
  
 Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A> por meio de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A> e o <xref:System.Diagnostics.EventLog.Log%2A> propriedade não foi definida no seu <xref:System.Diagnostics.EventLog> instância, o log padrão é o log de aplicativo.  
  
> [!NOTE]
>  Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) não pode ser o esperado se o computador remoto não está em execução do .NET Framework.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <summary>Grava uma entrada com o texto da mensagem especificado e o identificador de evento definido pelo aplicativo no log de eventos, usando a fonte de evento registrada especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada com um aplicativo definido `eventID` ao log de eventos, usando uma fonte já registrado como uma origem de evento para o log adequado. O `eventID`, juntamente com o código-fonte, identificar exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Visualizadores de eventos apresentam essas cadeias de caracteres para o usuário para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
 Além do identificador de evento, essa sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A> permite que você especifique um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <param name="category">A subcategoria específica do aplicativo associada à mensagem.</param>
        <param name="rawData">Uma matriz de bytes que contém os dados binários associados à entrada.</param>
        <summary>Grava uma entrada com o texto da mensagem fornecido, o identificador de eventos definido pelo aplicativo e a categoria definida por aplicativo no log de eventos e anexa dados binários à mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para gravar dados de eventos específicos definidos pelo aplicativo no log de eventos. O Visualizador de eventos não interpretar esses dados; ele exibe os dados brutos somente em um formato hexadecimal e textual combinado. Use dados de eventos específicos com moderação, incluí-lo somente se você tiver certeza será útil para alguém depurar o problema. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você poderia escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o arquivo de log e cria relatórios que incluem informações sobre os dados específicos do evento.  
  
 Além dos dados binários, você pode especificar uma categoria definida pelo aplicativo e um identificador de evento definido pelo aplicativo. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma origem do evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou ele pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.  
  
> [!NOTE]
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
> [!NOTE]
>  O `category` parâmetro deve ser um valor positivo. Valores negativos de categorias aparecem como um número positivo complementar no Visualizador de eventos. Por exemplo, um -10 aparece como 65,526, -1 como 65.535.  
  
 Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso da categoria e defina o `category` para um identificador de recurso no arquivo de recurso da categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso da categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso da categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recurso, usando o <xref:System.Diagnostics.EventLogInstaller> ou o <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Identificadores de eventos, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de eventos exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
 Por fim, você pode especificar um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> antes que você pode gravar entradas no log de componente. Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte.  
  
 Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 Se a fonte especificada na <xref:System.Diagnostics.EventLog.Source%2A> propriedade deste <xref:System.Diagnostics.EventLog> instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A> chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra o código-fonte.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A> ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (".") é assumido.  
  
 Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A> por meio de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A> e o <xref:System.Diagnostics.EventLog.Log%2A> propriedade não foi definida no seu <xref:System.Diagnostics.EventLog> instância, o log padrão é o log de aplicativo.  
  
> [!NOTE]
>  Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) não pode ser o esperado se o computador remoto não está em execução do .NET Framework.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <param name="category">A subcategoria específica do aplicativo associada à mensagem.</param>
        <summary>Grava uma entrada com o texto da mensagem fornecido, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo no log de eventos, usando a fonte de evento registrada especificada. O <paramref name="category" /> pode ser usado pelo Visualizador de Eventos para filtrar eventos no log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada com um aplicativo definido `category` ao log de eventos, usando uma fonte que já está registrada como uma origem de evento para o log adequado. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma origem do evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou ele pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.  
  
> [!NOTE]
>  O `category` parâmetro deve ser um valor positivo. Valores negativos de categorias aparecem como um número positivo complementar no Visualizador de eventos. Por exemplo, um -10 aparece como 65,526, -1 como 65.535.  
  
 Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso da categoria e defina o `category` para um identificador de recurso no arquivo de recurso da categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso da categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso da categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recurso, usando o <xref:System.Diagnostics.EventLogInstaller> ou o <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Além da categoria, você pode especificar um identificador de evento para o evento que está sendo gravado no log de eventos. Identificadores de eventos, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de eventos exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
 Por fim, você pode especificar um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
>   
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">A origem pela qual o aplicativo está registrado no computador especificado.</param>
        <param name="message">A cadeia de caracteres a ser gravada no log de eventos.</param>
        <param name="type">Um dos valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">O identificador específico do aplicativo para o evento.</param>
        <param name="category">A subcategoria específica do aplicativo associada à mensagem.</param>
        <param name="rawData">Uma matriz de bytes que contém os dados binários associados à entrada.</param>
        <summary>Grava uma entrada com o texto da mensagem fornecido, o identificador de eventos definido pelo aplicativo e a categoria definida por aplicativo no log de eventos (usando a fonte de evento registrada especificada) e anexa dados binários à mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar dados de eventos específicos definidos pelo aplicativo no log de eventos, usando uma fonte já registrada como uma origem de evento para o log adequado. O Visualizador de eventos não interpretar esses dados; ele exibe os dados brutos somente em um formato hexadecimal e textual combinado. Use dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você poderia escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o arquivo de log e cria relatórios que incluem informações sobre os dados específicos do evento.  
  
 Além dos dados binários, você pode especificar uma categoria definida pelo aplicativo e um identificador de evento definido pelo aplicativo. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma origem do evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou ele pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.  
  
> [!NOTE]
>  O `category` parâmetro deve ser um valor positivo. Valores negativos de categorias aparecem como um número positivo complementar no Visualizador de eventos. Por exemplo, um -10 será exibido como 65,526, -1 como 65.535.  
  
 Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso da categoria e defina o `category` para um identificador de recurso no arquivo de recurso da categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso da categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso da categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recurso, usando o <xref:System.Diagnostics.EventLogInstaller> ou o <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Identificadores de eventos, junto com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de eventos exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugere ações a serem tomadas.  
  
 Por fim, você pode especificar um <xref:System.Diagnostics.EventLogEntryType> para o evento que está sendo gravado no log de eventos. O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é o erro, aviso, informação, auditoria de êxito ou auditoria de falha.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A> método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável. Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar eventos usando um arquivo de recurso de mensagem localizada.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se o `message` parâmetro contém um caractere de terminação nula, a mensagem no log de eventos é encerrada no caractere NUL.  
>   
>  O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="eventID" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
A cadeia de caracteres da mensagem tem mais de 31.839 bytes (32.766 em sistemas operacionais Windows anteriores ao Windows Vista).  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> não é um <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava uma entrada de evento localizada no log de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Uma instância <see cref="T:System.Diagnostics.EventInstance" /> que representa uma entrada de log de eventos localizada.</param>
        <param name="values">Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada de log de eventos.</param>
        <summary>Grava uma entrada localizada no log de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada localizada no log de eventos. Você pode especificar as propriedades de evento com identificadores de recurso em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recurso para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para o <xref:System.Diagnostics.EventLog.Source%2A>. Você deve registrar a fonte com o arquivo de recurso correspondente antes de gravar eventos usando identificadores de recurso.  
  
 A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Defina as <xref:System.Diagnostics.EventInstance.InstanceId%2A> do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem. Opcionalmente, você pode definir as <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> da `instance` entrada para definir o tipo de evento e a categoria da sua inscrição de evento. Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação para cadeias de caracteres de substituição.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. A origem especificada deve ser configurada para gravar entradas localizadas no log; no mínimo, a origem deve ter um arquivo de recurso de mensagem definido.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A> método se seu aplicativo grava os valores de cadeia de caracteres diretamente ao log de eventos.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada para um computador remoto, o valor da `message` cadeia de caracteres pode não ser o esperado se o computador remoto não está em execução do .NET Framework. Além disso, o `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
   
  
## Examples  
 O exemplo a seguir grava duas entradas no log de eventos de auditoria `myNewLog`. O exemplo cria uma nova origem do evento e um novo log de eventos se eles não existirem no computador local. O texto da mensagem de evento é especificado usando um identificador de recurso em um arquivo de recurso.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
 <paramref name="instance.InstanceId" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
 <paramref name="values" /> tem mais de 256 elementos.  
  
- ou - 
Um dos elementos <paramref name="values" /> é maior que 32766 bytes.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Uma instância <see cref="T:System.Diagnostics.EventInstance" /> que representa uma entrada de log de eventos localizada.</param>
        <param name="data">Uma matriz de bytes que contém os dados binários associados à entrada.</param>
        <param name="values">Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada de log de eventos.</param>
        <summary>Grava uma entrada de log de eventos com os dados de evento, cadeias de caracteres de substituição de mensagem e os dados binários associados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada localizada com dados específicos de evento adicionais no log de eventos. Você pode especificar as propriedades de evento com identificadores de recurso em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recurso para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para o <xref:System.Diagnostics.EventLog.Source%2A>. Você deve registrar a fonte com o arquivo de recurso correspondente antes de gravar eventos usando identificadores de recurso.  
  
 A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Defina as <xref:System.Diagnostics.EventInstance.InstanceId%2A> do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem. Opcionalmente, você pode definir as <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> da `instance` entrada para definir o tipo de evento e a categoria da sua inscrição de evento. Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação para cadeias de caracteres de substituição.  
  
 Especifica dados binários com um evento quando for necessário fornecer detalhes adicionais para o evento. Por exemplo, use o `data` parâmetro incluir informações sobre um erro específico. O Visualizador de eventos não interpreta os dados de evento associado; ele exibe os dados em um formato hexadecimal e textual combinado. Use dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você poderia escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o log de eventos e cria relatórios que incluem informações sobre os dados específicos do evento.  
  
 Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A> propriedade em seu <xref:System.Diagnostics.EventLog> componente antes do componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. A origem especificada deve ser configurada para gravar entradas localizadas no log; no mínimo, a origem deve ter um arquivo de recurso de mensagem definido.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
> [!NOTE]
>  Se você não especificar uma <xref:System.Diagnostics.EventLog.MachineName%2A> para seu <xref:System.Diagnostics.EventLog> instância antes de chamar <xref:System.Diagnostics.EventLog.WriteEvent%2A>, o computador local (".") é assumido.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A> método se seu aplicativo grava os valores de cadeia de caracteres diretamente ao log de eventos.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
> [!NOTE]
>  Se você gravar uma entrada para um computador remoto, o valor da `message` cadeia de caracteres pode não ser o esperado se o computador remoto não está em execução do .NET Framework. Além disso, o `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor de inteiro (por exemplo, %1), porque o Visualizador de eventos a trata como uma cadeia de caracteres de inserção. Como um protocolo de Internet, a versão do endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.  
  
   
  
## Examples  
 O exemplo a seguir grava duas entradas no log de eventos de auditoria `myNewLog`. O exemplo cria uma nova origem do evento e um novo log de eventos se eles não existirem no computador local. O texto da mensagem de evento é especificado usando um identificador de recurso em um arquivo de recurso.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Diagnostics.EventLog.Source" /> do <see cref="T:System.Diagnostics.EventLog" /> não foi definida.  
  
- ou - 
O método tentou registrar uma nova fonte de evento, mas o nome do computador em <see cref="P:System.Diagnostics.EventLog.MachineName" /> não é válido.  
  
- ou - 
A origem já está registrada para um log de eventos diferente.  
  
- ou - 
 <paramref name="instance.InstanceId" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
 <paramref name="values" /> tem mais de 256 elementos.  
  
- ou - 
Um dos elementos <paramref name="values" /> é maior que 32766 bytes.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">O nome da origem de evento registrada para o aplicativo no computador especificado.</param>
        <param name="instance">Uma instância <see cref="T:System.Diagnostics.EventInstance" /> que representa uma entrada de log de eventos localizada.</param>
        <param name="values">Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada de log de eventos.</param>
        <summary>Grava uma entrada de log de eventos com os dados do evento e as cadeias de caracteres de substituição de mensagem, usando a origem de evento registrada especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada localizada no log de eventos, usando uma fonte já registrada como uma origem de evento para o log adequado. Você pode especificar as propriedades de evento com identificadores de recurso em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recurso para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para a fonte. Você deve registrar a fonte com o arquivo de recurso correspondente antes de gravar eventos usando identificadores de recurso.  
  
 A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Defina as <xref:System.Diagnostics.EventInstance.InstanceId%2A> do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem. Opcionalmente, você pode definir as <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> da `instance` entrada para definir o tipo de evento e a categoria da sua inscrição de evento. Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação para cadeias de caracteres de substituição.  
  
 A origem especificada deve ser registrada para um log de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. A origem especificada deve ser configurada para gravar entradas localizadas no log; no mínimo, a origem deve ter um arquivo de recurso de mensagem definido.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A> método se seu aplicativo grava os valores de cadeia de caracteres diretamente ao log de eventos.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
   
  
## Examples  
 O exemplo a seguir grava uma entrada de evento informativo e uma entrada de evento de aviso para um log de eventos existente. O texto da mensagem de evento é especificado usando um identificador de recurso em um arquivo de recurso. O exemplo supõe que o arquivo de recurso correspondente foi registrado para a fonte.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance.InstanceId" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
 <paramref name="values" /> tem mais de 256 elementos.  
  
- ou - 
Um dos elementos <paramref name="values" /> é maior que 32766 bytes.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">O nome da origem de evento registrada para o aplicativo no computador especificado.</param>
        <param name="instance">Uma instância <see cref="T:System.Diagnostics.EventInstance" /> que representa uma entrada de log de eventos localizada.</param>
        <param name="data">Uma matriz de bytes que contém os dados binários associados à entrada.</param>
        <param name="values">Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada de log de eventos.</param>
        <summary>Grava uma entrada de log de eventos com os dados de evento, cadeias de caracteres de substituição de mensagem e os dados binários associados e usando a origem do evento registrada especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para gravar uma entrada localizada com dados específicos de evento adicionais no log de eventos, usando uma fonte já registrada como uma origem de evento para o log adequado. Você pode especificar as propriedades de evento com identificadores de recurso em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recurso para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para a fonte. Você deve registrar a fonte com o arquivo de recurso correspondente antes de gravar eventos usando identificadores de recurso.  
  
 A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Defina as <xref:System.Diagnostics.EventInstance.InstanceId%2A> do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem. Opcionalmente, você pode definir as <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> da `instance` entrada para definir o tipo de evento e a categoria da sua inscrição de evento. Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação para cadeias de caracteres de substituição.  
  
 Especifica dados binários com um evento quando for necessário fornecer detalhes adicionais para o evento. Por exemplo, use o `data` parâmetro incluir informações sobre um erro específico. O Visualizador de eventos não interpreta os dados de evento associado; ele exibe os dados em um formato hexadecimal e textual combinado. Use dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você poderia escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o log de eventos e cria relatórios que incluem informações sobre os dados específicos do evento.  
  
 A origem especificada deve ser registrada para um log de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. A origem especificada deve ser configurada para gravar entradas localizadas no log; no mínimo, a origem deve ter um arquivo de recurso de mensagem definido.  
  
 Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com o código-fonte. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.  
  
 A origem deve ser configurada para gravar entradas localizadas ou para gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A> método se seu aplicativo grava os valores de cadeia de caracteres diretamente ao log de eventos.  
  
 Se seu aplicativo grava entradas usando os valores de cadeia de caracteres e identificadores de recurso, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para gravar entradas usando identificadores de recurso para o log de eventos. Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escrever cadeias de caracteres diretamente ao log de eventos usando essa fonte.  
  
   
  
## Examples  
 O exemplo a seguir grava uma entrada de evento informativo e uma entrada de evento de aviso para um log de eventos existente. O texto da mensagem de evento é especificado usando um identificador de recurso em um arquivo de recurso. O exemplo supõe que o arquivo de recurso correspondente foi registrado para a fonte.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 O exemplo usa o seguinte arquivo de texto de mensagem, criado para a biblioteca do recurso EventLogMsgs.dll. Um arquivo de texto da mensagem é a origem do qual o arquivo de recurso de mensagem é criado. O arquivo de texto de mensagem define os identificadores de recurso e o texto para a categoria, a mensagem de evento e a cadeias de caracteres de inserção de parâmetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor <paramref name="source" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O valor <paramref name="source" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="instance.InstanceId" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.  
  
- ou - 
 <paramref name="values" /> tem mais de 256 elementos.  
  
- ou - 
Um dos elementos <paramref name="values" /> é maior que 32766 bytes.  
  
- ou - 
O nome da origem resulta em um caminho de chave do Registro com mais de 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível abrir a chave do Registro para o log de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para gravar as informações de log de eventos no computador. Enumeração associada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>