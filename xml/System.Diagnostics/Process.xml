<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58cf5f02c19c3c52ac8d26e1ed52e28a450d7b17" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676162" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to local and remote processes and enables you to start and stop local system processes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Diagnostics.Process> componente fornece acesso a um processo que está executando em um computador. Um processo, em termos mais simples, é um aplicativo em execução. Um thread é a unidade básica para o qual o sistema operacional aloca tempo do processador. Um thread pode executar qualquer parte do código do processo, incluindo partes que está sendo executadas no momento por outro thread.  
  
 O <xref:System.Diagnostics.Process> componente é uma ferramenta útil para iniciar, parar, controlar e monitorar aplicativos. Você pode usar o <xref:System.Diagnostics.Process> componente, para obter uma lista dos processos em execução, ou você pode iniciar um novo processo. Um <xref:System.Diagnostics.Process> componente é usado para acessar os processos do sistema. Após um <xref:System.Diagnostics.Process> componente foi inicializado, ele pode ser usado para obter informações sobre o processo em execução. Essas informações incluem o conjunto de threads, os módulos carregados (arquivos. dll e .exe), e informações de desempenho, como a quantidade de memória que o processo está usando.  
  
 Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
> [!NOTE]
>  processos de 32 bits não podem acessar os módulos de um processo de 64 bits. Se você tentar obter informações sobre um processo de 64 bits de um processo de 32 bits, você receberá um <xref:System.ComponentModel.Win32Exception> exceção. Por outro lado, um processo de 64 bits, pode acessar os módulos de um processo de 32 bits.  
  
 O componente do processo obtém informações sobre um grupo de propriedades de uma só vez. Após o <xref:System.Diagnostics.Process> componente obteve informações sobre um membro de nenhum grupo, ele armazenar em cache os valores para as outras propriedades no grupo e não obter novas informações sobre os outros membros do grupo até que você chamar o <xref:System.Diagnostics.Process.Refresh%2A> método. Portanto, um valor de propriedade não é garantido para ser qualquer mais recente do que a última chamada para o <xref:System.Diagnostics.Process.Refresh%2A> método. As divisões de grupo são dependentes do sistema operacional.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
 Um processo do sistema é identificado exclusivamente no sistema por seu identificador de processo. Como muitos recursos do Windows, um processo também é identificado por seu identificador, que pode não ser exclusivo no computador. Um identificador é o termo genérico para um identificador de um recurso. O sistema operacional persistir o identificador de processo, que é acessado através de <xref:System.Diagnostics.Process.Handle%2A> propriedade o <xref:System.Diagnostics.Process> componente, mesmo quando o processo foi encerrado. Assim, você pode obter informações administrativas do processo, como o <xref:System.Diagnostics.Process.ExitCode%2A> (geralmente um zero em êxito ou um código de erro diferente de zero) e o <xref:System.Diagnostics.Process.ExitTime%2A>. Identificadores são um recurso extremamente valioso, portanto vazando identificadores é mais virulentos de vazamento de memória.  
  
> [!NOTE]
>  Esta classe contém uma demanda de link e uma demanda de herança no nível de classe que se aplica a todos os membros. Um <xref:System.Security.SecurityException> é lançado quando o chamador imediato ou a classe derivada não tem permissão de confiança total. Para obter detalhes sobre as exigências de segurança, consulte [demandas de Link](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Anotações  
 No .NET Framework, o <xref:System.Diagnostics.Process> classe por padrão, usa <xref:System.Console> codificações, que geralmente são codificações de página, para os fluxos de entrada, saída e de erro de código. Por exemplo de código, em sistemas cuja é cultura é inglês (Estados Unidos), página de código 437 é a codificação padrão para o <xref:System.Console> classe. No entanto, [!INCLUDE[net_core](~/includes/net-core-md.md)] podem criar somente um subconjunto limitado dessas codificações disponível. Se esse for o caso, ele usa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> como a codificação padrão.  
  
 Se um <xref:System.Diagnostics.Process> objeto depende de codificações de página de código específico, você poderá ainda disponibilizá-los usando o seguinte procedimento *antes de* você chamar qualquer <xref:System.Diagnostics.Process> métodos:  
  
1.  Adicione uma referência ao assembly System.Text.Encoding.CodePages.dll ao seu projeto.  
  
2.  Recuperar o <xref:System.Text.EncodingProvider> de objeto do <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriedade.  
  
3.  Passar o <xref:System.Text.EncodingProvider> o objeto para o <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para fazer as codificações adicionais com suporte pelo provedor de codificação disponível.  
  
 O <xref:System.Diagnostics.Process> classe automaticamente usará a codificação padrão do sistema em vez de UTF8, desde que você registrou o provedor de codificação antes de chamar qualquer <xref:System.Diagnostics.Process> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância do <xref:System.Diagnostics.Process> classe para iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.Diagnostics.Process> de classe em si e estático <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 O seguinte exemplo F # define uma `runProc` função que inicia um processo de captura todas as informações de saída e o erro e registra o número de milissegundos que o processo foi executado.  O `runProc` função tem três parâmetros: o nome do aplicativo para iniciar, os argumentos para fornecer ao aplicativo e o diretório inicial.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 O código para o `runProc` função foi escrita por [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) e está disponível sob o [licença pública da Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Esta classe não pode ser usada pelo código parcialmente confiável.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser herdada pelo código parcialmente confiável.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não especificar o <xref:System.Diagnostics.Process.MachineName%2A> propriedade, o padrão é o computador local, (".").  
  
 Você tem duas opções para associar um novo <xref:System.Diagnostics.Process> componente com um processo no computador. A primeira opção é usar o construtor para criar o <xref:System.Diagnostics.Process> componente, definir os membros apropriados a <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chame <xref:System.Diagnostics.Process.Start%2A> para associar o <xref:System.Diagnostics.Process> com um novo processo de sistema. A segunda opção é associar o <xref:System.Diagnostics.Process> com um processo de sistema em execução usando <xref:System.Diagnostics.Process.GetProcessById%2A> ou uma da <xref:System.Diagnostics.Process.GetProcesses%2A> valores de retorno.  
  
 Se você usar um `static` de sobrecarga do <xref:System.Diagnostics.Process.Start%2A> método para iniciar um novo processo do sistema, o método cria um novo <xref:System.Diagnostics.Process> componente e a associa o processo.  
  
 Quando o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> propriedade é definida como seu valor padrão, `true`, você pode iniciar aplicativos e documentos de maneira semelhante ao uso de `Run` caixa de diálogo do Windows `Start` menu. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> é `false`, você pode iniciar somente os executáveis.  
  
 Qualquer arquivo executável que você pode chamar a partir da linha de comando pode ser iniciado em uma das duas maneiras: definindo os membros apropriados do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar o <xref:System.Diagnostics.Process.Start%2A> método sem parâmetros ou passando o parâmetro apropriado para o `static` <xref:System.Diagnostics.Process.Start%2A> membro.  
  
 Você pode criar um <xref:System.Diagnostics.Process> componente usando o construtor, um estático <xref:System.Diagnostics.Process.Start%2A> sobrecargas ou qualquer o <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> métodos. Depois de você ter feito isso, você tem uma exibição para o processo associado. Isso não é uma exibição dinâmica que se atualiza automaticamente quando as propriedades de processo foram alteradas na memória. Em vez disso, você deve chamar <xref:System.Diagnostics.Process.Refresh%2A> para o componente atualizar o <xref:System.Diagnostics.Process> informações de propriedade em seu aplicativo.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the associated process.</summary>
        <value>A prioridade base, que é calculada de <see cref="P:System.Diagnostics.Process.PriorityClass" /> do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.BasePriority%2A> do processo é a prioridade inicial de threads criados dentro do processo associado. Você pode exibir informações sobre a prioridade base por meio de contador Base de prioridade do Monitor do sistema.  
  
 Com base no tempo decorrida ou outras aumenta, o sistema operacional pode alterar a prioridade base quando um processo deve ser colocado antes dos outros.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba inicial prioridade atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> para definir a prioridade do processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade. O <xref:System.Diagnostics.Process.BasePriority%2A> pode ser exibido usando o Monitor do sistema, enquanto o <xref:System.Diagnostics.Process.PriorityClass%2A> não é. Tanto o <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> podem ser exibidas programaticamente. A tabela a seguir mostra a relação entre <xref:System.Diagnostics.Process.BasePriority%2A> valores e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not started, so there is no process ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Esse método permite que o manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> como `true`.  
  
3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived> evento. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process> escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardError%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo de saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados para o console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> como `true`.  
  
3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived> evento. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process> escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `sort` comando. O `sort` comando é um aplicativo de console que lê e classifica a entrada de texto.  
  
 O exemplo cria um delegado de evento para o `SortOutputHandler` manipulador de eventos e o associa a <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto do redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e escreve o texto na tela.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. <xref:System.Diagnostics.Process.CancelErrorRead%2A> termina a assíncrona operação de leitura.  
  
 Depois de cancelar, você pode retomar a operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelErrorRead%2A>, todas as operações para de leitura em andamento <xref:System.Diagnostics.Process.StandardError%2A> sejam concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardError%2A> é salvo em um buffer. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas. Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardError%2A> e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelErrorRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardError%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de saída e de erro são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas serão canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. <xref:System.Diagnostics.Process.CancelOutputRead%2A> termina a assíncrona operação de leitura.  
  
 Depois de cancelar, você pode retomar operações de leitura assíncronas chamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelOutputRead%2A>, todas as operações para de leitura em andamento <xref:System.Diagnostics.Process.StandardOutput%2A> sejam concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardOutput%2A> é salvo em um buffer. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas. Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardOutput%2A> e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelOutputRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardOutput%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de saída e de erro são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas serão canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all the resources that are associated with this component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Close%2A> método faz com que o processo de interromper a espera para sair se estava aguardando, fecha o identificador de processo e limpa propriedades específicas do processo. <xref:System.Diagnostics.Process.Close%2A> Não feche o gravadores e leitores de saída, de entrada e de erro padrão caso eles estão sendo referenciados externamente.  
  
> [!NOTE]
>  O método <xref:System.Diagnostics.Process.Dispose%2A> chama <xref:System.Diagnostics.Process.Close%2A>. Colocando o <xref:System.Diagnostics.Process> do objeto em um `using` bloco libera recursos sem a necessidade de chamar <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em intervalos de 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a process that has a user interface by sending a close message to its main window.</summary>
        <returns>
          <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um processo está em execução, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo. A solicitação para sair do processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> faz com que um encerramento anormal de processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para encerrar o processo. <xref:System.Diagnostics.Process.Kill%2A> é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Release all resources used by this process.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</summary>
        <value>
          <see langword="true" /> se o evento <see cref="E:System.Diagnostics.Process.Exited" /> precisar ser gerado quando o processo associado for terminado (por meio de uma saída ou uma chamada a <see cref="M:System.Diagnostics.Process.Kill" />); caso contrário, <see langword="false" />. O padrão é <see langword="false" />. Observe que o <see cref="E:System.Diagnostics.Process.Exited" /> é gerado mesmo se o valor de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> é <see langword="false" /> quando o processo foi encerrado durante ou antes que o usuário executa um <see cref="P:System.Diagnostics.Process.HasExited" /> verificar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade sugere se o componente deve ser notificado quando o sistema operacional foi fechado por um processo. O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> no processamento assíncrono, a propriedade é usada para notificar o aplicativo que um processo foi encerrado. Para forçar o aplicativo de forma síncrona espera para um evento de saída (que interrompe o processamento do aplicativo até que o evento de saída ocorreu), use o <xref:System.Diagnostics.Process.WaitForExit%2A> método.

> [!NOTE]
> Se você estiver usando o Visual Studio e clique duas vezes em um <xref:System.Diagnostics.Process> componente no seu projeto, um <xref:System.Diagnostics.Process.Exited> delegado do evento e o manipulador de eventos são gerados automaticamente. Conjuntos de código adicional a <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade `false`. Você deve alterar essa propriedade como `true` para o manipulador de eventos executar quando o processo associado for encerrado.

Se o componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valor é `true`, ou quando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é `false` e um <xref:System.Diagnostics.Process.HasExited%2A> verificação é chamada pelo componente, o componente pode acessar as informações administrativas para o processo associado, que permanece armazenado pelo sistema operacional. Essas informações incluem o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.ExitCode%2A>.

Depois que o processo associado for encerrado, o <xref:System.Diagnostics.Process.Handle%2A> do componente não aponta para um recurso existente do processo. Em vez disso, ele só pode ser usado para acessar as informações do sistema operacional sobre o recurso de processo. O sistema operacional está ciente de que há identificadores encerrados processos que ainda não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória.

Há um custo associado observando um processo sair. Se <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é `true`, o <xref:System.Diagnostics.Process.Exited> é gerado quando o processo associado é encerrado. Os procedimentos para o <xref:System.Diagnostics.Process.Exited> eventos que são executados nesse horário.

Às vezes, o aplicativo inicia um processo, mas não requer a notificação de seu fechamento. Por exemplo, seu aplicativo pode iniciar o bloco de notas para permitir que o usuário efetue a edição de texto, mas nenhuma outra fazer uso do aplicativo bloco de notas. Você pode escolher evitar a notificação quando o processo foi encerrado porque ele não é relevante para a operação contínua de seu aplicativo. Configuração <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> para `false` pode salvar os recursos do sistema.

## Examples  
O exemplo de código a seguir cria um processo que imprime um arquivo. Ele define o <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade para fazer com que o processo gerar o <xref:System.Diagnostics.Process.Exited> evento quando ele sai. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos do sistema operacional executado em um modo especial. Tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você chamou <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica que o processo associado foi gravados seu redirecionado <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 O evento ocorre apenas durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>. Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardError%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.ErrorDataReceived> sinais de evento sempre que o processo grava uma linha para o redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> transmitir, até que o processo será encerrado ou chame <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit> método para garantir que o buffer de saída foi liberado. Observe que especificar um tempo limite usando o <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> sobrecarga *não* Certifique-se de que o buffer de saída foi liberado.
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo de saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados para o console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value that the associated process specified when it terminated.</summary>
        <value>O código especificado pelo processo associado quando ele foi finalizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.ExitCode%2A> para obter o status que o processo de sistema retornado quando ele foi encerrado. Você pode usar o código de saída muito, como um número inteiro retornar o valor de uma `main()` procedimento.  
  
 O <xref:System.Diagnostics.Process.ExitCode%2A> valor para um processo reflete a convenção específica implementada pelo desenvolvedor do aplicativo para que o processo. Se você usar o valor de código de saída para tomar decisões em seu código, certifique-se de que você sabe que a convenção de código de saída usada pelo processo de aplicativo.  
  
 Os desenvolvedores geralmente indicam uma saída com êxito por um <xref:System.Diagnostics.Process.ExitCode%2A> valor de zero e designar erros por valores diferentes de zero e o método de chamada pode usar para identificar a causa do encerramento de um processo anormal. Não é necessário seguir essas diretrizes, mas eles são a convenção.  
  
 Se você tentar obter o <xref:System.Diagnostics.Process.ExitCode%2A> antes que o processo foi encerrado, a tentativa de lança uma exceção. Examine o <xref:System.Diagnostics.Process.HasExited%2A> propriedade primeiro para verificar se o processo associado foi encerrado.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída terá não concluído quando <xref:System.Diagnostics.Process.HasExited%2A> retorna `true`. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Você pode usar o <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A> método para fazer com que um processo associado sair.  
  
 Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona depende de chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para pausar o processamento de seu aplicativo até que o componente associado será encerrado. Notificação assíncrona depende de <xref:System.Diagnostics.Process.Exited> eventos. Ao usar a notificação assíncrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definido como `true` para o <xref:System.Diagnostics.Process> componente para receber a notificação de que o processo foi encerrado.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not exited.  -or-  The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Exited> evento indica que o processo associado foi encerrado. Essa ocorrência significa que o processo encerrado (interrompida) ou fechada com êxito. Esse evento pode ocorrer somente se o valor de <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é de propriedade `true`.  
  
 Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona significa chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para bloquear o thread atual até que o processo foi encerrado. Notificação assíncrona usa o <xref:System.Diagnostics.Process.Exited> evento, que permite que o thread de chamada continuar a execução nesse meio tempo. No último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definido como `true` para o aplicativo de chamada receber o evento Exited.  
  
 Quando o sistema operacional é desligado por um processo, ele notifica todos os outros processos que registraram manipuladores para o evento Exited. Neste momento, o identificador do processo que acabou de sair pode ser usado para acessar algumas propriedades como <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.HasExited%2A> que o sistema operacional mantém até que ele libera esse identificador completamente.  
  
> [!NOTE]
>  Mesmo se você tiver um identificador para um processo encerrado, não é possível chamar <xref:System.Diagnostics.Process.Start%2A> novamente para reconectar-se para o mesmo processo. Chamando <xref:System.Diagnostics.Process.Start%2A> automaticamente libera o processo associado e se conecta a um processo com o mesmo arquivo, mas um totalmente novo <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Para obter mais informações sobre o uso do <xref:System.Diagnostics.Process.Exited> eventos em aplicativos de formulários do Windows, consulte o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. Ele gera o <xref:System.Diagnostics.Process.Exited> evento quando o processo foi encerrado porque o <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade foi definida quando o processo foi criado. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process exited.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando o processo associado foi encerrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o processo não foi encerrado, a tentativa de recuperar o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade gera uma exceção. Use <xref:System.Diagnostics.Process.HasExited%2A> antes de obter o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade para determinar se o processo associado foi encerrado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. O processo gera o <xref:System.Diagnostics.Process.Exited> eventos quando ele sai e o manipulador de eventos exibe o <xref:System.Diagnostics.Process.ExitTime%2A> processam de propriedade e outras informações.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> instância e associá-lo com o recurso de processo no computador local.  
  
 Como o semelhante <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A> métodos, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associa um recurso existente com um novo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo no computador local. O recurso de processo já deve existir no computador, pois <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> pode ser recuperado somente para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo em um computador remoto na rede. O recurso de processo já deve existir no computador especificado, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> pode ser recuperado somente para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
 Se você não especificar um `machineName`, será usado o computador local. Como alternativa, você pode especificar o computador local, definindo `machineName` com o valor "." ou uma cadeia de caracteres vazia ("").  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.  -or-  The <paramref name="machineName" /> parameter syntax is invalid. The name might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo no computador local. Os recursos de processo já devem existir no computador local, pois <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to read the list of processes.</param>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo no computador (geralmente remoto) especificado. Os recursos de processo já devem existir no computador local, pois <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.  
  
 Esta sobrecarga do <xref:System.Diagnostics.Process.GetProcesses%2A> método geralmente é usado para recuperar a lista de recursos do processo em execução em um computador remoto na rede, mas você pode especificar o computador local, passando ".".  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador local. Os recursos de processo já devem existir no computador, pois <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A> é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador especificado. Os recursos de processo já devem existir no computador, pois <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A> é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
 Você pode usar essa sobrecarga para obter os processos no computador local, bem como em um computador remoto. Use "." para especificar o computador local. Outra sobrecarga existe que utiliza o computador local por padrão.  
  
 Você pode acessar processos em computadores remotos somente para exibir informações, como estatísticas sobre os processos. Você não pode fechar, encerrar (usando <xref:System.Diagnostics.Process.Kill%2A>), ou inicie os processos em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle of the associated process.</summary>
        <value>O identificador que o sistema operacional atribuiu ao processo associado quando o processo foi iniciado. O sistema usa esse identificador para manter o controle dos atributos do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode obter um identificador para um processo que pode ser usado como um parâmetro para muitas funções de informações de processo e controle. Você pode usar esse identificador para inicializar um <xref:System.Threading.WaitHandle> ou chamar métodos nativos com a plataforma de invocação.  
  
 Esse identificador de processo é particular para um aplicativo - em outras palavras, processo identificadores não podem ser compartilhados. Um processo também tem um processo <xref:System.Diagnostics.Process.Id%2A> que, diferentemente do <xref:System.Diagnostics.Process.Handle%2A>, é exclusivo e, portanto, válido em todo o sistema.  
  
 Somente processos iniciados por meio de uma chamada para <xref:System.Diagnostics.Process.Start%2A> definir o <xref:System.Diagnostics.Process.Handle%2A> propriedade correspondente <xref:System.Diagnostics.Process> instâncias.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not been started or has exited. The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of handles opened by the process.</summary>
        <value>O número de identificadores do sistema operacional abertos pelo processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores fornecem uma maneira para um processo para se referir a objetos. Um processo pode obter identificadores de arquivos, recursos, filas de mensagens e muitos outros objetos do sistema operacional. O sistema operacional recupera a memória associada ao processo somente quando a contagem de identificadores é zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the associated process has been terminated.</summary>
        <value>
          <see langword="true" /> se o processo do sistema operacional referenciado pelo componente <see cref="T:System.Diagnostics.Process" /> tiver sido terminado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de `true` para <xref:System.Diagnostics.Process.HasExited%2A> indica que o processo associado foi finalizado, normalmente ou anormal. Você pode solicitar ou forçar o processo associado ao sair chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Se um identificador é aberto para o processo, o sistema operacional libera a memória do processo quando o processo foi encerrado, mas retém informações administrativas sobre o processo, como o identificador, o código de saída e a hora de saída. Para obter essas informações, você pode usar o <xref:System.Diagnostics.Process.ExitCode%2A> e <xref:System.Diagnostics.Process.ExitTime%2A> propriedades. Essas propriedades são preenchidas automaticamente para os processos que foram iniciados por este componente. A informação administrativa é liberada quando todos os a <xref:System.Diagnostics.Process> componentes que estão associados com o processo de sistema são destruídos e manter não mais identificadores para o processo encerrado.  
  
 Um processo pode encerrar independentemente de seu código. Se você iniciou o processo usando esse componente, o sistema atualiza o valor de <xref:System.Diagnostics.Process.HasExited%2A> automaticamente, mesmo que o processo associado for encerrado independentemente.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando essa propriedade retornará `true`. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with the object.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the associated process.</summary>
        <value>O identificador exclusivo gerado pelo sistema do processo que é referenciado por essa instância de <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processo de <xref:System.Diagnostics.Process.Id%2A> não é válido se o processo associado não está em execução. Portanto, você deve garantir que o processo está em execução antes de tentar recuperar o <xref:System.Diagnostics.Process.Id%2A> propriedade. Até que o processo termina, o identificador de processo identifica exclusivamente o processo em todo o sistema.  
  
 Você pode se conectar a um processo que está em execução em um computador local ou remoto para um novo <xref:System.Diagnostics.Process> instância passando o identificador de processo para o <xref:System.Diagnostics.Process.GetProcessById%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> é um `static` método que cria um novo componente e define o <xref:System.Diagnostics.Process.Id%2A> propriedade para o novo <xref:System.Diagnostics.Process> instância automaticamente.  
  
 Identificadores de processo podem ser reutilizados pelo sistema. O <xref:System.Diagnostics.Process.Id%2A> o valor da propriedade é exclusivo somente enquanto o processo associado está em execução. Depois que o processo foi encerrado, o sistema pode reutilizar o <xref:System.Diagnostics.Process.Id%2A> valor da propriedade de um processo relacionado.  
  
 Como o identificador é exclusivo no sistema, você pode passar para outros threads como uma alternativa para passar um <xref:System.Diagnostics.Process> instância. Esta ação pode economizar recursos do sistema e garantir que o processo é identificado corretamente.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como obter o <xref:System.Diagnostics.Process.Id%2A> para todas as instâncias de um aplicativo em execução. O código cria uma nova instância do bloco de notas, lista todas as instâncias do bloco de notas e, em seguida, permite que o usuário insira o <xref:System.Diagnostics.Process.Id%2A> número para remover uma instância específica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Immediately stops the associated process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> força um encerramento do processo, enquanto <xref:System.Diagnostics.Process.CloseMainWindow%2A> solicita somente um encerramento. Durante a execução de um processo com uma interface gráfica, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo. A solicitação para sair do processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.  
  
> [!NOTE]
>  O <xref:System.Diagnostics.Process.Kill%2A> método é executado de forma assíncrona. Depois de chamar o <xref:System.Diagnostics.Process.Kill%2A> método, chame o <xref:System.Diagnostics.Process.WaitForExit%2A> método para aguardar o processo sair ou verificar o <xref:System.Diagnostics.Process.HasExited%2A> propriedade para determinar se o processo foi encerrado.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> faz com que um encerramento anormal de processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para encerrar o processo. <xref:System.Diagnostics.Process.Kill%2A> é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
> [!NOTE]
>  Se a chamada para o <xref:System.Diagnostics.Process.Kill%2A> método é feito durante o processo está sendo encerrado no momento, um <xref:System.ComponentModel.Win32Exception> é lançada para acesso negado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated.  -or-  The process is terminating.  -or-  The associated process is a Win16 executable.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos do sistema operacional executado em um modo especial. Tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você chamou <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the computer the associated process is running on.</summary>
        <value>O nome do computador no qual o processo associado está em execução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode exibir dados de estatísticas e informações de processo para processos em execução em computadores remotos, mas não é possível chamar <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A> em computadores remotos.  
  
> [!NOTE]
>  Quando o processo associado está em execução no computador local, essa propriedade retorna um ponto (".") para o nome do computador. Você deve usar o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para obter o nome do computador correto.  
  
   
  
## Examples  
 Para usar o exemplo a seguir, você deve primeiro iniciar pelo menos uma instância do bloco de notas em um computador remoto. O exemplo solicita o nome do computador remoto no qual o bloco de notas está em execução e, em seguida, exibe os respectivos <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, e <xref:System.Diagnostics.Process.MachineName%2A> propriedades para cada instância.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the main module for the associated process.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessModule" /> usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. O <xref:System.Diagnostics.Process.MainModule%2A> propriedade permite que você exiba informações sobre o executável usado para iniciar o processo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A 32-bit process is trying to access the modules of a 64-bit process.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the window handle of the main window of the associated process.</summary>
        <value>O identificador de janela gerado pelo sistema da janela principal do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A janela principal é a janela aberta pelo processo que atualmente tem o foco (o <xref:System.Windows.Forms.Form.TopLevel%2A> formulário). Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto para obter o identificador de janela principal atual, se ele tiver sido alterada. Em geral, como o identificador de janela é armazenado em cache, use <xref:System.Diagnostics.Process.Refresh%2A> antecipadamente para garantir que você vai recuperar o identificador atual.  
  
 Você pode obter o <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade somente para processos em execução no computador local. O <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade é um valor que identifica exclusivamente a janela que está associada com o processo.  
  
 Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal, o <xref:System.Diagnostics.Process.MainWindowHandle%2A> valor é zero. O valor também é zero para processos que foram ocultos, ou seja, processos que não são visíveis na barra de tarefas. Isso pode ser o caso para processos que são exibidos como ícones na área de notificação, na extrema direita da barra de tarefas.  
  
 Se você acabou de iniciar um processo e deseja usar seu identificador de janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, uma exceção será gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caption of the main window of the process.</summary>
        <value>O título da janela principal do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal (para que <xref:System.Diagnostics.Process.MainWindowHandle%2A> é zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> é uma cadeia de caracteres vazia (""). Se você acabou de iniciar um processo e deseja usar o título da janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, o sistema gerará uma exceção.  
  
> [!NOTE]
>  A janela principal é a janela que atualmente tem o foco. Observe que isso pode não ser a janela principal para o processo. Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto para obter o identificador de janela principal atual, se ele tiver sido alterada.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas e recupera a legenda da janela principal do processo.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</summary>
        <value>O tamanho máximo do conjunto de trabalho permitido na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você colocar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</summary>
        <value>O tamanho mínimo do conjunto de trabalho necessário na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você colocar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the modules that have been loaded by the associated process.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessModule" /> que representa os módulos que foram carregados pelo processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. Um <xref:System.Diagnostics.ProcessModule> instância permite que você exiba informações sobre um módulo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo.  
  
 Um processo pode carregar vários módulos na memória. Por exemplo, arquivos de .exe que carregar arquivos. dll adicionais têm vários módulos.  
  
 Depois de iniciar o processo, essa coleção está vazia até que o sistema tenha carregado o processo. Se o processo tem uma janela principal, você pode chamar <xref:System.Diagnostics.Process.WaitForInputIdle%2A> antes de recuperar esta propriedade para garantir que a coleção está vazia quando você obtém a lista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process. These processes do not have modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória, em bytes, que o sistema alocou para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual de memória não paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Alocações de memória não paginada permanecem na memória do sistema e não são transferidas para o arquivo de paginação de memória virtual.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool não-paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> é o método de API que gera o <xref:System.Diagnostics.Process.Exited> evento. Chamando <xref:System.Diagnostics.Process.OnExited%2A> faz com que o <xref:System.Diagnostics.Process.Exited> evento ocorra e é a única maneira de gerar o evento usando o <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> é usado principalmente ao derivar de classes do componente.  
  
 Como uma alternativa para <xref:System.Diagnostics.Process.OnExited%2A>, você pode escrever seu próprio manipulador de eventos. Crie seu próprio delegado do manipulador de eventos e seu próprio método de manipulação de eventos.  
  
> [!NOTE]
>  Se você estiver usando o ambiente do Visual Studio, um representante do manipulador de eventos (AddOnExited) e um método de manipulação de eventos (Process1_Exited) são criados para você quando você arrasta um <xref:System.Diagnostics.Process> componente em um formulário e clique duas vezes no ícone. O código que você cria para executar quando o <xref:System.Diagnostics.Process.Exited> evento ocorre é inserido no procedimento Process1_Exited. Você não precisa criar o <xref:System.Diagnostics.Process.OnExited%2A> membro, porque ele é implementado para você.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Diagnostics.Process.OnExited%2A> método em uma classe derivada.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.OutputDataReceived> evento indica que o associado <xref:System.Diagnostics.Process> escreveu uma linha, terminando com um caractere de nova linha, para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 O evento é ativado durante operações de leitura assíncronas <xref:System.Diagnostics.Process.StandardOutput%2A>. Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.OutputDataReceived> sinais de evento sempre que o processo grava uma linha para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir, até que o processo será encerrado ou chame <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para garantir que o buffer de saída foi liberado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `ipconfig` comando.  
  
 O exemplo cria um delegado de evento para o `OutputHandler` manipulador de eventos e o associa a <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto do redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e salva-o em uma cadeia de caracteres de saída que é mostrada posteriormente na janela do console de exemplo.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória, em bytes, alocada pelo processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual da memória no arquivo de paginação de memória virtual usada pelo processo, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho de memória usada pelo sistema operacional para o processo, use o <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes do arquivo de página** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas e, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória, em bytes, o sistema tem alocada para o processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho atual de memória paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho da memória do aplicativo usado pelo processo, use o <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada pelo processo associado foi possível gravar o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado desde que ele foi iniciado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho máximo de memória no arquivo de paginação de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes de arquivo de paginação** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, que solicitou o processo associado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, alocada ao processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho máximo de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the peak working set size for the associated process, in bytes.</summary>
        <value>A quantidade máxima de memória física que o processo associado foi necessária uma só vez, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo módulos de processo e as bibliotecas do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of physical memory, in bytes, used by the associated process.</summary>
        <value>A quantidade máxima de memória física, em bytes, alocada para o processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho máximo do trabalho conjunto de memória usada pelo processo desde que ele iniciado, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções de módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</summary>
        <value>
          <see langword="true" /> se o aumento dinâmico da prioridade de processo deve ocorrer para um processo quando ele sair do estado de espera; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread é executado em um processo para o qual a classe de prioridade tem um dos valores de enumeração prioridade dinâmica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), o sistema aumenta a prioridade do segmento temporariamente quando ele é retirado de um estado de espera. Essa ação impede que outros processos a interromper o processamento do thread atual. O <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> configuração afeta todos os threads existentes e qualquer threads criados posteriormente pelo processo. Para restaurar o comportamento normal, defina o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriedade `false`.  
  
> [!NOTE]
>  Aumentando demais a prioridade pode esgotar os recursos essenciais do sistema operacional e funções de rede, causando problemas com outras tarefas do sistema operacional.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Priority boost information could not be retrieved from the associated process resource.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the overall priority category for the associated process.</summary>
        <value>A categoria de prioridade do processo associado, do qual o <see cref="P:System.Diagnostics.Process.BasePriority" /> do processo é calculado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe de prioridade do processo abrange uma gama de níveis de prioridade de thread. Os threads com diferentes prioridades, que estão em execução no processo de executar em relação a classe de prioridade do processo. Win32 usa quatro classes de prioridade com sete níveis de prioridade básica por classe. Essas classes de prioridade de processo são capturados no <xref:System.Diagnostics.ProcessPriorityClass> enumeração, que permite que você defina a prioridade do processo <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Com base no tempo decorrida ou outras aumenta, o nível de prioridade base pode ser alterada pelo sistema operacional quando um processo precisa ser colocado à frente de outros usuários para acesso ao processador. Além disso, você pode definir o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> para aumentar temporariamente o nível de prioridade de segmentos que foram executadas fora do estado de espera. A prioridade será redefinida quando o processo de volta para o estado de espera.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba a prioridade inicial que é atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> propriedade para definir a prioridade de um processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade, que obtém ou define a categoria geral de prioridade para o processo.  
  
 A classe de prioridade não pode ser exibida usando o Monitor do sistema. A tabela a seguir mostra a relação entre o <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Process priority information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>O número de bytes alocados pelo processo associado que não podem ser compartilhados com outros processos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória, em bytes, alocada ao processo associado que não pode ser compartilhada com outros processos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual da memória usada pelo processo, em bytes, que não pode ser compartilhada com outros processos.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes particulares** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the privileged processor time for this process.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo gastou executando o código no núcleo do sistema operacional.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process.</summary>
        <value>O nome que o sistema usa para identificar o processo para o usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ProcessName%2A> propriedade contém um nome de arquivo executável, como o Outlook, que não inclui a extensão .exe ou o caminho. É útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável.  
  
> [!NOTE]
>  Em [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemas operacionais, o <xref:System.Diagnostics.Process.ProcessName%2A> propriedade poderá ser truncada a 15 caracteres, se as informações do módulo de processo não podem ser obtidas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando um nome de arquivo executável, para recuperar uma matriz que contém todas as instâncias em execução no computador especificado. Você pode usar essa matriz, por exemplo, para fechar todas as instâncias em execução do arquivo executável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">The process is not on this computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the processors on which the threads in this process can be scheduled to run.</summary>
        <value>Um bitmask que representa os processadores nos quais os threads do processo associado podem ser executados. O padrão depende do número de processadores no computador. O valor padrão é 2 <sup>n</sup> -1, em que n é o número de processadores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No Windows 2000 e posterior, um thread em um processo pode migrar do processador, com cada migração recarregando o cache do processador. Sob cargas de sistema pesadas, especificar qual processador deve executar um thread específico pode melhorar o desempenho reduzindo o número de vezes que o cache de processador é recarregado. A associação entre um processador e um thread é chamada a afinidade do processador.  
  
 Cada processador é representado como um pouco. Bit 0 é o processador de um, o bit 1 é o processador de dois e assim por diante. Se você definir um bit para o valor 1, o processador correspondente é selecionado para atribuição de thread. Quando você define o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor como zero, o sistema operacional do agendamento de conjunto de algoritmos a afinidade do thread. Quando o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor é definido como qualquer valor diferente de zero, o valor será interpretado como um bitmask que especifica esses processadores qualificados para seleção.  
  
 A tabela a seguir mostra uma seleção de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valores para um sistema com oito processadores.  
  
|Máscara de bits|Valor binário|Processadores qualificados|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 e 2|  
|0x0007|00000000 00000111|1, 2 e 3|  
|0x0009|00000000 00001001|1 e 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 e 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Discards any information about the associated process that has been cached inside the process component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de <xref:System.Diagnostics.Process.Refresh%2A> é chamado, a primeira solicitação para obter informações sobre cada propriedade faz com que o componente do processo obter um novo valor do processo associado.  
  
 Quando um <xref:System.Diagnostics.Process> componente está associado um recurso de processo, os valores de propriedade de <xref:System.Diagnostics.Process> imediatamente são preenchidas de acordo com o status do processo associado. Se as informações sobre o processo associado for alterado posteriormente, essas alterações não são refletidas no <xref:System.Diagnostics.Process> do componente de valores em cache. O <xref:System.Diagnostics.Process> componente é um instantâneo do recurso de processo no momento em que eles estão associados. Para exibir os valores atuais para o processo associado, chame o <xref:System.Diagnostics.Process.Refresh%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user interface of the process is responding.</summary>
        <value>
          <see langword="true" /> se a interface do usuário do processo associado estiver respondendo ao sistema; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um processo tem uma interface de usuário, o <xref:System.Diagnostics.Process.Responding%2A> propriedade entra em contato com a interface do usuário para determinar se o processo está respondendo à entrada do usuário. Se a interface não responder imediatamente, o <xref:System.Diagnostics.Process.Responding%2A> propriedade retorna `false`. Use essa propriedade para determinar se a interface do processo associado parou de responder.  
  
 Se o processo não tem um <xref:System.Diagnostics.Process.MainWindowHandle%2A>, essa propriedade retornará `true`.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle to this process.</summary>
        <value>O identificador nativo para esse processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador só estará disponível se o componente de discagem iniciou o processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Terminal Services session identifier for the associated process.</summary>
        <value>O identificador de sessão dos Serviços de Terminal para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.SessionId%2A> propriedade identifica a sessão na qual o aplicativo está sendo executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">There is no session associated with this process.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this session identifier.  -or-  The associated process is not on this machine.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the error output of the application.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de erro padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> escreve o texto para seu fluxo de erro padrão que o texto é exibido normalmente no console. Redirecionando o <xref:System.Diagnostics.Process.StandardError%2A> fluxo, você pode manipular ou suprimir a saída de erro de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardError%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> para `true`. Caso contrário, ler o <xref:System.Diagnostics.Process.StandardError%2A> fluxo lança uma exceção.  
  
 O redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações apresentam uma dependência entre o chamador leem o <xref:System.Diagnostics.Process.StandardError%2A> fluxo e o filho processam gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.  
  
 O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 O exemplo de código evita uma condição de deadlock chamando `p.StandardError.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita a condição de deadlock pela execução assíncrona de operações de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardError%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net use` comando junto com um usuário forneceu o argumento para mapear um recurso de rede. Em seguida, ele lê o fluxo de erro padrão do comando net e grava no console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to write the input of the application.</summary>
        <value>Um <see cref="T:System.IO.StreamWriter" /> que pode ser usado para gravar o fluxo de entrada padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Diagnostics.Process> pode ler o texto de entrada de seu fluxo de entrada padrão, normalmente o teclado. Redirecionando o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo, programaticamente, você pode especificar a entrada. Por exemplo, em vez de usar a entrada do teclado, você pode fornecer o texto do conteúdo de um arquivo designado ou saída de outro aplicativo.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardInput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> para `true`. Caso contrário, gravar o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo lança uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como redirecionar o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo de um processo. O exemplo inicia o `sort` com entrada redirecionada. Ele, em seguida, solicita ao usuário para texto e passa para o `sort` processo por meio do redirecionamento <xref:System.Diagnostics.Process.StandardInput%2A> fluxo. O `sort` resultados são exibidos para o usuário no console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the textual output of the application.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de saída padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> escreve o texto para seu fluxo padrão, que o texto é exibido normalmente no console. Redirecionando o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, você pode manipular ou suprimir a saída de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardOutput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> para `true`. Caso contrário, ler o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo lança uma exceção.  
  
 O redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações apresentam uma dependência entre o chamador leem o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo e o filho processam gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.  
  
 O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita uma condição de deadlock chamando `p.StandardOutput.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardOutput.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita a condição de deadlock pela execução assíncrona de operações de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir executa o comando ipconfig.exe e redireciona a saída padrão para a janela do console de exemplo.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</summary>
        <returns>
          <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo e associá-lo a atual <xref:System.Diagnostics.Process> componente. O valor de retorno `true` indica que um novo recurso do processo foi iniciado. Se o recurso de processo especificado pelo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade já está em execução no computador, nenhum recurso de processo adicional será iniciado. Em vez disso, a execução processar recursos é reutilizado e `false` é retornado.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
> [!NOTE]
>  Se você estiver usando o Visual Studio, essa sobrecarga do <xref:System.Diagnostics.Process.Start%2A> método é aquele que você inserir no seu código depois que você arrasta um <xref:System.Diagnostics.Process> componente no designer. Use o `Properties` janela para expandir o `StartInfo` categoria e gravar o valor apropriado para o `FileName` propriedade. As alterações serão exibidas no formulário de `InitializeComponent` procedimento.  
  
 Esta sobrecarga do <xref:System.Diagnostics.Process.Start%2A> não é um `static` método. Você deve chamá-lo de uma instância do <xref:System.Diagnostics.Process> classe. Antes de chamar <xref:System.Diagnostics.Process.Start%2A>, você deve primeiro especificar <xref:System.Diagnostics.Process.StartInfo%2A> informações de propriedade para este <xref:System.Diagnostics.Process> instância, porque essa informação é usada para determinar o recurso de processo para iniciar.  
  
 As outras sobrecargas do <xref:System.Diagnostics.Process.Start%2A> método são `static` membros. Você não precisa criar uma instância do <xref:System.Diagnostics.Process> componente antes de chamar essas sobrecargas do método. Em vez disso, você pode chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> de classe em si e um novo <xref:System.Diagnostics.Process> componente é criado se o processo foi iniciado. Ou, `null` será retornado se um processo foi reutilizado. O recurso de processo é associado automaticamente com o novo <xref:System.Diagnostics.Process> componente que é retornado pelo <xref:System.Diagnostics.Process.Start%2A> método.  
  
 O <xref:System.Diagnostics.Process.StartInfo%2A> membros podem ser usados para duplicar a funcionalidade do `Run` caixa de diálogo do Windows `Start` menu. Qualquer coisa que podem ser digitados em uma linha de comando pode ser iniciada, definindo os valores apropriados no <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. A única <xref:System.Diagnostics.Process.StartInfo%2A> é de propriedade deve ser definida a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não tem que ser um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Na linha de comando, você pode especificar ações a serem tomadas para determinados tipos de arquivos. Por exemplo, você pode imprimir documentos ou editar arquivos de texto. Especifique essas ações usando o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. Para outros tipos de arquivos, você pode especificar argumentos de linha de comando ao iniciar o arquivo a partir de `Run` caixa de diálogo. Por exemplo, você pode passar uma URL como um argumento, se você especificar o navegador como o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Esses argumentos podem ser especificados no <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membro.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância do <xref:System.Diagnostics.Process> classe para iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.
-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</param>
        <summary>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando um <xref:System.Diagnostics.ProcessStartInfo> instância. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. Usando essa sobrecarga com um <xref:System.Diagnostics.ProcessStartInfo> parâmetro é uma alternativa às etapas de criação de um novo explícitas <xref:System.Diagnostics.Process> instância, definindo seu <xref:System.Diagnostics.Process.StartInfo%2A> propriedades e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Usando um <xref:System.Diagnostics.ProcessStartInfo> instância como o parâmetro permite que você chame <xref:System.Diagnostics.Process.Start%2A> com mais controle sobre o que é passado para a chamada para iniciar o processo. Se você precisar passar um nome de arquivo ou um nome de arquivo e os argumentos, não é necessário criar um novo <xref:System.Diagnostics.ProcessStartInfo> instância, embora o que é uma opção. A única <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> é de propriedade deve ser definida a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisam para representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> instância são definidas, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Se o <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> é de propriedade `null`, o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propriedade deve estar no formato UPN, *usuário*@*DNS_domain_name*.   
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique as informações de início para o recurso de processo usando um <xref:System.Diagnostics.ProcessStartInfo> instância.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` no `startInfo` parâmetro, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 Para obter exemplos adicionais de outros usos desse método, consulte as propriedades individuais do <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="startInfo" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of a document or application file to run in the process.</param>
        <summary>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando seu nome de arquivo. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o `fileName` parâmetro para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Iniciar um processo especificando seu nome de arquivo é semelhante ao digitar as informações de `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad".  
  
 Essa sobrecarga não permite que os argumentos de linha de comando para o processo. Se você precisar especificar um ou mais argumentos de linha de comando para o processo, use o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> ou <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecargas.  
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo do recurso para iniciar o processo.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando seu nome de arquivo e argumentos de linha de comando. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membros do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Iniciar um processo, especificando seu nome de arquivo e argumentos é semelhante ao digitar o nome de arquivo e argumentos de linha de comando do `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`. Se o `fileName` parâmetro representa um arquivo de comando (. cmd), o `arguments` parâmetro deve incluir um "`/c`"ou"`/k`" argumento para especificar se a janela de comando sai ou permanece após a conclusão.  
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo do recurso de processo para iniciar e argumentos de linha de comando para passar.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome de arquivo, nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas de criação de um novo explícitas <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso dessa sobrecarga para iniciar um arquivo executável e também demonstra o lançamento de um <xref:System.ComponentModel.Win32Exception> quando é feita uma tentativa para iniciar um aplicativo associado a um arquivo não executável.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome do arquivo, argumentos de linha de comando, o nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas de criação de um novo explícitas <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e a chamada <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessStartInfo" /> que representa os dados com os quais o processo será iniciado. Esses argumentos incluem o nome do documento ou arquivo executável usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> representa o conjunto de parâmetros a serem usados para iniciar um processo. Quando <xref:System.Diagnostics.Process.Start%2A> é chamado, o <xref:System.Diagnostics.Process.StartInfo%2A> é usado para especificar o processo para iniciar. Somente necessário <xref:System.Diagnostics.Process.StartInfo%2A> é membro para definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. Iniciar um processo, especificando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade assemelha-se de digitar as informações de **executar** caixa de diálogo do Windows **iniciar** menu. Portanto, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisam para representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade como "Notepad.exe" ou "Notepad".  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o nome do arquivo envolve um arquivo não executável, como um arquivo. doc, você pode incluir um verbo especificando a ação que será executada no arquivo. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> para "Print" de um arquivo na extensão. doc. O nome de arquivo especificado no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não é necessário ter uma extensão, se você inserir manualmente um valor para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propriedade. No entanto, se você usar o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> para determinar quais verbos disponíveis, você deve incluir a extensão.  
  
 Você pode alterar os parâmetros especificados o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade até o momento em que você chamar o <xref:System.Diagnostics.Process.Start%2A> método sobre o processo. Depois de iniciar o processo, alterando o <xref:System.Diagnostics.Process.StartInfo%2A> valores não afetam ou reiniciar o processo associado. Se você chamar o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> método com o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriedades definidas, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Se você não usou o <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade não reflete os parâmetros usados para iniciar o processo. Por exemplo, se você usar <xref:System.Diagnostics.Process.GetProcesses%2A> para obter uma matriz de processos em execução no computador, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade de cada <xref:System.Diagnostics.Process> não contém o nome do arquivo original ou os argumentos usados para iniciar o processo.  
  
 Quando o processo é iniciado, o nome do arquivo é o arquivo que preenche (somente leitura) <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você quiser recuperar o arquivo executável que está associado com o processo depois que o processo foi iniciado, use o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você deseja definir o arquivo executável de um <xref:System.Diagnostics.Process> instância para que um processo associado não foi iniciado, use o <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Porque os membros do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade são argumentos que são passados para o <xref:System.Diagnostics.Process.Start%2A> método de um processo, alterando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade depois de iniciado o processo associado não será redefinido o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Essas propriedades são usadas apenas para inicializar o processo associado.  
  
   
  
## Examples  
 O exemplo a seguir preenche um <xref:System.Diagnostics.Process.StartInfo%2A> com o arquivo para executar, a ação executada nele e se ele deve exibe uma interface do usuário. Para obter exemplos adicionais, consulte as páginas de referência para propriedades da <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process was started.</summary>
        <value>Um objeto que indica quando o processo é iniciado. Uma exceção é lançada se o processo não está em execução.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not been started.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred in the call to the Windows function.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento <see cref="E:System.Diagnostics.Process.Exited" /> no processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> é `null`, métodos que manipulam o <xref:System.Diagnostics.Process.Exited> eventos são chamados em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.Diagnostics.Process.Exited> evento é manipulado por um componente de Windows Forms visual, como um <xref:System.Windows.Forms.Button>, acessar o componente através do pool de threads de sistema pode não funcionar, ou pode resultar em uma exceção. Evitar isso definindo <xref:System.Diagnostics.Process.SynchronizingObject%2A> para um componente de Windows Forms, que faz com que os métodos de manipulação de <xref:System.Diagnostics.Process.Exited> evento seja chamado no mesmo thread em que o componente foi criado.  
  
 Se o <xref:System.Diagnostics.Process> é usado dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] em um designer de formulários do Windows, <xref:System.Diagnostics.Process.SynchronizingObject%2A> é definida automaticamente como o controle que contém o <xref:System.Diagnostics.Process>. Por exemplo, se você colocar um <xref:System.Diagnostics.Process> em um designer para `Form1` (que herda de <xref:System.Windows.Forms.Form>) o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade <xref:System.Diagnostics.Process> é definido como a instância do `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Normalmente, essa propriedade é definida quando o componente é colocado dentro de um controle ou formulário, porque esses componentes estão associados a um segmento específico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the set of threads that are running in the associated process.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessThread" /> que representa o sistema operacional de threads em execução no processo associado no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread pode executar código em um processo. Cada processo é iniciado com um único thread, o thread principal. Qualquer thread pode criar threads adicionais. Threads em um processo compartilham o espaço de endereço do processo.  
  
 Use <xref:System.Diagnostics.ProcessThread> para obter todos os threads associados ao processo atual. O thread principal não é necessariamente no índice zero na matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formats the process's name as a string, combined with the parent component type, if applicable.</summary>
        <returns>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time for this process.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica o tempo que o processo associado passou utilizando a CPU. Esse valor é a soma de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> e <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user processor time for this process.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo associado gastou executando o código dentro da porção de aplicativo do processo (e não dentro do núcleo do sistema operacional).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the process's virtual memory, in bytes.</summary>
        <value>A quantidade de memória virtual, em bytes, que o processo associado solicitou.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória virtual, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual de memória virtual usada pelo processo, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited. To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.  For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> faz com que o thread atual Aguarde até que encerra o processo associado.  Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o evento <xref:System.Diagnostics.Process.Exited>.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente aguardar um período infinito para os processo e manipuladores de eventos sair. Isso pode causar um aplicativo pare de responder. Por exemplo, se você chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A> para um processo que tenha uma interface de usuário, a solicitação para o sistema operacional para encerrar o processo associado pode não ser manipulada se o processo é gravado nunca insira seu loop de mensagem.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não indefinidamente. Além disso, as versões anteriores não aguardou os manipuladores de eventos sair se completa <xref:System.Int32.MaxValue> tempo foi atingido.  
  
 Essa sobrecarga garante que todo o processamento foi concluída, incluindo a manipulação de eventos assíncronos para a saída redirecionada do padrão. Você deve usar essa sobrecarga após uma chamada para o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono de sobrecargas.  
  
 Quando um processo associado existe (ou seja, quando está desligado, o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram <xref:System.Diagnostics.Process.WaitForExit>. O <xref:System.Diagnostics.Process> componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta para um recurso existente do processo. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi finalizado e você não precisar mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A> libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte a seção comentários a <xref:System.Diagnostics.Process.StandardError%2A> página de propriedades de referência.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</summary>
        <returns>
          <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> faz com que o thread atual Aguarde até que encerra o processo associado. Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o evento <xref:System.Diagnostics.Process.Exited>.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente aguardar uma quantidade finita de tempo para o processo sair. Se o processo associado não sair no final do intervalo de porque a solicitação para encerrar for negada, `false` é retornado ao procedimento de chamada. Você pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para `milliseconds`, e <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> irão se comportar o mesmo que o <xref:System.Diagnostics.Process.WaitForExit> de sobrecarga. Se você passar 0 (zero) para o método, ele retorna `true` somente se o processo já terminou; caso contrário, ele retorna imediatamente `false`.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, se `milliseconds` foi -1, o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não indefinidamente.  
  
 Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando este método retorna. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro após o recebimento um `true` dessa sobrecarga. Para ajudar a garantir que o <xref:System.Diagnostics.Process.Exited> evento é manipulado corretamente em aplicativos de formulários do Windows, defina o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
 Quando um processo associado for encerrado (desligar o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. O <xref:System.Diagnostics.Process> componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta para um recurso existente do processo. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi finalizado e você não precisar mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A> libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte o exemplo de código para o <xref:System.Diagnostics.Process.ExitCode%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle> para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.  
  
 Se um processo não tem um loop de mensagem, <xref:System.Diagnostics.Process.WaitForInputIdle> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle> sobrecarga instrui o <xref:System.Diagnostics.Process> componente aguardar indefinidamente para o processo de ficar ocioso no loop de mensagem. Essa instrução pode fazer com que um aplicativo pare de responder. Por exemplo, se o processo for gravado sempre sair seu loop de mensagem imediatamente, como o fragmento de código `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</param>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.  
  
 Se um processo não tem um loop de mensagem, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> sobrecarga instrui o <xref:System.Diagnostics.Process> componente aguardar uma quantidade finita de tempo para o processo de ficar ocioso no loop de mensagem. Se o processo associado não ficou ocioso até o final do intervalo de porque o loop ainda está processando mensagens, `false` é retornado ao procedimento de chamada.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the associated process's physical memory usage, in bytes.</summary>
        <value>A quantidade total de memória física usada pelo processo associado, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo os módulos de processo e as bibliotecas do sistema.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory, in bytes, allocated for the associated process.</summary>
        <value>A quantidade de memória física, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções em módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>